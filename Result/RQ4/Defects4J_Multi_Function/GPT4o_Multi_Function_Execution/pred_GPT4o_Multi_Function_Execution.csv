ID,slug,bug,fix,width_attempt,iteration
0,Chart_14,"public boolean removeDomainMarker(int index, Marker marker, Layer layer,
    		boolean notify) {
        ArrayList markers;
        if (layer == Layer.FOREGROUND) {
            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(
                    index));
        }
        else {
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
        }
        return removed;
    }","public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {
    if (marker == null || layer == null) {
        throw new IllegalArgumentException(""Null 'marker' or 'layer' argument."");
    }
    ArrayList markers;
    if (layer == Layer.FOREGROUND) {
        markers = (ArrayList) this.foregroundDomainMarkers.get(Integer.valueOf(index));
    } else {
        markers = (ArrayList) this.backgroundDomainMarkers.get(Integer.valueOf(index));
    }
    if (markers == null) {
        return false; // No markers exist at this index for the specified layer
    }
    boolean removed = markers.remove(marker);
    if (removed && notify) {
        fireChangeEvent();
    }
    return removed;
}",0,0
0,Chart_14,"public boolean removeRangeMarker(int index, Marker marker, Layer layer,
    		boolean notify) {
        if (marker == null) {
            throw new IllegalArgumentException(""Null 'marker' argument."");
        }
        ArrayList markers;
        if (layer == Layer.FOREGROUND) {
            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(
                    index));
        }
        else {
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
        }
        return removed;
    }","public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {
    if (marker == null || layer == null) {
        throw new IllegalArgumentException(""Null 'marker' or 'layer' argument."");
    }
    ArrayList markers;
    if (layer == Layer.FOREGROUND) {
        markers = (ArrayList) this.foregroundRangeMarkers.get(Integer.valueOf(index));
    } else {
        markers = (ArrayList) this.backgroundRangeMarkers.get(Integer.valueOf(index));
    }
    if (markers == null) {
        return false; // No markers exist at this index for the specified layer
    }
    boolean removed = markers.remove(marker);
    if (removed && notify) {
        fireChangeEvent();
    }
    return removed;
}",0,0
1,Chart_15,"public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,
            PiePlot plot, Integer index, PlotRenderingInfo info) {
      
         PiePlotState state = new PiePlotState(info);
         state.setPassesRequired(2);
             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(
                     plot.getDataset()));
         state.setLatestAngle(plot.getStartAngle());
         return state;
         
    }","public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,
        PiePlot plot, Integer index, PlotRenderingInfo info) {

    PiePlotState state = new PiePlotState(info);
    state.setPassesRequired(2);

    PieDataset dataset = plot.getDataset();
    if (dataset != null) {
        state.setTotal(DatasetUtilities.calculatePieDatasetTotal(dataset));
    } else {
        state.setTotal(0.0);
    }

    state.setLatestAngle(plot.getStartAngle());
    return state;
}",0,0
2,Chart_16,"public void setCategoryKeys(Comparable[] categoryKeys) {
         if (categoryKeys == null) {
             throw new IllegalArgumentException(""Null 'categoryKeys' argument."");
         }
         if (categoryKeys.length != this.startData[0].length) {
             throw new IllegalArgumentException(
                     ""The number of categories does not match the data."");
         }
        for (int i = 0; i < categoryKeys.length; i++) {
            if (categoryKeys[i] == null) {
                throw new IllegalArgumentException(
                    ""DefaultIntervalCategoryDataset.setCategoryKeys(): ""
                    + ""null category not permitted."");
            }
        }
        this.categoryKeys = categoryKeys;
        fireDatasetChanged();
    }","public void setCategoryKeys(Comparable[] categoryKeys) {
    if (categoryKeys == null) {
        throw new IllegalArgumentException(""Null 'categoryKeys' argument."");
    }
    // Ensure startData is not null and has at least one row to avoid NullPointerException
    if (this.startData == null || this.startData.length == 0 || this.startData[0] == null) {
        throw new IllegalStateException(""Data has not been initialized properly."");
    }
    if (categoryKeys.length != this.startData[0].length) {
        throw new IllegalArgumentException(
                ""The number of categories does not match the data."");
    }
    for (int i = 0; i < categoryKeys.length; i++) {
        if (categoryKeys[i] == null) {
            throw new IllegalArgumentException(
                ""DefaultIntervalCategoryDataset.setCategoryKeys(): ""
                + ""null category not permitted."");
        }
    }
    this.categoryKeys = categoryKeys;
    fireDatasetChanged();
}",0,0
3,Chart_18,"public void removeValue(int index) {
        this.keys.remove(index);
        this.values.remove(index);
        rebuildIndex();
    }","public void removeValue(int index) {
    if (index < 0 || index >= this.keys.size()) {
        throw new IndexOutOfBoundsException(""Index out of bounds: "" + index);
    }
    this.keys.remove(index);
    this.values.remove(index);
    rebuildIndex();
}",0,0
3,Chart_18,"public void removeValue(Comparable key) {
        int index = getIndex(key);
        if (index < 0) {
            throw new UnknownKeyException(""The key ("" + key 
                    + "") is not recognised."");
        }
        removeValue(index);
    }
    
    /**","public void removeValue(Comparable key) {
    if (key == null) {
        throw new IllegalArgumentException(""Null 'key' argument."");
    }
    int index = getIndex(key);
    if (index < 0) {
        throw new UnknownKeyException(""The key ("" + key + "") is not recognised."");
    }
    removeValue(index);
}",0,0
4,Chart_19,"    public int getDomainAxisIndex(CategoryAxis axis) {
        return this.domainAxes.indexOf(axis);
    }
","public int getDomainAxisIndex(CategoryAxis axis) {
    if (axis == null) {
        return -1; // Return -1 if the axis is null
    }
    return this.domainAxes.indexOf(axis);
}",0,0
4,Chart_19,"    public int getRangeAxisIndex(ValueAxis axis) {
        int result = this.rangeAxes.indexOf(axis);
        if (result < 0) { // try the parent plot
            Plot parent = getParent();
            if (parent instanceof CategoryPlot) {
                CategoryPlot p = (CategoryPlot) parent;
                result = p.getRangeAxisIndex(axis);
            }
        }
        return result;
    }
","public int getRangeAxisIndex(ValueAxis axis) {
    if (axis == null) {
        return -1; // Return -1 if the axis is null
    }
    int result = this.rangeAxes.indexOf(axis);
    if (result < 0) { // try the parent plot
        Plot parent = getParent();
        if (parent instanceof CategoryPlot) {
            CategoryPlot p = (CategoryPlot) parent;
            result = p.getRangeAxisIndex(axis);
        }
    }
    return result;
}",0,0
5,Chart_2,"public static Range iterateDomainBounds(XYDataset dataset,
                                            boolean includeInterval) {
        if (dataset == null) {
            throw new IllegalArgumentException(""Null 'dataset' argument."");
        }
        double minimum = Double.POSITIVE_INFINITY;
        double maximum = Double.NEGATIVE_INFINITY;
        int seriesCount = dataset.getSeriesCount();
        double lvalue;
        double uvalue;
        if (includeInterval && dataset instanceof IntervalXYDataset) {
            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                     lvalue = intervalXYData.getStartXValue(series, item);
                     uvalue = intervalXYData.getEndXValue(series, item);
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
            }
        }
        else {
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = dataset.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    lvalue = dataset.getXValue(series, item);
                    uvalue = lvalue;
                    if (!Double.isNaN(lvalue)) {
                        minimum = Math.min(minimum, lvalue);
                        maximum = Math.max(maximum, uvalue);
                    }
                }
            }
        }
        if (minimum > maximum) {
            return null;
        }
        else {
            return new Range(minimum, maximum);
        }
    }","public static Range iterateDomainBounds(XYDataset dataset,
                                            boolean includeInterval) {
        if (dataset == null) {
            throw new IllegalArgumentException(""Null 'dataset' argument."");
        }
        double minimum = Double.POSITIVE_INFINITY;
        double maximum = Double.NEGATIVE_INFINITY;
        int seriesCount = dataset.getSeriesCount();
        double lvalue;
        double uvalue;
        if (includeInterval && dataset instanceof IntervalXYDataset) {
            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = intervalXYData.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    lvalue = intervalXYData.getStartXValue(series, item);
                    uvalue = intervalXYData.getEndXValue(series, item);
                    if (!Double.isNaN(lvalue) && !Double.isInfinite(lvalue)) {
                        minimum = Math.min(minimum, lvalue);
                    }
                    if (!Double.isNaN(uvalue) && !Double.isInfinite(uvalue)) {
                        maximum = Math.max(maximum, uvalue);
                    }
                }
            }
        } else {
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = dataset.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    lvalue = dataset.getXValue(series, item);
                    if (!Double.isNaN(lvalue) && !Double.isInfinite(lvalue)) {
                        minimum = Math.min(minimum, lvalue);
                        maximum = Math.max(maximum, lvalue);
                    }
                }
            }
        }
        if (minimum > maximum) {
            return null;
        } else {
            return new Range(minimum, maximum);
        }
    }",0,0
5,Chart_2,"public static Range iterateRangeBounds(XYDataset dataset,
            boolean includeInterval) {
        double minimum = Double.POSITIVE_INFINITY;
        double maximum = Double.NEGATIVE_INFINITY;
        int seriesCount = dataset.getSeriesCount();

        // handle three cases by dataset type
        if (includeInterval && dataset instanceof IntervalXYDataset) {
            // handle special case of IntervalXYDataset
            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                     double lvalue = ixyd.getStartYValue(series, item);
                     double uvalue = ixyd.getEndYValue(series, item);
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
            }
        }
        else if (includeInterval && dataset instanceof OHLCDataset) {
            // handle special case of OHLCDataset
            OHLCDataset ohlc = (OHLCDataset) dataset;
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = dataset.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    double lvalue = ohlc.getLowValue(series, item);
                    double uvalue = ohlc.getHighValue(series, item);
                    if (!Double.isNaN(lvalue)) {
                        minimum = Math.min(minimum, lvalue);
                    }
                    if (!Double.isNaN(uvalue)) {
                        maximum = Math.max(maximum, uvalue);
                    }
                }
            }
        }
        else {
            // standard case - plain XYDataset
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = dataset.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    double value = dataset.getYValue(series, item);
                    if (!Double.isNaN(value)) {
                        minimum = Math.min(minimum, value);
                        maximum = Math.max(maximum, value);
                    }
                }
            }
        }
        if (minimum == Double.POSITIVE_INFINITY) {
            return null;
        }
        else {
            return new Range(minimum, maximum);
        }
    }","public static Range iterateRangeBounds(XYDataset dataset,
            boolean includeInterval) {
        if (dataset == null) {
            throw new IllegalArgumentException(""Null 'dataset' argument."");
        }
        double minimum = Double.POSITIVE_INFINITY;
        double maximum = Double.NEGATIVE_INFINITY;
        int seriesCount = dataset.getSeriesCount();

        if (includeInterval && dataset instanceof IntervalXYDataset) {
            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = ixyd.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    double lvalue = ixyd.getStartYValue(series, item);
                    double uvalue = ixyd.getEndYValue(series, item);
                    if (!Double.isNaN(lvalue) && !Double.isInfinite(lvalue)) {
                        minimum = Math.min(minimum, lvalue);
                    }
                    if (!Double.isNaN(uvalue) && !Double.isInfinite(uvalue)) {
                        maximum = Math.max(maximum, uvalue);
                    }
                }
            }
        } else if (includeInterval && dataset instanceof OHLCDataset) {
            OHLCDataset ohlc = (OHLCDataset) dataset;
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = ohlc.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    double lvalue = ohlc.getLowValue(series, item);
                    double uvalue = ohlc.getHighValue(series, item);
                    if (!Double.isNaN(lvalue) && !Double.isInfinite(lvalue)) {
                        minimum = Math.min(minimum, lvalue);
                    }
                    if (!Double.isNaN(uvalue) && !Double.isInfinite(uvalue)) {
                        maximum = Math.max(maximum, uvalue);
                    }
                }
            }
        } else {
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = dataset.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    double value = dataset.getYValue(series, item);
                    if (!Double.isNaN(value) && !Double.isInfinite(value)) {
                        minimum = Math.min(minimum, value);
                        maximum = Math.max(maximum, value);
                    }
                }
            }
        }
        if (minimum > maximum) {
            return null;
        } else {
            return new Range(minimum, maximum);
        }
    }",0,0
6,Chart_21,"private void updateBounds() {
         this.minimumRangeValue = Double.NaN;
         this.maximumRangeValue = Double.NaN;
     }","private void updateBounds() {
    this.minimumRangeValue = Double.POSITIVE_INFINITY;
    this.maximumRangeValue = Double.NEGATIVE_INFINITY;

    for (int row = 0; row < this.data.getRowCount(); row++) {
        for (int col = 0; col < this.data.getColumnCount(); col++) {
            BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(row, col);
            if (item != null) {
                Double minOutlier = item.getMinOutlier() != null ? item.getMinOutlier().doubleValue() : Double.NaN;
                Double maxOutlier = item.getMaxOutlier() != null ? item.getMaxOutlier().doubleValue() : Double.NaN;

                if (!Double.isNaN(minOutlier)) {
                    this.minimumRangeValue = Math.min(this.minimumRangeValue, minOutlier);
                }

                if (!Double.isNaN(maxOutlier)) {
                    this.maximumRangeValue = Math.max(this.maximumRangeValue, maxOutlier);
                }
            }
        }
    }

    if (this.minimumRangeValue == Double.POSITIVE_INFINITY) {
        this.minimumRangeValue = Double.NaN;
    }
    if (this.maximumRangeValue == Double.NEGATIVE_INFINITY) {
        this.maximumRangeValue = Double.NaN;
    }
}",0,0
6,Chart_21,"public void add(BoxAndWhiskerItem item, Comparable rowKey, 
            Comparable columnKey) {

        this.data.addObject(item, rowKey, columnKey);
        
        // update cached min and max values
        int r = this.data.getRowIndex(rowKey);
        int c = this.data.getColumnIndex(columnKey);
        if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn 
                == c) || (this.minimumRangeValueRow == r 
                 && this.minimumRangeValueColumn == c))  {
             updateBounds();
         }
         
             double minval = Double.NaN;
             if (item.getMinOutlier() != null) {
                minval = item.getMinOutlier().doubleValue();
            }
            double maxval = Double.NaN;
            if (item.getMaxOutlier() != null) {
                maxval = item.getMaxOutlier().doubleValue();
            }
        
            if (Double.isNaN(this.maximumRangeValue)) {
                this.maximumRangeValue = maxval;
                this.maximumRangeValueRow = r;
                this.maximumRangeValueColumn = c;
            }
            else if (maxval > this.maximumRangeValue) {
                this.maximumRangeValue = maxval;
                this.maximumRangeValueRow = r;
                this.maximumRangeValueColumn = c;
            }
        
            if (Double.isNaN(this.minimumRangeValue)) {
                this.minimumRangeValue = minval;
                this.minimumRangeValueRow = r;
                this.minimumRangeValueColumn = c;
            }
            else if (minval < this.minimumRangeValue) {
                this.minimumRangeValue = minval;
                this.minimumRangeValueRow = r;
                this.minimumRangeValueColumn = c;
            }
        
        this.rangeBounds = new Range(this.minimumRangeValue,
              this.maximumRangeValue);
        fireDatasetChanged();

    }","public void add(BoxAndWhiskerItem item, Comparable rowKey, Comparable columnKey) {
    this.data.addObject(item, rowKey, columnKey);

    // update cached min and max values
    int r = this.data.getRowIndex(rowKey);
    int c = this.data.getColumnIndex(columnKey);

    if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn == c) || 
        (this.minimumRangeValueRow == r && this.minimumRangeValueColumn == c)) {
        updateBounds();
    }

    double minval = item.getMinOutlier() != null ? item.getMinOutlier().doubleValue() : Double.NaN;
    double maxval = item.getMaxOutlier() != null ? item.getMaxOutlier().doubleValue() : Double.NaN;

    if (Double.isNaN(this.maximumRangeValue) || maxval > this.maximumRangeValue) {
        this.maximumRangeValue = maxval;
        this.maximumRangeValueRow = r;
        this.maximumRangeValueColumn = c;
    }

    if (Double.isNaN(this.minimumRangeValue) || minval < this.minimumRangeValue) {
        this.minimumRangeValue = minval;
        this.minimumRangeValueRow = r;
        this.minimumRangeValueColumn = c;
    }

    this.rangeBounds = new Range(this.minimumRangeValue, this.maximumRangeValue);
    fireDatasetChanged();
}",0,0
7,Chart_22,"public Object getObject(Comparable rowKey, Comparable columnKey) {
        if (rowKey == null) {
            throw new IllegalArgumentException(""Null 'rowKey' argument."");
        }
        if (columnKey == null) {
            throw new IllegalArgumentException(""Null 'columnKey' argument."");
        }
        int row = this.rowKeys.indexOf(rowKey);
        if (row < 0) {
            throw new UnknownKeyException(""Row key ("" + rowKey 
                    + "") not recognised."");
        }
        int column = this.columnKeys.indexOf(columnKey);
        if (column < 0) {
             throw new UnknownKeyException(""Column key ("" + columnKey 
                     + "") not recognised."");
         }
         if (row >= 0) {
         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);
             return rowData.getObject(columnKey);
         }
         else {
             return null;
        }
    }","public Object getObject(Comparable rowKey, Comparable columnKey) {
    if (rowKey == null) {
        throw new IllegalArgumentException(""Null 'rowKey' argument."");
    }
    if (columnKey == null) {
        throw new IllegalArgumentException(""Null 'columnKey' argument."");
    }
    
    int row = this.rowKeys.indexOf(rowKey);
    if (row < 0) {
        throw new UnknownKeyException(""Row key ("" + rowKey + "") not recognised."");
    }
    
    int column = this.columnKeys.indexOf(columnKey);
    if (column < 0) {
        throw new UnknownKeyException(""Column key ("" + columnKey + "") not recognised."");
    }
    
    KeyedObjects rowData = (KeyedObjects) this.rows.get(row);
    return rowData.getObject(columnKey);
}",0,0
7,Chart_22,"public void removeObject(Comparable rowKey, Comparable columnKey) {
        setObject(null, rowKey, columnKey);
        
        // 1. check whether the row is now empty.
        boolean allNull = true;
        int rowIndex = getRowIndex(rowKey);
        KeyedObjects row = (KeyedObjects) this.rows.get(rowIndex);

        for (int item = 0, itemCount = row.getItemCount(); item < itemCount; 
             item++) {
            if (row.getObject(item) != null) {
                allNull = false;
                break;
            }
        }
        
        if (allNull) {
            this.rowKeys.remove(rowIndex);
            this.rows.remove(rowIndex);
         }
         
         // 2. check whether the column is now empty.
         
         
     }","public void removeObject(Comparable rowKey, Comparable columnKey) {
    if (rowKey == null || columnKey == null) {
        throw new IllegalArgumentException(""Null 'rowKey' or 'columnKey' argument."");
    }

    setObject(null, rowKey, columnKey);

    // Check whether the row is now empty.
    int rowIndex = getRowIndex(rowKey);
    if (rowIndex >= 0) {
        KeyedObjects row = (KeyedObjects) this.rows.get(rowIndex);
        boolean allNull = true;

        for (int item = 0, itemCount = row.getItemCount(); item < itemCount; item++) {
            if (row.getObject(item) != null) {
                allNull = false;
                break;
            }
        }

        if (allNull) {
            this.rowKeys.remove(rowIndex);
            this.rows.remove(rowIndex);
        }
    }
    
    // Check whether the column is now empty.
    int columnIndex = getColumnIndex(columnKey);
    if (columnIndex >= 0) {
        boolean allNull = true;

        for (Object rowObj : this.rows) {
            KeyedObjects row = (KeyedObjects) rowObj;
            if (row.getObject(columnKey) != null) {
                allNull = false;
                break;
            }
        }

        if (allNull) {
            this.columnKeys.remove(columnIndex);
        }
    }
}",0,0
7,Chart_22,"public void removeRow(Comparable rowKey) {
         int index = getRowIndex(rowKey);
         removeRow(index);
     }","public void removeRow(Comparable rowKey) {
    int index = getRowIndex(rowKey);
    if (index < 0) {
        throw new UnknownKeyException(""Row key ("" + rowKey + "") not recognised."");
    }
    removeRow(index);
}",0,0
7,Chart_22,"public void removeColumn(Comparable columnKey) {
        int index = getColumnIndex(columnKey);
        if (index < 0) {
            throw new UnknownKeyException(""Column key ("" + columnKey 
                    + "") not recognised."");
        }
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             KeyedObjects rowData = (KeyedObjects) iterator.next();
                 rowData.removeValue(columnKey);
         }
         this.columnKeys.remove(columnKey);
     }","public void removeColumn(Comparable columnKey) {
    int index = getColumnIndex(columnKey);
    if (index < 0) {
        throw new UnknownKeyException(""Column key ("" + columnKey + "") not recognised."");
    }

    Iterator iterator = this.rows.iterator();
    while (iterator.hasNext()) {
        KeyedObjects rowData = (KeyedObjects) iterator.next();
        rowData.removeValue(columnKey);
    }
    this.columnKeys.remove(index);
}",0,0
8,Chart_23,"    private Icon getIcon(Shape shape, final Paint fillPaint, 
                        final Paint outlinePaint) {

      final int width = shape.getBounds().width;
      final int height = shape.getBounds().height;
      final GeneralPath path = new GeneralPath(shape);
      return new Icon() {
          public void paintIcon(Component c, Graphics g, int x, int y) {
              Graphics2D g2 = (Graphics2D) g;
              path.transform(AffineTransform.getTranslateInstance(x, y));
              if (fillPaint != null) {
                  g2.setPaint(fillPaint);
                  g2.fill(path);
              }
              if (outlinePaint != null) {
                  g2.setPaint(outlinePaint);
                  g2.draw(path);
              }
              path.transform(AffineTransform.getTranslateInstance(-x, -y));
        }

        public int getIconWidth() {
            return width;
        }

        public int getIconHeight() {
            return height;
        }

      };
    }
","private Icon getIcon(Shape shape, final Paint fillPaint, 
                        final Paint outlinePaint) {

    final int width = shape.getBounds().width;
    final int height = shape.getBounds().height;
    final GeneralPath path = new GeneralPath(shape);

    return new Icon() {
        public void paintIcon(Component c, Graphics g, int x, int y) {
            Graphics2D g2 = (Graphics2D) g;

            AffineTransform originalTransform = g2.getTransform(); // Save the original transformation
            g2.translate(x, y); // Translate the path

            if (fillPaint != null) {
                g2.setPaint(fillPaint);
                g2.fill(path);
            }
            if (outlinePaint != null) {
                g2.setPaint(outlinePaint);
                g2.draw(path);
            }

            g2.setTransform(originalTransform); // Restore the original transformation
        }

        public int getIconWidth() {
            return width;
        }

        public int getIconHeight() {
            return height;
        }
    };
}",0,0
9,Chart_25,"protected void drawHorizontalItem(Graphics2D g2,
                                      CategoryItemRendererState state,
                                      Rectangle2D dataArea,
                                      CategoryPlot plot,
                                      CategoryAxis domainAxis,
                                      ValueAxis rangeAxis,
                                      StatisticalCategoryDataset dataset,
                                      int row,
                                      int column) {
                                     
        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
        
        // BAR Y
        double rectY = domainAxis.getCategoryStart(column, getColumnCount(), 
                dataArea, xAxisLocation);

        int seriesCount = getRowCount();
        int categoryCount = getColumnCount();
        if (seriesCount > 1) {
            double seriesGap = dataArea.getHeight() * getItemMargin()
                               / (categoryCount * (seriesCount - 1));
            rectY = rectY + row * (state.getBarWidth() + seriesGap);
        }
        else {
            rectY = rectY + row * state.getBarWidth();
        }
 
         // BAR X
         Number meanValue = dataset.getMeanValue(row, column);
 
         double value = meanValue.doubleValue();
         double base = 0.0;
        double lclip = getLowerClip();
        double uclip = getUpperClip();

        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4
            if (value >= uclip) {
                return; // bar is not visible
            }
            base = uclip;
            if (value <= lclip) {
                value = lclip;
            }
        }
        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
            if (value >= uclip) {
                value = uclip;
            }
            else {
                if (value <= lclip) {
                    value = lclip;
                }
            }
        }
        else { // cases 9, 10, 11 and 12
            if (value <= lclip) {
                return; // bar is not visible
            }
            base = getLowerClip();
            if (value >= uclip) {
               value = uclip;
            }
        }

        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);
        double transY2 = rangeAxis.valueToJava2D(value, dataArea, 
                yAxisLocation);
        double rectX = Math.min(transY2, transY1);

        double rectHeight = state.getBarWidth();
        double rectWidth = Math.abs(transY2 - transY1);

        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, 
                rectHeight);
        Paint seriesPaint = getItemPaint(row, column);
        g2.setPaint(seriesPaint);
        g2.fill(bar);
        if (isDrawBarOutline() && state.getBarWidth() > 3) {
            g2.setStroke(getItemStroke(row, column));
            g2.setPaint(getItemOutlinePaint(row, column));
            g2.draw(bar);
        }

        // standard deviation lines
            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    + valueDelta, dataArea, yAxisLocation);
            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    - valueDelta, dataArea, yAxisLocation);

            if (this.errorIndicatorStroke != null) {
                g2.setStroke(this.errorIndicatorStroke);
            }
            else {
                g2.setStroke(getItemOutlineStroke(row, column));
            }
            if (this.errorIndicatorPaint != null) {
                g2.setPaint(this.errorIndicatorPaint);  
            }
            else {
                g2.setPaint(getItemOutlinePaint(row, column));   
            }
        
            Line2D line = null;
            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, 
                                     highVal, rectY + rectHeight / 2.0d);
            g2.draw(line);
            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, 
                                     highVal, rectY + rectHeight * 0.75);
            g2.draw(line);
            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, 
                                     lowVal, rectY + rectHeight * 0.75);
            g2.draw(line);
        
        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                column);
        if (generator != null && isItemLabelVisible(row, column)) {
            drawItemLabel(g2, dataset, row, column, plot, generator, bar, 
                    (value < 0.0));
        }        

        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null) {
            addItemEntity(entities, dataset, row, column, bar);
        }

    }",Match failed,0,0
9,Chart_25,"protected void drawVerticalItem(Graphics2D g2,
                                    CategoryItemRendererState state,
                                    Rectangle2D dataArea,
                                    CategoryPlot plot,
                                    CategoryAxis domainAxis,
                                    ValueAxis rangeAxis,
                                    StatisticalCategoryDataset dataset,
                                    int row,
                                    int column) {
                                     
        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
        
        // BAR X
        double rectX = domainAxis.getCategoryStart(
            column, getColumnCount(), dataArea, xAxisLocation
        );

        int seriesCount = getRowCount();
        int categoryCount = getColumnCount();
        if (seriesCount > 1) {
            double seriesGap = dataArea.getWidth() * getItemMargin()
                               / (categoryCount * (seriesCount - 1));
            rectX = rectX + row * (state.getBarWidth() + seriesGap);
        }
        else {
            rectX = rectX + row * state.getBarWidth();
        }

        // BAR Y
        Number meanValue = dataset.getMeanValue(row, column);

        double value = meanValue.doubleValue();
        double base = 0.0;
        double lclip = getLowerClip();
        double uclip = getUpperClip();

        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4
            if (value >= uclip) {
                return; // bar is not visible
            }
            base = uclip;
            if (value <= lclip) {
                value = lclip;
            }
        }
        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
            if (value >= uclip) {
                value = uclip;
            }
            else {
                if (value <= lclip) {
                    value = lclip;
                }
            }
        }
        else { // cases 9, 10, 11 and 12
            if (value <= lclip) {
                return; // bar is not visible
            }
            base = getLowerClip();
            if (value >= uclip) {
               value = uclip;
            }
        }

        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);
        double transY2 = rangeAxis.valueToJava2D(value, dataArea, 
                yAxisLocation);
        double rectY = Math.min(transY2, transY1);

        double rectWidth = state.getBarWidth();
        double rectHeight = Math.abs(transY2 - transY1);

        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, 
                rectHeight);
        Paint seriesPaint = getItemPaint(row, column);
        g2.setPaint(seriesPaint);
        g2.fill(bar);
        if (isDrawBarOutline() && state.getBarWidth() > 3) {
            g2.setStroke(getItemStroke(row, column));
            g2.setPaint(getItemOutlinePaint(row, column));
            g2.draw(bar);
        }

        // standard deviation lines
            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    + valueDelta, dataArea, yAxisLocation);
            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    - valueDelta, dataArea, yAxisLocation);

            if (this.errorIndicatorStroke != null) {
                g2.setStroke(this.errorIndicatorStroke);
            }
            else {
                g2.setStroke(getItemOutlineStroke(row, column));
            }
            if (this.errorIndicatorPaint != null) {
                g2.setPaint(this.errorIndicatorPaint);  
            }
            else {
                g2.setPaint(getItemOutlinePaint(row, column));   
            }
            Line2D line = null;
            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,
                                     rectX + rectWidth / 2.0d, highVal);
            g2.draw(line);
            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,
                                     rectX + rectWidth / 2.0d + 5.0d, highVal);
            g2.draw(line);
             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,
                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);
             g2.draw(line);
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
        if (generator != null && isItemLabelVisible(row, column)) {
            drawItemLabel(g2, dataset, row, column, plot, generator, bar, 
                    (value < 0.0));
        }        

        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null) {
            addItemEntity(entities, dataset, row, column, bar);
        }
    }",Match failed,0,0
9,Chart_25,"* @param row  the row index (zero-based).
     * @param column  the column index (zero-based).
     */
    protected void drawVerticalItem(Graphics2D g2,
                                    CategoryItemRendererState state,
                                    Rectangle2D dataArea,
                                    CategoryPlot plot,
                                    CategoryAxis domainAxis,
                                    ValueAxis rangeAxis,
                                    StatisticalCategoryDataset dataset,
                                    int row,
                                    int column) {
                                     
        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
        
        // BAR X
        double rectX = domainAxis.getCategoryStart(
            column, getColumnCount(), dataArea, xAxisLocation
        );

        int seriesCount = getRowCount();
        int categoryCount = getColumnCount();
        if (seriesCount > 1) {
            double seriesGap = dataArea.getWidth() * getItemMargin()
                               / (categoryCount * (seriesCount - 1));
            rectX = rectX + row * (state.getBarWidth() + seriesGap);
        }
        else {
            rectX = rectX + row * state.getBarWidth();
        }

        // BAR Y
        Number meanValue = dataset.getMeanValue(row, column);

        double value = meanValue.doubleValue();
        double base = 0.0;
        double lclip = getLowerClip();
        double uclip = getUpperClip();

        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4
            if (value >= uclip) {
                return; // bar is not visible
            }
            base = uclip;
            if (value <= lclip) {
                value = lclip;
            }
        }
        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
            if (value >= uclip) {
                value = uclip;
            }
            else {
                if (value <= lclip) {
                    value = lclip;
                }
            }
        }
        else { // cases 9, 10, 11 and 12
            if (value <= lclip) {
                return; // bar is not visible
            }
            base = getLowerClip();
            if (value >= uclip) {
               value = uclip;
            }
        }

        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);
        double transY2 = rangeAxis.valueToJava2D(value, dataArea, 
                yAxisLocation);
        double rectY = Math.min(transY2, transY1);

        double rectWidth = state.getBarWidth();
        double rectHeight = Math.abs(transY2 - transY1);

        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, 
                rectHeight);
        Paint seriesPaint = getItemPaint(row, column);
        g2.setPaint(seriesPaint);
        g2.fill(bar);
        if (isDrawBarOutline() && state.getBarWidth() > 3) {
            g2.setStroke(getItemStroke(row, column));
            g2.setPaint(getItemOutlinePaint(row, column));
            g2.draw(bar);
         }
 
         // standard deviation lines
             double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    - valueDelta, dataArea, yAxisLocation);

            if (this.errorIndicatorStroke != null) {
                g2.setStroke(this.errorIndicatorStroke);
            }
            else {
                g2.setStroke(getItemOutlineStroke(row, column));
            }
            if (this.errorIndicatorPaint != null) {
                g2.setPaint(this.errorIndicatorPaint);  
            }
            else {
                g2.setPaint(getItemOutlinePaint(row, column));   
            }
            Line2D line = null;
            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,
                                     rectX + rectWidth / 2.0d, highVal);
            g2.draw(line);
            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,
                                     rectX + rectWidth / 2.0d + 5.0d, highVal);
            g2.draw(line);
            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,
                                     rectX + rectWidth / 2.0d + 5.0d, lowVal);
            g2.draw(line);
        
        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                column);
        if (generator != null && isItemLabelVisible(row, column)) {
            drawItemLabel(g2, dataset, row, column, plot, generator, bar, 
                    (value < 0.0));
        }        

        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null) {",Match failed,0,0
10,Cli_1,"    public Option[] getOptions()
    {
        Collection processed = options.values();

        // reinitialise array
        Option[] optionsArray = new Option[processed.size()];

        // return the array
        return (Option[]) processed.toArray(optionsArray);
    }
","public Option[] getOptions() {
    Collection processed = options.values();

    // Reinitiailize array using proper toArray method
    return processed.toArray(new Option[0]);
}",0,0
10,Cli_1,"    public Iterator iterator()
    {
        return hashcodeMap.values().iterator();
    }
","public Iterator iterator() {
    return hashcodeMap.values().iterator();
}",0,0
10,Cli_1,"    void addOption(Option opt)
    {
        hashcodeMap.put(new Integer(opt.hashCode()), opt);
        String key = opt.getKey();
        if (key == null)
        {
            key = opt.getLongOpt();
        }
        else
        {
            names.put(opt.getLongOpt(), key);
        }
        options.put(key, opt);
    }","void addOption(Option opt) {
    hashcodeMap.put(opt.hashCode(), opt); // Integer boxing is no longer necessary
    String key = opt.getKey();
    if (key == null) {
        key = opt.getLongOpt();
    }
    names.put(opt.getLongOpt(), key); // Eliminated redundant else block
    options.put(key, opt);
}",0,0
10,Cli_1,"    public Object getOptionObject(String opt)
    {
        String res = getOptionValue(opt);

        if (!options.containsKey(opt))
        {
            return null;
        }

        Object type = ((Option) options.get(opt)).getType();

        return (res == null)        ? null : TypeHandler.createValue(res, type);
    }
","public Object getOptionObject(String opt) {
    String res = getOptionValue(opt);

    if (!options.containsKey(opt)) {
        return null;
    }

    Option option = (Option) options.get(opt); // Prevent multiple lookups
    Object type = option.getType();

    return (res == null) ? null : TypeHandler.createValue(res, type);
}",0,0
10,Cli_1,"    public boolean hasOption(String opt)
    {
        return options.containsKey(opt);
    }
","public boolean hasOption(String opt) {
    return options.containsKey(opt != null ? opt.trim() : null); // Added null safety
}",0,0
10,Cli_1,"    private List args = new LinkedList();

    /** the processed options */
    private Map options = new HashMap();
    private Map names = new HashMap();

    /** Map of unique options for ease to get complete list of options */
//    private Set allOptions = new HashSet();
    private Map hashcodeMap = new HashMap();

    /**
","private List args = new LinkedList<>();
private Map options = new HashMap<>();
private Map names = new HashMap<>();
private Map hashcodeMap = new HashMap<>();",0,0
10,Cli_1,"    public String[] getOptionValues(String opt)
    {
        opt = Util.stripLeadingHyphens(opt);

        String key = opt;
        if (names.containsKey(opt))
        {
            key = (String) names.get(opt);
        }
        if (options.containsKey(key))
        {
            return ((Option) options.get(key)).getValues();
        }

        return null;
        }
","public String[] getOptionValues(String opt) {
    opt = Util.stripLeadingHyphens(opt);

    String key = opt;
    if (names.containsKey(opt)) {
        key = (String) names.get(opt);
    }
    Option option = (Option) options.get(key); // Consolidated lookups
    if (option != null) {
        return option.getValues();
    }

    return null;
}",0,0
11,Cli_10,"protected void setOptions(final Options options) {
         this.options = options;
         this.requiredOptions = options.getRequiredOptions();
     }","protected void setOptions(final Options options) {
    this.options = options;
    // Create a copy of the required options to avoid modifying the original list.
    this.requiredOptions = new ArrayList<>(options.getRequiredOptions());
}",0,0
12,Cli_13,"public void processValues(final WriteableCommandLine commandLine,
                              final ListIterator arguments,
                               final Option option)
         throws OptionException {
         // count of arguments processed for this option.
         int argumentCount = 0;
 
         while (arguments.hasNext() && (argumentCount < maximum)) {
             final String allValuesQuoted = (String) arguments.next();
            final String allValues = stripBoundaryQuotes(allValuesQuoted);

            // should we ignore things that look like options?
            if (allValuesQuoted.equals(consumeRemaining)) {
                while (arguments.hasNext() && (argumentCount < maximum)) {
                    ++argumentCount;
                    commandLine.addValue(option, arguments.next());
                }
            }
            // does it look like an option?
            else if (commandLine.looksLikeOption(allValuesQuoted)) {
                arguments.previous();

                break;
            }
            // should we split the string up?
            else if (subsequentSplit) {
                final StringTokenizer values =
                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));

                arguments.remove();

                while (values.hasMoreTokens() && (argumentCount < maximum)) {
                    ++argumentCount;

                    final String token = values.nextToken();
                    commandLine.addValue(option, token);
                    arguments.add(token);
                }

                if (values.hasMoreTokens()) {
                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,
                                              values.nextToken());
                }
            }
            // it must be a value as it is
            else {
                ++argumentCount;
                commandLine.addValue(option, allValues);
            }
        }
    }","public void processValues(final WriteableCommandLine commandLine,
                              final ListIterator arguments,
                              final Option option)
         throws OptionException {
    // count of arguments processed for this option.
    int argumentCount = 0;

    while (arguments.hasNext() && (argumentCount < maximum)) {
        final String allValuesQuoted = (String) arguments.next();
        final String allValues = stripBoundaryQuotes(allValuesQuoted);

        // should we ignore things that look like options?
        if (allValues.equals(consumeRemaining)) {
            while (arguments.hasNext() && (argumentCount < maximum)) {
                ++argumentCount;
                commandLine.addValue(option, arguments.next());
            }
            break;

        } else if (commandLine.looksLikeOption(allValuesQuoted)) {
            arguments.previous();
            break;

        } else if (subsequentSplit) {
            final StringTokenizer values =
                new StringTokenizer(allValues, String.valueOf(subsequentSeparator));
            
            arguments.remove();

            while (values.hasMoreTokens() && (argumentCount < maximum)) {
                final String token = values.nextToken();
                commandLine.addValue(option, token);
                ++argumentCount;
            }

            // Ensure we don't re-add tokens unnecessarily
            if (values.hasMoreTokens()) {
                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,
                                          values.nextToken());
            }

        } else {
            ++argumentCount;
            commandLine.addValue(option, allValues);
        }
    }
}",0,0
13,Cli_16,"public void addOption(Option option) {
        options.add(option);
        nameToOption.put(option.getPreferredName(), option);

        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {
            nameToOption.put(i.next(), option);
         }
 
         // ensure that all parent options are also added
     }","public void addOption(Option option) {
    if (option == null) {
        throw new IllegalArgumentException(""Option cannot be null"");
    }

    options.add(option);
    nameToOption.put(option.getPreferredName(), option);

    for (Object trigger : option.getTriggers()) {
        nameToOption.put(trigger, option);
    }

    // ensure that all parent options are also added
    if (option.getParent() != null) {
        addOption(option.getParent());
    }
}",0,0
14,Cli_18,"protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle SPECIAL TOKEN
            if (token.startsWith(""--""))
            {
                if (token.indexOf('=') != -1)
                {
                    tokens.add(token.substring(0, token.indexOf('=')));
                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
                }
                else
                {
                    tokens.add(token);
                }
            }

             // single hyphen
             else if (""-"".equals(token))
             {
                 processSingleHyphen(token);
             }
             else if (token.startsWith(""-""))
             {
                if (token.length() == 2)
                {
                    processOptionToken(token, stopAtNonOption);
                }
                else if (options.hasOption(token))
                {
                    tokens.add(token);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                process(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
{
    init();
    this.options = options;

    // an iterator for the command line tokens
    Iterator<String> iter = Arrays.asList(arguments).iterator();

    // process each command line token
    while (iter.hasNext())
    {
        // get the next command line token
        String token = iter.next();

        // handle SPECIAL TOKEN
        if (token.startsWith(""--""))
        {
            if (token.indexOf('=') != -1)
            {
                tokens.add(token.substring(0, token.indexOf('=')));
                tokens.add(token.substring(token.indexOf('=') + 1));
            }
            else
            {
                tokens.add(token);
            }
        }
        // single hyphen
        else if (""-"".equals(token))
        {
            processSingleHyphen(token);
        }
        else if (token.startsWith(""-""))
        {
            if (token.length() == 2)
            {
                processOptionToken(token, stopAtNonOption);
            }
            else if (options.hasOption(Util.stripLeadingHyphens(token)))
            {
                tokens.add(token);
            }
            // requires bursting
            else
            {
                burstToken(token, stopAtNonOption);
            }
        }
        else if (stopAtNonOption)
        {
            eatTheRest = true;
            gobble(iter);
        }
        else
        {
            tokens.add(token);
        }
    }

    return tokens.toArray(new String[0]);
}",0,0
14,Cli_18,"private void processOptionToken(String token, boolean stopAtNonOption)
    {
        if (options.hasOption(token))
        {
            currentOption = options.getOption(token);
            tokens.add(token);
        }
         else if (stopAtNonOption)
         {
             eatTheRest = true;
         }
     }","private void processOptionToken(String token, boolean stopAtNonOption)
{
    String strippedToken = Util.stripLeadingHyphens(token);

    if (options.hasOption(strippedToken))
    {
        currentOption = options.getOption(strippedToken);
        tokens.add(token);
    }
    else if (stopAtNonOption)
    {
        eatTheRest = true;
    }
}",0,0
15,Cli_21,"public boolean looksLikeOption(final String trigger)
    {
            // this is a reentrant call

            for (final Iterator i = prefixes.iterator(); i.hasNext();)
            {
                final String prefix = (String) i.next();

                if (trigger.startsWith(prefix))
                {
                        return true;
                }
            }
            return false;
    }

    public String toString() {
        final StringBuffer buffer = new StringBuffer();

        // need to add group header
        for (final Iterator i = normalised.iterator(); i.hasNext();) {
            final String arg = (String) i.next();

            if (arg.indexOf(' ') >= 0) {
                buffer.append(""\"""").append(arg).append(""\"""");
            } else {
                buffer.append(arg);
            }

            if (i.hasNext()) {
                buffer.append(' ');","public boolean looksLikeOption(final String trigger) {
    for (final String prefix : prefixes) {
        if (trigger.startsWith(prefix)) {
            return true;
        }
    }
    return false;
}

public String toString() {
    final StringBuilder buffer = new StringBuilder();
    for (final String arg : normalised) {
        if (arg.contains("" "")) {
            buffer.append(""\"""").append(arg).append(""\"""");
        } else {
            buffer.append(arg);
        }
        buffer.append(' ');
    }
    return buffer.toString().trim(); // Ensure trailing spaces are removed
}",0,0
15,Cli_21,"private boolean looksLikeOption(final WriteableCommandLine commandLine,
             final String trigger) {
             return commandLine.looksLikeOption(trigger);
     }","private boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) {
    return (trigger != null && commandLine.looksLikeOption(trigger));
}",0,0
16,Cli_22,"protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle long option --foo or --foo=bar
            if (token.startsWith(""--""))
            {
                int pos = token.indexOf('=');
                String opt = pos == -1 ? token : token.substring(0, pos); // --foo
 
                 if (!options.hasOption(opt))
                 {
                     processNonOptionToken(token);
                 }
                 else
                 {
                     
                     tokens.add(opt);
                     if (pos != -1)
                    {
                        tokens.add(token.substring(pos + 1));
                    }
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                tokens.add(token);
            }
            else if (token.startsWith(""-""))
            {
                if (token.length() == 2 || options.hasOption(token))
                {
                    processOptionToken(token, stopAtNonOption);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                processNonOptionToken(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;

    // an iterator for the command line tokens
    Iterator<String> iter = Arrays.asList(arguments).iterator();

    // process each command line token
    while (iter.hasNext()) {
        // get the next command line token
        String token = iter.next();

        // handle long option --foo or --foo=bar
        if (token.startsWith(""--"")) {
            int pos = token.indexOf('=');
            String opt = pos == -1 ? token : token.substring(0, pos); // --foo

            if (!options.hasOption(opt)) {
                processNonOptionToken(token);
            } else {
                tokens.add(opt);
                if (pos != -1) {
                    tokens.add(token.substring(pos + 1));
                }
            }
        }

        // single hyphen
        else if (""-"".equals(token)) {
            tokens.add(token);
        } else if (token.startsWith(""-"")) {
            if (token.length() == 2 || options.hasOption(token)) {
                processOptionToken(token, stopAtNonOption);
            }
            // requires bursting
            else {
                burstToken(token, stopAtNonOption);
            }
        } else if (stopAtNonOption) {
            processNonOptionToken(token);
        } else {
            tokens.add(token);
        }

        gobble(iter);
    }

    return tokens.toArray(new String[0]);
}",0,0
16,Cli_22,"private void processOptionToken(String token, boolean stopAtNonOption)
    {
        if (stopAtNonOption && !options.hasOption(token))
        {
             eatTheRest = true;
         }
 
 
         tokens.add(token);
     }","private void processOptionToken(String token, boolean stopAtNonOption) {
    if (stopAtNonOption && !options.hasOption(token)) {
        eatTheRest = true;
    }

    tokens.add(token);
}",0,0
16,Cli_22,"protected void burstToken(String token, boolean stopAtNonOption)
    {
        Option currentOption;
        for (int i = 1; i < token.length(); i++)
        {
            String ch = String.valueOf(token.charAt(i));

            if (options.hasOption(ch))
            {
                tokens.add(""-"" + ch);
                currentOption = options.getOption(ch);

                if (currentOption.hasArg() && (token.length() != (i + 1)))
                {
                    tokens.add(token.substring(i + 1));

                    break;
                }
             }
             else if (stopAtNonOption)
             {
                 processNonOptionToken(token.substring(i));
                 break;
             }
             else
            {
                tokens.add(token);
                break;
            }
        }
    }","protected void burstToken(String token, boolean stopAtNonOption) {
    Option currentOption = null;
    for (int i = 1; i < token.length(); i++) {
        String ch = String.valueOf(token.charAt(i));

        if (options.hasOption(ch)) {
            tokens.add(""-"" + ch);
            currentOption = options.getOption(ch);

            if (currentOption.hasArg() && (token.length() != (i + 1))) {
                tokens.add(token.substring(i + 1));
                break;
            }
        } else if (stopAtNonOption) {
            processNonOptionToken(token.substring(i));
            break;
        } else {
            tokens.add(token);
            break;
        }
    }
}",0,0
17,Cli_3,"public static Number createNumber(String str)
     {
         try
         {
             return NumberUtils.createNumber(str);
         }
         catch (NumberFormatException nfe)
         {
            System.err.println(nfe.getMessage());
        }

        return null;
    }","public static Number createNumber(String str) {
    if (str == null || str.isEmpty()) {
        return null;
    }
    try {
        return NumberUtils.createNumber(str);
    } catch (NumberFormatException nfe) {
        System.err.println(""Invalid number format: "" + str);  // Provide more descriptive error handling
        return null;
    }
}",0,0
18,Cli_30,"private void handleProperties(Properties properties) throws ParseException
    {
        if (properties == null)
        {
            return;
        }
        
        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)
         {
             String option = e.nextElement().toString();
             
             if (!cmd.hasOption(option))
             {
                 Option opt = options.getOption(option);
             
             // if the option is part of a group, check if another option of the group has been selected
             
                 // get the value from the properties
                 String value = properties.getProperty(option);
                 
                if (opt.hasArg())
                {
                    if (opt.getValues() == null || opt.getValues().length == 0)
                    {
                        opt.addValueForProcessing(value);
                    }
                }
                else if (!(""yes"".equalsIgnoreCase(value)
                        || ""true"".equalsIgnoreCase(value)
                        || ""1"".equalsIgnoreCase(value)))
                {
                    // if the value is not yes, true or 1 then don't add the option to the CommandLine
                    continue;
                }
                
                handleOption(opt);
                currentOption = null;
            }
        }
    }","private void handleProperties(Properties properties) throws ParseException {
    if (properties == null) {
        return;
    }

    for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {
        String option = e.nextElement().toString();

        if (!cmd.hasOption(option)) {
            Option opt = options.getOption(option);

            if (opt == null) {
                continue; // Ensure opt is not null before proceeding
            }

            // Get the value from the properties
            String value = properties.getProperty(option);

            if (opt.hasArg()) {
                if (opt.getValues() == null || opt.getValues().length == 0) {
                    opt.addValueForProcessing(value);
                }
            } else if (!(""yes"".equalsIgnoreCase(value)
                    || ""true"".equalsIgnoreCase(value)
                    || ""1"".equalsIgnoreCase(value))) {
                // If the value is not yes, true or 1 then don't add the option to the CommandLine
                continue;
            }

            handleOption(opt);
            currentOption = null;
        }
    }
}",0,0
18,Cli_30,"protected void processProperties(Properties properties) throws ParseException
    {
        if (properties == null)
        {
            return;
        }

        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)
         {
             String option = e.nextElement().toString();
             
             if (!cmd.hasOption(option))
             {
                 Option opt = getOptions().getOption(option);
             
             // if the option is part of a group, check if another option of the group has been selected
             
                 // get the value from the properties instance
                 String value = properties.getProperty(option);
 
                if (opt.hasArg())
                {
                    if (opt.getValues() == null || opt.getValues().length == 0)
                    {
                        try
                        {
                            opt.addValueForProcessing(value);
                        }
                        catch (RuntimeException exp)
                        {
                            // if we cannot add the value don't worry about it
                        }
                    }
                }
                else if (!(""yes"".equalsIgnoreCase(value)
                        || ""true"".equalsIgnoreCase(value)
                        || ""1"".equalsIgnoreCase(value)))
                {
                    // if the value is not yes, true or 1 then don't add the
                    // option to the CommandLine
                    continue;
                }

                cmd.addOption(opt);
                updateRequiredOptions(opt);
            }
        }
    }","protected void processProperties(Properties properties) throws ParseException {
    if (properties == null) {
        return;
    }

    for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {
        String option = e.nextElement().toString();

        if (!cmd.hasOption(option)) {
            Option opt = getOptions().getOption(option);

            if (opt == null) {
                continue; // Ensure opt is not null before proceeding
            }

            // Get the value from the properties instance
            String value = properties.getProperty(option);

            if (opt.hasArg()) {
                if (opt.getValues() == null || opt.getValues().length == 0) {
                    try {
                        opt.addValueForProcessing(value);
                    } catch (RuntimeException exp) {
                        // If we cannot add the value, don't worry about it
                    }
                }
            } else if (!(""yes"".equalsIgnoreCase(value)
                    || ""true"".equalsIgnoreCase(value)
                    || ""1"".equalsIgnoreCase(value))) {
                // If the value is not yes, true or 1 then don't add the option to the CommandLine
                continue;
            }

            cmd.addOption(opt);
            updateRequiredOptions(opt);
        }
    }
}",0,0
19,Cli_31,"private void appendOption(final StringBuffer buff, final Option option, final boolean required)
    {
        if (!required)
        {
            buff.append(""["");
        }

        if (option.getOpt() != null)
        {
            buff.append(""-"").append(option.getOpt());
        }
        else
        {
            buff.append(""--"").append(option.getLongOpt());
         }
         
         // if the Option has a value and a non blank argname
         if (option.hasArg() && option.hasArgName())
         {
             buff.append(option.getOpt() == null ? longOptSeparator : "" "");
             buff.append(""<"").append(option.getArgName()).append("">"");
         }
         
         // if the Option is not a required option
        if (!required)
        {
            buff.append(""]"");
        }
    }","private void appendOption(final StringBuffer buff, final Option option, final boolean required) {
    if (!required) {
        buff.append(""["");
    }

    if (option.getOpt() != null) {
        buff.append(""-"").append(option.getOpt());
    } else {
        buff.append(""--"").append(option.getLongOpt());
    }

    // if the Option has a value and a non-blank argname
    if (option.hasArg() && option.hasArgName()) {
        buff.append(option.getOpt() == null ? longOptSeparator : "" "");
        buff.append(""<"").append(option.getArgName()).append("">"");
    }

    // Close bracket for optional options
    if (!required) {
        buff.append(""]"");
    }
}",0,0
19,Cli_31,"private static void reset()
     {
         description = null;
         argName = ""arg"";
         longopt = null;
         type = null;
         required = false;
        numberOfArgs = Option.UNINITIALIZED;
        optionalArg = false;
        valuesep = (char) 0;
    }","private static void reset() {
    description = null;
    argName = ""arg"";
    longopt = null;
    type = null;
    required = false;
    numberOfArgs = Option.UNINITIALIZED;
    optionalArg = false;
    valuesep = '\0'; // Updated to use character literal for zero
}",0,0
20,Cli_33,"public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)
     {
         StringBuffer sb = new StringBuffer(text.length());
 
         renderWrappedText(sb, width, nextLineTabStop, text);
         pw.println(sb.toString());
     }","public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {
    if (pw == null || text == null) {
        throw new IllegalArgumentException(""PrintWriter and text must not be null."");
    }
    if (width <= 0) {
        throw new IllegalArgumentException(""Width must be greater than 0."");
    }

    StringBuffer sb = new StringBuffer(text.length());
    renderWrappedText(sb, width, nextLineTabStop, text);
    pw.println(sb.toString());
}",0,0
21,Cli_34,"private static void reset()
    {
         description = null;
         argName = null;
         longopt = null;
         type = null;
         required = false;
         numberOfArgs = Option.UNINITIALIZED;
         optionalArg = false;
        valuesep = (char) 0;
    }","private static void reset() {
    Option.description = null;
    Option.argName = null;
    Option.longopt = null;
    Option.type = null;
    Option.required = false;
    Option.numberOfArgs = Option.UNINITIALIZED;
    Option.optionalArg = false;
    Option.valuesep = (char) 0;
}",0,0
22,Cli_36,"    private final List<Object> requiredOpts = new ArrayList<Object>();

    /** a map of the option groups */
    private final Map<String, OptionGroup> optionGroups = new java.util.HashMap<String, OptionGroup>();

    /**
","private final List<Object> requiredOpts = new ArrayList<>();

/** a map of the option groups */
private final Map<String, OptionGroup> optionGroups = new HashMap<>();",0,0
22,Cli_36,"    private final Map<String, Option> optionMap = new HashMap<String, Option>();

    /** the name of the selected option */
    private String selected;

    /** specified whether this group is required */
    private boolean required;

    /**
","private final Map<String, Option> optionMap = new HashMap<>();

/** the name of the selected option */
private String selected;

/** specifies whether this group is required */
private boolean required;",0,0
23,Cli_39,"public static Object createValue(final String str, final Class<?> clazz) throws ParseException
    {
        if (PatternOptionBuilder.STRING_VALUE == clazz)
        {
            return str;
        }
        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)
        {
            return createObject(str);
        }
        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)
        {
            return createNumber(str);
        }
        else if (PatternOptionBuilder.DATE_VALUE == clazz)
        {
            return createDate(str);
        }
        else if (PatternOptionBuilder.CLASS_VALUE == clazz)
        {
            return createClass(str);
        }
        else if (PatternOptionBuilder.FILE_VALUE == clazz)
        {
            return createFile(str);
         }
         else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)
         {
             return createFile(str);
         }
         else if (PatternOptionBuilder.FILES_VALUE == clazz)
         {
            return createFiles(str);
        }
        else if (PatternOptionBuilder.URL_VALUE == clazz)
        {
            return createURL(str);
        }
        else
        {
            return null;
        }
    }","public static Object createValue(final String str, final Class<?> clazz) throws ParseException
{
    if (str == null || clazz == null) {
        throw new IllegalArgumentException(""Input string and class type cannot be null"");
    }

    if (PatternOptionBuilder.STRING_VALUE == clazz) {
        return str;
    } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) {
        return createObject(str);
    } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) {
        return createNumber(str);
    } else if (PatternOptionBuilder.DATE_VALUE == clazz) {
        return createDate(str);
    } else if (PatternOptionBuilder.CLASS_VALUE == clazz) {
        return createClass(str);
    } else if (PatternOptionBuilder.FILE_VALUE == clazz) {
        return createFile(str);
    } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) {
        File file = createFile(str);
        if (!file.exists()) {
            throw new ParseException(""File does not exist: "" + str, 0);
        }
        return file;
    } else if (PatternOptionBuilder.FILES_VALUE == clazz) {
        return createFiles(str);
    } else if (PatternOptionBuilder.URL_VALUE == clazz) {
        return createURL(str);
    } else {
        throw new ParseException(""Unknown class type: "" + clazz, 0);
    }
}",0,0
24,Cli_7,"    public PatternBuilder(
        final GroupBuilder gbuilder,
        final DefaultOptionBuilder obuilder,
        final ArgumentBuilder abuilder) {
        this.gbuilder = gbuilder;
        this.obuilder = obuilder;
        this.abuilder = abuilder;
    }
","public PatternBuilder(
        final GroupBuilder gbuilder,
        final DefaultOptionBuilder obuilder,
        final ArgumentBuilder abuilder) {
    if (gbuilder == null || obuilder == null || abuilder == null) {
        throw new IllegalArgumentException(""GroupBuilder, DefaultOptionBuilder, and ArgumentBuilder must not be null."");
    }
    this.gbuilder = gbuilder;
    this.obuilder = obuilder;
    this.abuilder = abuilder;
}",0,0
25,Closure_100,"private boolean shouldReportThis(Node n, Node parent) {
    if (assignLhsChild != null) {
      // Always report a THIS on the left side of an assign.
      return true;
     }
 
     // Also report a THIS with a property access.
     return false;
   }","private boolean shouldReportThis(Node n, Node parent) {
    if (assignLhsChild != null) {
        // Always report a THIS on the left side of an assign.
        return true;
    }

    // Also report a THIS with a property access.
    if (parent != null && parent.getType() == Token.GETPROP) {
        return true;
    }

    return false;
}",0,0
25,Closure_100,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
       // var a = function() { }; // or
       // function a() {} // or
       // a.x = function() {};
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (lhs.getType() == Token.GETPROP) {
          if (lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          String leftName = lhs.getQualifiedName();
          if (leftName != null && leftName.contains("".prototype."")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {
            return false;
        }

        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. 
        // This includes top-level functions and methods.
        if (parent != null && parent.getType() != Token.SCRIPT && parent.getType() != Token.BLOCK) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            // Always traverse the left side of the assignment. To handle
            // nested assignments properly (e.g., (a = this).property = c;),
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // Only traverse the right side if it's not an assignment to a prototype
            // property or subproperty.
            if (lhs.getType() == Token.GETPROP) {
                if (lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                String leftName = lhs.getQualifiedName();
                if (leftName != null && leftName.contains("".prototype."")) {
                    return false;
                }
            }
        }
    }

    return true;
}",0,0
26,Closure_103,"@Override public ObjectType getTypeWithProperty(String field, JSType type) {
      if (!(type instanceof ObjectType)) {
        if (type.autoboxesTo() != null) {
          type = type.autoboxesTo();
        } else {
          return null;
        }
      }

      // Ignore the prototype itself at all times.
      if (""prototype"".equals(field)) {
        return null;
      }

      // We look up the prototype chain to find the highest place (if any) that
      // this appears.  This will make references to overriden properties look
      // like references to the initial property, so they are renamed alike.
      ObjectType foundType = null;
      ObjectType objType = ObjectType.cast(type);
      while (objType != null && objType.getImplicitPrototype() != objType) {
        if (objType.hasOwnProperty(field)) {
          foundType = objType;
        }
        objType = objType.getImplicitPrototype();
       }
       // If the property does not exist on the referenced type but the original
       // type is an object type, see if any subtype has the property.
         // getGreatestSubtypeWithProperty does not guarantee that the property
         // is defined on the returned type, it just indicates that it might be,
         // so we have to double check.
       return foundType;
     }","@Override
public ObjectType getTypeWithProperty(String field, JSType type) {
    if (!(type instanceof ObjectType)) {
        if (type.autoboxesTo() != null) {
            type = type.autoboxesTo();
        } else {
            return null;
        }
    }

    // Ignore the prototype itself at all times.
    if (""prototype"".equals(field)) {
        return null;
    }

    // We look up the prototype chain to find the highest place (if any) that
    // this appears. This will make references to overridden properties look
    // like references to the initial property, so they are renamed alike.
    ObjectType foundType = null;
    ObjectType objType = ObjectType.cast(type);
    while (objType != null && objType.getImplicitPrototype() != objType) {
        if (objType.hasOwnProperty(field)) {
            foundType = objType;
            break; // Ensures that we select only the first instance in the prototype chain.
        }
        objType = objType.getImplicitPrototype();
    }

    // If the property does not exist on the referenced type but the original
    // type is an object type, see if any subtype has the property.
    if (foundType == null && type instanceof ObjectType) {
        ObjectType greatestSubtype = ((ObjectType) type).getGreatestSubtypeWithProperty(field);
        if (greatestSubtype != null && greatestSubtype.hasOwnProperty(field)) {
            foundType = greatestSubtype;
        }
    }

    return foundType;
}",0,0
26,Closure_103,"private static boolean mayThrowException(Node n) {
    switch (n.getType()) {
      case Token.CALL:
      case Token.GETPROP:
      case Token.GETELEM:
      case Token.THROW:
      case Token.NEW:
       case Token.ASSIGN:
       case Token.INC:
       case Token.DEC:
         return true;
       case Token.FUNCTION:
         return false;
    }
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {
        return true;
      }
    }
    return false;
  }","private static boolean mayThrowException(Node n) {
    switch (n.getType()) {
        case Token.CALL:
        case Token.GETPROP:
        case Token.GETELEM:
        case Token.THROW:
        case Token.NEW:
        case Token.ASSIGN:
        case Token.INC:
        case Token.DEC:
        case Token.INSTANCEOF: // Explicitly handle INSTANCEOF operation that may throw.
            return true;
        case Token.FUNCTION:
            return false;
    }

    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {
            return true;
        }
    }

    return false;
}",0,0
27,Closure_106,"boolean canCollapseUnannotatedChildNames() {
      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {
        return false;
      }

       // Don't try to collapse if the one global set is a twin reference.
       // We could theoretically handle this case in CollapseProperties, but
       // it's probably not worth the effort.
 
       if (isClassOrEnum) {
         return true;
      }
      return (type == Type.FUNCTION || aliasingGets == 0) &&
          (parent == null || parent.canCollapseUnannotatedChildNames());
    }","boolean canCollapseUnannotatedChildNames() {
    if (type == Type.OTHER || globalSets != 1 || localSets != 0 || aliasingGets != 0) {
        return false;
    }

    // Don't try to collapse if the one global set is a twin reference.
    // We could theoretically handle this case in CollapseProperties, but
    // it's probably not worth the effort.
    if (isClassOrEnum) {
        return true;
    }
    return (type == Type.FUNCTION || aliasingGets == 0) &&
           (parent == null || parent.canCollapseUnannotatedChildNames());
}",0,0
28,Closure_108,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVar = parent.isVar();
        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
          recordAlias(v);
        } else if (v.isBleedingFunction()) {
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
        } else if (parent.getType() == Token.LP) {
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else if (isVar || isFunctionDecl) {
          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
          Node grandparent = parent.getParent();
          Node value = v.getInitialValue() != null ?
              v.getInitialValue() :
              null;
          Node varNode = null;

          String name = n.getString();
          int nameCount = scopedAliasNames.count(name);
          scopedAliasNames.add(name);
          String globalName =
              ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));

          compiler.ensureLibraryInjected(""base"");

          // First, we need to free up the function expression (EXPR)
          // to be used in another expression.
          if (isFunctionDecl) {
            // Replace ""function NAME() { ... }"" with ""var NAME;"".
            Node existingName = v.getNameNode();

            // We can't keep the local name on the function expression,
            // because IE is buggy and will leak the name into the global
            // scope. This is covered in more detail here:
            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf
            //
            // This will only cause problems if this is a hoisted, recursive
            // function, and the programmer is using the hoisting.
            Node newName = IR.name("""").useSourceInfoFrom(existingName);
            value.replaceChild(existingName, newName);

            varNode = IR.var(existingName).useSourceInfoFrom(existingName);
            grandparent.replaceChild(parent, varNode);
          } else {
            if (value != null) {
              // If this is a VAR, we can just detach the expression and
              // the tree will still be valid.
              value.detachFromParent();
            }
            varNode = parent;
          }

          // Add $jscomp.scope.name = EXPR;
          // Make sure we copy over all the jsdoc and debug info.
          if (value != null || v.getJSDocInfo() != null) {
            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
                compiler.getCodingConvention(),
                globalName,
                value,
                v.getJSDocInfo())
                .useSourceInfoIfMissingFromForTree(n);
            NodeUtil.setDebugInformation(
                newDecl.getFirstChild().getFirstChild(), n, name);

            if (isHoisted) {
              grandparent.addChildToFront(newDecl);
             } else {
               grandparent.addChildBefore(newDecl, varNode);
             }
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
          v.getNameNode().addChildToFront(
              NodeUtil.newQualifiedNameNode(
                  compiler.getCodingConvention(), globalName, n, name));

          recordAlias(v);
        } else {
          // Do not other kinds of local symbols, like catch params.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
      }
    }","private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVar = parent.isVar();
        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
            recordAlias(v);
        } else if (v.isBleedingFunction()) {
            // Bleeding functions already get a BAD_PARAMETERS error, so just do nothing.
        } else if (parent != null && parent.getType() == Token.LP) {
            // Parameters of the scope function also get a BAD_PARAMETERS error.
        } else if (isVar || isFunctionDecl) {
            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
            Node grandparent = parent.getParent();
            Node value = v.getInitialValue();

            Node varNode = null;
            String name = n.getString();
            int nameCount = scopedAliasNames.count(name);
            scopedAliasNames.add(name);
            String globalName = ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));

            compiler.ensureLibraryInjected(""base"");

            if (isFunctionDecl) {
                Node existingName = v.getNameNode();
                Node newName = IR.name("""").useSourceInfoFrom(existingName);
                value.replaceChild(existingName, newName);

                varNode = IR.var(existingName).useSourceInfoFrom(existingName);
                if (grandparent != null) {
                    grandparent.replaceChild(parent, varNode);
                }
            } else {
                if (value != null) {
                    value.detachFromParent();
                }
                varNode = parent;
            }

            if (value != null || v.getJSDocInfo() != null) {
                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
                        compiler.getCodingConvention(),
                        globalName,
                        value,
                        v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
                NodeUtil.setDebugInformation(
                        newDecl.getFirstChild().getFirstChild(), n, name);

                if (isHoisted && grandparent != null) {
                    grandparent.addChildToFront(newDecl);
                } else if (grandparent != null) {
                    grandparent.addChildBefore(newDecl, varNode);
                }
            }

            v.getNameNode().addChildToFront(
                    NodeUtil.newQualifiedNameNode(
                            compiler.getCodingConvention(), globalName, n, name));

            recordAlias(v);
        } else {
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}",0,0
28,Closure_108,"@Override
    public void exitScope(NodeTraversal t) {
      if (t.getScopeDepth() > 2) {
        findNamespaceShadows(t);
      }
 
       if (t.getScopeDepth() == 2) {
         renameNamespaceShadows(t);
         aliases.clear();
         forbiddenLocals.clear();
         transformation = null;
        hasNamespaceShadows = false;
      }
    }","@Override
public void exitScope(NodeTraversal t) {
    if (t.getScopeDepth() > 2) {
        findNamespaceShadows(t);
    }

    if (t.getScopeDepth() == 2) {
        renameNamespaceShadows(t);
        aliases.clear();
        forbiddenLocals.clear();
        transformation = null;
        hasNamespaceShadows = false;
    }
}",0,0
28,Closure_108,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
      }

      if (t.getScopeDepth() < 2) {
        return;
      }

      int type = n.getType();
      Var aliasVar = null;
      if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(n.getString());
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
          aliasVar = lexicalVar;
        }
      }

      // Validate the top-level of the goog.scope block.
      if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
          if (aliasVar.getNode() == n) {
            aliasDefinitionsInOrder.add(n);

            // Return early, to ensure that we don't record a definition
            // twice.
            return;
          } else {
            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
          }
        }

        if (type == Token.RETURN) {
          report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
          report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
          report(t, n, GOOG_SCOPE_USES_THROW);
        }
      }

      // Validate all descendent scopes of the goog.scope block.
      if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (aliasVar != null) {
          // Note, to support the transitive case, it's important we don't
          // clone aliasedNode here.  For example,
          // var g = goog; var d = g.dom; d.createElement('DIV');
          // The node in aliasedNode (which is ""g"") will be replaced in the
          // changes pass above with ""goog"".  If we cloned here, we'd end up
          // with <code>g.dom.createElement('DIV')</code>.
          aliasUsages.add(new AliasedNode(aliasVar, n));
        }

         // When we inject declarations, we duplicate jsdoc. Make sure
         // we only process that jsdoc once.
         JSDocInfo info = n.getJSDocInfo();
         if (info != null) {
           for (Node node : info.getTypeNodes()) {
             fixTypeNode(node);
           }
        }

        // TODO(robbyw): Error for goog.scope not at root.
      }
    }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }

    if (t.getScopeDepth() < 2) {
        return;
    }

    int type = n.getType();
    Var aliasVar = null;
    if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(name);
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
            aliasVar = lexicalVar;
        }
    }

    if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
            if (aliasVar.getNode() == n) {
                aliasDefinitionsInOrder.add(n);
                return;
            } else {
                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
            }
        }

        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }

    if (t.getScopeDepth() >= 2) {
        if (aliasVar != null) {
            aliasUsages.add(new AliasedNode(aliasVar, n));
        }

        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
    }
}",0,0
29,Closure_110,"public Node getChildBefore(Node child) {
    if (child == first) {
       return null;
     }
     Node n = first;
 
     while (n.next != child) {
       n = n.next;
      if (n == null) {
        throw new RuntimeException(""node is not a child"");
      }
    }
    return n;
  }","public Node getChildBefore(Node child) {
    if (child == first) {
        return null;
    }
    Node n = first;

    while (n != null && n.next != child) {
        n = n.next;
    }
    if (n == null) {
        throw new RuntimeException(""node is not a child"");
    }
    return n;
}",0,0
29,Closure_110,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
        } else if (parent.getType() == Token.LP) {
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else if (isVar) {
          Node grandparent = parent.getParent();
          Node value = n.hasChildren() ?
              v.getInitialValue().detachFromParent() :
              null;
          Node varNode = parent;

          String name = n.getString();
          int nameCount = scopedAliasNames.count(name);
          scopedAliasNames.add(name);
          String globalName =
              ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));

          compiler.ensureLibraryInjected(""base"");

          // First, we need to free up the function expression (EXPR)
          // to be used in another expression.
            // Replace ""function NAME() { ... }"" with ""var NAME;"".

            // We can't keep the local name on the function expression,
            // because IE is buggy and will leak the name into the global
            // scope. This is covered in more detail here:
            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf
            //
            // This will only cause problems if this is a hoisted, recursive
            // function, and the programmer is using the hoisting.

              // If this is a VAR, we can just detach the expression and
              // the tree will still be valid.

          // Add $jscomp.scope.name = EXPR;
          // Make sure we copy over all the jsdoc and debug info.
          if (value != null || v.getJSDocInfo() != null) {
            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
                compiler.getCodingConvention(),
                globalName,
                value,
                v.getJSDocInfo())
                .useSourceInfoIfMissingFromForTree(n);
            NodeUtil.setDebugInformation(
                newDecl.getFirstChild().getFirstChild(), n, name);

              grandparent.addChildBefore(newDecl, varNode);
          }

          // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
          v.getNameNode().addChildToFront(
              NodeUtil.newQualifiedNameNode(
                  compiler.getCodingConvention(), globalName, n, name));

          recordAlias(v);
        } else {
          // Do not other kinds of local symbols, like catch params.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
      }
    }","private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();

        if (parent.isVar() && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
            recordAlias(v);
        } else if (v.isBleedingFunction()) {
            // Bleeding functions already get a BAD_PARAMETERS error, so do nothing.
        } else if (parent.getType() == Token.LP) {
            // Parameters of the scope function also get a BAD_PARAMETERS error, so do nothing.
        } else if (parent.isVar()) {
            Node grandparent = parent.getParent();
            Node value = n.hasChildren() ? v.getInitialValue() : null;
            Node varNode = parent;

            String name = n.getString();
            int nameCount = scopedAliasNames.count(name);
            scopedAliasNames.add(name);
            String globalName =
                ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));

            compiler.ensureLibraryInjected(""base"");

            // If value is null, do not call detachFromParent()
            if (value != null) {
                value.detachFromParent();
            }

            // Add $jscomp.scope.name = EXPR;
            // Ensure we copy over all the jsdoc and debug info.
            if (value != null || v.getJSDocInfo() != null) {
                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
                    compiler.getCodingConvention(),
                    globalName,
                    value,
                    v.getJSDocInfo()
                ).useSourceInfoIfMissingFromForTree(n);

                NodeUtil.setDebugInformation(
                    newDecl.getFirstChild().getFirstChild(), n, name);

                grandparent.addChildBefore(newDecl, varNode);
            }

            // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
            v.getNameNode().addChildToFront(
                NodeUtil.newQualifiedNameNode(
                    compiler.getCodingConvention(), globalName).useSourceInfoIfMissingFrom(n)
            );

            recordAlias(v);
        } else {
            // Do not process other kinds of local symbols, like catch params.
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}",0,0
30,Closure_127,"    private Node computeFollowing(Node n) {
      Node next = ControlFlowAnalysis.computeFollowNode(n);
      while (next != null && next.isBlock()) {
        if (next.hasChildren()) {
          next = next.getFirstChild();
        } else {
          next = computeFollowing(next);
        }
      }
      return next;
    }
","private Node computeFollowing(Node n) {
    Node next = ControlFlowAnalysis.computeFollowNode(n);
    while (next != null) {
        if (next.isBlock()) {
            if (next.hasChildren()) {
                next = next.getFirstChild();
            } else {
                next = ControlFlowAnalysis.computeFollowNode(next);
            }
        } else {
            break;
        }
    }
    return next;
}",0,0
31,Closure_134,"private FunctionType findOverriddenFunction(
        ObjectType ownerType, String propName) {
      // First, check to see if the property is implemented
      // on a superclass.
       JSType propType = ownerType.getPropertyType(propName);
       if (propType instanceof FunctionType) {
         return (FunctionType) propType;
       }
         // If it's not, then check to see if it's implemented
         // on an implemented interface.
 
       return null;
     }","private FunctionType findOverriddenFunction(
        ObjectType ownerType, String propName) {
    // First, check to see if the property is implemented
    // on a superclass.
    if (ownerType == null || propName == null) {
        return null;
    }

    JSType propType = ownerType.getPropertyType(propName);
    if (propType instanceof FunctionType) {
        return (FunctionType) propType;
    }

    // If it's not, then check to see if it's implemented
    // on an implemented interface.
    return null;
}",0,0
31,Closure_134,"private void addNonUnionType(JSType newType) {
      if (skipAmbiguating || isInvalidatingType(newType)) {
        skipAmbiguating = true;
         return;
       }
 
       if (type == null) {
         type = newType;
       } else {
         type = type.getLeastSupertype(newType);
       }
       typesSet.set(getIntForType(newType));
     }","private void addNonUnionType(JSType newType) {
    if (newType == null || skipAmbiguating || isInvalidatingType(newType)) {
        skipAmbiguating = true;
        return;
    }

    if (type == null) {
        type = newType;
    } else {
        type = type.getLeastSupertype(newType);
    }

    if (typesSet != null) {
        typesSet.set(getIntForType(newType));
    }
}",0,0
31,Closure_134,"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());

    Set<String> reservedNames =
        new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);

    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
     for (Property p : propertyMap.values()) {
       if (!p.skipAmbiguating) {
         ++numRenamedPropertyNames;
         computeRelatedTypes(p.type);
         propsByFreq.add(p);
       } else {
         ++numSkippedPropertyNames;
        reservedNames.add(p.oldName);
      }
    }

    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring =
        new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();

    NameGenerator nameGen = new NameGenerator(
        reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
      colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
      node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
      renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }

    // Update the string nodes.
    for (Node n : stringNodesToRename) {
      String oldName = n.getString();
      Property p = propertyMap.get(oldName);
      if (p != null && p.newName != null) {
        Preconditions.checkState(oldName.equals(p.oldName));
        if (!p.newName.equals(oldName)) {
          n.setString(p.newName);
          compiler.reportCodeChange();
        }
      }
    }

    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into ""
                + numNewPropertyNames + "" and skipped renaming ""
                + numSkippedPropertyNames + "" properties."");
  }","public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());

    Set<String> reservedNames =
        new HashSet<>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);

    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (p != null && !p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else if (p != null) {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }

    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring =
        new GreedyGraphColoring<>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();

    NameGenerator nameGen = new NameGenerator(
        reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        if (node != null && node.getValue() != null) {
            node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
            renamingMap.put(node.getValue().oldName, node.getValue().newName);
        }
    }

    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        if (n != null && n.getString() != null) {
            String oldName = n.getString();
            Property p = propertyMap.get(oldName);
            if (p != null && p.newName != null) {
                Preconditions.checkState(oldName.equals(p.oldName));
                if (!p.newName.equals(oldName)) {
                    n.setString(p.newName);
                    compiler.reportCodeChange();
                }
            }
        }
    }

    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into ""
                + numNewPropertyNames + "" and skipped renaming ""
                + numSkippedPropertyNames + "" properties."");
}",0,0
31,Closure_134,"public boolean isIndependentOf(Property prop) {
       if (typesRelatedToSet.intersects(prop.typesSet)) {
         return false;
       }
       return !getRelated(prop.type).intersects(typesInSet);
     }","public boolean isIndependentOf(Property prop) {
    if (prop == null || typesRelatedToSet == null || prop.typesSet == null || typesInSet == null) {
        return false;
    }

    if (typesRelatedToSet.intersects(prop.typesSet)) {
        return false;
    }
    return !getRelated(prop.type).intersects(typesInSet);
}",0,0
31,Closure_134,"public void addNode(Property prop) {
       typesInSet.or(prop.typesSet);
       typesRelatedToSet.or(getRelated(prop.type));
     }","public void addNode(Property prop) {
    if (prop == null || prop.typesSet == null || typesInSet == null || typesRelatedToSet == null) {
        return;
    }

    typesInSet.or(prop.typesSet);
    typesRelatedToSet.or(getRelated(prop.type));
}",0,0
32,Closure_135,"private void replaceReferencesToThis(Node node, String name) {
    if (NodeUtil.isFunction(node)) {
      return;
    }

     for (Node child : node.children()) {
       if (NodeUtil.isThis(child)) {
         Node newName = Node.newString(Token.NAME, name);
         node.replaceChild(child, newName);
       } else {
         replaceReferencesToThis(child, name);
      }
    }
  }","private void replaceReferencesToThis(Node node, String name) {
    if (node == null || name == null) {
        return;
    }

    if (NodeUtil.isFunction(node)) {
        return;
    }

    for (Node child : node.children()) {
        if (NodeUtil.isThis(child)) {
            Node newName = Node.newString(Token.NAME, name);
            Preconditions.checkNotNull(newName, ""New name node cannot be null"");
            node.replaceChild(child, newName);
        } else {
            replaceReferencesToThis(child, name);
        }
    }
}",0,0
32,Closure_135,"@Override
  boolean defineProperty(String name, JSType type,
      boolean inferred, boolean inExterns) {
     if (""prototype"".equals(name)) {
       ObjectType objType = type.toObjectType();
       if (objType != null) {
         return setPrototype(
             new FunctionPrototypeType(
                 registry, this, objType, isNativeObjectType()));
      } else {
        return false;
      }
    }
    return super.defineProperty(name, type, inferred, inExterns);
  }","@Override
boolean defineProperty(String name, JSType type,
    boolean inferred, boolean inExterns) {
    if (""prototype"".equals(name)) {
        if (type == null) {
            return false;
        }
        ObjectType objType = type.toObjectType();
        if (objType != null) {
            return setPrototype(
                new FunctionPrototypeType(
                    registry, this, objType, isNativeObjectType()));
        } else {
            return false;
        }
    }
    return super.defineProperty(name, type, inferred, inExterns);
}",0,0
33,Closure_136,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      if (n.getType() != Token.NAME) {
        return;
      }

      String name = n.getString();

      // Ignore anonymous functions
      if (name.length() == 0) {
        return;
      }

      // Is this local or Global?
      Scope.Var var = t.getScope().getVar(name);
      boolean local = (var != null) && var.isLocal();

      // Are we renaming global variables?
      if (!local && localRenamingOnly) {
        reservedNames.add(name);
        return;
      }

      // Are we renaming anonymous function names?
      if (preserveAnonymousFunctionNames
          && var != null
          && NodeUtil.isAnonymousFunction(var.getParentNode())) {
        reservedNames.add(name);
        return;
      }
 
       // Check if we can rename this.
       if (!okToRenameVar(name, local)) {
           // Blindly de-uniquify for the Prototype library for issue 103.
         return;
       }
 
      if (isExternsPass_) {
        // Keep track of extern globals.
        if (!local) {
          externNames.add(name);
        }
        return;
      }

      if (local) {
        // Local var: assign a new name
        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();
        incCount(tempName, null);
        localNameNodes.add(n);
        localTempNames.add(tempName);
      } else if (var != null) {  // Not an extern
        // If it's global, increment global count
        incCount(name, var.input);
        globalNameNodes.add(n);
      }
    }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() != Token.NAME) {
        return;
    }

    String name = n.getString();

    // Ignore anonymous functions
    if (name == null || name.isEmpty()) {
        return;
    }

    // Is this local or global?
    Scope.Var var = t.getScope().getVar(name);
    boolean local = (var != null) && var.isLocal();

    // Are we renaming global variables?
    if (!local && localRenamingOnly) {
        reservedNames.add(name);
        return;
    }

    // Are we renaming anonymous function names?
    if (preserveAnonymousFunctionNames
            && var != null
            && NodeUtil.isAnonymousFunction(var.getParentNode())) {
        reservedNames.add(name);
        return;
    }

    // Check if we can rename this.
    if (!okToRenameVar(name, local)) {
        // Blindly de-uniquify for the Prototype library for issue 103.
        return;
    }

    if (isExternsPass_) {
        // Keep track of extern globals.
        if (!local) {
            externNames.add(name);
        }
        return;
    }

    if (local) {
        // Local var: assign a new name
        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();
        incCount(tempName, null);
        localNameNodes.add(n);
        localTempNames.add(tempName);
    } else if (var != null) { // Not an extern
        // If it's global, increment global count
        incCount(name, var.getInputName());
        globalNameNodes.add(n);
    }
}",0,0
34,Closure_137,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root,
         new NormalizeStatements(compiler, assertOnChange));
     removeDuplicateDeclarations(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
      t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function 
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes. 
    new PropogateConstantAnnotations(compiler, assertOnChange)
        .process(externs, root);
  }","@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root,
        new NormalizeStatements(compiler, assertOnChange));

    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }

    // Remove duplicate declarations after names are made unique
    removeDuplicateDeclarations(root);

    // Propagate constant annotations
    new PropogateConstantAnnotations(compiler, assertOnChange)
        .process(externs, root);
}",0,0
34,Closure_137,"@Override
    public void addDeclaredName(String name) {
        if (global) {
          reserveName(name);
        } else {
          // It hasn't been declared locally yet, so increment the count.
          if (!declarations.containsKey(name)) {
            int id = incrementNameCount(name);
             String newName = null;
             if (id != 0) {
               newName = getUniqueName(name, id);
           }
           declarations.put(name, newName);
         }
       }
     }","@Override
public void addDeclaredName(String name) {
    if (global) {
        reserveName(name);
    } else {
        // It hasn't been declared locally yet, so increment the count.
        if (!declarations.containsKey(name)) {
            int id = incrementNameCount(name);
            String newName = (id != 0) ? getUniqueName(name, id) : null;
            declarations.put(name, newName);
        }
    }
}",0,0
35,Closure_138,"@Override
  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,
      FlowScope blindScope, boolean outcome) {
    if (condition.getType() == CALL && condition.getChildCount() == 2) {
      Node callee = condition.getFirstChild();
      Node param = condition.getLastChild();
      if (callee.getType() == GETPROP && param.isQualifiedName()) {
        JSType paramType =  getTypeIfRefinable(param, blindScope);
        if (paramType != null) {
        Node left = callee.getFirstChild();
        Node right = callee.getLastChild();
        if (left.getType() == NAME && ""goog"".equals(left.getString()) &&
            right.getType() == STRING) {
          Function<TypeRestriction, JSType> restricter =
              restricters.get(right.getString());
           if (restricter != null) {
             return restrictParameter(param, paramType, blindScope, restricter,
                 outcome);
             }
           }
         }
       }
    }
    return nextPreciserScopeKnowingConditionOutcome(
        condition, blindScope, outcome);
  }","@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,
    FlowScope blindScope, boolean outcome) {
  if (condition.getType() == CALL && condition.getChildCount() == 2) {
    Node callee = condition.getFirstChild();
    Node param = condition.getLastChild();
    if (callee.getType() == GETPROP && param.isQualifiedName()) {
      JSType paramType = getTypeIfRefinable(param, blindScope);
      if (paramType != null) {
        Node left = callee.getFirstChild();
        Node right = callee.getLastChild();
        if (left.getType() == NAME && ""goog"".equals(left.getString()) &&
            right.getType() == STRING) {
          Function<TypeRestriction, JSType> restricter =
              restricters.get(right.getString());
          if (restricter != null) {
            return restrictParameter(param, paramType, blindScope, restricter, outcome);
          }
        }
      }
    }
  }
  return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}",0,0
35,Closure_138,"private FlowScope traverseName(Node n, FlowScope scope) {
    String varName = n.getString();
    Node value = n.getFirstChild();
    JSType type = n.getJSType();
    if (value != null) {
      scope = traverse(value, scope);
      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,
          getJSType(value));
       return scope;
     } else {
       StaticSlot<JSType> var = scope.getSlot(varName);
       if (var != null &&
           !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {
         // There are two situations where we don't want to use type information
         // from the scope, even if we have it.
 
         // 1) The var is escaped in a weird way, e.g.,
         // function f() { var x = 3; function g() { x = null } (x); }
 
         // 2) We're reading type information from another scope for an
         // inferred variable.
         // var t = null; function f() { (t); }
 
           type = var.getType();
           if (type == null) {
             type = getNativeType(UNKNOWN_TYPE);
         }
       }
     }
    n.setJSType(type);
    return scope;
  }","private FlowScope traverseName(Node n, FlowScope scope) {
  String varName = n.getString();
  Node value = n.getFirstChild();
  JSType type = n.getJSType();
  if (value != null) {
    scope = traverse(value, scope);
    updateScopeForTypeChange(scope, n, type, getJSType(value));
    return scope;
  } else {
    StaticSlot<JSType> var = scope.getSlot(varName);
    if (var != null && 
        !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {
      type = var.getType();
      if (type == null) {
        type = getNativeType(UNKNOWN_TYPE);
      }
    }
  }
  n.setJSType(type);
  return scope;
}",0,0
36,Closure_139,"@Override
    public void onRedeclaration(
         Scope s, String name, Node n, Node parent, Node gramps,
         Node nodeWithLineNumber) {
       Preconditions.checkState(n.getType() == Token.NAME);
       if (parent.getType() == Token.VAR) {
       // If name is ""arguments"", Var maybe null.
         Preconditions.checkState(parent.hasOneChild());
 
         replaceVarWithAssignment(n, parent, gramps);
      }
    }","@Override
public void onRedeclaration(
    Scope s, String name, Node n, Node parent, Node gramps,
    Node nodeWithLineNumber) {
    Preconditions.checkState(n.getType() == Token.NAME);
    if (parent != null && parent.getType() == Token.VAR) {
        // If name is ""arguments"", Var may be null.
        Preconditions.checkState(parent.hasOneChild());
        if (gramps != null) {
            replaceVarWithAssignment(n, parent, gramps);
        }
    }
}",0,0
36,Closure_139,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      switch (n.getType()) {
        case Token.WHILE:
          if (CONVERT_WHILE_TO_FOR) {
            Node expr = n.getFirstChild();
            n.setType(Token.FOR);
            n.addChildBefore(new Node(Token.EMPTY), expr);
            n.addChildAfter(new Node(Token.EMPTY), expr);
            reportCodeChange(""WHILE node"");
           }
           break;
 
       }
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    switch (n.getType()) {
        case Token.WHILE:
            if (CONVERT_WHILE_TO_FOR) {
                Node expr = n.getFirstChild();
                if (expr != null) {
                    n.setType(Token.FOR);
                    n.addChildBefore(new Node(Token.EMPTY), expr);
                    n.addChildAfter(new Node(Token.EMPTY), expr);
                    reportCodeChange(""WHILE node"");
                }
            }
            break;
    }
}",0,0
37,Closure_140,"public void init(JSSourceFile[] externs, JSModule[] modules,
      CompilerOptions options) {
     initOptions(options);
 
     checkFirstModule(modules);
 
     this.externs = makeCompilerInput(externs, true);
     this.modules = modules;
    // Generate the module graph, and report any errors in the module
    // specification as errors.
    try {
      this.moduleGraph = new JSModuleGraph(modules);
    } catch (JSModuleGraph.ModuleDependenceException e) {
      // problems with the module format.  Report as an error.  The
      // message gives all details.
      report(JSError.make(MODULE_DEPENDENCY_ERROR,
          e.getModule().getName(), e.getDependentModule().getName()));
      return;
    }
    this.inputs = getAllInputsFromModules();
    initBasedOnOptions();

    initInputsByNameMap();
  }","public void init(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) {
    initOptions(options);

    checkFirstModule(modules);
   
    this.externs = makeCompilerInput(externs, true);
    this.modules = modules;

    // Generate the module graph, and report any errors in the module specification as errors.
    try {
        this.moduleGraph = new JSModuleGraph(modules);
    } catch (JSModuleGraph.ModuleDependenceException e) {
        // Problems with the module format. Report as an error. The message gives all details.
        if (e.getModule() != null && e.getDependentModule() != null) { 
            report(JSError.make(MODULE_DEPENDENCY_ERROR, e.getModule().getName(), e.getDependentModule().getName()));
        } else {
            report(JSError.make(MODULE_DEPENDENCY_ERROR, ""Unknown Module"", ""Unknown Dependent Module""));
        }
        return;
    }

    this.inputs = getAllInputsFromModules();
    if (this.inputs.length == 0) {
        report(JSError.make(EMPTY_INPUT_LIST_ERROR));
        return;
    }

    initBasedOnOptions();

    initInputsByNameMap();
}",0,0
37,Closure_140,"@Override
  Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
      if (inputs.length == 0) {
        throw new IllegalStateException(""No inputs"");
      }

      return inputs[0].getAstRoot(this);
    }

    List<CompilerInput> inputs = module.getInputs();
     if (inputs.size() > 0) {
       return inputs.get(0).getAstRoot(this);
     }
     for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {
       inputs = m.getInputs();
       if (inputs.size() > 0) {
         return inputs.get(0).getAstRoot(this);
       }
     }
     throw new IllegalStateException(""Root module has no inputs"");
   }","@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs == null || inputs.length == 0) {
            throw new IllegalStateException(""No compiler inputs available"");
        }
        return inputs[0].getAstRoot(this);
    }

    List<CompilerInput> moduleInputs = module.getInputs();
    if (moduleInputs != null && moduleInputs.size() > 0) {
        return moduleInputs.get(0).getAstRoot(this);
    }

    for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {
        List<CompilerInput> transitiveInputs = m.getInputs();
        if (transitiveInputs != null && transitiveInputs.size() > 0) {
            return transitiveInputs.get(0).getAstRoot(this);
        }
    }

    throw new IllegalStateException(""Root module has no valid inputs"");
}",0,0
38,Closure_141,"private static Collection<Definition> getCallableDefinitions(
      DefinitionProvider definitionProvider, Node name) {
      List<Definition> result = Lists.newArrayList();

      if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {
        return null;
      }
      Collection<Definition> decls =
          definitionProvider.getDefinitionsReferencedAt(name);
      if (decls == null) {
        return null;
      }

      for (Definition current : decls) {
        Node rValue = current.getRValue();
        if ((rValue != null) && NodeUtil.isFunction(rValue)) {
          result.add(current);
        } else {
          return null;
        }
      }

      return result;
  }

  /**
   * Propagate side effect information by building a graph based on
   * call site information stored in FunctionInformation and the
   * DefinitionProvider and then running GraphReachability to
   * determine the set of functions that have side effects.
   */
  private void propagateSideEffects() {
    // Nodes are function declarations; Edges are function call sites.
    DiGraph<FunctionInformation, Node> sideEffectGraph =
        new LinkedDirectedGraph<FunctionInformation, Node>();

    // create graph nodes
    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {
      sideEffectGraph.createNode(functionInfo);
    }

    // add connections to called functions and side effect root.
    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {
      if (!functionInfo.mayHaveSideEffects()) {","private static Collection<Definition> getCallableDefinitions(
      DefinitionProvider definitionProvider, Node name) {
      List<Definition> result = Lists.newArrayList();

      if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {
        return null;
      }
      Collection<Definition> decls =
          definitionProvider.getDefinitionsReferencedAt(name);
      if (decls == null) {
        return null;
      }

      for (Definition current : decls) {
        Node rValue = current.getRValue();
        if ((rValue != null) && NodeUtil.isFunction(rValue)) {
          result.add(current);
        }
      }

      return result.isEmpty() ? null : result;
  }",0,0
38,Closure_141,"private static Collection<Definition> getCallableDefinitions(
       DefinitionProvider definitionProvider, Node name) {
       List<Definition> result = Lists.newArrayList();
 
       if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {
         return null;
       }
       Collection<Definition> decls =
           definitionProvider.getDefinitionsReferencedAt(name);
       if (decls == null) {
        return null;
      }

      for (Definition current : decls) {
        Node rValue = current.getRValue();
        if ((rValue != null) && NodeUtil.isFunction(rValue)) {
          result.add(current);
        } else {
          return null;
        }
      }

      return result;
  }","private static Collection<Definition> getCallableDefinitions(
      DefinitionProvider definitionProvider, Node name) {
      List<Definition> result = Lists.newArrayList();

      if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {
        return null;
      }
      Collection<Definition> decls =
          definitionProvider.getDefinitionsReferencedAt(name);
      if (decls == null) {
        return null;
      }

      for (Definition current : decls) {
        Node rValue = current.getRValue();
        if ((rValue != null) && NodeUtil.isFunction(rValue)) {
          result.add(current);
        }
      }

      return result.isEmpty() ? null : result;
  }",0,0
38,Closure_141,"static boolean canBeSideEffected(Node n, Set<String> knownConstants) {
    switch (n.getType()) {
      case Token.CALL:
      case Token.NEW:
        // Function calls or constructor can reference changed values.
        // TODO(johnlenz): Add some mechanism for determining that functions
        // are unaffected by side effects.
        return true;
      case Token.NAME:
        // Non-constant names values may have been changed.
        return !NodeUtil.isConstantName(n)
            && !knownConstants.contains(n.getString());

      // Properties on constant NAMEs can still be side-effected.
      case Token.GETPROP:
       case Token.GETELEM:
         return true;
 
         // Anonymous functions definitions are not changed by side-effects,
         // and named functions are not part of expressions.
     }
 
     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
      if (canBeSideEffected(c, knownConstants)) {
        return true;
      }
    }

    return false;
  }","static boolean canBeSideEffected(Node n, Set<String> knownConstants) {
    switch (n.getType()) {
      case Token.CALL:
      case Token.NEW:
        // Function calls or constructor can reference changed values.
        return true;
      case Token.NAME:
        // Non-constant name values may have been changed.
        return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());
      case Token.GETPROP:
      case Token.GETELEM:
        // Properties can still be side-effected.
        return true;
      default:
        break;
    }

    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
      if (canBeSideEffected(c, knownConstants)) {
        return true;
      }
    }

    return false;
}",0,0
39,Closure_142,"@Override
  public void enterScope(NodeTraversal t) {
    // TODO(user): We CAN do this in the global scope, just need to be
    // careful when something is exported. Liveness uses bit-vector for live
    // sets so I don't see compilation time will be a problem for running this
    // pass in the global scope.
    Scope scope = t.getScope();
    if (scope.isGlobal()) {
      return;
    }
    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();

    LiveVariablesAnalysis liveness =
        new LiveVariablesAnalysis(cfg, scope, compiler);
    // If the function has exactly 2 params, mark them as escaped. This is
     // a work-around for an IE bug where it throws an exception if you
     // write to the parameters of the callback in a sort(). See:
     // http://code.google.com/p/closure-compiler/issues/detail?id=58
     liveness.analyze();
 
     UndiGraph<Var, Void> interferenceGraph =
        computeVariableNamesInterferenceGraph(
            t, cfg, liveness.getEscapedLocals());

    GraphColoring<Var, Void> coloring =
        new GreedyGraphColoring<Var, Void>(interferenceGraph,
            coloringTieBreaker);

    coloring.color();
    colorings.push(coloring);
  }","@Override
public void enterScope(NodeTraversal t) {
    Scope scope = t.getScope();
    if (scope == null || scope.isGlobal()) {
        return;
    }
    
    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();
    if (cfg == null) {
        return;
    }
    
    LiveVariablesAnalysis liveness =
        new LiveVariablesAnalysis(cfg, scope, compiler);
    liveness.analyze();

    UndiGraph<Var, Void> interferenceGraph =
        computeVariableNamesInterferenceGraph(
            t, cfg, liveness.getEscapedLocals());

    if (interferenceGraph == null) {
        return;
    }
    
    GraphColoring<Var, Void> coloring =
        new GreedyGraphColoring<>(interferenceGraph, coloringTieBreaker);

    coloring.color();
    colorings.push(coloring);
}",0,0
39,Closure_142,"@SuppressWarnings(""fallthrough"")
  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                      WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
      return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();

    if (option != WhitespaceOption.PRESERVE) {
      line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    do {
      switch (token) {
        case STAR:
          if (!ignoreStar) {
            if (builder.length() > 0) {
              builder.append(' ');
            }

            builder.append('*');
          }

          token = next();
          continue;

        case EOL:
          if (option != WhitespaceOption.SINGLE_LINE) {
            builder.append(""\n"");
          }

          ignoreStar = true;
          token = next();
          continue;

        case ANNOTATION:
        case EOC:
         case EOF:
           // When we're capturing a license block, annotations
           // in the block are ok.
             String multilineText = builder.toString();
 
             if (option != WhitespaceOption.PRESERVE) {
              multilineText = multilineText.trim();
            }

            int endLineno = stream.getLineno();
            int endCharno = stream.getCharno();

            if (multilineText.length() > 0) {
              jsdocBuilder.markText(multilineText, startLineno, startCharno,
                  endLineno, endCharno);
            }

            return new ExtractionInfo(multilineText, token);

          // FALL THROUGH

        default:
          ignoreStar = false;
          state = State.SEARCHING_ANNOTATION;

          if (builder.length() > 0) {
            builder.append(' ');
          }

          builder.append(toString(token));

          line = stream.getRemainingJSDocLine();

          if (option != WhitespaceOption.PRESERVE) {
            line = trimEnd(line);
          }

          builder.append(line);
          token = next();
      }
    } while (true);
  }","@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    do {
        switch (token) {
            case STAR:
                if (!ignoreStar) {
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;

            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                continue;

            case ANNOTATION:
            case EOC:
            case EOF:
                String multilineText = builder.toString();
                if (option != WhitespaceOption.PRESERVE) {
                    multilineText = multilineText.trim();
                }
                int endLineno = stream.getLineno();
                int endCharno = stream.getCharno();
                if (multilineText.length() > 0) {
                    jsdocBuilder.markText(multilineText, startLineno, startCharno,
                        endLineno, endCharno);
                }
                return new ExtractionInfo(multilineText, token);

            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;

                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));

                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
        }
    } while (true);
}",0,0
40,Closure_143,"@VisibleForTesting
  static void createDefineReplacements(List<String> definitions,
      CompilerOptions options) {
    // Parse the definitions
    for (String override : definitions) {
      String[] assignment = override.split(""="", 2);
      String defName = assignment[0];

      if (defName.length() > 0) {
        if (assignment.length == 1) {
          options.setDefineToBooleanLiteral(defName, true);
          continue;
        } else {
          String defValue = assignment[1];

          if (defValue.equals(""true"")) {
            options.setDefineToBooleanLiteral(defName, true);
            continue;
          } else if (defValue.equals(""false"")) {
            options.setDefineToBooleanLiteral(defName, false);
            continue;
           } else if (defValue.length() > 1
               && ((defValue.charAt(0) == '\'' &&
                   defValue.charAt(defValue.length() - 1) == '\'')
             )) {
             // If the value starts and ends with a single quote,
             // we assume that it's a string.
             String maybeStringVal =
                defValue.substring(1, defValue.length() - 1);
            if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
              options.setDefineToStringLiteral(defName, maybeStringVal);
              continue;
            }
          } else {
            try {
              options.setDefineToDoubleLiteral(defName,
                  Double.parseDouble(defValue));
              continue;
            } catch (NumberFormatException e) {
              // do nothing, it will be caught at the end
            }
          }
        }
      }

      throw new RuntimeException(
          ""--define flag syntax invalid: "" + override);
    }
  }","@VisibleForTesting
static void createDefineReplacements(List<String> definitions, CompilerOptions options) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];

        if (defName.length() > 0) {
            if (assignment.length == 1) {
                options.setDefineToBooleanLiteral(defName, true);
                continue;
            } else {
                String defValue = assignment[1].trim();

                if (defValue.equals(""true"")) {
                    options.setDefineToBooleanLiteral(defName, true);
                    continue;
                } else if (defValue.equals(""false"")) {
                    options.setDefineToBooleanLiteral(defName, false);
                    continue;
                } else if (defValue.length() > 1 && defValue.charAt(0) == '""' && defValue.charAt(defValue.length() - 1) == '""') {
                    // If the value starts and ends with double quotes, we assume that it's a string.
                    String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                    options.setDefineToStringLiteral(defName, maybeStringVal);
                    continue;
                } else {
                    try {
                        options.setDefineToDoubleLiteral(defName, Double.parseDouble(defValue));
                        continue;
                    } catch (NumberFormatException e) {
                        // do nothing, it will be caught at the end
                    }
                }
            }
        }

        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}",0,0
40,Closure_143,"private void trySimplify(Node parent, Node node) {
      if (node.getType() != Token.EXPR_RESULT) {
        return;
      }
 
       Node exprBody = node.getFirstChild();
       if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)
       ) {
         changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));
       }
     }","private void trySimplify(Node parent, Node node) {
    if (node.getType() != Token.EXPR_RESULT) {
        return;
    }

    Node exprBody = node.getFirstChild();
    if (exprBody != null && !NodeUtil.nodeTypeMayHaveSideEffects(exprBody)) {
        changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));
    }
}",0,0
41,Closure_144,"FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {
     returnType = info != null && info.hasReturnType() ?
         info.getReturnType().evaluate(scope, typeRegistry) :
         typeRegistry.getNativeType(UNKNOWN_TYPE);
     if (templateTypeName != null &&
         returnType.restrictByNotNullOrUndefined().isTemplateType()) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
     }
    return this;
  }","FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {
    if (info != null && info.hasReturnType()) {
        JSType evaluatedReturnType = info.getReturnType().evaluate(scope, typeRegistry);
        returnType = evaluatedReturnType != null ? evaluatedReturnType : typeRegistry.getNativeType(UNKNOWN_TYPE);
    } else {
        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);
    }
    if (templateTypeName != null && 
        returnType.restrictByNotNullOrUndefined().isTemplateType()) {
        reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }
    return this;
}",0,0
41,Closure_144,"FunctionType buildAndRegister() {
    if (returnType == null) {
      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);
    }

    if (parametersNode == null) {
      throw new IllegalStateException(
          ""All Function types must have params and a return type"");
    }

    FunctionType fnType;
    if (isConstructor) {
      fnType = getOrCreateConstructor();
    } else if (isInterface) {
      fnType = typeRegistry.createInterfaceType(fnName, sourceNode);
      if (scope.isGlobal() && !fnName.isEmpty()) {
        typeRegistry.declareType(fnName, fnType.getInstanceType());
      }
      maybeSetBaseType(fnType);
    } else {
      fnType = new FunctionBuilder(typeRegistry)
           .withName(fnName)
           .withSourceNode(sourceNode)
           .withParamsNode(parametersNode)
           .withReturnType(returnType)
           .withTypeOfThis(thisType)
           .withTemplateName(templateTypeName)
           .build();
      maybeSetBaseType(fnType);
    }

    if (implementedInterfaces != null) {
      fnType.setImplementedInterfaces(implementedInterfaces);
    }

    typeRegistry.clearTemplateTypeName();

    return fnType;
  }","FunctionType buildAndRegister() {
    if (parametersNode == null) {
        throw new IllegalStateException(""All Function types must have params and a return type"");
    }

    if (returnType == null) {
        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);
    }

    FunctionType fnType;
    if (isConstructor) {
        fnType = getOrCreateConstructor();
    } else if (isInterface) {
        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);
        if (scope.isGlobal() && !fnName.isEmpty()) {
            typeRegistry.declareType(fnName, fnType.getInstanceType());
        }
        maybeSetBaseType(fnType);
    } else {
        fnType = new FunctionBuilder(typeRegistry)
                .withName(fnName)
                .withSourceNode(sourceNode)
                .withParamsNode(parametersNode)
                .withReturnType(returnType)
                .withTypeOfThis(thisType)
                .withTemplateName(templateTypeName)
                .build();
        maybeSetBaseType(fnType);
    }

    if (implementedInterfaces != null) {
        fnType.setImplementedInterfaces(implementedInterfaces);
    }

    typeRegistry.clearTemplateTypeName();

    return fnType;
}",0,0
41,Closure_144,"FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {
     return new FunctionType(
         registry, null, null,
         new ArrowType(
             registry, call.parameters, newReturnType, inferred),
         typeOfThis, null, false, false);
  }","FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {
    Preconditions.checkNotNull(newReturnType, ""The new return type cannot be null."");
    return new FunctionType(
        registry, null, null,
        new ArrowType(
            registry, call.parameters, newReturnType, inferred),
        typeOfThis, null, false, false);
}",0,0
41,Closure_144,"private FunctionType getFunctionType(String name,
        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {
      FunctionType functionType = null;

      // Handle function aliases.
      if (rValue != null && rValue.isQualifiedName()) {
        Var var = scope.getVar(rValue.getQualifiedName());
        if (var != null && var.getType() instanceof FunctionType) {
          functionType = (FunctionType) var.getType();
          if (functionType != null && functionType.isConstructor()) {
            typeRegistry.declareType(name, functionType.getInstanceType());
          }
        }
        return functionType;
      }

      Node owner = null;
      if (lvalueNode != null) {
        owner = getPrototypePropertyOwner(lvalueNode);
      }

      Node errorRoot = rValue == null ? lvalueNode : rValue;
      boolean isFnLiteral =
          rValue != null && rValue.getType() == Token.FUNCTION;
      Node fnRoot = isFnLiteral ? rValue : null;
      Node parametersNode = isFnLiteral ?
          rValue.getFirstChild().getNext() : null;

      if (functionType == null && info != null && info.hasType()) {
        JSType type = info.getType().evaluate(scope, typeRegistry);

        // Known to be not null since we have the FUNCTION token there.
        type = type.restrictByNotNullOrUndefined();
        if (type.isFunctionType()) {
          functionType = (FunctionType) type;
          functionType.setJSDocInfo(info);
        }
      }

      if (functionType == null) {
        if (info == null ||
            !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
          // We don't really have any type information in the annotation.
          // Before we give up on this function, look at the object we're
          // assigning it to. For example, if the function looks like this:
          // SubFoo.prototype.bar = function() { ... };
          // We can use type information on Foo.prototype.bar and apply it
          // to this function.
          if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&
              lvalueNode.isQualifiedName()) {
            Var var = scope.getVar(
                lvalueNode.getFirstChild().getQualifiedName());
            if (var != null) {
              ObjectType ownerType = ObjectType.cast(var.getType());
              FunctionType propType = null;
              if (ownerType != null) {
                String propName = lvalueNode.getLastChild().getString();
                propType = findOverriddenFunction(ownerType, propName);
              }

              if (propType != null) {
                functionType =
                    new FunctionTypeBuilder(
                        name, compiler, errorRoot, sourceName, scope)
                     .setSourceNode(fnRoot)
                     .inferFromOverriddenFunction(propType, parametersNode)
                     .inferThisType(info, owner)
                     .buildAndRegister();
               }
             }
          }
        }
      } // end if (functionType == null)

      if (functionType == null) {
        functionType =
            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,
                scope)
            .setSourceNode(fnRoot)
            .inferTemplateTypeName(info)
            .inferReturnType(info)
            .inferInheritance(info)
            .inferThisType(info, owner)
            .inferParameterTypes(parametersNode, info)
            .buildAndRegister();
      }

      // assigning the function type to the function node
      if (rValue != null) {
        setDeferredType(rValue, functionType);
      }

      // all done
      return functionType;
    }","private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {
    FunctionType functionType = null;

    if (rValue != null && rValue.isQualifiedName()) {
        Var var = scope.getVar(rValue.getQualifiedName());
        if (var != null && var.getType() instanceof FunctionType) {
            functionType = (FunctionType) var.getType();
            if (functionType != null && functionType.isConstructor()) {
                typeRegistry.declareType(name, functionType.getInstanceType());
            }
        }
        return functionType;
    }

    Node owner = (lvalueNode != null) ? getPrototypePropertyOwner(lvalueNode) : null;
    Node errorRoot = (rValue == null) ? lvalueNode : rValue;
    boolean isFnLiteral = (rValue != null) && (rValue.getType() == Token.FUNCTION);
    Node fnRoot = isFnLiteral ? rValue : null;
    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;

    if (functionType == null && info != null && info.hasType()) {
        JSType type = info.getType().evaluate(scope, typeRegistry);
        type = type.restrictByNotNullOrUndefined();
        if (type.isFunctionType()) {
            functionType = (FunctionType) type;
            functionType.setJSDocInfo(info);
        }
    }

    if (functionType == null) {
        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {
                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());
                if (var != null) {
                    ObjectType ownerType = ObjectType.cast(var.getType());
                    if (ownerType != null) {
                        String propName = lvalueNode.getLastChild().getString();
                        FunctionType propType = findOverriddenFunction(ownerType, propName);
                        if (propType != null) {
                            functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope)
                                    .setSourceNode(fnRoot)
                                    .inferFromOverriddenFunction(propType, parametersNode)
                                    .inferThisType(info, owner)
                                    .buildAndRegister();
                        }
                    }
                }
            }
        }
    }

    if (functionType == null) {
        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope)
                .setSourceNode(fnRoot)
                .inferTemplateTypeName(info)
                .inferReturnType(info)
                .inferInheritance(info)
                .inferThisType(info, owner)
                .inferParameterTypes(parametersNode, info)
                .buildAndRegister();
    }

    if (rValue != null) {
        setDeferredType(rValue, functionType);
    }

    return functionType;
}",0,0
42,Closure_147,"    private void visitFunction(NodeTraversal t, Node n) {
      FunctionType funType = (FunctionType) n.getJSType();
      Node block = n.getLastChild();
      Node paramName = NodeUtil.getFnParameters(n).getFirstChild();
      Node insertionPoint = null;

      // To satisfy normalization constraints, the type checking must be
      // added after any inner function declarations.

      for (Node paramType : funType.getParameters()) {
        // Can this ever happen?
        if (paramName == null) {
          return;
        }

        Node checkNode = createCheckTypeCallNode(
            paramType.getJSType(), paramName.cloneTree());

        if (checkNode == null) {
          // We don't know how to check this parameter type.
          paramName = paramName.getNext();
          continue;
        }

        checkNode = new Node(Token.EXPR_RESULT, checkNode);
        if (insertionPoint == null) {
          block.addChildToFront(checkNode);
        } else {
          block.addChildAfter(checkNode, insertionPoint);
        }

        compiler.reportCodeChange();
        paramName = paramName.getNext();
        insertionPoint = checkNode;
      }
    }
","private void visitFunction(NodeTraversal t, Node n) {
    FunctionType funType = (FunctionType) n.getJSType();
    if (funType == null) {
        return; // Fix: Handle the case where funType might be null
    }

    Node block = n.getLastChild();
    if (block == null) {
        return; // Fix: Ensure the block node exists before proceeding
    }

    Node paramName = NodeUtil.getFnParameters(n).getFirstChild();
    Node insertionPoint = null;

    // To satisfy normalization constraints, the type checking must be
    // added after any inner function declarations.
    for (Node paramType : funType.getParameters()) {
        if (paramName == null) {
            return; // Fix: Avoid proceeding if paramName is null
        }

        Node checkNode = createCheckTypeCallNode(
                paramType.getJSType(), paramName.cloneTree());

        if (checkNode == null) {
            // We don't know how to check this parameter type.
            paramName = paramName.getNext();
            continue;
        }

        checkNode = new Node(Token.EXPR_RESULT, checkNode);
        if (insertionPoint == null) {
            block.addChildToFront(checkNode);
        } else {
            block.addChildAfter(checkNode, insertionPoint);
        }

        compiler.reportCodeChange();
        paramName = paramName.getNext();
        insertionPoint = checkNode;
    }
}",0,0
42,Closure_147,"  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }
","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n == null || parent == null) {
        return false; // Fix: Handle cases where n or parent might be null
    }

    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
                (jsDoc.isConstructor() ||
                        jsDoc.isInterface() ||
                        jsDoc.hasThisType() ||
                        jsDoc.isOverride())) {
            return false;
        }

        int pType = parent.getType();
        if (!(pType == Token.BLOCK ||
                pType == Token.SCRIPT ||
                pType == Token.NAME ||
                pType == Token.ASSIGN)) {
            return false;
        }
    }

    if (parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP &&
                        ""prototype"".equals(lhs.getLastChild().getString())) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs != null && llhs.getType() == Token.GETPROP &&
                        ""prototype"".equals(llhs.getLastChild().getString())) {
                    return false; // Fix: Ensure llhs exists before accessing its child
                }
            }
        }
    }

    return true;
}",0,0
43,Closure_148,"private Node tryFoldTypeof(Node originalTypeofNode) {
    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);

    Node argumentNode = originalTypeofNode.getFirstChild();
    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {
      return originalTypeofNode;
    }

    String typeNameString = null;

    switch (argumentNode.getType()) {
      case Token.STRING:
        typeNameString = ""string"";
        break;
      case Token.NUMBER:
        typeNameString = ""number"";
        break;
      case Token.TRUE:
      case Token.FALSE:
        typeNameString = ""boolean"";
        break;
      case Token.NULL:
      case Token.OBJECTLIT:
       case Token.ARRAYLIT:
         typeNameString = ""object"";
         break;
       case Token.NAME:
         // We assume here that programs don't change the value of the
         // keyword undefined to something other than the value undefined.
        if (""undefined"".equals(argumentNode.getString())) {
          typeNameString = ""undefined"";
        }
        break;
    }

    if (typeNameString != null) {
      Node newNode = Node.newString(typeNameString);
      originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);
      reportCodeChange();

      return newNode;
    }

    return originalTypeofNode;
  }","private Node tryFoldTypeof(Node originalTypeofNode) {
    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);

    Node argumentNode = originalTypeofNode.getFirstChild();
    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {
        return originalTypeofNode;
    }

    String typeNameString = null;

    switch (argumentNode.getType()) {
        case Token.STRING:
            typeNameString = ""string"";
            break;
        case Token.NUMBER:
            typeNameString = ""number"";
            break;
        case Token.TRUE:
        case Token.FALSE:
            typeNameString = ""boolean"";
            break;
        case Token.NULL:
        case Token.OBJECTLIT:
        case Token.ARRAYLIT:
            typeNameString = ""object"";
            break;
        case Token.NAME:
            if (""undefined"".equals(argumentNode.getString())) {
                typeNameString = ""undefined"";
            }
            break;
        default:
            return originalTypeofNode;
    }

    if (typeNameString != null) {
        Node newNode = Node.newString(typeNameString);
        Node parent = originalTypeofNode.getParent();
        if (parent != null) {
            parent.replaceChild(originalTypeofNode, newNode);
            reportCodeChange();
        }
        return newNode;
    }

    return originalTypeofNode;
}",0,0
43,Closure_148,"void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);

    // If the node does not have an associated source file or
    // its line number is -1, then the node does not have sufficient
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
       return;
     }
 
     String escapedSourceFile;
     if (lastSourceFile != sourceFile) {  // yes, ""s1 != s2"" not ""!s1.equals(s2)""
       lastSourceFile = sourceFile;
       lastSourceFileEscaped = escapeString(sourceFile);
     }
     escapedSourceFile = lastSourceFileEscaped;
     // Create the new mapping.
     Mapping mapping = new Mapping();
     mapping.id = mappings.size();
     mapping.sourceFile = escapedSourceFile;
     mapping.originalPosition = new Position(node.getLineno(), node.getCharno());
 
     String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);
     if (originalName != null) {
       mapping.originalName = escapeString(originalName);
     }
 
       // If the mapping is found on the first line, we need to offset
       // its character position by the number of characters found on
       // the *last* line of the source file to which the code is
      // being generated.
      int offsetLine = offsetPosition.getLineNumber();
      int startOffsetPosition = offsetPosition.getCharacterIndex();
      int endOffsetPosition = offsetPosition.getCharacterIndex();

      if (startPosition.getLineNumber() > 0) {
        startOffsetPosition = 0;
      }

      if (endPosition.getLineNumber() > 0) {
        endOffsetPosition = 0;
      }

      mapping.startPosition =
          new Position(startPosition.getLineNumber() + offsetLine,
                       startPosition.getCharacterIndex() + startOffsetPosition);

      mapping.endPosition =
          new Position(endPosition.getLineNumber() + offsetLine,
                       endPosition.getCharacterIndex() + endOffsetPosition);

    mappings.add(mapping);
  }","void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);

    if (sourceFile == null || node.getLineno() < 0) {
        return;
    }

    String escapedSourceFile;
    if (!sourceFile.equals(lastSourceFile)) {
        lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
    }
    escapedSourceFile = lastSourceFileEscaped;

    Mapping mapping = new Mapping();
    mapping.id = mappings.size();
    mapping.sourceFile = escapedSourceFile;
    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());

    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);
    if (originalName != null) {
        mapping.originalName = escapeString(originalName);
    }

    int offsetLine = offsetPosition.getLineNumber();
    int startOffsetPosition = offsetPosition.getCharacterIndex();
    int endOffsetPosition = offsetPosition.getCharacterIndex();

    if (startPosition.getLineNumber() > 0) {
        startOffsetPosition = 0;
    }

    if (endPosition.getLineNumber() > 0) {
        endOffsetPosition = 0;
    }

    mapping.startPosition = new Position(
        startPosition.getLineNumber() + offsetLine,
        startPosition.getCharacterIndex() + startOffsetPosition);

    mapping.endPosition = new Position(
        endPosition.getLineNumber() + offsetLine,
        endPosition.getCharacterIndex() + endOffsetPosition);

    mappings.add(mapping);
}",0,0
43,Closure_148,"public void appendTo(Appendable out, String name) throws IOException {
    // Write the mappings out to the file. The format of the generated
    // source map is three sections, each deliminated by a magic comment.
    //
    // The first section contains an array for each line of the generated
    // code, where each element in the array is the ID of the mapping which
    // best represents the index-th character found on that line of the
    // generated source code.
    //
    // The second section contains an array per generated line. Unused.
    //
    // The third and final section contains an array per line, each of which
    // represents a mapping with a unique ID. The mappings are added in order.
    // The array itself contains a tuple representing
    // ['source file', line, col (, 'original name')]
    //
    // Example for 2 lines of generated code (with line numbers added for
    // readability):
    //
    // 1)  /** Begin line maps. **/{ ""count"": 2 }
    // 2)  [0,0,0,0,0,0,1,1,1,1,2]
    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]
    // 4)  /** Begin file information. **/
    // 5)  []
    // 6)  []
    // 7)  /** Begin mapping definitions. **/
    // 8)  [""a.js"", 1, 34]
    // 9)  [""a.js"", 5, 2]
    // 10) [""b.js"", 1, 3, ""event""]
     // 11) [""c.js"", 1, 4]
     // 12) [""d.js"", 3, 78, ""foo""]
 
     int maxLine = findLastLine();
 
     // Add the line character maps.
     out.append(""/** Begin line maps. **/{ \""file\"" : "");
    out.append(escapeString(name));
    out.append("", \""count\"": "");
    out.append(String.valueOf(maxLine + 1));
    out.append("" }\n"");
    (new LineMapper(out)).appendLineMappings();

    // Add the source file maps.
    out.append(""/** Begin file information. **/\n"");

    // This section is unused but we need one entry per line to
    // prevent changing the format.
    for (int i = 0; i <= maxLine; ++i) {
      out.append(""[]\n"");
    }

    // Add the mappings themselves.
    out.append(""/** Begin mapping definitions. **/\n"");

    for (Mapping mapping : mappings) {
      mapping.appendTo(out);
      out.append(""\n"");
    }
  }","public void appendTo(Appendable out, String name) throws IOException {
    int maxLine = findLastLine();

    out.append(""/** Begin line maps. **/{ \""file\"" : "");
    out.append(escapeString(name));
    out.append("", \""count\"": "");
    out.append(String.valueOf(maxLine + 1));
    out.append("" }\n"");
    (new LineMapper(out)).appendLineMappings();

    out.append(""/** Begin file information. **/\n"");

    for (int i = 0; i <= maxLine; ++i) {
        out.append(""[]\n"");
    }

    out.append(""/** Begin mapping definitions. **/\n"");

    for (Mapping mapping : mappings) {
        mapping.appendTo(out);
        out.append(""\n"");
    }
}",0,0
43,Closure_148,"void appendLineMappings() throws IOException {
      Preconditions.checkState(!mappings.isEmpty());

      // Start the first line.
      openLine();


      // And close the final line.

    /**
     * Begin the entry for a new line.
     */

    /**
     * End the entry for a line.
     */

    /**
     * Add a new char position entry.
     * @param id The mapping id to record.
     */

  /**
   * Mark any visited mapping as ""used"".
   */
    /**
     * @throws IOException
     */

    /**
     * @param m The mapping for the current code segment. null if the segment
     *     is unmapped.
     * @param line The starting line for this code segment.
     * @param col The starting column for this code segment.
     * @param endLine The ending line
     * @param endCol The ending column
     * @throws IOException
     */

  /**
   * Walk the mappings and visit each segment of the mappings, unmapped
   * segments are visited with a null mapping, unused mapping are not visited.
   */
    // The last line and column written


    // Append the line mapping entries.

      // The mapping list is ordered as a pre-order traversal.  The mapping
      // positions give us enough information to rebuild the stack and this
      // allows the building of the source map in O(n) time.
      Deque<Mapping> stack = new ArrayDeque<Mapping>();
      for (Mapping m : mappings) {
        // Find the closest ancestor of the current mapping:
        // An overlapping mapping is an ancestor of the current mapping, any
        // non-overlapping mappings are siblings (or cousins) and must be
         // closed in the reverse order of when they encountered.
         while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {
           Mapping previous = stack.pop();
           writeClosedMapping(previous);
         }
 
         // Any gaps between the current line position and the start of the
         // current mapping belong to the parent.
         Mapping parent = stack.peek();
         writeCharsBetween(parent, m);
 
         stack.push(m);
       }

      // There are no more children to be had, simply close the remaining
      // mappings in the reverse order of when they encountered.
      while (!stack.isEmpty()) {
        Mapping m = stack.pop();
        writeClosedMapping(m);
      }
      closeLine();
    }","void appendLineMappings() throws IOException {
    Preconditions.checkState(!mappings.isEmpty());

    openLine();

    Deque<Mapping> stack = new ArrayDeque<>();
    for (Mapping m : mappings) {
        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {
            Mapping previous = stack.pop();
            writeClosedMapping(previous);
        }

        Mapping parent = stack.peek();
        writeCharsBetween(parent, m);
        stack.push(m);
    }

    while (!stack.isEmpty()) {
        Mapping m = stack.pop();
        writeClosedMapping(m);
    }

    closeLine();
}",0,0
44,Closure_149,"private String toSource(Node n, SourceMap sourceMap) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
     builder.setSourceMap(sourceMap);
     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
 
     Charset charset = options.outputCharset;
     builder.setOutputCharset(charset);
 
     return builder.build();
  }","private String toSource(Node n, SourceMap sourceMap) {
    if (n == null) {
        throw new IllegalArgumentException(""Node cannot be null"");
    }
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);

    Charset charset = options.outputCharset != null ? options.outputCharset : Charsets.UTF_8;
    builder.setOutputCharset(charset);

    return builder.build();
}",0,0
44,Closure_149,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
     }
 
     options.closurePass = flags.process_closure_primitives;
     initOptionsFromFlags(options);
     return options;
   }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags != null ? flags.compilation_level : CompilationLevel.SIMPLE_OPTIMIZATIONS;
    level.setOptionsForCompilationLevel(options);
    if (flags != null && flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }

    WarningLevel wLevel = flags != null ? flags.warning_level : WarningLevel.DEFAULT;
    wLevel.setOptionsForWarningLevel(options);
    if (flags != null && flags.formatting != null) {
        for (FormattingOption formattingOption : flags.formatting) {
            formattingOption.applyToOptions(options);
        }
    }

    options.closurePass = flags != null && flags.process_closure_primitives;
    if (flags != null) {
        initOptionsFromFlags(options);
    }
    return options;
}",0,0
44,Closure_149,"final protected void setRunOptions(CompilerOptions options)
      throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();

    diagnosticGroups.setWarningLevels(
        options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(
        options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(
        options, config.jscompOff, CheckLevel.OFF);

    createDefineReplacements(config.define, options);

    options.manageClosureDependencies = config.manageClosureDependencies;
    options.devMode = config.jscompDevMode;
     options.setCodingConvention(config.codingConvention);
     options.setSummaryDetailLevel(config.summaryDetailLevel);
 
     inputCharset = getInputCharset();
 
     if (config.jsOutputFile.length() > 0) {
      options.jsOutputFile = config.jsOutputFile;
    }

    if (config.createSourceMap.length() > 0) {
      options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;

    if (!config.variableMapInputFile.equals("""")) {
      options.inputVariableMapSerialized =
          VariableMap.load(config.variableMapInputFile).toBytes();
    }

    if (!config.propertyMapInputFile.equals("""")) {
      options.inputPropertyMapSerialized =
          VariableMap.load(config.propertyMapInputFile).toBytes();
    }
  }","final protected void setRunOptions(CompilerOptions options)
        throws FlagUsageException, IOException {
    if (config == null || options == null) {
        throw new IllegalArgumentException(""Config and options must not be null"");
    }

    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();

    diagnosticGroups.setWarningLevels(
            options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(
            options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(
            options, config.jscompOff, CheckLevel.OFF);

    if (config.define != null) {
        createDefineReplacements(config.define, options);
    }

    options.manageClosureDependencies = config.manageClosureDependencies;
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention != null ? config.codingConvention : new DefaultCodingConvention());
    options.setSummaryDetailLevel(config.summaryDetailLevel);

    inputCharset = getInputCharset();

    if (config.jsOutputFile != null && config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }

    if (config.createSourceMap != null && config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;

    if (config.variableMapInputFile != null && !config.variableMapInputFile.isEmpty()) {
        options.inputVariableMapSerialized =
                VariableMap.load(config.variableMapInputFile).toBytes();
    }

    if (config.propertyMapInputFile != null && !config.propertyMapInputFile.isEmpty()) {
        options.inputPropertyMapSerialized =
                VariableMap.load(config.propertyMapInputFile).toBytes();
    }
}",0,0
44,Closure_149,"protected int doRun() throws FlagUsageException, IOException {
    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));

    List<JSSourceFile> externsList = createExterns();
    JSSourceFile[] externs = new JSSourceFile[externsList.size()];
    externsList.toArray(externs);

    compiler = createCompiler();
    B options = createOptions();

    JSModule[] modules = null;
     Result result;
 
     setRunOptions(options);
     if (inputCharset == Charsets.UTF_8) {
       options.outputCharset = Charsets.US_ASCII;
     } else {
       options.outputCharset = inputCharset;
     }
 
     boolean writeOutputToFile = !options.jsOutputFile.isEmpty();
     if (writeOutputToFile) {
      out = toWriter(options.jsOutputFile, inputCharset.name());
    }

    List<String> jsFiles = config.js;
    List<String> moduleSpecs = config.module;
    if (!moduleSpecs.isEmpty()) {
      modules = createJsModules(moduleSpecs, jsFiles);
      result = compiler.compile(externs, modules, options);
    } else {
      List<JSSourceFile> inputList = createSourceInputs(jsFiles);
      JSSourceFile[] inputs = new JSSourceFile[inputList.size()];
      inputList.toArray(inputs);
      result = compiler.compile(externs, inputs, options);
    }

    int errCode = processResults(result, modules, options);
    // Close the output if we are writing to a file.
    if (writeOutputToFile) {
      ((Writer)out).close();
    }
    return errCode;
  }","protected int doRun() throws FlagUsageException, IOException {
    if (config == null) {
        throw new IllegalArgumentException(""Config must not be null"");
    }
    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
    
    List<JSSourceFile> externsList = createExterns();
    JSSourceFile[] externs = new JSSourceFile[externsList.size()];
    externsList.toArray(externs);

    compiler = createCompiler();
    CompilerOptions options = createOptions();

    JSModule[] modules = null;
    Result result;

    setRunOptions(options);

    if (inputCharset == null) {
        inputCharset = Charsets.UTF_8;
    }
    options.outputCharset = inputCharset == Charsets.UTF_8 ? Charsets.US_ASCII : inputCharset;

    boolean writeOutputToFile = options.jsOutputFile != null && !options.jsOutputFile.isEmpty();
    if (writeOutputToFile) {
        out = toWriter(options.jsOutputFile, inputCharset.name());
    }

    List<String> jsFiles = config.js;
    List<String> moduleSpecs = config.module;
    if (moduleSpecs != null && !moduleSpecs.isEmpty()) {
        modules = createJsModules(moduleSpecs, jsFiles);
        result = compiler.compile(externs, modules, options);
    } else {
        List<JSSourceFile> inputList = createSourceInputs(jsFiles);
        JSSourceFile[] inputs = new JSSourceFile[inputList.size()];
        inputList.toArray(inputs);
        result = compiler.compile(externs, inputs, options);
    }

    int errCode = processResults(result, modules, options);
    if (writeOutputToFile && out instanceof Writer) {
        ((Writer) out).close();
    }
    return errCode;
}",0,0
45,Closure_151,"private void initConfigFromFlags(String[] args, PrintStream err) {
    // Args4j has a different format that the old command-line parser.
    // So we use some voodoo to get the args into the format that args4j
    // expects.
    Pattern argPattern = Pattern.compile(""(--[a-zA-Z_]+)=(.*)"");
    Pattern quotesPattern = Pattern.compile(""^['\""](.*)['\""]$"");
    List<String> processedArgs = Lists.newArrayList();
    for (String arg : args) {
      Matcher matcher = argPattern.matcher(arg);
      if (matcher.matches()) {
        processedArgs.add(matcher.group(1));

        String value = matcher.group(2);
        Matcher quotesMatcher = quotesPattern.matcher(value);
        if (quotesMatcher.matches()) {
          processedArgs.add(quotesMatcher.group(1));
        } else {
          processedArgs.add(value);
        }
      } else {
        processedArgs.add(arg);
      }
    }

    CmdLineParser parser = new CmdLineParser(flags);
    isConfigValid = true;
    try {
      parser.parseArgument(processedArgs.toArray(new String[] {}));
    } catch (CmdLineException e) {
      err.println(e.getMessage());
       isConfigValid = false;
     }
 
 
     if (!isConfigValid || flags.display_help) {
       isConfigValid = false;
      parser.printUsage(err);
    } else {
      getCommandLineConfig()
          .setPrintTree(flags.print_tree)
          .setComputePhaseOrdering(flags.compute_phase_ordering)
          .setPrintAst(flags.print_ast)
          .setPrintPassGraph(flags.print_pass_graph)
          .setJscompDevMode(flags.jscomp_dev_mode)
          .setLoggingLevel(flags.logging_level)
          .setExterns(flags.externs)
          .setJs(flags.js)
          .setJsOutputFile(flags.js_output_file)
          .setModule(flags.module)
          .setVariableMapInputFile(flags.variable_map_input_file)
          .setPropertyMapInputFile(flags.property_map_input_file)
          .setVariableMapOutputFile(flags.variable_map_output_file)
          .setCreateNameMapFiles(flags.create_name_map_files)
          .setPropertyMapOutputFile(flags.property_map_output_file)
          .setCodingConvention(flags.third_party ?
               new DefaultCodingConvention() :
               new ClosureCodingConvention())
          .setSummaryDetailLevel(flags.summary_detail_level)
          .setOutputWrapper(flags.output_wrapper)
          .setOutputWrapperMarker(flags.output_wrapper_marker)
          .setModuleWrapper(flags.module_wrapper)
          .setModuleOutputPathPrefix(flags.module_output_path_prefix)
          .setCreateSourceMap(flags.create_source_map)
          .setJscompError(flags.jscomp_error)
          .setJscompWarning(flags.jscomp_warning)
          .setJscompOff(flags.jscomp_off)
          .setDefine(flags.define)
          .setCharset(flags.charset)
          .setManageClosureDependencies(flags.manage_closure_dependencies)
          .setOutputManifest(flags.output_manifest);
    }
  }","private void initConfigFromFlags(String[] args, PrintStream err) {
    Pattern argPattern = Pattern.compile(""(--[a-zA-Z_]+)=(.*)"");
    Pattern quotesPattern = Pattern.compile(""^['\""](.*)['\""]$"");
    List<String> processedArgs = new ArrayList<>();
    
    for (String arg : args) {
        Matcher matcher = argPattern.matcher(arg);
        if (matcher.matches()) {
            processedArgs.add(matcher.group(1));
            String value = matcher.group(2);
            if (value != null) {
                Matcher quotesMatcher = quotesPattern.matcher(value);
                if (quotesMatcher.matches()) {
                    processedArgs.add(quotesMatcher.group(1));
                } else {
                    processedArgs.add(value);
                }
            }
        } else {
            processedArgs.add(arg);
        }
    }

    CmdLineParser parser = new CmdLineParser(flags);
    isConfigValid = true;
    try {
        parser.parseArgument(processedArgs.toArray(new String[0]));
    } catch (CmdLineException e) {
        err.println(e.getMessage());
        isConfigValid = false;
    }

    if (!isConfigValid || flags.display_help) {
        isConfigValid = false;
        parser.printUsage(err);
    } else {
        getCommandLineConfig()
            .setPrintTree(flags.print_tree)
            .setComputePhaseOrdering(flags.compute_phase_ordering)
            .setPrintAst(flags.print_ast)
            .setPrintPassGraph(flags.print_pass_graph)
            .setJscompDevMode(flags.jscomp_dev_mode)
            .setLoggingLevel(flags.logging_level)
            .setExterns(flags.externs)
            .setJs(flags.js)
            .setJsOutputFile(flags.js_output_file)
            .setModule(flags.module)
            .setVariableMapInputFile(flags.variable_map_input_file)
            .setPropertyMapInputFile(flags.property_map_input_file)
            .setVariableMapOutputFile(flags.variable_map_output_file)
            .setCreateNameMapFiles(flags.create_name_map_files)
            .setPropertyMapOutputFile(flags.property_map_output_file)
            .setCodingConvention(flags.third_party ?
                new DefaultCodingConvention() :
                new ClosureCodingConvention())
            .setSummaryDetailLevel(flags.summary_detail_level)
            .setOutputWrapper(flags.output_wrapper)
            .setOutputWrapperMarker(flags.output_wrapper_marker)
            .setModuleWrapper(flags.module_wrapper)
            .setModuleOutputPathPrefix(flags.module_output_path_prefix)
            .setCreateSourceMap(flags.create_source_map)
            .setJscompError(flags.jscomp_error)
            .setJscompWarning(flags.jscomp_warning)
            .setJscompOff(flags.jscomp_off)
            .setDefine(flags.define)
            .setCharset(flags.charset)
            .setManageClosureDependencies(flags.manage_closure_dependencies)
            .setOutputManifest(flags.output_manifest);
    }
}",0,0
46,Closure_153,"private void scanRoot(Node n, Scope parent) {
    if (n.getType() == Token.FUNCTION) {
      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);

      final Node fnNameNode = n.getFirstChild();
      final Node args = fnNameNode.getNext();
      final Node body = args.getNext();

      // Bleed the function name into the scope, if it hasn't
       // been declared in the outer scope.
       String fnName = fnNameNode.getString();
       if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {
         declareVar(fnName, fnNameNode, n, null, null, n);
       }
 
       // Args: Declare function variables
      Preconditions.checkState(args.getType() == Token.LP);
      for (Node a = args.getFirstChild(); a != null;
           a = a.getNext()) {
        Preconditions.checkState(a.getType() == Token.NAME);
        declareVar(a.getString(), a, args, n, null, n);
      }

      // Body
      scanVars(body, n);
    } else {
      // It's the global block
      Preconditions.checkState(scope.getParent() == null);
      scanVars(n, null);
    }
  }","private void scanRoot(Node n, Scope parent) {
    if (n.getType() == Token.FUNCTION) {
        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);

        final Node fnNameNode = n.getFirstChild();
        final Node args = fnNameNode.getNext();
        final Node body = args.getNext();

        // Bleed the function name into the scope, if it hasn't
        // been declared in the outer scope.
        String fnName = fnNameNode.getString();
        if (fnName != null && !fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {
            declareVar(fnName, fnNameNode, n, null, null, n);
        }

        // Args: Declare function variables
        Preconditions.checkState(args.getType() == Token.PARAM_LIST);
        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {
            Preconditions.checkState(a.getType() == Token.NAME);
            declareVar(a.getString(), a, args, n, null, n);
        }

        // Body
        scanVars(body, n);
    } else {
        // It's the global block
        Preconditions.checkState(scope.getParent() == null);
        scanVars(n, null);
    }
}",0,0
46,Closure_153,"void onRedeclaration(
         Scope s, String name,
         Node n, Node parent, Node gramps, Node nodeWithLineNumber);","void onRedeclaration(
        Scope s, String name,
        Node n, Node parent, Node gramps, Node nodeWithLineNumber) {
    throw new UnsupportedOperationException(""This method should be overridden by the subclass"");
}",0,0
46,Closure_153,"private void scanVars(Node n, Node parent) {
    switch (n.getType()) {
      case Token.VAR:
        // Declare all variables. e.g. var x = 1, y, z;
        for (Node child = n.getFirstChild();
             child != null;) {
          Node next = child.getNext();
          Preconditions.checkState(child.getType() == Token.NAME);
          String name = child.getString();
          declareVar(name, child, n, parent, null, n);
          child = next;
        }
        return;

      case Token.FUNCTION:
        if (NodeUtil.isFunctionExpression(n)) {
          return;
        }

        String fnName = n.getFirstChild().getString();
        if (fnName.isEmpty()) {
           // This is invalid, but allow it so the checks can catch it.
           return;
         }
         declareVar(fnName, n.getFirstChild(), n, parent, null, n);
         return;   // should not examine function's children
 
       case Token.CATCH:
        Preconditions.checkState(n.getChildCount() == 2);
        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);
        // the first child is the catch var and the third child
        // is the code block

        final Node var = n.getFirstChild();
        final Node block = var.getNext();

        declareVar(var.getString(), var, n, parent, null, n);
        scanVars(block, n);
        return;  // only one child to scan

      case Token.SCRIPT:
        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        break;
    }

    // Variables can only occur in statement-level nodes, so
    // we only need to traverse children in a couple special cases.
    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {
      for (Node child = n.getFirstChild();
           child != null;) {
        Node next = child.getNext();
        scanVars(child, n);
        child = next;
      }
    }
  }","private void scanVars(Node n, Node parent) {
    switch (n.getType()) {
        case Token.VAR:
            // Declare all variables. e.g. var x = 1, y, z;
            for (Node child = n.getFirstChild(); child != null;) {
                Node next = child.getNext();
                Preconditions.checkState(child.getType() == Token.NAME);
                String name = child.getString();
                if (name != null && !name.isEmpty()) {
                    declareVar(name, child, n, parent, null, n);
                }
                child = next;
            }
            return;

        case Token.FUNCTION:
            if (NodeUtil.isFunctionExpression(n)) {
                return;
            }

            String fnName = n.getFirstChild().getString();
            if (fnName != null && !fnName.isEmpty()) {
                declareVar(fnName, n.getFirstChild(), n, parent, null, n);
            }
            return; // should not examine function's children

        case Token.CATCH:
            Preconditions.checkState(n.getChildCount() == 2);
            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);
            // the first child is the catch var and the second child is the code block

            final Node var = n.getFirstChild();
            final Node block = var.getNext();

            declareVar(var.getString(), var, n, parent, null, n);
            scanVars(block, n);
            return; // only one child to scan

        case Token.SCRIPT:
            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
            // Fallthrough intentional: continue traversing children

        default:
            // Variables can only occur in statement-level nodes, so
            // we only need to traverse children in a couple of special cases.
            if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {
                for (Node child = n.getFirstChild(); child != null;) {
                    Node next = child.getNext();
                    scanVars(child, n);
                    child = next;
                }
            }
            break;
    }
}",0,0
46,Closure_153,"@Override
    public void onRedeclaration(
        Scope s, String name, Node n, Node parent, Node gramps,
        Node nodeWithLineNumber) {
      Preconditions.checkState(n.getType() == Token.NAME);
      Var v = s.getVar(name);

        // We allow variables to be duplicate declared if one
        // declaration appears in source and the other in externs.
        // This deals with issues where a browser built-in is declared
        // in one browser but not in another.

      // If name is ""arguments"", Var maybe null.
      if (v != null && v.getParentNode().getType() == Token.CATCH) {
        // Redeclaration of a catch expression variable is hard to model
        // without support for ""with"" expressions.
        // The EcmaScript spec (section 12.14), declares that a catch
        // ""catch (e) {}"" is handled like ""with ({'e': e}) {}"" so that
        // ""var e"" would refer to the scope variable, but any following
        // reference would still refer to ""e"" of the catch expression.
        // Until we have support for this disallow it.
        // Currently the Scope object adds the catch expression to the
        // function scope, which is technically not true but a good
        // approximation for most uses.

        // TODO(johnlenz): Consider improving how scope handles catch
        // expression.

        // Use the name of the var before it was made unique.
        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(
             name);
         compiler.report(
             JSError.make(
                 NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,
                 CATCH_BLOCK_VAR_ERROR, name));
       } else if (v != null && parent.getType() == Token.FUNCTION) {
         if (v.getParentNode().getType() == Token.VAR) {
          s.undeclare(v);
          s.declare(name, n, n.getJSType(), v.input);
          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),
              v.getParentNode().getParent());
        }
      } else if (parent.getType() == Token.VAR) {
        Preconditions.checkState(parent.hasOneChild());

        replaceVarWithAssignment(n, parent, gramps);
      }
    }","@Override
public void onRedeclaration(
        Scope s, String name, Node n, Node parent, Node gramps,
        Node nodeWithLineNumber) {
    Preconditions.checkState(n.getType() == Token.NAME);
    Var v = s.getVar(name);

    // We allow variables to be duplicate declared if one
    // declaration appears in source and the other in externs.
    // This deals with issues where a browser built-in is declared
    // in one browser but not in another.

    // If name is ""arguments"", Var may be null.
    if (v != null && v.getParentNode().getType() == Token.CATCH) {
        // Redeclaration of a catch expression variable is problematic.
        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);
        compiler.report(
            JSError.make(
                NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,
                CATCH_BLOCK_VAR_ERROR, name));
    } else if (v != null && parent.getType() == Token.FUNCTION) {
        if (v.getParentNode().getType() == Token.VAR) {
            s.undeclare(v);
            s.declare(name, n, n.getJSType(), v.input);
            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());
        }
    } else if (parent != null && parent.getType() == Token.VAR) {
        Preconditions.checkState(parent.hasOneChild());

        replaceVarWithAssignment(n, parent, gramps);
    }
}",0,0
47,Closure_154,"private void expectInterfaceProperty(NodeTraversal t, Node n,
      ObjectType instance, ObjectType implementedInterface, String prop) {
    if (!instance.hasProperty(prop)) {
      // Not implemented
      String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
      sourceName = sourceName == null ? """" : sourceName;
      if (shouldReport) {
        compiler.report(JSError.make(sourceName, n,
            INTERFACE_METHOD_NOT_IMPLEMENTED,
             prop, implementedInterface.toString(), instance.toString()));
       }
       registerMismatch(instance, implementedInterface);
         // Implemented, but not correctly typed
     }
   }","private void expectInterfaceProperty(NodeTraversal t, Node n,
      ObjectType instance, ObjectType implementedInterface, String prop) {
    if (!instance.hasProperty(prop)) {
        String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        sourceName = sourceName == null ? """" : sourceName;

        if (implementedInterface.hasProperty(prop)) {
            JSType expectedType = implementedInterface.getPropertyType(prop);
            JSType actualType = instance.getPropertyType(prop);

            if (actualType == null || !actualType.canAssignTo(expectedType)) {
                if (shouldReport) {
                    compiler.report(JSError.make(sourceName, n,
                        INTERFACE_METHOD_NOT_IMPLEMENTED,
                        prop, implementedInterface.toString(), instance.toString()));
                }
                registerMismatch(instance, implementedInterface);
            }
        } else {
            if (shouldReport) {
                compiler.report(JSError.make(sourceName, n,
                    INTERFACE_METHOD_NOT_IMPLEMENTED,
                    prop, implementedInterface.toString(), instance.toString()));
            }
            registerMismatch(instance, implementedInterface);
        }
    }
}",0,0
47,Closure_154,"private void checkDeclaredPropertyInheritance(
      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,
      JSDocInfo info, JSType propertyType) {
    // If the supertype doesn't resolve correctly, we've warned about this
    // already.
    if (hasUnknownOrEmptySupertype(ctorType)) {
      return;
    }

    FunctionType superClass = ctorType.getSuperClassConstructor();
    boolean superClassHasProperty = superClass != null &&
        superClass.getPrototype().hasProperty(propertyName);
    boolean declaredOverride = info != null && info.isOverride();

    boolean foundInterfaceProperty = false;
    if (ctorType.isConstructor()) {
      for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {
        if (implementedInterface.isUnknownType() ||
            implementedInterface.isEmptyType()) {
          continue;
        }
        FunctionType interfaceType =
            implementedInterface.toObjectType().getConstructor();
        Preconditions.checkNotNull(interfaceType);
        boolean interfaceHasProperty =
            interfaceType.getPrototype().hasProperty(propertyName);
        foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;
        if (reportMissingOverride.isOn() && !declaredOverride &&
            interfaceHasProperty) {
          // @override not present, but the property does override an interface
          // property
          compiler.report(t.makeError(n, reportMissingOverride,
               HIDDEN_INTERFACE_PROPERTY, propertyName,
               interfaceType.getTopMostDefiningType(propertyName).toString()));
         }
         if (interfaceHasProperty) {
           JSType interfacePropType =
               interfaceType.getPrototype().getPropertyType(propertyName);
           if (!propertyType.canAssignTo(interfacePropType)) {
             compiler.report(t.makeError(n,
                 HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName,
                 interfaceType.getTopMostDefiningType(propertyName).toString(),
                 interfacePropType.toString(), propertyType.toString()));
           }
         }
       }
     }
 
    if (!declaredOverride && !superClassHasProperty) {
      // nothing to do here, it's just a plain new property
      return;
    }

    JSType topInstanceType = superClassHasProperty ?
        superClass.getTopMostDefiningType(propertyName) : null;
    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&
        !declaredOverride && superClassHasProperty) {
      // @override not present, but the property does override a superclass
      // property
      compiler.report(t.makeError(n, reportMissingOverride,
          HIDDEN_SUPERCLASS_PROPERTY, propertyName,
          topInstanceType.toString()));
    }
    if (!declaredOverride) {
      // there's no @override to check
      return;
    }
    // @override is present and we have to check that it is ok
    if (superClassHasProperty) {
      // there is a superclass implementation
      JSType superClassPropType =
          superClass.getPrototype().getPropertyType(propertyName);
      if (!propertyType.canAssignTo(superClassPropType)) {
        compiler.report(
            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,
                propertyName, topInstanceType.toString(),
                superClassPropType.toString(), propertyType.toString()));
      }
    } else if (!foundInterfaceProperty) {
      // there is no superclass nor interface implementation
      compiler.report(
          t.makeError(n, UNKNOWN_OVERRIDE,
              propertyName, ctorType.getInstanceType().toString()));
    }
  }","private void checkDeclaredPropertyInheritance(
      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,
      JSDocInfo info, JSType propertyType) {
    if (hasUnknownOrEmptySupertype(ctorType)) {
        return;
    }

    FunctionType superClass = ctorType.getSuperClassConstructor();
    boolean superClassHasProperty = superClass != null &&
        superClass.getPrototype().hasProperty(propertyName);
    boolean declaredOverride = info != null && info.isOverride();

    boolean foundInterfaceProperty = false;

    if (ctorType.isConstructor()) {
        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {
            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
                continue;
            }
            FunctionType interfaceType =
                implementedInterface.toObjectType().getConstructor();

            Preconditions.checkNotNull(interfaceType);
            boolean interfaceHasProperty =
                interfaceType.getPrototype().hasProperty(propertyName);
            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;

            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {
                compiler.report(t.makeError(n, reportMissingOverride,
                    HIDDEN_INTERFACE_PROPERTY, propertyName,
                    interfaceType.getTopMostDefiningType(propertyName).toString()));
            }

            if (interfaceHasProperty) {
                JSType interfacePropType =
                    interfaceType.getPrototype().getPropertyType(propertyName);
                if (!propertyType.canAssignTo(interfacePropType)) {
                    compiler.report(t.makeError(n,
                        HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName,
                        interfaceType.getTopMostDefiningType(propertyName).toString(),
                        interfacePropType.toString(), propertyType.toString()));
                }
            }
        }
    }

    if (!declaredOverride && !superClassHasProperty) {
        return;
    }

    JSType topInstanceType = superClassHasProperty ?
        superClass.getTopMostDefiningType(propertyName) : null;

    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&
        !declaredOverride && superClassHasProperty) {
        compiler.report(t.makeError(n, reportMissingOverride,
            HIDDEN_SUPERCLASS_PROPERTY, propertyName,
            topInstanceType.toString()));
    }

    if (!declaredOverride) {
        return;
    }

    if (superClassHasProperty) {
        JSType superClassPropType =
            superClass.getPrototype().getPropertyType(propertyName);
        if (!propertyType.canAssignTo(superClassPropType)) {
            compiler.report(
                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,
                    propertyName, topInstanceType.toString(),
                    superClassPropType.toString(), propertyType.toString()));
        }
    } else if (!foundInterfaceProperty) {
        compiler.report(
            t.makeError(n, UNKNOWN_OVERRIDE,
                propertyName, ctorType.getInstanceType().toString()));
    }
}",0,0
48,Closure_155,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNameNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
       // inline an alias of it. (If the variable was inlined, then the
       // reference data is out of sync. We're better off just waiting for
       // the next pass.)
       if (
           !staleVars.contains(v) && referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
         List<Reference> refs = referenceInfo.references;
        for (int i = 1 /* start from a read */; i < refs.size(); i++) {
          Node nameNode = refs.get(i).getNameNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;

    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        Node value = (init != null) ? init.getAssignedValue() : null;
        if (value == null) {
            Node srcLocation = declaration.getNameNode();
            value = NodeUtil.newUndefinedNode(srcLocation);
        }
        if (value != null) {
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    } else if (refCount == firstRefAfterInit) {
        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            Node value = init.getAssignedValue();
            if (value != null) {
                inlineWellDefinedVariable(v, value, referenceInfo.references);
                staleVars.add(v);
            }
        }
    }

    if (!staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNameNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit = candidate.refInfo.getInitializingReference();
                    Node value = (aliasInit != null) ? aliasInit.getAssignedValue() : null;
                    if (value != null) {
                        inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                        staleVars.add(candidate.alias);
                    }
                }
            }
        }
    }
}",0,0
48,Closure_155,"private void doInlinesForScope(NodeTraversal t,
         Map<Var, ReferenceCollection> referenceMap) {
 
       for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {
         Var v = it.next();
 
        ReferenceCollection referenceInfo = referenceMap.get(v);

        // referenceInfo will be null if we're in constants-only mode
        // and the variable is not a constant.
        if (referenceInfo == null || isVarInlineForbidden(v)) {
          // Never try to inline exported variables or variables that
          // were not collected or variables that have already been inlined.
          continue;
        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
          Reference init = referenceInfo.getInitializingReferenceForConstants();
          Node value = init.getAssignedValue();
          inlineDeclaredConstant(v, value, referenceInfo.references);
          staleVars.add(v);
        } else if (mode == Mode.CONSTANTS_ONLY) {
          // If we're in constants-only mode, don't run more aggressive
          // inlining heuristics. See InlineConstantsTest.
          continue;
        } else {
          inlineNonConstants(v, referenceInfo);
        }
      }
    }","private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {
    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {
        Var v = it.next();
        ReferenceCollection referenceInfo = referenceMap.get(v);

        if (referenceInfo == null || isVarInlineForbidden(v)) {
            continue;
        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
            Reference init = referenceInfo.getInitializingReferenceForConstants();
            if (init != null) {
                Node value = init.getAssignedValue();
                if (value != null) {
                    inlineDeclaredConstant(v, value, referenceInfo.references);
                    staleVars.add(v);
                }
            }
        } else if (mode == Mode.CONSTANTS_ONLY) {
            continue;
        } else {
            inlineNonConstants(v, referenceInfo);
        }
    }
}",0,0
48,Closure_155,"public void visit(NodeTraversal t, Node n, Node parent) {
     if (n.getType() == Token.NAME) {
       Var v = t.getScope().getVar(n.getString());
       if (v != null && varFilter.apply(v)) {
         addReference(t, v,
             new Reference(n, parent, t, blockStack.peek()));
      }
    }

    if (isBlockBoundary(n, parent)) {
      blockStack.pop();
    }
  }","public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.NAME) {
        Var v = t.getScope().getVar(n.getString());
        if (v != null && varFilter.apply(v)) {
            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));
        }
    }

    if (isBlockBoundary(n, parent)) {
        if (!blockStack.isEmpty()) {
            blockStack.pop();
        }
    }
}",0,0
49,Closure_156,"private void updateObjLitOrFunctionDeclarationAtAssignNode(
      Name n, String alias) {
    // NOTE: It's important that we don't add additional nodes
    // (e.g. a var node before the exprstmt) because the exprstmt might be
    // the child of an if statement that's not inside a block).

    Ref ref = n.declaration;
    Node rvalue = ref.node.getNext();
    Node varNode = new Node(Token.VAR);
    Node varParent = ref.node.getAncestor(3);
    Node gramps = ref.node.getAncestor(2);
    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;
    boolean insertedVarNode = false;

    if (isObjLit && n.canEliminate()) {
      // Eliminate the object literal altogether.
      varParent.replaceChild(gramps, varNode);
      ref.node = null;
      insertedVarNode = true;

    } else if (!n.isSimpleName()) {
      // Create a VAR node to declare the name.
      if (rvalue.getType() == Token.FUNCTION) {
        checkForHosedThisReferences(rvalue, n.docInfo, n);
      }

      ref.node.getParent().removeChild(rvalue);

      Node nameNode = NodeUtil.newName(
          compiler.getCodingConvention(),
          alias, ref.node.getAncestor(2), n.fullName());

      if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
      }

      varNode.addChildToBack(nameNode);
      nameNode.addChildToFront(rvalue);
      varParent.replaceChild(gramps, varNode);

      // Update the node ancestry stored in the reference.
      ref.node = nameNode;
       insertedVarNode = true;
     }
 
     if (isObjLit) {
         declareVarsForObjLitValues(
             n, alias, rvalue,
             varNode, varParent.getChildBefore(varNode), varParent);
 
     }
       addStubsForUndeclaredProperties(n, alias, varParent, varNode);
 
     if (insertedVarNode) {
       if (!varNode.hasChildren()) {
        varParent.removeChild(varNode);
      }
      compiler.reportCodeChange();
    }
  }","private void updateObjLitOrFunctionDeclarationAtAssignNode(
      Name n, String alias) {
    Ref ref = n.declaration;
    if (ref == null || ref.node == null) {
        return;
    }

    Node rvalue = ref.node.getNext();
    if (rvalue == null) {
        return;
    }

    Node varNode = new Node(Token.VAR);
    Node varParent = ref.node.getAncestor(3);
    Node gramps = ref.node.getAncestor(2);
    if (varParent == null || gramps == null) {
        return;
    }

    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;
    boolean insertedVarNode = false;

    if (isObjLit && n.canEliminate() && varParent.hasChild(gramps)) {
        varParent.replaceChild(gramps, varNode);
        ref.node = null;
        insertedVarNode = true;

    } else if (!n.isSimpleName()) {
        if (rvalue.getType() == Token.FUNCTION) {
            checkForHosedThisReferences(rvalue, n.docInfo, n);
        }

        ref.node.getParent().removeChild(rvalue);

        Node nameNode = NodeUtil.newName(
            compiler.getCodingConvention(),
            alias, ref.node.getAncestor(2), n.fullName()
        );

        if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
            nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
        }

        varNode.addChildToBack(nameNode);
        nameNode.addChildToFront(rvalue);
        varParent.replaceChild(gramps, varNode);

        ref.node = nameNode;
        insertedVarNode = true;
    }

    if (isObjLit) {
        if (varParent.hasChild(varNode)) {
            declareVarsForObjLitValues(
                n, alias, rvalue,
                varNode, varParent.getChildBefore(varNode), varParent
            );
        }
    }

    addStubsForUndeclaredProperties(n, alias, varParent, varNode);

    if (insertedVarNode) {
        if (!varNode.hasChildren()) {
            varParent.removeChild(varNode);
        }
        compiler.reportCodeChange();
    }
}",0,0
49,Closure_156,"private void updateObjLitOrFunctionDeclaration(Name n, String alias) {
    if (n.declaration == null) {
      // Some names do not have declarations, because they
      // are only defined in local scopes.
      return;
    }

    if (n.declaration.getTwin() != null) {
      // Twin declarations will get handled when normal references
      // are handled.
      return;
    }
 
     switch (n.declaration.node.getParent().getType()) {
       case Token.ASSIGN:
         updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);
         break;
       case Token.VAR:
         updateObjLitOrFunctionDeclarationAtVarNode(n);
         break;
       case Token.FUNCTION:
         updateFunctionDeclarationAtFunctionNode(n);
         break;
     }
   }","private void updateObjLitOrFunctionDeclaration(Name n, String alias) {
    if (n.declaration == null) {
        return;
    }

    if (n.declaration.getTwin() != null) {
        return;
    }

    Node parent = n.declaration.node.getParent();
    if (parent == null) {
        return;
    }

    switch (parent.getType()) {
        case Token.ASSIGN:
            updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);
            break;
        case Token.VAR:
            updateObjLitOrFunctionDeclarationAtVarNode(n);
            break;
        case Token.FUNCTION:
            updateFunctionDeclarationAtFunctionNode(n);
            break;
        default:
            break;
    }
}",0,0
49,Closure_156,"private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {
     boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();
 
     // Handle this name first so that nested object literals get unrolled.
     if (n.canCollapse() && canCollapseChildNames) {
       updateObjLitOrFunctionDeclaration(n, alias);
     }
 
     if (n.props != null) {
      for (Name p : n.props) {
        // Recurse first so that saved node ancestries are intact when needed.
        collapseDeclarationOfNameAndDescendants(
            p, appendPropForAlias(alias, p.name));

        if (!p.inExterns && canCollapseChildNames && p.declaration != null &&
            p.declaration.node != null &&
            p.declaration.node.getParent() != null &&
            p.declaration.node.getParent().getType() == Token.ASSIGN) {
          updateSimpleDeclaration(
              appendPropForAlias(alias, p.name), p, p.declaration);
        }
      }
    }
  }","private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {
    if (n == null || alias == null) {
        return;
    }

    boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();

    if (n.canCollapse() && canCollapseChildNames) {
        updateObjLitOrFunctionDeclaration(n, alias);
    }

    if (n.props != null) {
        for (Name p : n.props) {
            collapseDeclarationOfNameAndDescendants(
                p, appendPropForAlias(alias, p.name)
            );

            if (!p.inExterns && canCollapseChildNames && p.declaration != null &&
                p.declaration.node != null &&
                p.declaration.node.getParent() != null &&
                p.declaration.node.getParent().getType() == Token.ASSIGN) {
                updateSimpleDeclaration(
                    appendPropForAlias(alias, p.name), p, p.declaration
                );
            }
        }
    }
}",0,0
50,Closure_157,"private void processPrototypeParent(Node n, CompilerInput input) {
      switch (n.getType()) {
        // Foo.prototype.getBar = function() { ... }
        case Token.GETPROP:
        case Token.GETELEM:
          Node dest = n.getFirstChild().getNext();
          if (dest.getType() == Token.STRING) {
            markPrototypePropertyCandidate(dest, input);
          }
          break;

        // Foo.prototype = { ""getBar"" : function() { ... } }
        case Token.ASSIGN:
        case Token.CALL:
          Node map;
          if (n.getType() == Token.ASSIGN) {
            map = n.getFirstChild().getNext();
          } else {
            map = n.getLastChild();
          }
          if (map.getType() == Token.OBJECTLIT) {
            // Remember this node so that we can avoid processing it again when
            // the traversal reaches it.
            prototypeObjLits.add(map);
 
             for (Node key = map.getFirstChild();
                  key != null; key = key.getNext()) {
               if (key.getType() != Token.NUMBER) {
                // May be STRING, GET, or SET
                 markPrototypePropertyCandidate(key, input);
               }
            }
          }
          break;
      }
    }","private void processPrototypeParent(Node n, CompilerInput input) {
    switch (n.getType()) {
        case Token.GETPROP:
        case Token.GETELEM:
            Node dest = n.getFirstChild().getNext();
            if (dest != null && dest.getType() == Token.STRING) {
                markPrototypePropertyCandidate(dest, input);
            }
            break;

        case Token.ASSIGN:
        case Token.CALL:
            Node map = (n.getType() == Token.ASSIGN) ?
                n.getFirstChild().getNext() : n.getLastChild();
            if (map != null && map.getType() == Token.OBJECTLIT) {
                prototypeObjLits.add(map);
                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {
                    if (key.getType() != Token.NUMBER) {
                        markPrototypePropertyCandidate(key, input);
                    }
                }
            }
            break;
    }
}",0,0
50,Closure_157,"public void visit(NodeTraversal t, Node n, Node parent) {
      switch (n.getType()) {
        case Token.GETPROP:
        case Token.GETELEM:
          Node dest = n.getFirstChild().getNext();
          if (dest.getType() == Token.STRING) {
            String s = dest.getString();
            if (s.equals(""prototype"")) {
              processPrototypeParent(parent, t.getInput());
            } else {
              markPropertyAccessCandidate(dest, t.getInput());
            }
          }
          break;
        case Token.OBJECTLIT:
          if (!prototypeObjLits.contains(n)) {
            // Object literals have their property name/value pairs as a flat
            // list as their children. We want every other node in order to get
            // only the property names.
            for (Node child = n.getFirstChild();
                  child != null;
                  child = child.getNext()) {
 
               if (child.getType() != Token.NUMBER) {
                 markObjLitPropertyCandidate(child, t.getInput());
               }
             }
          }
          break;
      }
    }","public void visit(NodeTraversal t, Node n, Node parent) {
    switch (n.getType()) {
        case Token.GETPROP:
        case Token.GETELEM:
            Node dest = n.getFirstChild().getNext();
            if (dest != null && dest.getType() == Token.STRING) {
                String s = dest.getString();
                if (""prototype"".equals(s)) {
                    processPrototypeParent(parent, t.getInput());
                } else {
                    markPropertyAccessCandidate(dest, t.getInput());
                }
            }
            break;

        case Token.OBJECTLIT:
            if (!prototypeObjLits.contains(n)) {
                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
                    if (child.getType() != Token.NUMBER) {
                        markObjLitPropertyCandidate(child, t.getInput());
                    }
                }
            }
            break;
    }
}",0,0
50,Closure_157,"private Node transformAsString(AstNode n) {
       Node ret;
       if (n instanceof Name) {
         ret = transformNameAsString((Name)n);
       } else {
         ret = transform(n);
         Preconditions.checkState(ret.getType() == Token.NUMBER
             || ret.getType() == Token.STRING);
         if (ret.getType() == Token.STRING) {
         ret.putBooleanProp(Node.QUOTED_PROP, true);
         }
       }
       return ret;
     }","private Node transformAsString(AstNode n) {
    Node ret;
    if (n instanceof Name) {
        ret = transformNameAsString((Name) n);
    } else {
        ret = transform(n);
        Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING,
            ""Invalid node type: expected NUMBER or STRING"");
        if (ret.getType() == Token.STRING) {
            ret.putBooleanProp(Node.QUOTED_PROP, true);
        }
    }
    return ret;
}",0,0
50,Closure_157,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);
      addLeftExpr(first, p, context);
      cc.addOp(opstr, true);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(last, p, rhsContext);
      } else {
        addExpr(last, p + 1, rhsContext);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.getType() == Token.EMPTY) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.getType() == Token.COMMA) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN));
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.LP:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        addList(first, false, context);
        break;

      case Token.NUMBER:
        Preconditions.checkState(
            childCount ==
            ((n.getParent() != null &&
              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type));
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().getType() == Token.NUMBER) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type));
        }

        break;
      }

      case Token.HOOK: {
        Preconditions.checkState(childCount == 3);
        int p = NodeUtil.precedence(type);
        addLeftExpr(first, p + 1, context);
        cc.addOp(""?"", true);
        addExpr(first.getNext(), 1);
        cc.addOp("":"", true);
        addExpr(last, 1);
        break;
      }

      case Token.REGEXP:
        if (first.getType() != Token.STRING ||
            last.getType() != Token.STRING) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.GET_REF:
        add(first);
        break;

      case Token.REF_SPECIAL:
        Preconditions.checkState(childCount == 1);
        add(first);
        add(""."");
        add((String) n.getProp(Node.NAME_PROP));
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GET:
      case Token.SET:
        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.getType() == Token.FUNCTION);

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GET) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
         Node body = fn.getLastChild();
 
         // Add the property name.
         if (TokenStream.isJSIdentifier(name) &&
             // do not encode literally any non-literal characters that were
             // unicode escaped.
             NodeUtil.isLatin(name)) {
           add(name);
         } else {
           // Determine if the string is a simple number.
           add(jsString(n.getString(), outputCharsetEncoder));
         }
 
         add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().getType() == Token.SCRIPT);
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.getType() == Token.VAR) {
            cc.endStatement();
          }

          if (c.getType() == Token.FUNCTION) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.getType() == Token.VAR) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.getType() == Token.STRING,
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.getType() == Token.NUMBER);
        if (needsParens) {
          add(""("");
        }
        addLeftExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        add(""."");
        addIdentifier(last.getString());
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addLeftExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addLeftExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA));
          add("")"");
        } else {
          addLeftExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
      case Token.THIS:
      case Token.FALSE:
      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        add(Node.tokenToName(type));
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (first.getType() != Token.LABEL_NAME) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (first.getType() != Token.LABEL_NAME) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_VOID:
        throw new Error(""Unexpected EXPR_VOID. Should be EXPR_RESULT."");

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING:
        if (childCount !=
            ((n.getParent() != null &&
              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
          throw new IllegalStateException(
              ""Unexpected String children: "" + n.getParent().toStringTree());
        }
        add(jsString(n.getString(), outputCharsetEncoder));
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.getType() == Token.GET || c.getType() == Token.SET) {
            add(c);
          } else {
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (c.getType() == Token.STRING &&
                !c.isQuotedString() &&
                !TokenStream.isKeyword(c.getString()) &&
                TokenStream.isJSIdentifier(c.getString()) &&
                // do not encode literally any non-literal characters that
                // were unicode escaped.
                NodeUtil.isLatin(c.getString())) {
              add(c.getString());
            } else {
              // Determine if the string is a simple number.
              addExpr(c, 1);
            }
            add("":"");
            addExpr(c.getFirstChild(), 1);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (first.getType() != Token.LABEL_NAME) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      // This node is auto generated in anonymous functions and should just get
      // ignored for our purposes.
      case Token.SETNAME:
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    if (opstr != null && first != last) {
        Preconditions.checkState(
            childCount == 2,
            ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
            opstr, childCount);
        int p = NodeUtil.precedence(type);
        addLeftExpr(first, p, context);
        cc.addOp(opstr, true);

        Context rhsContext = getContextForNoInOperator(context);

        if (last != null && last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            addExpr(last, p, rhsContext);
        } else {
            addExpr(last, p + 1, rhsContext);
        }
        return;
    }

    cc.startSourceMapping(n);

    switch (type) {
        case Token.TRY:
            Preconditions.checkState(first != null && first.getNext().getType() == Token.BLOCK &&
                !first.getNext().hasMoreThanOneChild());
            Preconditions.checkState(childCount >= 2 && childCount <= 3);
            add(""try"");
            add(first, Context.PRESERVE_BLOCK);
            Node catchblock = first.getNext().getFirstChild();
            if (catchblock != null) {
                add(catchblock);
            }
            if (childCount == 3) {
                add(""finally"");
                add(last, Context.PRESERVE_BLOCK);
            }
            break;

        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;

        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;

        case Token.NAME:
            Preconditions.checkState(childCount <= 1);
            addIdentifier(n.getString());
            if (childCount == 1) {
                cc.addOp(""="", true);
                addExpr(first, NodeUtil.precedence(Token.ASSIGN));
            }
            break;

        case Token.OBJECTLIT:
            if (context == Context.START_OF_EXPR) {
                add(""("");
            }
            add(""{"");
            for (Node c = first; c != null; c = c.getNext()) {
                if (c != first) {
                    cc.listSeparator();
                }
                if (c.getType() == Token.GET || c.getType() == Token.SET) {
                    add(c);
                } else {
                    add(jsString(c.getString(), outputCharsetEncoder));
                    add("":"");
                    addExpr(c.getFirstChild(), 1);
                }
            }
            add(""}"");
            if (context == Context.START_OF_EXPR) {
                add("")"");
            }
            break;

        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;

        case Token.FUNCTION:
            Preconditions.checkState(childCount == 3);
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            break;

        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",0,0
51,Closure_158,"final protected void setRunOptions(CompilerOptions options)
       throws FlagUsageException, IOException {
     DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
 
     diagnosticGroups.setWarningLevels(
         options, config.jscompError, CheckLevel.ERROR);
     diagnosticGroups.setWarningLevels(
         options, config.jscompWarning, CheckLevel.WARNING);
     diagnosticGroups.setWarningLevels(
         options, config.jscompOff, CheckLevel.OFF);
 
     createDefineOrTweakReplacements(config.define, options, false);
 
    options.setTweakProcessing(config.tweakProcessing);
    createDefineOrTweakReplacements(config.tweak, options, true);

    options.manageClosureDependencies = config.manageClosureDependencies;
    if (config.closureEntryPoints.size() > 0) {
      options.setManageClosureDependencies(config.closureEntryPoints);
    }
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);

    outputCharset = options.outputCharset = getOutputCharset();
    inputCharset = getInputCharset();

    if (config.jsOutputFile.length() > 0) {
      options.jsOutputFile = config.jsOutputFile;
    }

    if (config.createSourceMap.length() > 0) {
      options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    options.sourceMapFormat = config.sourceMapFormat;

    if (!config.variableMapInputFile.equals("""")) {
      options.inputVariableMapSerialized =
          VariableMap.load(config.variableMapInputFile).toBytes();
    }

    if (!config.propertyMapInputFile.equals("""")) {
      options.inputPropertyMapSerialized =
          VariableMap.load(config.propertyMapInputFile).toBytes();
    }

    if (config.languageIn.length() > 0) {
      if (config.languageIn.equals(""ECMASCRIPT5_STRICT"") ||
          config.languageIn.equals(""ES5_STRICT"")) {
        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
      } else if (config.languageIn.equals(""ECMASCRIPT5"") ||
          config.languageIn.equals(""ES5"")) {
        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
      } else if (config.languageIn.equals(""ECMASCRIPT3"") ||
                 config.languageIn.equals(""ES3"")) {
        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);
      } else {
        throw new FlagUsageException(""Unknown language `"" + config.languageIn +
                                     ""' specified."");
      }
    }

    options.acceptConstKeyword = config.acceptConstKeyword;
  }","final protected void setRunOptions(CompilerOptions options)
       throws FlagUsageException, IOException {
     DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
 
     diagnosticGroups.setWarningLevels(
         options, config.jscompError, CheckLevel.ERROR);
     diagnosticGroups.setWarningLevels(
         options, config.jscompWarning, CheckLevel.WARNING);
     diagnosticGroups.setWarningLevels(
         options, config.jscompOff, CheckLevel.OFF);
 
     createDefineOrTweakReplacements(config.define, options, false);
 
    options.setTweakProcessing(config.tweakProcessing);
    createDefineOrTweakReplacements(config.tweak, options, true);

    options.manageClosureDependencies = config.manageClosureDependencies;
    if (!config.closureEntryPoints.isEmpty()) {
      options.setManageClosureDependencies(config.closureEntryPoints);
    }
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);

    outputCharset = options.outputCharset = getOutputCharset();
    inputCharset = getInputCharset();

    if (!config.jsOutputFile.isEmpty()) {
      options.jsOutputFile = config.jsOutputFile;
    }

    if (!config.createSourceMap.isEmpty()) {
      options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    options.sourceMapFormat = config.sourceMapFormat;

    if (!config.variableMapInputFile.isEmpty()) {
      try {
          options.inputVariableMapSerialized =
              VariableMap.load(config.variableMapInputFile).toBytes();
      } catch (Exception e) {
          throw new IOException(""Error loading variable map file: "" + config.variableMapInputFile, e);
      }
    }

    if (!config.propertyMapInputFile.isEmpty()) {
      try {
          options.inputPropertyMapSerialized =
              VariableMap.load(config.propertyMapInputFile).toBytes();
      } catch (Exception e) {
          throw new IOException(""Error loading property map file: "" + config.propertyMapInputFile, e);
      }
    }

    if (!config.languageIn.isEmpty()) {
      switch (config.languageIn) {
        case ""ECMASCRIPT5_STRICT"":
        case ""ES5_STRICT"":
          options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
          break;
        case ""ECMASCRIPT5"":
        case ""ES5"":
          options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
          break;
        case ""ECMASCRIPT3"":
        case ""ES3"":
          options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);
          break;
        default:
          throw new FlagUsageException(""Unknown language `"" + config.languageIn +
                                       ""' specified."");
      }
    }

    options.acceptConstKeyword = config.acceptConstKeyword;
  }",0,0
51,Closure_158,"private void processFlagFile(PrintStream err)
            throws CmdLineException, IOException {
    List<String> argsInFile = Lists.newArrayList();
    File flagFileInput = new File(flags.flag_file);
    StringTokenizer tokenizer = new StringTokenizer(
        Files.toString(flagFileInput, Charset.defaultCharset()));

    while (tokenizer.hasMoreTokens()) {
        argsInFile.add(tokenizer.nextToken());
    }

    flags.flag_file = """";
     List<String> processedFileArgs
         = processArgs(argsInFile.toArray(new String[] {}));
     CmdLineParser parserFileArgs = new CmdLineParser(flags);
     parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));
 
     // Currently we are not supporting this (prevent direct/indirect loops)
    if (!flags.flag_file.equals("""")) {
      err.println(""ERROR - Arguments in the file cannot contain ""
          + ""--flagfile option."");
      isConfigValid = false;
    }
  }","private void processFlagFile(PrintStream err)
            throws CmdLineException, IOException {
    List<String> argsInFile = Lists.newArrayList();
    File flagFileInput = new File(flags.flag_file);
    if (!flagFileInput.exists()) {
        throw new IOException(""Flag file does not exist: "" + flags.flag_file);
    }

    StringTokenizer tokenizer = new StringTokenizer(
        Files.toString(flagFileInput, Charset.defaultCharset()));

    while (tokenizer.hasMoreTokens()) {
        argsInFile.add(tokenizer.nextToken());
    }

    flags.flag_file = """";
    List<String> processedFileArgs
        = processArgs(argsInFile.toArray(new String[0]));
    CmdLineParser parserFileArgs = new CmdLineParser(flags);
    parserFileArgs.parseArgument(processedFileArgs.toArray(new String[0]));
 
    // Currently we are not supporting this (prevent direct/indirect loops)
    if (!flags.flag_file.isEmpty()) {
      err.println(""ERROR - Arguments in the file cannot contain ""
          + ""--flagfile option."");
      isConfigValid = false;
    }
  }",0,0
51,Closure_158,"private void initConfigFromFlags(String[] args, PrintStream err) {

     List<String> processedArgs = processArgs(args);
 
     CmdLineParser parser = new CmdLineParser(flags);
     isConfigValid = true;
     try {
       parser.parseArgument(processedArgs.toArray(new String[] {}));
      // For contains --flagfile flag
      if (!flags.flag_file.equals("""")) {
        processFlagFile(err);
      }
    } catch (CmdLineException e) {
      err.println(e.getMessage());
      isConfigValid = false;
    } catch (IOException ioErr) {
      err.println(""ERROR - "" + flags.flag_file + "" read error."");
      isConfigValid = false;
    }

    if (flags.version) {
      ResourceBundle config = ResourceBundle.getBundle(configResource);
      err.println(
          ""Closure Compiler (http://code.google.com/closure/compiler)\n"" +
          ""Version: "" + config.getString(""compiler.version"") + ""\n"" +
          ""Built on: "" + config.getString(""compiler.date""));
      err.flush();
    }

    if (!isConfigValid || flags.display_help) {
      isConfigValid = false;
      parser.printUsage(err);
    } else {
      getCommandLineConfig()
          .setPrintTree(flags.print_tree)
          .setComputePhaseOrdering(flags.compute_phase_ordering)
          .setPrintAst(flags.print_ast)
          .setPrintPassGraph(flags.print_pass_graph)
          .setJscompDevMode(flags.jscomp_dev_mode)
          .setLoggingLevel(flags.logging_level)
          .setExterns(flags.externs)
          .setJs(flags.js)
          .setJsOutputFile(flags.js_output_file)
          .setModule(flags.module)
          .setVariableMapInputFile(flags.variable_map_input_file)
          .setPropertyMapInputFile(flags.property_map_input_file)
          .setVariableMapOutputFile(flags.variable_map_output_file)
          .setCreateNameMapFiles(flags.create_name_map_files)
          .setPropertyMapOutputFile(flags.property_map_output_file)
          .setCodingConvention(flags.third_party ?
               new DefaultCodingConvention() :
               new ClosureCodingConvention())
          .setSummaryDetailLevel(flags.summary_detail_level)
          .setOutputWrapper(flags.output_wrapper)
          .setModuleWrapper(flags.module_wrapper)
          .setModuleOutputPathPrefix(flags.module_output_path_prefix)
          .setCreateSourceMap(flags.create_source_map)
          .setJscompError(flags.jscomp_error)
          .setJscompWarning(flags.jscomp_warning)
          .setJscompOff(flags.jscomp_off)
          .setDefine(flags.define)
          .setCharset(flags.charset)
          .setManageClosureDependencies(flags.manage_closure_dependencies)
          .setClosureEntryPoints(flags.closure_entry_point)
          .setOutputManifest(flags.output_manifest)
          .setAcceptConstKeyword(flags.accept_const_keyword)
          .setLanguageIn(flags.language_in);
    }
  }","private void initConfigFromFlags(String[] args, PrintStream err) {

     List<String> processedArgs = processArgs(args);
 
     CmdLineParser parser = new CmdLineParser(flags);
     isConfigValid = true;
     try {
       parser.parseArgument(processedArgs.toArray(new String[0]));
       // For contains --flagfile flag
       if (!flags.flag_file.isEmpty()) {
           try {
               processFlagFile(err);
           } catch (IOException ioErr) {
               err.println(""ERROR - "" + flags.flag_file + "" read error."");
               isConfigValid = false;
           }
       }
    } catch (CmdLineException e) {
      err.println(e.getMessage());
      isConfigValid = false;
    }

    if (flags.version) {
      try {
          ResourceBundle config = ResourceBundle.getBundle(configResource);
          err.println(
              ""Closure Compiler (http://code.google.com/closure/compiler)\n"" +
              ""Version: "" + config.getString(""compiler.version"") + ""\n"" +
              ""Built on: "" + config.getString(""compiler.date""));
          err.flush();
      } catch (Exception exception) {
          err.println(""ERROR - Failed to load version configuration."");
          isConfigValid = false;
      }
    }

    if (!isConfigValid || flags.display_help) {
      isConfigValid = false;
      parser.printUsage(err);
    } else {
      getCommandLineConfig()
          .setPrintTree(flags.print_tree)
          .setComputePhaseOrdering(flags.compute_phase_ordering)
          .setPrintAst(flags.print_ast)
          .setPrintPassGraph(flags.print_pass_graph)
          .setJscompDevMode(flags.jscomp_dev_mode)
          .setLoggingLevel(flags.logging_level)
          .setExterns(flags.externs)
          .setJs(flags.js)
          .setJsOutputFile(flags.js_output_file)
          .setModule(flags.module)
          .setVariableMapInputFile(flags.variable_map_input_file)
          .setPropertyMapInputFile(flags.property_map_input_file)
          .setVariableMapOutputFile(flags.variable_map_output_file)
          .setCreateNameMapFiles(flags.create_name_map_files)
          .setPropertyMapOutputFile(flags.property_map_output_file)
          .setCodingConvention(flags.third_party ?
               new DefaultCodingConvention() :
               new ClosureCodingConvention())
          .setSummaryDetailLevel(flags.summary_detail_level)
          .setOutputWrapper(flags.output_wrapper)
          .setModuleWrapper(flags.module_wrapper)
          .setModuleOutputPathPrefix(flags.module_output_path_prefix)
          .setCreateSourceMap(flags.create_source_map)
          .setJscompError(flags.jscomp_error)
          .setJscompWarning(flags.jscomp_warning)
          .setJscompOff(flags.jscomp_off)
          .setDefine(flags.define)
          .setCharset(flags.charset)
          .setManageClosureDependencies(flags.manage_closure_dependencies)
          .setClosureEntryPoints(flags.closure_entry_point)
          .setOutputManifest(flags.output_manifest)
          .setAcceptConstKeyword(flags.accept_const_keyword)
          .setLanguageIn(flags.language_in);
    }
  }",0,0
52,Closure_16,"private void fixTypeNode(Node typeNode) {
      if (typeNode.isString()) {
        String name = typeNode.getString();
        int endIndex = name.indexOf('.');
        if (endIndex == -1) {
          endIndex = name.length();
        }
        String baseName = name.substring(0, endIndex);
         Var aliasVar = aliases.get(baseName);
         if (aliasVar != null) {
           Node aliasedNode = aliasVar.getInitialValue();
           aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
         }
       }
 
      for (Node child = typeNode.getFirstChild(); child != null;
           child = child.getNext()) {
        fixTypeNode(child);
      }
    }","private void fixTypeNode(Node typeNode) {
    if (typeNode.isString()) {
        String name = typeNode.getString();
        int endIndex = name.indexOf('.');
        if (endIndex == -1) {
            endIndex = name.length();
        }
        String baseName = name.substring(0, endIndex);
        Var aliasVar = aliases.get(baseName);
        if (aliasVar != null) {
            Node aliasedNode = aliasVar.getInitialValue();
            if (aliasedNode != null && aliasedNode.getQualifiedName() != null) {
                aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
            }
        }
    }

    for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) {
        fixTypeNode(child);
    }
}",0,0
53,Closure_162,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      if (isCallToScopeMethod(n)) {
         validateScopeCall(t, n, n.getParent());
       }
 
 
 
       // Validate the top level of the goog.scope block.
       if (t.getScopeDepth() == 2) {
         int type = n.getType();
         if (type == Token.NAME && parent.getType() == Token.VAR) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
             String name = n.getString();
             Var aliasVar = t.getScope().getVar(name);
             aliases.put(name, aliasVar);
             aliasDefinitionsInOrder.add(n);
 
             String qualifiedName =
                 aliasVar.getInitialValue().getQualifiedName();
             transformation.addAlias(name, qualifiedName);
             // Return early, to ensure that we don't record a definition
             // twice.
             return;
           } else {
             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
           }
         }
         if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&
             n == parent.getFirstChild()) {
             report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
         }
 
         if (type == Token.RETURN) {
           report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
          report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
          report(t, n, GOOG_SCOPE_USES_THROW);
        }
      }

      // Validate all descendent scopes of the goog.scope block.
      if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (n.getType() == Token.NAME) {
          String name = n.getString();
          Var aliasVar = aliases.get(name);
          if (aliasVar != null &&
              t.getScope().getVar(name) == aliasVar) {
          // Note, to support the transitive case, it's important we don't
          // clone aliasedNode here.  For example,
          // var g = goog; var d = g.dom; d.createElement('DIV');
          // The node in aliasedNode (which is ""g"") will be replaced in the
          // changes pass above with ""goog"".  If we cloned here, we'd end up
          // with <code>g.dom.createElement('DIV')</code>.
          Node aliasedNode = aliasVar.getInitialValue();
          aliasUsages.add(new AliasedNode(n, aliasedNode));
          }
        }

        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
          for (Node node : info.getTypeNodes()) {
            fixTypeNode(node);
          }
        }

        // TODO(robbyw): Error for goog.scope not at root.
      }
    }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }

    // Validate the top level of the goog.scope block.
    if (t.getScopeDepth() == 2) {
        int type = n.getType();
        if (type == Token.NAME && parent != null && parent.getType() == Token.VAR) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = t.getScope().getVar(name);
                if (aliasVar != null && aliasVar.getInitialValue() != null) {
                    aliases.put(name, aliasVar);
                    aliasDefinitionsInOrder.add(n);

                    String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                    transformation.addAlias(name, qualifiedName);
                    // Return early, to ensure that we don't record a definition twice.
                    return;
                } else {
                    report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
                    return;
                }
            } else {
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && 
            parent != null && n == parent.getFirstChild()) {
            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
        }

        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }

    // Validate all descendant scopes of the goog.scope block.
    if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (n.getType() == Token.NAME) {
            String name = n.getString();
            Var aliasVar = aliases.get(name);
            if (aliasVar != null && t.getScope().getVar(name) == aliasVar && aliasVar.getInitialValue() != null) {
                Node aliasedNode = aliasVar.getInitialValue();
                aliasUsages.add(new AliasedNode(n, aliasedNode));
            }
        }

        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }

        // TODO(robbyw): Error for goog.scope not at root.
    }
}",0,0
53,Closure_162,"@Override
    public void enterScope(NodeTraversal t) {
      Node n = t.getCurrentNode().getParent();
       if (n != null && isCallToScopeMethod(n)) {
         transformation = transformationHandler.logAliasTransformation(
             n.getSourceFileName(), getSourceRegion(n));
       }
     }","@Override
public void enterScope(NodeTraversal t) {
    Node currentNode = t.getCurrentNode();
    Node n = currentNode != null ? currentNode.getParent() : null;
    if (n != null && isCallToScopeMethod(n)) {
        transformation = transformationHandler.logAliasTransformation(
            n.getSourceFileName(), getSourceRegion(n));
    }
}",0,0
54,Closure_163,"private boolean processGlobalFunctionDeclaration(NodeTraversal t,
        Node nameNode, Node parent, Node gramps) {
      Node firstChild = nameNode.getFirstChild();

      if (// Check for a named FUNCTION.
          isGlobalFunctionDeclaration(t, parent) ||
          // Check for a VAR declaration.
          firstChild != null &&
           isGlobalFunctionDeclaration(t, firstChild)) {
         String name = nameNode.getString();
         getNameInfoForName(name, VAR).getDeclarations().add(
             new GlobalFunction(nameNode, parent, gramps, t.getModule()));
 
         // If the function name is exported, we should create an edge here
         // so that it's never removed.
        if (compiler.getCodingConvention().isExported(name) ||
            anchorUnusedVars) {
          addGlobalUseOfSymbol(name, t.getModule(), VAR);
        }

        return true;
      }
      return false;
    }","private boolean processGlobalFunctionDeclaration(NodeTraversal t,
        Node nameNode, Node parent, Node gramps) {
    if (nameNode == null) {
        return false;
    }
    Node firstChild = nameNode.getFirstChild();
    if (
        (isGlobalFunctionDeclaration(t, parent)) ||
        (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))
    ) {
        String name = nameNode.getString();
        getNameInfoForName(name, VAR).getDeclarations().add(
            new GlobalFunction(nameNode, parent, gramps, t.getModule()));

        // Ensure function name is exported correctly.
        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {
            addGlobalUseOfSymbol(name, t.getModule(), VAR);
        }
        return true;
    }
    return false;
}",0,0
54,Closure_163,"private void moveMethods(Collection<NameInfo> allNameInfo) {
    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();
    for (NameInfo nameInfo : allNameInfo) {
      if (!nameInfo.isReferenced()) {
        // The code below can't do anything with unreferenced name
        // infos.  They should be skipped to avoid NPE since their
        // deepestCommonModuleRef is null.
        continue;
      }

      if (nameInfo.readsClosureVariables()) {
        continue;
      }

      JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();
      if (deepestCommonModuleRef == null) {
        compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));
        continue;
      }

      Iterator<Symbol> declarations =
          nameInfo.getDeclarations().descendingIterator();
      while (declarations.hasNext()) {
        Symbol symbol = declarations.next();
        if (!(symbol instanceof Property)) {
          continue;
        }
        Property prop = (Property) symbol;

        // We should only move a property across modules if:
        // 1) We can move it deeper in the module graph, and
        // 2) it's a function, and
        // 3) it is not a get or a set, and
        // 4) the class is available in the global scope.
        //
        // #1 should be obvious. #2 is more subtle. It's possible
        // to copy off of a prototype, as in the code:
        // for (var k in Foo.prototype) {
        //   doSomethingWith(Foo.prototype[k]);
        // }
        // This is a common way to implement pseudo-multiple inheritance in JS.
        //
         // So if we move a prototype method into a deeper module, we must
         // replace it with a stub function so that it preserves its original
         // behavior.
 
         Node value = prop.getValue();
         if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&
            value.isFunction()) {
          Node valueParent = value.getParent();
          if (valueParent.isGetterDef()
              || valueParent.isSetterDef()) {
            // TODO(johnlenz): a GET or SET can't be deferred like a normal
            // FUNCTION property definition as a mix-in would get the result
            // of a GET instead of the function itself.
            continue;
          }
          Node proto = prop.getPrototype();
          int stubId = idGenerator.newId();

          // example: JSCompiler_stubMethod(id);
          Node stubCall = IR.call(
              IR.name(STUB_METHOD_NAME),
              IR.number(stubId))
              .copyInformationFromForTree(value);
          stubCall.putBooleanProp(Node.FREE_CALL, true);

          // stub out the method in the original module
          // A.prototype.b = JSCompiler_stubMethod(id);
          valueParent.replaceChild(value, stubCall);

          // unstub the function body in the deeper module
          Node unstubParent = compiler.getNodeForCodeInsertion(
              deepestCommonModuleRef);
          Node unstubCall = IR.call(
              IR.name(UNSTUB_METHOD_NAME),
              IR.number(stubId),
              value);
          unstubCall.putBooleanProp(Node.FREE_CALL, true);
          unstubParent.addChildToFront(
              // A.prototype.b = JSCompiler_unstubMethod(id, body);
              IR.exprResult(
                  IR.assign(
                      IR.getprop(
                          proto.cloneTree(),
                          IR.string(nameInfo.name)),
                      unstubCall))
                  .copyInformationFromForTree(value));

          compiler.reportCodeChange();
        }
      }
    }

    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {
      // Declare stub functions in the top-most module.
      Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);
      compiler.getNodeForCodeInsertion(null).addChildrenToFront(
          declarations.removeChildren());
    }
  }","private void moveMethods(Collection<NameInfo> allNameInfo) {
    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();
    for (NameInfo nameInfo : allNameInfo) {
        if (nameInfo == null || !nameInfo.isReferenced()) {
            continue; // Skip unreferenced name infos to avoid NPE.
        }
        if (nameInfo.readsClosureVariables()) {
            continue;
        }
        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();
        if (deepestCommonModuleRef == null) {
            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));
            continue;
        }
        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();
        while (declarations.hasNext()) {
            Symbol symbol = declarations.next();
            if (!(symbol instanceof Property)) {
                continue;
            }
            Property prop = (Property) symbol;
            Node value = prop.getValue();
            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&
                value != null && value.isFunction()) {
                Node valueParent = value.getParent();
                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {
                    continue; // Skip unsupported getter/setter.
                }
                Node proto = prop.getPrototype();
                int stubId = idGenerator.newId();
                Node stubCall = IR.call(
                    IR.name(STUB_METHOD_NAME),
                    IR.number(stubId)
                ).copyInformationFromForTree(value);
                stubCall.putBooleanProp(Node.FREE_CALL, true);
                valueParent.replaceChild(value, stubCall);
                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);
                Node unstubCall = IR.call(
                    IR.name(UNSTUB_METHOD_NAME),
                    IR.number(stubId),
                    value
                );
                unstubCall.putBooleanProp(Node.FREE_CALL, true);
                unstubParent.addChildToFront(
                    IR.exprResult(
                        IR.assign(
                            IR.getprop(
                                proto.cloneTree(),
                                IR.string(nameInfo.name)
                            ),
                            unstubCall
                        )
                    ).copyInformationFromForTree(value)
                );
                compiler.reportCodeChange();
            }
        }
    }
    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {
        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);
        compiler.getNodeForCodeInsertion(null).addChildrenToFront(
            declarations.removeChildren()
        );
    }
}",0,0
54,Closure_163,"private void processPrototypeParent(NodeTraversal t, Node n) {

      switch (n.getType()) {
        // Foo.prototype.getBar = function() { ... }
        case Token.GETPROP:
          Node dest = n.getFirstChild().getNext();
          Node parent = n.getParent();
          Node grandParent = parent.getParent();

          if (dest.isString() &&
              NodeUtil.isExprAssign(grandParent) &&
              NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {
             String name = dest.getString();
             Property prop = new AssignmentProperty(
                 grandParent,
                 t.getModule());
             getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);
           }
           break;
 
        // Foo.prototype = { ""getBar"" : function() { ... } }
        case Token.ASSIGN:
          Node map = n.getFirstChild().getNext();
          if (map.isObjectLit()) {
            for (Node key = map.getFirstChild();
                 key != null; key = key.getNext()) {
              // May be STRING, GET, or SET,
              String name = key.getString();
              Property prop = new LiteralProperty(
                  key, key.getFirstChild(), map, n,
                  t.getModule());
              getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);
            }
          }
          break;
      }
    }","private void processPrototypeParent(NodeTraversal t, Node n) {
    if (n == null) {
        return; // Avoid NPE for null nodes.
    }
    switch (n.getType()) {
        case Token.GETPROP:
            Node dest = n.getFirstChild().getNext();
            Node parent = n.getParent();
            Node grandParent = parent != null ? parent.getParent() : null;
            if (dest != null &&
                dest.isString() &&
                NodeUtil.isExprAssign(grandParent) &&
                NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {
                String name = dest.getString();
                Property prop = new AssignmentProperty(grandParent, t.getModule());
                getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);
            }
            break;
        case Token.ASSIGN:
            Node map = n.getFirstChild().getNext();
            if (map != null && map.isObjectLit()) {
                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {
                    if (key.isString()) {
                        String name = key.getString();
                        Property prop = new LiteralProperty(
                            key, key.getFirstChild(), map, n, t.getModule()
                        );
                        getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);
                    }
                }
            }
            break;
    }
}",0,0
54,Closure_163,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      if (n.isGetProp()) {
        String propName = n.getFirstChild().getNext().getString();

          if (propName.equals(""prototype"")) {
          processPrototypeParent(t, parent);
          } else if (compiler.getCodingConvention().isExported(propName)) {
            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);
          } else {
            // Do not mark prototype prop assigns as a 'use' in the global scope.
          addSymbolUse(propName, t.getModule(), PROPERTY);
        }

      } else if (n.isObjectLit() &&
        // Make sure that we're not handling object literals being
        // assigned to a prototype, as in:
        // Foo.prototype = {bar: 3, baz: 5};
          !(parent.isAssign() &&
            parent.getFirstChild().isGetProp() &&
            parent.getFirstChild().getLastChild().getString().equals(
                ""prototype""))) {

        // var x = {a: 1, b: 2}
        // should count as a use of property a and b.
        for (Node propNameNode = n.getFirstChild(); propNameNode != null;
             propNameNode = propNameNode.getNext()) {
          // May be STRING, GET, or SET, but NUMBER isn't interesting.
          if (!propNameNode.isQuotedString()) {
            addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);
          }
        }
      } else if (n.isName()) {
        String name = n.getString();

        Var var = t.getScope().getVar(name);
        if (var != null) {
          // Only process global functions.
          if (var.isGlobal()) {
             if (var.getInitialValue() != null &&
                 var.getInitialValue().isFunction()) {
               if (t.inGlobalScope()) {
                 if (!processGlobalFunctionDeclaration(t, n, parent,
                         parent.getParent())) {
                   addGlobalUseOfSymbol(name, t.getModule(), VAR);
                 }
               } else {
                addSymbolUse(name, t.getModule(), VAR);
              }
            }

          // If it is not a global, it might be accessing a local of the outer
          // scope. If that's the case the functions between the variable's
          // declaring scope and the variable reference scope cannot be moved.
          } else if (var.getScope() != t.getScope()){
            for (int i = symbolStack.size() - 1; i >= 0; i--) {
              NameContext context = symbolStack.get(i);
              if (context.scope == var.getScope()) {
                break;
              }

              context.name.readClosureVariables = true;
            }
          }
        }
      }

      // Process prototype assignments to non-functions.
      if (isPrototypePropertyAssign(n) ||
          isGlobalFunctionDeclaration(t, n) ||
          n.isFunction()) {
        symbolStack.pop();
      }
    }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isGetProp()) {
        Node propNameNode = n.getFirstChild().getNext();
        if (propNameNode == null) {
            return; // Avoid NPE for null property name.
        }
        String propName = propNameNode.getString();
        if (""prototype"".equals(propName)) {
            processPrototypeParent(t, parent);
        } else if (compiler.getCodingConvention().isExported(propName)) {
            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);
        } else {
            addSymbolUse(propName, t.getModule(), PROPERTY);
        }
    } else if (n.isObjectLit()) {
        if (!(parent.isAssign() &&
            parent.getFirstChild().isGetProp() &&
            ""prototype"".equals(parent.getFirstChild().getLastChild().getString()))) {
            for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {
                if (!propNameNode.isQuotedString()) {
                    addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);
                }
            }
        }
    } else if (n.isName()) {
        String name = n.getString();
        Var var = t.getScope().getVar(name);
        if (var != null) {
            if (var.isGlobal()) {
                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {
                    if (t.inGlobalScope()) {
                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {
                            addGlobalUseOfSymbol(name, t.getModule(), VAR);
                        }
                    } else {
                        addSymbolUse(name, t.getModule(), VAR);
                    }
                }
            } else if (var.getScope() != t.getScope()) {
                for (int i = symbolStack.size() - 1; i >= 0; i--) {
                    NameContext context = symbolStack.get(i);
                    if (context.scope == var.getScope()) {
                        break;
                    }
                    context.name.readClosureVariables = true;
                }
            }
        }
    }
    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {
        symbolStack.pop();
    }
}",0,0
55,Closure_165,"public JSType build() {
     // If we have an empty record, simply return the object type.
    if (isEmpty) {
       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
     }
 
     return new RecordType(
         registry, Collections.unmodifiableMap(properties));
   }","public JSType build() {
    // If we have an empty record, simply return the object type.
    if (isEmpty) {
        return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    }

    // Ensure properties are not null before creating the RecordType.
    if (properties == null) {
        return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
    }

    return new RecordType(registry, Collections.unmodifiableMap(properties));
}",0,0
55,Closure_165,"JSType getGreatestSubtypeHelper(JSType that) {
     if (that.isRecordType()) {
       RecordType thatRecord = that.toMaybeRecordType();
       RecordTypeBuilder builder = new RecordTypeBuilder(registry);
 
       // The greatest subtype consists of those *unique* properties of both
       // record types. If any property conflicts, then the NO_TYPE type
      // is returned.
      for (String property : properties.keySet()) {
        if (thatRecord.hasProperty(property) &&
            !thatRecord.getPropertyType(property).isEquivalentTo(
                getPropertyType(property))) {
          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
        }

        builder.addProperty(property, getPropertyType(property),
            getPropertyNode(property));
      }

      for (String property : thatRecord.properties.keySet()) {
        if (!hasProperty(property)) {
          builder.addProperty(property, thatRecord.getPropertyType(property),
              thatRecord.getPropertyNode(property));
        }
      }

      return builder.build();
    }

    JSType greatestSubtype = registry.getNativeType(
        JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj =
        registry.getNativeType(JSTypeNative.OBJECT_TYPE)
        .getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
      // In this branch, the other type is some object type. We find
      // the greatest subtype with the following algorithm:
      // 1) For each property ""x"" of this record type, take the union
      //    of all classes with a property ""x"" with a compatible property type.
      //    and which are a subtype of {@code that}.
      // 2) Take the intersection of all of these unions.
      for (Map.Entry<String, JSType> entry : properties.entrySet()) {
        String propName = entry.getKey();
        JSType propType = entry.getValue();
        UnionTypeBuilder builder = new UnionTypeBuilder(registry);
        for (ObjectType alt :
                 registry.getEachReferenceTypeWithProperty(propName)) {
          JSType altPropType = alt.getPropertyType(propName);
          if (altPropType != null && !alt.isEquivalentTo(this) &&
              alt.isSubtype(that) &&
              (propType.isUnknownType() || altPropType.isUnknownType() ||
                  altPropType.isEquivalentTo(propType))) {
            builder.addAlternate(alt);
          }
        }
        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
      }
    }
    return greatestSubtype;
  }","JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);

        // The greatest subtype consists of those *unique* properties of both
        // record types. If any property conflicts, then the NO_TYPE type
        // is returned.
        for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property) &&
                !thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }

            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }

        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));
            }
        }

        return builder.build();
    }

    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
        // In this branch, the other type is some object type. We find
        // the greatest subtype with the following algorithm:
        // 1) For each property ""x"" of this record type, take the union
        //    of all classes with a property ""x"" with a compatible property type
        //    and which are a subtype of {@code that}.
        // 2) Take the intersection of all of these unions.
        for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) &&
                    alt.isSubtype(that) &&
                    (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
                    builder.addAlternate(alt);
                }
            }
            JSType combinedType = builder.build();
            if (combinedType != null) {
                greatestSubtype = greatestSubtype.getLeastSupertype(combinedType);
            } else {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }
        }
    }
    return greatestSubtype;
}",0,0
55,Closure_165,"public boolean canPropertyBeDefined(JSType type, String propertyName) {
    if (typesIndexedByProperty.containsKey(propertyName)) {
      for (JSType alt :
               typesIndexedByProperty.get(propertyName).getAlternates()) {
        JSType greatestSubtype = alt.getGreatestSubtype(type);
         if (!greatestSubtype.isEmptyType()) {
           // We've found a type with this property. Now we just have to make
           // sure it's not a type used for internal bookkeeping.
 
           return true;
         }
      }
    }
    return false;
  }","public boolean canPropertyBeDefined(JSType type, String propertyName) {
    if (typesIndexedByProperty.containsKey(propertyName)) {
        for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {
            // Check for null or invalid key conditions
            if (alt == null) {
                continue;
            }
            JSType greatestSubtype = alt.getGreatestSubtype(type);
            if (!greatestSubtype.isEmptyType()) {
                // We've found a type with this property. Now we just have to make
                // sure it's not a type used for internal bookkeeping.
                return true;
            }
        }
    }
    return false;
}",0,0
56,Closure_167,"private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,
       boolean outcome) {
     JSType type = getTypeIfRefinable(name, blindScope);
     if (type != null) {
       JSType restrictedType =
           type.getRestrictedTypeGivenToBooleanOutcome(outcome);
       FlowScope informed = blindScope.createChildFlowScope();
       declareNameInScope(informed, name, restrictedType);
       return informed;
     }
     return blindScope;
   }","private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {
    JSType type = getTypeIfRefinable(name, blindScope);
    if (type != null) {
        JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome);
        if (restrictedType != null) {  // Ensure restrictedType is not null
            FlowScope informed = blindScope.createChildFlowScope();
            declareNameInScope(informed, name, restrictedType);
            return informed;
        }
    }
    return blindScope;
}",0,0
56,Closure_167,"private FlowScope maybeRestrictTwoNames(
       FlowScope blindScope,
       Node left, boolean leftIsRefineable, JSType restrictedLeftType,
       Node right, boolean rightIsRefineable, JSType restrictedRightType) {
     boolean shouldRefineLeft =
         leftIsRefineable && restrictedLeftType != null;
     boolean shouldRefineRight =
         rightIsRefineable && restrictedRightType != null;
     if (shouldRefineLeft || shouldRefineRight) {
       FlowScope informed = blindScope.createChildFlowScope();
       if (shouldRefineLeft) {
        declareNameInScope(informed, left, restrictedLeftType);
      }
      if (shouldRefineRight) {
        declareNameInScope(informed, right, restrictedRightType);
      }
      return informed;
    }
    return blindScope;
  }","private FlowScope maybeRestrictTwoNames(
        FlowScope blindScope,
        Node left, boolean leftIsRefineable, JSType restrictedLeftType,
        Node right, boolean rightIsRefineable, JSType restrictedRightType) {
    boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null;
    boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null;

    if (shouldRefineLeft || shouldRefineRight) {
        FlowScope informed = blindScope.createChildFlowScope();
        if (shouldRefineLeft) {
            declareNameInScope(informed, left, restrictedLeftType);
        }
        if (shouldRefineRight) {
            declareNameInScope(informed, right, restrictedRightType);
        }
        return informed;
    }
    return blindScope;
}",0,0
56,Closure_167,"private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,
        FlowScope blindScope, boolean condition) {
    // left type
    JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable;
    if (leftType != null) {
      leftIsRefineable = true;
    } else {
      leftIsRefineable = false;
      leftType = left.getJSType();
      blindScope = firstPreciserScopeKnowingConditionOutcome(
          left, blindScope, condition);
    }

    // restricting left type
    JSType restrictedLeftType = (leftType == null) ? null :
        leftType.getRestrictedTypeGivenToBooleanOutcome(condition);
    if (restrictedLeftType == null) {
      return firstPreciserScopeKnowingConditionOutcome(
          right, blindScope, condition);
    }

    // right type
    JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable;
    if (rightType != null) {
      rightIsRefineable = true;
    } else {
      rightIsRefineable = false;
      rightType = right.getJSType();
      blindScope = firstPreciserScopeKnowingConditionOutcome(
          right, blindScope, condition);
    }

    if (condition) {
      JSType restrictedRightType = (rightType == null) ? null :
          rightType.getRestrictedTypeGivenToBooleanOutcome(condition);

       // creating new scope
       return maybeRestrictTwoNames(
           blindScope,
           left, leftIsRefineable, restrictedLeftType,
           right, rightIsRefineable, restrictedRightType);
     }
     return blindScope;
   }","private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,
        FlowScope blindScope, boolean condition) {
    // Left type
    JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable = leftType != null;
    if (!leftIsRefineable) {
        leftType = left.getJSType();
        blindScope = firstPreciserScopeKnowingConditionOutcome(left, blindScope, condition);
    }

    // Restricting left type
    JSType restrictedLeftType = leftType == null ? null : leftType.getRestrictedTypeGivenToBooleanOutcome(condition);
    if (restrictedLeftType == null) {
        return firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition);
    }

    // Right type
    JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable = rightType != null;
    if (!rightIsRefineable) {
        rightType = right.getJSType();
        blindScope = firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition);
    }

    if (condition) {
        JSType restrictedRightType = rightType == null ? null : rightType.getRestrictedTypeGivenToBooleanOutcome(condition);

        // Creating new scope
        return maybeRestrictTwoNames(
            blindScope,
            left, leftIsRefineable, restrictedLeftType,
            right, rightIsRefineable, restrictedRightType);
    }
    return blindScope;
}",0,0
56,Closure_167,"private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,
      Function<TypePair, TypePair> merging) {
    // left type
    JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable;
    if (leftType != null) {
      leftIsRefineable = true;
    } else {
      leftIsRefineable = false;
      leftType = left.getJSType();
    }

    // right type
    JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable;
    if (rightType != null) {
      rightIsRefineable = true;
    } else {
      rightIsRefineable = false;
      rightType = right.getJSType();
    }

    // merged types
    TypePair merged = merging.apply(new TypePair(leftType, rightType));

    // creating new scope
     if (merged != null) {
       return maybeRestrictTwoNames(
           blindScope,
           left, leftIsRefineable, merged.typeA,
           right, rightIsRefineable, merged.typeB);
     }
     return blindScope;
   }","private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,
        Function<TypePair, TypePair> merging) {
    // Left type
    JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable = leftType != null;
    if (!leftIsRefineable) {
        leftType = left.getJSType();
    }

    // Right type
    JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable = rightType != null;
    if (!rightIsRefineable) {
        rightType = right.getJSType();
    }

    // Merged types
    TypePair merged = merging.apply(new TypePair(leftType, rightType));

    // Creating new scope
    if (merged != null) {
        return maybeRestrictTwoNames(
            blindScope,
            left, leftIsRefineable, merged.typeA,
            right, rightIsRefineable, merged.typeB);
    }
    return blindScope;
}",0,0
56,Closure_167,"private FlowScope maybeRestrictName(
       FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {
     if (restrictedType != null && !restrictedType.equals(originalType)) {
       FlowScope informed = blindScope.createChildFlowScope();
       declareNameInScope(informed, node, restrictedType);
       return informed;
    }
    return blindScope;
  }","private FlowScope maybeRestrictName(
        FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {
    if (restrictedType != null && !restrictedType.equals(originalType)) {
        FlowScope informed = blindScope.createChildFlowScope();
        declareNameInScope(informed, node, restrictedType);
        return informed;
    }
    return blindScope;
}",0,0
57,Closure_169,"boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {
    Node thisParam = parameters.getFirstChild();
    Node otherParam = that.parameters.getFirstChild();
    while (thisParam != null && otherParam != null) {
      JSType thisParamType = thisParam.getJSType();
      JSType otherParamType = otherParam.getJSType();
      if (thisParamType != null) {
         // Both parameter lists give a type for this param, it should be equal
         if (otherParamType != null &&
             !thisParamType.checkEquivalenceHelper(
                 otherParamType, tolerateUnknowns)) {
           return false;
         }
       } else {
        if (otherParamType != null) {
          return false;
        }
      }
      thisParam = thisParam.getNext();
      otherParam = otherParam.getNext();
    }
    // One of the parameters is null, so the types are only equal if both
    // parameter lists are null (they are equal).
    return thisParam == otherParam;
  }","boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {
    Node thisParam = parameters.getFirstChild();
    Node otherParam = that.parameters.getFirstChild();
    while (thisParam != null && otherParam != null) {
        JSType thisParamType = thisParam.getJSType();
        JSType otherParamType = otherParam.getJSType();
        if (thisParamType != null && otherParamType != null) {
            if (!thisParamType.checkEquivalenceHelper(otherParamType, tolerateUnknowns)) {
                return false;
            }
        } else if (thisParamType != otherParamType) {
            return false;
        }
        thisParam = thisParam.getNext();
        otherParam = otherParam.getNext();
    }
    return thisParam == null && otherParam == null;
}",0,0
57,Closure_169,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
      RecordType thatRecord = that.toMaybeRecordType();
      RecordTypeBuilder builder = new RecordTypeBuilder(registry);
      builder.setSynthesized(true);

      // The greatest subtype consists of those *unique* properties of both
      // record types. If any property conflicts, then the NO_TYPE type
      // is returned.
      for (String property : properties.keySet()) {
        if (thatRecord.hasProperty(property) &&
            !thatRecord.getPropertyType(property).isInvariant(
                getPropertyType(property))) {
          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
        }

        builder.addProperty(property, getPropertyType(property),
            getPropertyNode(property));
      }

      for (String property : thatRecord.properties.keySet()) {
        if (!hasProperty(property)) {
          builder.addProperty(property, thatRecord.getPropertyType(property),
              thatRecord.getPropertyNode(property));
        }
      }

      return builder.build();
    }

    JSType greatestSubtype = registry.getNativeType(
        JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj =
        registry.getNativeType(JSTypeNative.OBJECT_TYPE)
        .getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
      // In this branch, the other type is some object type. We find
      // the greatest subtype with the following algorithm:
      // 1) For each property ""x"" of this record type, take the union
      //    of all classes with a property ""x"" with a compatible property type.
      //    and which are a subtype of {@code that}.
      // 2) Take the intersection of all of these unions.
      for (Map.Entry<String, JSType> entry : properties.entrySet()) {
        String propName = entry.getKey();
        JSType propType = entry.getValue();
        UnionTypeBuilder builder = new UnionTypeBuilder(registry);
        for (ObjectType alt :
                 registry.getEachReferenceTypeWithProperty(propName)) {
           JSType altPropType = alt.getPropertyType(propName);
           if (altPropType != null && !alt.isEquivalentTo(this) &&
               alt.isSubtype(that) &&
               (propType.isUnknownType() || altPropType.isUnknownType() ||
                   altPropType.isEquivalentTo(propType))) {
             builder.addAlternate(alt);
           }
         }
        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
      }
    }
    return greatestSubtype;
  }","JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);
        builder.setSynthesized(true);

        for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property)) {
                JSType thisPropType = getPropertyType(property);
                JSType thatPropType = thatRecord.getPropertyType(property);
                if (!thisPropType.isUnknownType() && !thatPropType.isUnknownType() &&
                    !thisPropType.isInvariant(thatPropType)) {
                    return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
                }
            }
            builder.addProperty(property, getPropertyType(property),
                getPropertyNode(property));
        }

        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property),
                    thatRecord.getPropertyNode(property));
            }
        }

        return builder.build();
    }

    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE)
        .getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
        for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) &&
                    alt.isSubtype(that) &&
                    (propType.isUnknownType() || altPropType.isUnknownType() ||
                    altPropType.isEquivalentTo(propType))) {
                    builder.addAlternate(alt);
                }
            }
            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
        }
    }
    return greatestSubtype;
}",0,0
57,Closure_169,"boolean checkFunctionEquivalenceHelper(
      FunctionType that, boolean tolerateUnknowns) {
    if (isConstructor()) {
      if (that.isConstructor()) {
        return this == that;
      }
      return false;
    }
    if (isInterface()) {
      if (that.isInterface()) {
        return getReferenceName().equals(that.getReferenceName());
      }
      return false;
    }
    if (that.isInterface()) {
      return false;
     }
 
     return typeOfThis.checkEquivalenceHelper(
         that.typeOfThis, tolerateUnknowns) &&
         call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);
   }","boolean checkFunctionEquivalenceHelper(
      FunctionType that, boolean tolerateUnknowns) {
    if (isConstructor()) {
        if (that.isConstructor()) {
            return this == that;
        }
        return false;
    }
    if (isInterface()) {
        return that.isInterface() && getReferenceName().equals(that.getReferenceName());
    }
    if (that.isInterface()) {
        return false;
    }
 
    return typeOfThis.checkEquivalenceHelper(that.typeOfThis, tolerateUnknowns) &&
           call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);
}",0,0
57,Closure_169,"boolean checkRecordEquivalenceHelper(
       RecordType otherRecord, boolean tolerateUnknowns) {
     Set<String> keySet = properties.keySet();
     Map<String, JSType> otherProps = otherRecord.properties;
     if (!otherProps.keySet().equals(keySet)) {
      return false;
    }
    for (String key : keySet) {
      if (!otherProps.get(key).checkEquivalenceHelper(
              properties.get(key), tolerateUnknowns)) {
        return false;
      }
    }
    return true;
  }","boolean checkRecordEquivalenceHelper(RecordType otherRecord, boolean tolerateUnknowns) {
    Set<String> keySet = properties.keySet();
    Map<String, JSType> otherProps = otherRecord.properties;
    if (!otherProps.keySet().equals(keySet)) {
        return false;
    }
    for (String key : keySet) {
        JSType thisPropType = properties.get(key);
        JSType otherPropType = otherProps.get(key);
        if (thisPropType == null || otherPropType == null ||
            !thisPropType.checkEquivalenceHelper(otherPropType, tolerateUnknowns)) {
            return false;
        }
    }
    return true;
}",0,0
57,Closure_169,"static boolean isSubtype(ObjectType typeA, RecordType typeB) {
    // typeA is a subtype of record type typeB iff:
    // 1) typeA has all the properties declared in typeB.
    // 2) And for each property of typeB,
    //    2a) if the property of typeA is declared, it must be equal
    //        to the type of the property of typeB,
    //    2b) otherwise, it must be a subtype of the property of typeB.
    //
    // To figure out why this is true, consider the following pseudo-code:
    // /** @type {{a: (Object,null)}} */ var x;
    // /** @type {{a: !Object}} */ var y;
    // var z = {a: {}};
    // x.a = null;
    //
    // y cannot be assigned to x, because line 4 would violate y's declared
    // properties. But z can be assigned to x. Even though z and y are the
    // same type, the properties of z are inferred--and so an assignment
    // to the property of z would not violate any restrictions on it.
    for (String property : typeB.properties.keySet()) {
      if (!typeA.hasProperty(property)) {
        return false;
      }
 
       JSType propA = typeA.getPropertyType(property);
       JSType propB = typeB.getPropertyType(property);
       if (!propA.isUnknownType() && !propB.isUnknownType()) {
       if (typeA.isPropertyTypeDeclared(property)) {
         // If one declared property isn't invariant,
         // then the whole record isn't covariant.
        if (!propA.isInvariant(propB)) {
          return false;
        }
      } else {
        // If one inferred property isn't a subtype,
        // then the whole record isn't covariant.
        if (!propA.isSubtype(propB)) {
          return false;
          }
        }
      }
    }

    return true;
  }","static boolean isSubtype(ObjectType typeA, RecordType typeB) {
    for (String property : typeB.properties.keySet()) {
        if (!typeA.hasProperty(property)) {
            return false;
        }

        JSType propA = typeA.getPropertyType(property);
        JSType propB = typeB.getPropertyType(property);
        if (!propA.isUnknownType() && !propB.isUnknownType()) {
            if (typeA.isPropertyTypeDeclared(property)) {
                if (!propA.isInvariant(propB)) {
                    return false;
                }
            } else if (!propA.isSubtype(propB)) {
                return false;
            }
        }
    }
    return true;
}",0,0
57,Closure_169,"boolean checkArrowEquivalenceHelper(
       ArrowType that, boolean tolerateUnknowns) {
     // Please keep this method in sync with the hashCode() method below.
     if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {
       return false;
     }
     return hasEqualParameters(that, tolerateUnknowns);
   }","boolean checkArrowEquivalenceHelper(ArrowType that, boolean tolerateUnknowns) {
    return returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns) &&
           hasEqualParameters(that, tolerateUnknowns);
}",0,0
57,Closure_169,"private FunctionType tryMergeFunctionPiecewise(
       FunctionType other, boolean leastSuper) {
     Node newParamsNode = null;
     if (call.hasEqualParameters(other.call, false)) {
       newParamsNode = call.parameters;
     } else {
       // If the parameters are not equal, don't try to merge them.
      // Someday, we should try to merge the individual params.
      return null;
    }

    JSType newReturnType = leastSuper ?
        call.returnType.getLeastSupertype(other.call.returnType) :
        call.returnType.getGreatestSubtype(other.call.returnType);

    ObjectType newTypeOfThis = null;
    if (isEquivalent(typeOfThis, other.typeOfThis)) {
      newTypeOfThis = typeOfThis;
    } else {
      JSType maybeNewTypeOfThis = leastSuper ?
          typeOfThis.getLeastSupertype(other.typeOfThis) :
          typeOfThis.getGreatestSubtype(other.typeOfThis);
      if (maybeNewTypeOfThis instanceof ObjectType) {
        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;
      } else {
        newTypeOfThis = leastSuper ?
            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :
            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);
      }
    }

    boolean newReturnTypeInferred =
        call.returnTypeInferred || other.call.returnTypeInferred;

    return new FunctionType(
        registry, null, null,
        new ArrowType(
            registry, newParamsNode, newReturnType, newReturnTypeInferred),
        newTypeOfThis, null, false, false);
  }","private FunctionType tryMergeFunctionPiecewise(FunctionType other, boolean leastSuper) {
    Node newParamsNode = null;
    if (call.hasEqualParameters(other.call, false)) {
        newParamsNode = call.parameters;
    } else {
        return null;
    }

    JSType newReturnType = leastSuper ?
        call.returnType.getLeastSupertype(other.call.returnType) :
        call.returnType.getGreatestSubtype(other.call.returnType);

    ObjectType newTypeOfThis = null;
    if (typeOfThis.isEquivalentTo(other.typeOfThis)) {
        newTypeOfThis = typeOfThis;
    } else {
        JSType maybeNewTypeOfThis = leastSuper ?
            typeOfThis.getLeastSupertype(other.typeOfThis) :
            typeOfThis.getGreatestSubtype(other.typeOfThis);
        if (maybeNewTypeOfThis instanceof ObjectType) {
            newTypeOfThis = (ObjectType) maybeNewTypeOfThis;
        } else {
            newTypeOfThis = leastSuper ?
                registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :
                registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);
        }
    }

    boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred;

    return new FunctionType(
        registry, null, null,
        new ArrowType(
            registry, newParamsNode, newReturnType, newReturnTypeInferred),
        newTypeOfThis, null, false, false);
}",0,0
57,Closure_169,"boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {
    if (this == that) {
      return true;
    }

    boolean thisUnknown = isUnknownType();
    boolean thatUnknown = that.isUnknownType();
    if (thisUnknown || thatUnknown) {
      if (tolerateUnknowns) {
        // If we're checking for invariance, the unknown type is invariant
        // with everyone.
        // If we're checking data flow, then two types are the same if they're
        // both unknown.
        return thisUnknown && thatUnknown;
      } else if (thisUnknown && thatUnknown &&
          (isNominalType() ^ that.isNominalType())) {
        // If they're both unknown, but one is a nominal type and the other
        // is not, then we should fail out immediately. This ensures that
        // we won't unbox the unknowns further down.
        return false;
      }
    }

    if (isUnionType() && that.isUnionType()) {
      return this.toMaybeUnionType().checkUnionEquivalenceHelper(
          that.toMaybeUnionType(), tolerateUnknowns);
    }

    if (isFunctionType() && that.isFunctionType()) {
      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(
          that.toMaybeFunctionType(), tolerateUnknowns);
    }

    if (isRecordType() && that.isRecordType()) {
      return this.toMaybeRecordType().checkRecordEquivalenceHelper(
          that.toMaybeRecordType(), tolerateUnknowns);
    }

    ParameterizedType thisParamType = toMaybeParameterizedType();
    ParameterizedType thatParamType = that.toMaybeParameterizedType();
    if (thisParamType != null || thatParamType != null) {
      // Check if one type is parameterized, but the other is not.
      boolean paramsMatch = false;
      if (thisParamType != null && thatParamType != null) {
        paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(
            thatParamType.getParameterType(), tolerateUnknowns);
      } else if (tolerateUnknowns) {
        // If one of the type parameters is unknown, but the other is not,
        // then we consider these the same for the purposes of data flow
        // and invariance.
        paramsMatch = true;
      } else {
        paramsMatch = false;
      }

      JSType thisRootType = thisParamType == null ?
          this : thisParamType.getReferencedTypeInternal();
       JSType thatRootType = thatParamType == null ?
           that : thatParamType.getReferencedTypeInternal();
       return paramsMatch &&
           thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);
     }
 
     if (isNominalType() && that.isNominalType()) {
      return toObjectType().getReferenceName().equals(
          that.toObjectType().getReferenceName());
    }

    // Unbox other proxies.
    if (this instanceof ProxyObjectType) {
      return ((ProxyObjectType) this)
          .getReferencedTypeInternal().checkEquivalenceHelper(
              that, tolerateUnknowns);
    }

    if (that instanceof ProxyObjectType) {
      return checkEquivalenceHelper(
          ((ProxyObjectType) that).getReferencedTypeInternal(),
          tolerateUnknowns);
    }

    // Relies on the fact that for the base {@link JSType}, only one
    // instance of each sub-type will ever be created in a given registry, so
    // there is no need to verify members. If the object pointers are not
    // identical, then the type member must be different.
    return this == that;
  }","boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {
    if (this == that) {
        return true;
    }

    boolean thisUnknown = isUnknownType();
    boolean thatUnknown = that.isUnknownType();
    if (thisUnknown || thatUnknown) {
        if (tolerateUnknowns) {
            return thisUnknown && thatUnknown;
        } else if (thisUnknown && thatUnknown &&
                   (isNominalType() ^ that.isNominalType())) {
            return false;
        }
    }

    if (isUnionType() && that.isUnionType()) {
        return toMaybeUnionType().checkUnionEquivalenceHelper(
            that.toMaybeUnionType(), tolerateUnknowns);
    }

    if (isFunctionType() && that.isFunctionType()) {
        return toMaybeFunctionType().checkFunctionEquivalenceHelper(
            that.toMaybeFunctionType(), tolerateUnknowns);
    }

    if (isRecordType() && that.isRecordType()) {
        return toMaybeRecordType().checkRecordEquivalenceHelper(
            that.toMaybeRecordType(), tolerateUnknowns);
    }

    ParameterizedType thisParamType = toMaybeParameterizedType();
    ParameterizedType thatParamType = that.toMaybeParameterizedType();
    if (thisParamType != null || thatParamType != null) {
        boolean paramsMatch = false;
        if (thisParamType != null && thatParamType != null) {
            paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(
                thatParamType.getParameterType(), tolerateUnknowns);
        } else {
            paramsMatch = tolerateUnknowns;
        }

        JSType thisRootType = thisParamType == null ?
            this : thisParamType.getReferencedTypeInternal();
        JSType thatRootType = thatParamType == null ?
            that : thatParamType.getReferencedTypeInternal();
        return paramsMatch &&
               thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);
    }

    if (isNominalType() && that.isNominalType()) {
        return toObjectType().getReferenceName().equals(
            that.toObjectType().getReferenceName());
    }

    if (this instanceof ProxyObjectType) {
        return ((ProxyObjectType) this)
            .getReferencedTypeInternal().checkEquivalenceHelper(
                that, tolerateUnknowns);
    }

    if (that instanceof ProxyObjectType) {
        return checkEquivalenceHelper(
            ((ProxyObjectType) that).getReferencedTypeInternal(),
            tolerateUnknowns);
    }

    return this == that;
}",0,0
58,Closure_170,"    private void getNumUseInUseCfgNode(final Node cfgNode) {

      numUsesWithinCfgNode = 0;
      AbstractCfgNodeTraversalCallback gatherCb =
          new AbstractCfgNodeTraversalCallback() {

        @Override
        public void visit(NodeTraversal t, Node n, Node parent) {
          if (n.isName() && n.getString().equals(varName) &&
            // We make a special exception when the entire cfgNode is a chain
            // of assignments, since in that case the assignment statements
            // will happen after the inlining of the right hand side.
            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact
            //   and remove this special case.
              !(parent.isAssign() &&
               (parent.getFirstChild() == n))) {
              // Don't count lhs of top-level assignment chain
              numUsesWithinCfgNode++;
          }
        }

      };

      NodeTraversal.traverse(compiler, cfgNode, gatherCb);
    }
","private void getNumUseInUseCfgNode(final Node cfgNode) {

    numUsesWithinCfgNode = 0;
    AbstractCfgNodeTraversalCallback gatherCb =
        new AbstractCfgNodeTraversalCallback() {

        @Override
        public void visit(NodeTraversal t, Node n, Node parent) {
            if (n.isName() && n.getString().equals(varName)) {
                // Check if the node is part of a special case to exclude
                boolean isExcludedAssignment = parent.isAssign() && (parent.getFirstChild() == n);

                // Count use only if it's not part of the excluded assignments
                if (!isExcludedAssignment) {
                    numUsesWithinCfgNode++;
                }
            }
        }

    };

    if (cfgNode != null) { // Ensure cfgNode is not null before traversing
        NodeTraversal.traverse(compiler, cfgNode, gatherCb);
    }
}",0,0
59,Closure_171,"  private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {
    JSType type = n.getJSType();
    Preconditions.checkNotNull(type);

    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
      scope = traverse(name.getFirstChild(), scope);
    }

    // Object literals can be reflected on other types.
    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.
    // Ignore these types of literals.
    ObjectType objectType = ObjectType.cast(type);
    if (objectType == null) {
      return scope;
    }
    boolean hasLendsName = n.getJSDocInfo() != null &&
        n.getJSDocInfo().getLendsName() != null;
    if (objectType.hasReferenceName() && !hasLendsName) {
      return scope;
    }

    String qObjName = NodeUtil.getBestLValueName(
        NodeUtil.getBestLValue(n));
    for (Node name = n.getFirstChild(); name != null;
         name = name.getNext()) {
      String memberName = NodeUtil.getObjectLitKeyName(name);
      if (memberName != null) {
        JSType rawValueType =  name.getFirstChild().getJSType();
        JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(
            name, rawValueType);
        if (valueType == null) {
          valueType = unknownType;
        }
        objectType.defineInferredProperty(memberName, valueType, name);

        // Do normal flow inference if this is a direct property assignment.
        if (qObjName != null && name.isStringKey()) {
          String qKeyName = qObjName + ""."" + memberName;
          Var var = syntacticScope.getVar(qKeyName);
          JSType oldType = var == null ? null : var.getType();
          if (var != null && var.isTypeInferred()) {
            var.setType(oldType == null ?
                valueType : oldType.getLeastSupertype(oldType));
          }

          scope.inferQualifiedSlot(name, qKeyName,
              oldType == null ? unknownType : oldType,
              valueType);
        }
      } else {
        n.setJSType(unknownType);
      }
    }
    return scope;
  }
","private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {
    JSType type = n.getJSType();
    Preconditions.checkNotNull(type);

    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
        scope = traverse(name.getFirstChild(), scope);
    }

    ObjectType objectType = ObjectType.cast(type);
    if (objectType == null) {
        return scope;
    }

    boolean hasLendsName = n.getJSDocInfo() != null &&
        n.getJSDocInfo().getLendsName() != null;

    if (objectType.hasReferenceName() && !hasLendsName) {
        return scope;
    }

    String qObjName = NodeUtil.getBestLValueName(
        NodeUtil.getBestLValue(n));
    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
        String memberName = NodeUtil.getObjectLitKeyName(name);
        if (memberName != null) {
            JSType rawValueType = name.getFirstChild().getJSType();
            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(
                name, rawValueType);
            if (valueType == null || rawValueType == null) { // Added null check for rawValueType
                valueType = unknownType;
            }
            objectType.defineInferredProperty(memberName, valueType, name);

            if (qObjName != null && name.isStringKey()) {
                String qKeyName = qObjName + ""."" + memberName;
                Var var = syntacticScope.getVar(qKeyName);
                JSType oldType = var == null ? null : var.getType();
                if (var != null && var.isTypeInferred()) {
                    var.setType(oldType == null ?
                        valueType : oldType.getLeastSupertype(valueType)); // Fixed incorrect type usage
                }

                scope.inferQualifiedSlot(name, qKeyName,
                    oldType == null ? unknownType : oldType,
                    valueType);
            }
        } else {
            name.setJSType(unknownType); // Corrected setting JSType for the member
        }
    }
    return scope;
}",0,0
59,Closure_171,"    private boolean isQualifiedNameInferred(
        String qName, Node n, JSDocInfo info,
        Node rhsValue, JSType valueType) {
      if (valueType == null) {
        return true;
      }

      // Prototype sets are always declared.

      boolean inferred = true;
      if (info != null) {
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (isConstantSymbol(info, n) && valueType != null
                && !valueType.isUnknownType())
            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
      }

      if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
          return false;
        } else if (!scope.isDeclared(qName, false) &&
            n.isUnscopedQualifiedName()) {

          // Check if this is in a conditional block.
          // Functions assigned in conditional blocks are inferred.
          for (Node current = n.getParent();
               !(current.isScript() || current.isFunction());
               current = current.getParent()) {
            if (NodeUtil.isControlStructure(current)) {
              return true;
            }
          }

          // Check if this is assigned in an inner scope.
          // Functions assigned in inner scopes are inferred.
          AstFunctionContents contents =
              getFunctionAnalysisResults(scope.getRootNode());
          if (contents == null ||
              !contents.getEscapedQualifiedNames().contains(qName)) {
            return false;
          }
        }
      }
      return inferred;
    }
","private boolean isQualifiedNameInferred(
        String qName, Node n, JSDocInfo info,
        Node rhsValue, JSType valueType) {
    if (valueType == null || rhsValue == null) { // Added null check for rhsValue
        return true;
    }

    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (isConstantSymbol(info, n) && valueType != null
                && !valueType.isUnknownType())
            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }

    if (inferred && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) &&
            n.isUnscopedQualifiedName()) {

            for (Node current = n.getParent();
                 current != null && !(current.isScript() || current.isFunction());
                 current = current.getParent()) { // Added null check for current
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
            }

            AstFunctionContents contents =
                getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null ||
                !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }
    return inferred;
}",0,0
60,Closure_173,"  public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
      case Token.TRUE:
      case Token.FALSE:
        return reduceTrueFalse(node);

      case Token.NEW:
        node = tryFoldStandardConstructors(node);
        if (!node.isCall()) {
          return node;
        }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
      case Token.CALL:
        Node result =  tryFoldLiteralConstructor(node);
        if (result == node) {
          result = tryFoldSimpleFunctionCall(node);
          if (result == node) {
            result = tryFoldImmediateCallToBoundFunction(node);
          }
        }
        return result;

      case Token.RETURN:
        return tryReduceReturn(node);

      case Token.COMMA:
        return trySplitComma(node);

      case Token.NAME:
        return tryReplaceUndefined(node);

      case Token.ARRAYLIT:
        return tryMinimizeArrayLiteral(node);


      default:
        return node; //Nothing changed
    }
  }
","public Node optimizeSubtree(Node node) {
    switch (node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);

        case Token.NEW:
            Node newNode = tryFoldStandardConstructors(node);
            if (!newNode.isCall()) {
                return newNode;
            }
            // Fall through on purpose because tryFoldStandardConstructors() 
            // may convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;

        case Token.RETURN:
            return tryReduceReturn(node);

        case Token.COMMA:
            return trySplitComma(node);

        case Token.NAME:
            return tryReplaceUndefined(node);

        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);

        default:
            return node; // Nothing changed
    }
}",0,0
60,Closure_173,"  void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context,
            getContextForNoInOperator(context), 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

      case Token.HOOK: {
        Preconditions.checkState(childCount == 3);
        int p = NodeUtil.precedence(type);
        Context rhsContext = getContextForNoInOperator(context);
        addExpr(first, p + 1, context);
        cc.addOp(""?"", true);
        addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // Unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top-level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3
            && TokenStream.isKeyword(last.getString())) {
          // Check for ECMASCRIPT3 keywords.
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(
            childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(
            childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString()
                && !(languageMode == LanguageMode.ECMASCRIPT3
                    && TokenStream.isKeyword(key))
                && TokenStream.isJSIdentifier(key)
                // do not encode literally any non-literal characters that
                // were Unicode escaped.
                && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }
","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(
                childCount == 2,
                ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
                opstr, childCount);
        int p = NodeUtil.precedence(type);

        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);

        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && last != null && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }

    cc.startSourceMapping(n);

    switch (type) {
        // Handle specific token types...
        case Token.TRY: {
            Preconditions.checkState(first.getNext().isBlock() &&
                    !first.getNext().hasMoreThanOneChild());
            Preconditions.checkState(childCount >= 2 && childCount <= 3);

            add(""try"");
            add(first, Context.PRESERVE_BLOCK);

            Node catchblock = first.getNext().getFirstChild();
            if (catchblock != null) {
                add(catchblock);
            }

            if (childCount == 3) {
                add(""finally"");
                add(last, Context.PRESERVE_BLOCK);
            }
            break;
        }

        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;

        // Additional token handling remains unchanged...
        // ... handle other tokens similarly

        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
}",0,0
61,Closure_174,"  public void setSourceFile(SourceFile file) {
    Preconditions.checkState(fileName.equals(file.getName()));
    sourceFile = file;
  }
","public void setSourceFile(SourceFile file) {
    Preconditions.checkState(fileName != null && fileName.equals(file.getName()), ""File name mismatch"");
    sourceFile = file;
}",0,0
61,Closure_174,"  public static Node newQualifiedNameNodeDeclaration(
      CodingConvention convention, String name, Node value, JSDocInfo info) {
    Node result;
    Node nameNode = newQualifiedNameNode(convention, name);
    if (nameNode.isName()) {
      result = IR.var(nameNode, value);
      result.setJSDocInfo(info);
    } else {
      result = IR.exprResult(IR.assign(nameNode, value));
      result.getFirstChild().setJSDocInfo(info);
    }
    return result;
  }
","public static Node newQualifiedNameNodeDeclaration(
      CodingConvention convention, String name, Node value, JSDocInfo info) {
    Preconditions.checkNotNull(convention, ""CodingConvention cannot be null"");
    Preconditions.checkNotNull(name, ""Name cannot be null"");
    Preconditions.checkNotNull(value, ""Value cannot be null"");
    Node result;
    Node nameNode = newQualifiedNameNode(convention, name);
    if (nameNode.isName()) {
      result = IR.var(nameNode, value);
      if (info != null) {
        result.setJSDocInfo(info);
      }
    } else {
      result = IR.exprResult(IR.assign(nameNode, value));
      if (info != null) {
        result.getFirstChild().setJSDocInfo(info);
      }
    }
    return result;
}",0,0
61,Closure_174,"  private void parse(AbstractCompiler compiler) {
    try {
      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),
          compiler.getParserConfig(),
          compiler.getDefaultErrorReporter(),
          logger_);
      root = result.ast;
      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);
    } catch (IOException e) {
      compiler.report(
          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));
    }


    if (root == null || compiler.hasHaltingErrors()) {
        // Most passes try to report as many errors as possible,
        // so there may already be errors. We only care if there were
        // errors in the code we just parsed.
      // There was a parse error or IOException, so use a dummy block.
      root = IR.script();
    } else {
      compiler.prepareAst(root);
    }

    // Set the source name so that the compiler passes can track
    // the source file and module.
    root.setStaticSourceFile(sourceFile);
  }
","private void parse(AbstractCompiler compiler) {
    Preconditions.checkNotNull(compiler, ""Compiler cannot be null"");
    try {
      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),
          compiler.getParserConfig(),
          compiler.getDefaultErrorReporter(),
          logger_);
      root = result.ast;
      if (result.oldAst != null) {
        compiler.setOldParseTree(sourceFile.getName(), result.oldAst);
      }
    } catch (IOException e) {
      compiler.report(
          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));
    }

    if (root == null || compiler.hasHaltingErrors()) {
      root = IR.script(); // Use a dummy block in case of error
    } else {
      compiler.prepareAst(root);
    }

    if (root != null) {
      root.setStaticSourceFile(sourceFile); // Set the source name for tracking
    }
}",0,0
61,Closure_174,"    private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVarAssign = parent.isVar() && n.hasChildren();
        if (isVarAssign && n.getFirstChild().isQualifiedName()) {
          recordAlias(v);
        } else if (v.isBleedingFunction()) {
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
        } else if (parent.getType() == Token.LP) {
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else if (isVarAssign) {
          Node value = v.getInitialValue().detachFromParent();
          String name = n.getString();
          int nameCount = scopedAliasNames.count(name);
          scopedAliasNames.add(name);
          String globalName =
              ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));

          compiler.ensureLibraryInjected(""base"");

          // Add $jscomp.scope.name = EXPR;
          // Make sure we copy over all the jsdoc and debug info.
            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
                compiler.getCodingConvention(),
                globalName,
                value,
                v.getJSDocInfo())
                .useSourceInfoIfMissingFromForTree(n);
            NodeUtil.setDebugInformation(
                newDecl.getFirstChild().getFirstChild(), n, name);
            parent.getParent().addChildBefore(newDecl, parent);

          // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
          v.getNameNode().addChildToFront(
              NodeUtil.newQualifiedNameNode(
                  compiler.getCodingConvention(), globalName, n, name));

          recordAlias(v);
        } else {
          // Do not allow hoisted functions or other kinds of local symbols.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
      }
    }
","private void findAliases(NodeTraversal t) {
    Preconditions.checkNotNull(t, ""NodeTraversal cannot be null"");
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        if (n == null) {
            continue; // Skip null nodes to avoid null pointer exceptions
        }
        Node parent = n.getParent();
        boolean isVarAssign = parent != null && parent.isVar() && n.hasChildren();
        if (isVarAssign && n.getFirstChild().isQualifiedName()) {
            recordAlias(v);
        } else if (v.isBleedingFunction()) {
            // Bleeding functions already get a BAD_PARAMETERS error, so just do nothing.
        } else if (parent != null && parent.getType() == Token.LP) {
            // Parameters of the scope function also get a BAD_PARAMETERS error.
        } else if (isVarAssign) {
            Node value = v.getInitialValue();
            if (value != null) {
                value.detachFromParent();
                String name = n.getString();
                int nameCount = scopedAliasNames.count(name);
                scopedAliasNames.add(name);
                String globalName = ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));

                compiler.ensureLibraryInjected(""base"");

                // Add $jscomp.scope.name = EXPR;
                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
                    compiler.getCodingConvention(),
                    globalName,
                    value,
                    v.getJSDocInfo())
                    .useSourceInfoIfMissingFromForTree(n);
                NodeUtil.setDebugInformation(
                    newDecl.getFirstChild().getFirstChild(), n, name);
                parent.getParent().addChildBefore(newDecl, parent);

                // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
                v.getNameNode().addChildToFront(
                    NodeUtil.newQualifiedNameNode(
                        compiler.getCodingConvention(), globalName, n, name));

                recordAlias(v);
            }
        } else {
            // Do not allow hoisted functions or other kinds of local symbols.
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}",0,0
62,Closure_175,"  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,
      Node callNode, Node fnNode, Set<String> needAliases,
      InliningMode mode, boolean referencesThis, boolean containsFunctions) {
    // TODO(johnlenz): This function takes too many parameter, without
    // context.  Modify the API to take a structure describing the function.

    // Allow direct function calls or ""fn.call"" style calls.
    if (!isSupportedCallType(callNode)) {
      return CanInlineResult.NO;
    }

    // Limit where functions that contain functions can be inline.  Introducing
    // an inner function into another function can capture a variable and cause
    // a memory leak.  This isn't a problem in the global scope as those values
    // last until explicitly cleared.
    if (containsFunctions) {
      if (!assumeMinimumCapture && !t.inGlobalScope()) {
        // TODO(johnlenz): Allow inlining into any scope without local names or
        // inner functions.
        return CanInlineResult.NO;
      } else if (NodeUtil.isWithinLoop(callNode)) {
        // An inner closure maybe relying on a local value holding a value for a
        // single iteration through a loop.
        return CanInlineResult.NO;
      }
    }

    // TODO(johnlenz): Add support for 'apply'
    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {
      // TODO(johnlenz): Allow 'this' references to be replaced with a
      // global 'this' object.
      return CanInlineResult.NO;
    }

    if (mode == InliningMode.DIRECT) {
      return canInlineReferenceDirectly(callNode, fnNode);
    } else {
      return canInlineReferenceAsStatementBlock(
          t, callNode, fnNode, needAliases);
    }
  }",Match failed,0,0
62,Closure_175,"  private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
      if (fnParam != null) {
        if (cArg != null) {
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }
        fnParam = fnParam.getNext();
      }
      // Limit the inlining
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
        return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }
",Match failed,0,0
62,Closure_175,"  private Set<String> knownConstants = Sets.newHashSet();
  private final boolean assumeStrictThis;
  private final boolean assumeMinimumCapture;
  private final Supplier<String> safeNameIdSupplier;

  /**
",Match failed,0,0
63,Closure_26,"private void emitOptionalModuleExportsOverride(Node script,
         String moduleName) {
 
       Node moduleExportsProp = IR.getprop(IR.name(moduleName),
           IR.string(""module$exports""));
      script.addChildToBack(IR.ifNode(
          moduleExportsProp,
          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),
              moduleExportsProp.cloneTree())))).copyInformationFromForTree(
          script));
    }","private void emitOptionalModuleExportsOverride(Node script, String moduleName) {
    Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string(""module$exports""));
    if (moduleExportsProp != null) {
        script.addChildToBack(IR.ifNode(
            moduleExportsProp.cloneTree(),
            IR.block(IR.exprResult(IR.assign(IR.name(moduleName), moduleExportsProp.cloneTree())))
        ).copyInformationFromForTree(script));
    }
}",0,0
63,Closure_26,"private void visitModuleExports(Node prop) {
      String moduleName = guessCJSModuleName(prop.getSourceFileName());
      Node module = prop.getChildAtIndex(0);
      module.putProp(Node.ORIGINALNAME_PROP, ""module"");
      module.setString(moduleName);
       Node exports = prop.getChildAtIndex(1);
       exports.putProp(Node.ORIGINALNAME_PROP, ""exports"");
       exports.setString(""module$exports"");
     }","private void visitModuleExports(Node prop) {
    String moduleName = guessCJSModuleName(prop.getSourceFileName());
    if (moduleName != null && prop.getChildCount() >= 2) {
        Node module = prop.getChildAtIndex(0);
        module.putProp(Node.ORIGINALNAME_PROP, ""module"");
        module.setString(moduleName);
        Node exports = prop.getChildAtIndex(1);
        exports.putProp(Node.ORIGINALNAME_PROP, ""exports"");
        exports.setString(""module$exports"");
    }
}",0,0
64,Closure_27,"public static Node tryCatch(Node tryBody, Node catchNode) {
     Preconditions.checkState(tryBody.isBlock());
     Preconditions.checkState(catchNode.isCatch());
     Node catchBody = block(catchNode).copyInformationFrom(catchNode);
     return new Node(Token.TRY, tryBody, catchBody);
   }","public static Node tryCatch(Node tryBody, Node catchNode) {
    Preconditions.checkState(tryBody != null && tryBody.isBlock(), ""tryBody must be a BLOCK node and not null"");
    Preconditions.checkState(catchNode != null && catchNode.isCatch(), ""catchNode must be a CATCH node and not null"");
    Node catchBody = IR.block().copyInformationFrom(catchNode);
    return new Node(Token.TRY, tryBody, catchNode, catchBody);
}",0,0
65,Closure_3,"private boolean canInline() {
      // Cannot inline a parameter.
      if (getDefCfgNode().isFunction()) {
        return false;
      }

      // If one of our dependencies has been inlined, then our dependency
      // graph is wrong. Re-computing it would take another CFG computation,
      // so we just back off for now.
      for (Var dependency : defMetadata.depends) {
        if (inlinedNewDependencies.contains(dependency)) {
          return false;
        }
      }

      getDefinition(getDefCfgNode(), null);
      getNumUseInUseCfgNode(useCfgNode, null);

      // Definition was not found.
      if (def == null) {
        return false;
      }

      // Check that the assignment isn't used as a R-Value.
      // TODO(user): Certain cases we can still inline.
      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
        return false;
      }

      // The right of the definition has side effect:
      // Example, for x:
      // x = readProp(b), modifyProp(b); print(x);
      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {
        return false;
      }

      // Similar check as the above but this time, all the sub-expressions
      // left of the use of the variable.
      // x = readProp(b); modifyProp(b), print(x);
      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {
        return false;
      }

      // TODO(user): Side-effect is OK sometimes. As long as there are no
      // side-effect function down all paths to the use. Once we have all the
      // side-effect analysis tool.
      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {
        return false;
      }

      // TODO(user): We could inline all the uses if the expression is short.

      // Finally we have to make sure that there are no more than one use
      // in the program and in the CFG node. Even when it is semantically
      // correctly inlining twice increases code size.
      if (numUseWithinUseCfgNode != 1) {
        return false;
      }

      // Make sure that the name is not within a loop
      if (NodeUtil.isWithinLoop(use)) {
        return false;
      }


      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());

      if (uses.size() != 1) {
        return false;
      }

      // We give up inlining stuff with R-Value that has:
      // 1) GETPROP, GETELEM,
      // 2) anything that creates a new object.
      // 3) a direct reference to a catch expression.
      // Example:
      // var x = a.b.c; j.c = 1; print(x);
      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.
      // TODO(user): We could get more accuracy by looking more in-detail
      // what j is and what x is trying to into to.
      // TODO(johnlenz): rework catch expression handling when we
      // have lexical scope support so catch expressions don't
      // need to be special cased.
      if (NodeUtil.has(def.getLastChild(),
          new Predicate<Node>() {
              @Override
              public boolean apply(Node input) {
                switch (input.getType()) {
                  case Token.GETELEM:
                  case Token.GETPROP:
                  case Token.ARRAYLIT:
                  case Token.OBJECTLIT:
                   case Token.REGEXP:
                   case Token.NEW:
                     return true;
                 }
                 return false;
               }
          },
          new Predicate<Node>() {
              @Override
              public boolean apply(Node input) {
                // Recurse if the node is not a function.
                return !input.isFunction();
              }
          })) {
        return false;
      }

      // We can skip the side effect check along the paths of two nodes if
      // they are just next to each other.
      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&
          getDefCfgNode().getNext() != useCfgNode) {
        // Similar side effect check as above but this time the side effect is
        // else where along the path.
        // x = readProp(b); while(modifyProp(b)) {}; print(x);
        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>
          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(
                 cfg,
                 cfg.getDirectedGraphNode(getDefCfgNode()),
                 cfg.getDirectedGraphNode(useCfgNode),
                 SIDE_EFFECT_PREDICATE,
                 Predicates.
                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),
                 false);
        if (pathCheck.somePathsSatisfyPredicate()) {
          return false;
        }
      }

      return true;
    }","private boolean canInline() {
    if (getDefCfgNode() == null || getDefCfgNode().isFunction()) {
        return false;
    }

    for (Var dependency : defMetadata.depends) {
        if (inlinedNewDependencies.contains(dependency)) {
            return false;
        }
    }

    def = getDefinition(getDefCfgNode(), null);
    if (def == null) {
        return false;
    }

    useCfgNode = getNumUseInUseCfgNode(use, null);
    if (useCfgNode == null) {
        return false;
    }

    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
        return false;
    }

    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {
        return false;
    }

    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {
        return false;
    }

    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {
        return false;
    }

    if (numUseWithinUseCfgNode != 1) {
        return false;
    }

    if (NodeUtil.isWithinLoop(use)) {
        return false;
    }

    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());
    if (uses.size() != 1) {
        return false;
    }

    if (NodeUtil.has(def.getLastChild(), 
        input -> switch (input.getType()) {
            case Token.GETELEM, Token.GETPROP, Token.ARRAYLIT, Token.OBJECTLIT, 
                 Token.REGEXP, Token.NEW -> true;
            default -> false;
        }, 
        input -> !input.isFunction())) {
        return false;
    }

    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && 
        getDefCfgNode().getNext() != useCfgNode) {
        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = 
            new CheckPathsBetweenNodes<>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), 
            cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, 
            Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);
        if (pathCheck.somePathsSatisfyPredicate()) {
            return false;
        }
    }

    return true;
}",0,0
65,Closure_3,"@Override
  public void enterScope(NodeTraversal t) {

    if (t.inGlobalScope()) {
      return; // Don't even brother. All global variables are likely escaped.
    }

    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <
        t.getScope().getVarCount()) {
      return;
    }

    // Compute the forward reaching definition.
    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
    // Process the body of the function.
    Preconditions.checkState(t.getScopeRoot().isFunction());
    cfa.process(null, t.getScopeRoot().getLastChild());
    cfg = cfa.getCfg();
    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);
    reachingDef.analyze();
    candidates = Lists.newLinkedList();

    // Using the forward reaching definition search to find all the inline
    // candidates
    new NodeTraversal(compiler, new GatherCandiates()).traverse(
        t.getScopeRoot().getLastChild());

    // Compute the backward reaching use. The CFG can be reused.
     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
     reachingUses.analyze();
     for (Candidate c : candidates) {
       if (c.canInline()) {
         c.inlineVariable();
 
         // If definition c has dependencies, then inlining it may have
        // introduced new dependencies for our other inlining candidates.
        //
        // MustBeReachingVariableDef uses this dependency graph in its
        // analysis, so some of these candidates may no longer be valid.
        // We keep track of when the variable dependency graph changed
        // so that we can back off appropriately.
        if (!c.defMetadata.depends.isEmpty()) {
          inlinedNewDependencies.add(t.getScope().getVar(c.varName));
        }
      }
    }
  }","@Override
public void enterScope(NodeTraversal t) {
    if (t.inGlobalScope()) {
        return;
    }

    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < 
        t.getScope().getVarCount()) {
        return;
    }

    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
    Preconditions.checkState(t.getScopeRoot() != null && t.getScopeRoot().isFunction());
    cfa.process(null, t.getScopeRoot().getLastChild());
    cfg = cfa.getCfg();
    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);
    reachingDef.analyze();
    candidates = Lists.newLinkedList();

    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());

    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
    reachingUses.analyze();
    Iterator<Candidate> candidateIterator = candidates.iterator();

    while (candidateIterator.hasNext()) {
        Candidate c = candidateIterator.next();
        if (c.canInline()) {
            c.inlineVariable();
            if (!c.defMetadata.depends.isEmpty()) {
                inlinedNewDependencies.add(t.getScope().getVar(c.varName));
            }
        }
    }
}",0,0
66,Closure_30,"boolean dependsOnOuterScopeVars(String name, Node useNode) {
    Preconditions.checkArgument(getCfg().hasNode(useNode));
     GraphNode<Node, Branch> n = getCfg().getNode(useNode);
     FlowState<MustDef> state = n.getAnnotation();
     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
 
     for (Var s : def.depends) {
       if (s.scope != jsScope) {
        return true;
      }
    }
    return false;
  }","boolean dependsOnOuterScopeVars(String name, Node useNode) {
    Preconditions.checkArgument(getCfg().hasNode(useNode));
    GraphNode<Node, Branch> n = getCfg().getNode(useNode);
    FlowState<MustDef> state = n.getAnnotation();

    Var var = jsScope.getVar(name);
    if (var == null) { // Added null check for robustness
        return false;
    }

    Definition def = state.getIn().reachingDef.get(var);
    if (def == null) { // Added null check for robustness
        return false;
    }

    for (Var s : def.depends) {
        if (s != null && s.scope != jsScope) { // Added null check and ensured scope comparison is valid
            return true;
        }
    }
    return false;
}",0,0
67,Closure_34,"private void unrollBinaryOperator(
      Node n, int op, String opStr, Context context,
      Context rhsContext, int leftPrecedence, int rightPrecedence) {
    Node firstNonOperator = n.getFirstChild();
    while (firstNonOperator.getType() == op) {
      firstNonOperator = firstNonOperator.getFirstChild();
    }

    addExpr(firstNonOperator, leftPrecedence, context);

     Node current = firstNonOperator;
     do {
       current = current.getParent();
       cc.listSeparator();
       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
     } while (current != n);
   }","private void unrollBinaryOperator(
      Node n, int op, String opStr, Context context,
      Context rhsContext, int leftPrecedence, int rightPrecedence) {
    Node firstNonOperator = n.getFirstChild();
    while (firstNonOperator != null && firstNonOperator.getType() == op) {
      firstNonOperator = firstNonOperator.getFirstChild();
    }

    if (firstNonOperator == null) {
      return; // Handle case where firstNonOperator ends up being null
    }

    addExpr(firstNonOperator, leftPrecedence, context);

    Node current = firstNonOperator;
    do {
      current = current.getParent();
      if (current == null) {
        break; // Avoid potential null pointer issues
      }
      cc.listSeparator();
      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
    } while (current != n);
}",0,0
67,Closure_34,"@Override
     void appendOp(String op, boolean binOp) {
       if (binOp) {
         if (getLastChar() != ' ') {
           append("" "");
         }
         append(op);
        append("" "");
      } else {
        append(op);
      }
    }","@Override
void appendOp(String op, boolean binOp) {
    if (binOp) {
        if (getLastChar() != ' ' && getLastChar() != '\t' && getLastChar() != '\n') {
            append("" "");
        }
        append(op);
        append("" "");
    } else {
        append(op);
    }
}",0,0
67,Closure_34,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
         cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else {
         addExpr(first, p, context);
         cc.addOp(opstr, true);
         addExpr(last, p + 1, rhsContext);
       }
       return;
     }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context, Context.OTHER, 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

      case Token.HOOK: {
        Preconditions.checkState(childCount == 3);
        int p = NodeUtil.precedence(type);
        addExpr(first, p + 1, context);
        cc.addOp(""?"", true);
        addExpr(first.getNext(), 1, Context.OTHER);
        cc.addOp("":"", true);
        addExpr(last, 1, Context.OTHER);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        add(""."");
        addIdentifier(last.getString());
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        add(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        add(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        add(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING:
        if (childCount !=
            ((n.getParent() != null &&
              n.getParent().isObjectLit()) ? 1 : 0)) {
          throw new IllegalStateException(
              ""Unexpected String children: "" + n.getParent().toStringTree());
        }
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isString());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString() &&
                !TokenStream.isKeyword(key) &&
                TokenStream.isJSIdentifier(key) &&
                // do not encode literally any non-literal characters that
                // were unicode escaped.
                NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != null && last != null && first != last) {
        Preconditions.checkState(
            childCount == 2,
            ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
            opstr, childCount);
        int p = NodeUtil.precedence(type);

        Context rhsContext = getContextForNoInOperator(context);

        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p + 1, rhsContext);
        }
        return;
    }

    cc.startSourceMapping(n);

    switch (type) {
        // Add cases for supported tokens
        case Token.TRY:
            Preconditions.checkState(first.getNext().isBlock() &&
                    !first.getNext().hasMoreThanOneChild());
            Preconditions.checkState(childCount >= 2 && childCount <= 3);
            add(""try"");
            add(first, Context.PRESERVE_BLOCK);
            Node catchBlock = first.getNext().getFirstChild();
            if (catchBlock != null) {
                add(catchBlock);
            }
            if (childCount == 3) {
                add(""finally"");
                add(last, Context.PRESERVE_BLOCK);
            }
            break;

        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;

        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;

        // Include fixed cases for all other tokens...

        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
}",0,0
68,Closure_37,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
      Name name = functionNode.getFunctionName();
      Boolean isUnnamedFunction = false;
      if (name == null) {
        int functionType = functionNode.getFunctionType();
        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
          errorReporter.error(
            ""unnamed function statement"",
            sourceName,
            functionNode.getLineno(), """", 0);

          // Return the bare minimum to put the AST in a valid state.
          return newNode(Token.EXPR_RESULT, Node.newNumber(0));
        }
        name = new Name();
        name.setIdentifier("""");
        isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
        maybeSetLengthFrom(newName, name);
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.PARAM_LIST);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
       node.addChildToBack(lp);
 
       Node bodyNode = transform(functionNode.getBody());
         // When in ideMode Rhino tries to parse some constructs the compiler
         // doesn't support, repair it here. see Rhino's
         // Parser#parseFunctionBodyExpr.
       parseDirectives(bodyNode);
       node.addChildToBack(bodyNode);
      return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    boolean isUnnamedFunction = false;
    if (name == null) {
        int functionType = functionNode.getFunctionType();
        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
            errorReporter.error(
                ""unnamed function statement"",
                sourceName,
                functionNode.getLineno(), """", 0);

            // Return the bare minimum to put the AST in a valid state.
            return newNode(Token.EXPR_RESULT, Node.newNumber(0));
        }
        name = new Name();
        name.setIdentifier("""");
        isUnnamedFunction = true;
    }
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    if (isUnnamedFunction) {
        newName.setLineno(functionNode.getLineno());
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
        maybeSetLengthFrom(newName, name);
    }

    node.addChildToBack(newName);
    Node lp = newNode(Token.PARAM_LIST);
    Name fnName = functionNode.getFunctionName();
    if (fnName != null) {
        lp.setLineno(fnName.getLineno());
    } else {
        lp.setLineno(functionNode.getLineno());
    }
    int lparenCharno = functionNode.getLp() +
        functionNode.getAbsolutePosition();

    lp.setCharno(position2charno(lparenCharno));
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);

    Node bodyNode = transform(functionNode.getBody());
    if (bodyNode == null || !bodyNode.isBlock()) {
        // Handle edge cases where the body is not a valid block.
        bodyNode = newNode(Token.BLOCK);
    }
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);
    return node;
}",0,0
68,Closure_37,"private void traverseFunction(Node n, Node parent) {
    Preconditions.checkState(n.getChildCount() == 3);
    Preconditions.checkState(n.isFunction());

    final Node fnName = n.getFirstChild();

    boolean isFunctionExpression = (parent != null)
        && NodeUtil.isFunctionExpression(n);

    if (!isFunctionExpression) {
      // Functions declarations are in the scope containing the declaration.
      traverseBranch(fnName, n);
    }

    curNode = n;
    pushScope(n);

    if (isFunctionExpression) {
      // Function expression names are only accessible within the function
      // scope.
      traverseBranch(fnName, n);
    }

    final Node args = fnName.getNext();
    final Node body = args.getNext();

    // Args
    traverseBranch(args, n);
 
     // Body
     Preconditions.checkState(body.getNext() == null &&
             body.isBlock());
     traverseBranch(body, n);
 
     popScope();
  }","private void traverseFunction(Node n, Node parent) {
    Preconditions.checkState(n.getChildCount() == 3, ""Expected function node to have exactly 3 children."");
    Preconditions.checkState(n.isFunction(), ""Node is not a function."");

    final Node fnName = n.getFirstChild();

    boolean isFunctionExpression = (parent != null)
        && NodeUtil.isFunctionExpression(n);

    if (!isFunctionExpression) {
        traverseBranch(fnName, n);
    }

    curNode = n;
    pushScope(n);

    if (isFunctionExpression) {
        traverseBranch(fnName, n);
    }

    final Node args = fnName.getNext();
    final Node body = args.getNext();

    Preconditions.checkState(args != null && args.isParamList(), ""Expected second child to be PARAM_LIST."");

    traverseBranch(args, n);

    Preconditions.checkState(body != null && body.getNext() == null, ""Function body should be the last child."");
    Preconditions.checkState(body.isBlock(), ""Function body should be a BLOCK."");

    traverseBranch(body, n);

    popScope();
}",0,0
69,Closure_41,"FunctionTypeBuilder inferFromOverriddenFunction(
      @Nullable FunctionType oldType, @Nullable Node paramsParent) {
    if (oldType == null) {
      return this;
    }

    returnType = oldType.getReturnType();
    returnTypeInferred = oldType.isReturnTypeInferred();
    if (paramsParent == null) {
      // Not a function literal.
      parametersNode = oldType.getParametersNode();
      if (parametersNode == null) {
        parametersNode = new FunctionParamBuilder(typeRegistry).build();
      }
    } else {
      // We're overriding with a function literal. Apply type information
      // to each parameter of the literal.
      FunctionParamBuilder paramBuilder =
          new FunctionParamBuilder(typeRegistry);
      Iterator<Node> oldParams = oldType.getParameters().iterator();
      boolean warnedAboutArgList = false;
      boolean oldParamsListHitOptArgs = false;
      for (Node currentParam = paramsParent.getFirstChild();
           currentParam != null; currentParam = currentParam.getNext()) {
        if (oldParams.hasNext()) {
          Node oldParam = oldParams.next();
          Node newParam = paramBuilder.newParameterFromNode(oldParam);

          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||
              oldParam.isVarArgs() ||
              oldParam.isOptionalArg();

          // The subclass method might write its var_args as individual
          // arguments.
          if (currentParam.getNext() != null && newParam.isVarArgs()) {
            newParam.setVarArgs(false);
            newParam.setOptionalArg(true);
          }
        } else {
          warnedAboutArgList |= addParameter(
              paramBuilder,
              typeRegistry.getNativeType(UNKNOWN_TYPE),
              warnedAboutArgList,
              codingConvention.isOptionalParameter(currentParam) ||
                  oldParamsListHitOptArgs,
              codingConvention.isVarArgsParameter(currentParam));
        }
       }
 
       // Clone any remaining params that aren't in the function literal.
 
       parametersNode = paramBuilder.build();
     }
    return this;
  }","FunctionTypeBuilder inferFromOverriddenFunction(
      @Nullable FunctionType oldType, @Nullable Node paramsParent) {
    if (oldType == null) {
      return this;
    }

    returnType = oldType.getReturnType();
    returnTypeInferred = oldType.isReturnTypeInferred();

    if (paramsParent == null) {
      // Not a function literal.
      parametersNode = oldType.getParametersNode();
      if (parametersNode == null) {
        parametersNode = new FunctionParamBuilder(typeRegistry).build();
      }
    } else {
      // We're overriding with a function literal. Apply type information
      // to each parameter of the literal.
      FunctionParamBuilder paramBuilder =
          new FunctionParamBuilder(typeRegistry);
      Iterator<Node> oldParams = oldType.getParameters().iterator();
      boolean warnedAboutArgList = false;
      boolean oldParamsListHitOptArgs = false;
      for (Node currentParam = paramsParent.getFirstChild();
           currentParam != null; currentParam = currentParam.getNext()) {
        if (oldParams.hasNext()) {
          Node oldParam = oldParams.next();
          Node newParam = paramBuilder.newParameterFromNode(oldParam);
          
          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||
              oldParam.isVarArgs() ||
              oldParam.isOptionalArg();

          // The subclass method might write its var_args as individual
          // arguments.
          if (currentParam.getNext() != null && newParam.isVarArgs()) {
            newParam.setVarArgs(false);
            newParam.setOptionalArg(true);
          }
        } else {
          warnedAboutArgList |= addParameter(
              paramBuilder,
              typeRegistry.getNativeType(UNKNOWN_TYPE),
              warnedAboutArgList,
              codingConvention.isOptionalParameter(currentParam) ||
                  oldParamsListHitOptArgs,
              codingConvention.isVarArgsParameter(currentParam));
        }
      }

      // Clone any remaining params that aren't in the function literal.
      while (oldParams.hasNext()) {
        Node oldParam = oldParams.next();
        paramBuilder.newParameterFromNode(oldParam);
      }

      parametersNode = paramBuilder.build();
    }
    return this;
  }",0,0
69,Closure_41,"FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,
      @Nullable JSDocInfo info) {
    if (argsParent == null) {
      if (info == null) {
        return this;
      } else {
        return inferParameterTypes(info);
      }
    }

    // arguments
    Node oldParameterType = null;
    if (parametersNode != null) {
      oldParameterType = parametersNode.getFirstChild();
    }

    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);
    boolean warnedAboutArgList = false;
    Set<String> allJsDocParams = (info == null) ?
        Sets.<String>newHashSet() :
        Sets.newHashSet(info.getParameterNames());
    boolean foundTemplateType = false;
    boolean isVarArgs = false;
    for (Node arg : argsParent.children()) {
      String argumentName = arg.getString();
      allJsDocParams.remove(argumentName);

      // type from JSDocInfo
      JSType parameterType = null;
      boolean isOptionalParam = isOptionalParameter(arg, info);
      isVarArgs = isVarArgsParameter(arg, info);

      if (info != null && info.hasParameterType(argumentName)) {
        parameterType =
            info.getParameterType(argumentName).evaluate(scope, typeRegistry);
      } else if (oldParameterType != null &&
          oldParameterType.getJSType() != null) {
        parameterType = oldParameterType.getJSType();
        isOptionalParam = oldParameterType.isOptionalArg();
        isVarArgs = oldParameterType.isVarArgs();
      } else {
        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);
      }

      if (templateTypeName != null &&
          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {
        if (foundTemplateType) {
          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);
        }
        foundTemplateType = true;
      }
      warnedAboutArgList |= addParameter(
          builder, parameterType, warnedAboutArgList,
          isOptionalParam,
          isVarArgs);

      if (oldParameterType != null) {
        oldParameterType = oldParameterType.getNext();
      }
     }
 
     // Copy over any old parameters that aren't in the param list.
 
     if (templateTypeName != null && !foundTemplateType) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }

    for (String inexistentName : allJsDocParams) {
      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);
    }

    parametersNode = builder.build();
    return this;
  }","FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,
      @Nullable JSDocInfo info) {
    if (argsParent == null) {
      if (info == null) {
        return this;
      } else {
        return inferParameterTypes(info);
      }
    }

    // arguments
    Node oldParameterType = null;
    if (parametersNode != null) {
      oldParameterType = parametersNode.getFirstChild();
    }

    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);
    boolean warnedAboutArgList = false;
    Set<String> allJsDocParams = (info == null) ?
        Sets.<String>newHashSet() :
        Sets.newHashSet(info.getParameterNames());
    boolean foundTemplateType = false;

    for (Node arg : argsParent.children()) {
      String argumentName = arg.getString();
      allJsDocParams.remove(argumentName);

      // type from JSDocInfo
      JSType parameterType = null;
      boolean isOptionalParam = isOptionalParameter(arg, info);
      boolean isVarArgs = isVarArgsParameter(arg, info);

      if (info != null && info.hasParameterType(argumentName)) {
        parameterType =
            info.getParameterType(argumentName).evaluate(scope, typeRegistry);
      } else if (oldParameterType != null &&
          oldParameterType.getJSType() != null) {
        parameterType = oldParameterType.getJSType();
        isOptionalParam = oldParameterType.isOptionalArg();
        isVarArgs = oldParameterType.isVarArgs();
      } else {
        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);
      }

      if (templateTypeName != null &&
          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {
        if (foundTemplateType) {
          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);
        }
        foundTemplateType = true;
      }

      warnedAboutArgList |= addParameter(
          builder, parameterType, warnedAboutArgList,
          isOptionalParam,
          isVarArgs);

      if (oldParameterType != null) {
        oldParameterType = oldParameterType.getNext();
      }
    }

    // Copy over any old parameters that aren't in the param list.
    while (oldParameterType != null) {
      builder.addParameter(oldParameterType.cloneNode());
      oldParameterType = oldParameterType.getNext();
    }

    if (templateTypeName != null && !foundTemplateType) {
      reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }

    for (String inexistentName : allJsDocParams) {
      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);
    }

    parametersNode = builder.build();
    return this;
  }",0,0
70,Closure_43,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      inputId = t.getInputId();
      attachLiteralTypes(t, n);

      switch (n.getType()) {
        case Token.CALL:
          checkForClassDefiningCalls(t, n, parent);
          checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
          break;

        case Token.FUNCTION:
          if (t.getInput() == null || !t.getInput().isExtern()) {
            nonExternFunctions.add(n);
          }

          // Hoisted functions are handled during pre-traversal.
          if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
            defineFunctionLiteral(n, parent);
          }
          break;

        case Token.ASSIGN:
          // Handle initialization of properties.
          Node firstChild = n.getFirstChild();
          if (firstChild.isGetProp() &&
              firstChild.isQualifiedName()) {
            maybeDeclareQualifiedName(t, n.getJSDocInfo(),
                firstChild, n, firstChild.getNext());
          }
          break;

        case Token.CATCH:
          defineCatch(n, parent);
          break;

        case Token.VAR:
          defineVar(n, parent);
          break;

        case Token.GETPROP:
          // Handle stubbed properties.
          if (parent.isExprResult() &&
              n.isQualifiedName()) {
            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
          }
          break;
       }
 
       // Analyze any @lends object literals in this statement.
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    inputId = t.getInputId();
    attachLiteralTypes(t, n);

    switch (n.getToken()) {
        case Token.CALL:
            checkForClassDefiningCalls(t, n, parent);
            checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
            break;

        case Token.FUNCTION:
            if (t.getInput() != null && !t.getInput().isExtern()) {
                nonExternFunctions.add(n);
            }

            // Hoisted functions are handled during pre-traversal.
            if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
                defineFunctionLiteral(n, parent);
            }
            break;

        case Token.ASSIGN:
            // Handle initialization of properties.
            Node firstChild = n.getFirstChild();
            if (firstChild.isGetProp() && firstChild.isQualifiedName()) {
                maybeDeclareQualifiedName(
                    t, n.getJSDocInfo(), firstChild, n, firstChild.getNext());
            }
            break;

        case Token.CATCH:
            defineCatch(n, parent);
            break;

        case Token.VAR:
            defineVar(n, parent);
            break;

        case Token.GETPROP:
            // Handle stubbed properties.
            if (parent.isExprResult() && n.isQualifiedName()) {
                maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
            }
            break;

        default:
            break;
    }
    
    // Analyze any @lends object literals in this statement.
}",0,0
70,Closure_43,"private void attachLiteralTypes(NodeTraversal t, Node n) {
      switch (n.getType()) {
        case Token.NULL:
          n.setJSType(getNativeType(NULL_TYPE));
          break;

        case Token.VOID:
          n.setJSType(getNativeType(VOID_TYPE));
          break;

        case Token.STRING:
          // Defer keys to the Token.OBJECTLIT case
          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
            n.setJSType(getNativeType(STRING_TYPE));
          }
          break;

        case Token.NUMBER:
          n.setJSType(getNativeType(NUMBER_TYPE));
          break;

        case Token.TRUE:
        case Token.FALSE:
          n.setJSType(getNativeType(BOOLEAN_TYPE));
          break;

        case Token.REGEXP:
          n.setJSType(getNativeType(REGEXP_TYPE));
           break;
 
         case Token.OBJECTLIT:
             defineObjectLiteral(n);
           break;
 
           // NOTE(nicksantos): If we ever support Array tuples,
          // we will need to put ARRAYLIT here as well.
      }
    }","private void attachLiteralTypes(NodeTraversal t, Node n) {
    switch (n.getToken()) {
        case Token.NULL:
            n.setJSType(getNativeType(NULL_TYPE));
            break;

        case Token.VOID:
            n.setJSType(getNativeType(VOID_TYPE));
            break;

        case Token.STRING:
            // Defer keys to the Token.OBJECTLIT case
            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                n.setJSType(getNativeType(STRING_TYPE));
            }
            break;

        case Token.NUMBER:
            n.setJSType(getNativeType(NUMBER_TYPE));
            break;

        case Token.TRUE:
        case Token.FALSE:
            n.setJSType(getNativeType(BOOLEAN_TYPE));
            break;

        case Token.REGEXP:
            n.setJSType(getNativeType(REGEXP_TYPE));
            break;

        case Token.OBJECTLIT:
            defineObjectLiteral(n);
            break;

        default:
            break;
    }
}",0,0
71,Closure_45,"private void interpretAssigns() {
    boolean changes = false;
    do {
      changes = false;

      // We can't use traditional iterators and iterables for this list,
      // because our lazily-evaluated continuations will modify it while
      // we traverse it.
      for (int current = 0; current < maybeUnreferenced.size(); current++) {
        Var var = maybeUnreferenced.get(current);
        if (referenced.contains(var)) {
          maybeUnreferenced.remove(current);
          current--;
        } else {
          boolean assignedToUnknownValue = false;
          boolean hasPropertyAssign = false;

          if (var.getParentNode().isVar() &&
              !NodeUtil.isForIn(var.getParentNode().getParent())) {
            Node value = var.getInitialValue();
            assignedToUnknownValue = value != null &&
                !NodeUtil.isLiteralValue(value, true);
          } else {
            // This was initialized to a function arg or a catch param
            // or a for...in variable.
            assignedToUnknownValue = true;
          }

          for (Assign assign : assignsByVar.get(var)) {
            if (assign.isPropertyAssign) {
              hasPropertyAssign = true;
            } else if (!NodeUtil.isLiteralValue(
                 assign.assignNode.getLastChild(), true)) {
               assignedToUnknownValue = true;
             }
           }
 
           if (assignedToUnknownValue && hasPropertyAssign) {
             changes = markReferencedVar(var) || changes;
             maybeUnreferenced.remove(current);
             current--;
          }
        }
      }
    } while (changes);
  }","private void interpretAssigns() {
    boolean changes;
    do {
        changes = false;

        // Iterating over maybeUnreferenced list
        for (int current = 0; current < maybeUnreferenced.size(); current++) {
            Var var = maybeUnreferenced.get(current);
            if (referenced.contains(var)) {
                // Remove the variable from maybeUnreferenced if it's already referenced
                maybeUnreferenced.remove(current);
                current--;
            } else {
                boolean assignedToUnknownValue = false;
                boolean hasPropertyAssign = false;

                // Check if the variable is a var and not part of a for-in loop
                if (var.getParentNode() != null && var.getParentNode().isVar() &&
                    !NodeUtil.isForIn(var.getParentNode().getParent())) {
                    Node value = var.getInitialValue();
                    assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true);
                } else {
                    // This was initialized to a function arg or a catch param or a for...in variable
                    assignedToUnknownValue = true;
                }

                // Iterate over associated assignments
                if (assignsByVar.containsKey(var)) {
                    for (Assign assign : assignsByVar.get(var)) {
                        if (assign.isPropertyAssign) {
                            hasPropertyAssign = true;
                        } else if (assign.assignNode != null && 
                                   assign.assignNode.getLastChild() != null &&
                                   !NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {
                            assignedToUnknownValue = true;
                        }
                    }
                }

                // Mark and remove referenced variables, if applicable
                if (assignedToUnknownValue && hasPropertyAssign) {
                    changes = markReferencedVar(var) || changes;
                    maybeUnreferenced.remove(current);
                    current--;
                }
            }
        }
    } while (changes);
}",0,0
72,Closure_47,"public void addMapping(
      Node node,
      FilePosition outputStartPosition,
      FilePosition outputEndPosition) {
    String sourceFile = node.getSourceFileName();

    // If the node does not have an associated source file or
    // its line number is -1, then the node does not have sufficient
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
      return;
    }

    sourceFile = fixupSourceLocation(sourceFile);

    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);

    // Strangely, Rhino source lines are one based but columns are
     // zero based.
     // We don't change this for the v1 or v2 source maps but for
     // v3 we make them both 0 based.
 
     generator.addMapping(
         sourceFile, originalName,
         new FilePosition(node.getLineno(), node.getCharno()),
         outputStartPosition, outputEndPosition);
   }","public void addMapping(
      Node node,
      FilePosition outputStartPosition,
      FilePosition outputEndPosition) {
    String sourceFile = node.getSourceFileName();

    // If the node does not have an associated source file or
    // its line number is -1, then the node does not have sufficient
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0 || node.getCharno() < 0) {
        return;
    }

    sourceFile = fixupSourceLocation(sourceFile);

    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);

    // Strangely, Rhino source lines are one based but columns are
    // zero based.
    // We don't change this for the v1 or v2 source maps but for
    // v3 we make them both 0 based.
    generator.addMapping(
        sourceFile, originalName,
        new FilePosition(node.getLineno() - 1, node.getCharno()), // Adjusting for 0-based indexing
        outputStartPosition, outputEndPosition);
}",0,0
72,Closure_47,"private OriginalMapping getOriginalMappingForEntry(Entry entry) {
    if (entry.getSourceFileId() == UNMAPPED) {
      return null;
    } else {
       // Adjust the line/column here to be start at 1.
       Builder x = OriginalMapping.newBuilder()
         .setOriginalFile(sources[entry.getSourceFileId()])
         .setLineNumber(entry.getSourceLine())
         .setColumnPosition(entry.getSourceColumn());
       if (entry.getNameId() != UNMAPPED) {
         x.setIdentifier(names[entry.getNameId()]);
       }
      return x.build();
    }
  }","private OriginalMapping getOriginalMappingForEntry(Entry entry) {
    if (entry.getSourceFileId() == UNMAPPED) {
        return null;
    } else {
        // Adjust the line/column here to start at 1.
        Builder builder = OriginalMapping.newBuilder()
            .setOriginalFile(sources[entry.getSourceFileId()])
            .setLineNumber(entry.getSourceLine() + 1) // Increment line number to 1-based indexing
            .setColumnPosition(entry.getSourceColumn() + 1); // Increment column position to 1-based indexing

        if (entry.getNameId() != UNMAPPED) {
            builder.setIdentifier(names[entry.getNameId()]);
        }
        return builder.build();
    }
}",0,0
73,Closure_49,"@Override
  public void enterScope(NodeTraversal t) {
    Node declarationRoot = t.getScopeRoot();
    Renamer renamer;
    if (nameStack.isEmpty()) {
      // If the contextual renamer is being used the starting context can not
      // be a function.
      Preconditions.checkState(
          declarationRoot.getType() != Token.FUNCTION ||
          !(rootRenamer instanceof ContextualRenamer));
      Preconditions.checkState(t.inGlobalScope());
      renamer = rootRenamer;
    } else {
       renamer = nameStack.peek().forChildScope();
     }
 
     if (declarationRoot.getType() == Token.FUNCTION) {
       for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {
         String name = c.getString();
         renamer.addDeclaredName(name);
       }
       Node functionBody = declarationRoot.getLastChild();
       findDeclaredNames(functionBody, null, renamer);
     }  else 
     if (declarationRoot.getType() != Token.FUNCTION) {
       // Add the block declarations
       findDeclaredNames(declarationRoot, null, renamer);
    }
    nameStack.push(renamer);
  }","@Override
public void enterScope(NodeTraversal t) {
    Node declarationRoot = t.getScopeRoot();
    Renamer renamer;
    if (nameStack.isEmpty()) {
        // Ensure starting context is not a function if using ContextualRenamer
        Preconditions.checkState(
                declarationRoot.getType() != Token.FUNCTION ||
                !(rootRenamer instanceof ContextualRenamer));
        Preconditions.checkState(t.inGlobalScope());
        renamer = rootRenamer;
    } else {
        renamer = nameStack.peek().forChildScope();
    }

    if (declarationRoot.getType() == Token.FUNCTION) {
        Node paramList = declarationRoot.getFirstChild().getNext();
        if (paramList != null) {
            for (Node c = paramList.getFirstChild(); c != null; c = c.getNext()) {
                String name = c.getString();
                renamer.addDeclaredName(name);
            }
        }
        Node functionBody = declarationRoot.getLastChild();
        if (functionBody != null) {
            findDeclaredNames(functionBody, null, renamer);
        }
    } else {
        // Add non-function block declarations
        findDeclaredNames(declarationRoot, null, renamer);
    }
    nameStack.push(renamer);
}",0,0
73,Closure_49,"@Override
  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    switch (n.getType()) {
      case Token.FUNCTION:
        {
          // Add recursive function name, if needed.
          // NOTE: ""enterScope"" is called after we need to pick up this name.
          Renamer renamer = nameStack.peek().forChildScope();

          // If needed, add the function recursive name.
          String name = n.getFirstChild().getString();
          if (name != null && !name.isEmpty() && parent != null
              && !NodeUtil.isFunctionDeclaration(n)) {
             renamer.addDeclaredName(name);
           }
 
 
 
           // Add the function parameters
 
           // Add the function body declarations
 
           nameStack.push(renamer);
         }
        break;

      case Token.CATCH:
        {
          Renamer renamer = nameStack.peek().forChildScope();

          String name = n.getFirstChild().getString();
          renamer.addDeclaredName(name);

          nameStack.push(renamer);
        }
        break;
    }

    return true;
  }","@Override
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    switch (n.getType()) {
        case Token.FUNCTION: {
            // Add recursive function name, if applicable
            Renamer renamer = nameStack.peek().forChildScope();
            String name = n.getFirstChild().getString();
            if (name != null && !name.isEmpty() && parent != null 
                    && !NodeUtil.isFunctionDeclaration(n)) {
                renamer.addDeclaredName(name);
            }

            // Add function scope to the name stack
            nameStack.push(renamer);
            break;
        }
        case Token.CATCH: {
            Renamer renamer = nameStack.peek().forChildScope();
            String name = n.getFirstChild().getString();
            if (name != null) {
                renamer.addDeclaredName(name);
            }
            nameStack.push(renamer);
            break;
        }
    }
    return true;
}",0,0
73,Closure_49,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    switch (n.getType()) {
      case Token.NAME:
        String newName = getReplacementName(n.getString());
        if (newName != null) {
          Renamer renamer = nameStack.peek();
          if (renamer.stripConstIfReplaced()) {
            // TODO(johnlenz): Do we need to do anything about the javadoc?
            n.removeProp(Node.IS_CONSTANT_NAME);
          }
          n.setString(newName);
          t.getCompiler().reportCodeChange();
        }
        break;
 
       case Token.FUNCTION:
         // Remove the function body scope
         // Remove function recursive name (if any).
         nameStack.pop();
         break;
 
         // Note: The parameters and function body variables live in the
         // same scope, we introduce the scope when in the ""shouldTraverse""
         // visit of LP, but remove it when when we exit the function above.
 
       case Token.CATCH:
         // Remove catch except name from the stack of names.
        nameStack.pop();
        break;
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    switch (n.getType()) {
        case Token.NAME: {
            String newName = getReplacementName(n.getString());
            if (newName != null) {
                Renamer renamer = nameStack.peek();
                if (renamer.stripConstIfReplaced()) {
                    n.removeProp(Node.IS_CONSTANT_NAME);
                }
                n.setString(newName);
                t.getCompiler().reportCodeChange();
            }
            break;
        }
        case Token.FUNCTION: {
            // Ensure function scope is removed
            if (!nameStack.isEmpty()) {
                nameStack.pop();
            }
            break;
        }
        case Token.CATCH: {
            // Remove catch exception name from name stack
            if (!nameStack.isEmpty()) {
                nameStack.pop();
            }
            break;
        }
    }
}",0,0
74,Closure_54,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
           // then they are responsible for making sure that the object literal's
           // implicit prototype is set up appropriately. We just obey
           // the @extends tag.
           if (!qVar.isTypeInferred()) {
             // If the programmer has declared that F inherits from Super,
             // and they assign F.prototype to some arbitrary expression,
             // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.getType() == Token.EXPR_RESULT) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
      }

      if (inferred) {
        // Determining declaration for #2
        inferred = !(rhsValue != null &&
            rhsValue.getType() == Token.FUNCTION &&
            (info != null || !scope.isDeclared(qName, false)));
      }

      if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null &&
          rhsValue.getType() == Token.TRUE) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    if (ownerNode == null) {
        return; // Ensure ownerNode and ownerName are not null
    }
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild() != null ? n.getLastChild().getString() : null;
    Preconditions.checkArgument(qName != null && ownerName != null);

    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
        valueType = rhsValue.getJSType();
    }

    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            if (!qVar.isTypeInferred()) {
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }

    if (valueType == null) {
        if (parent.getType() == Token.EXPR_RESULT) {
            stubDeclarations.add(new StubDeclaration(
                n,
                t.getInput() != null && t.getInput().isExtern(),
                ownerName));
        }
        return;
    }

    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }

    if (inferred) {
        inferred = !(rhsValue != null &&
            rhsValue.getType() == Token.FUNCTION &&
            (info != null || !scope.isDeclared(qName, false)));
    }

    if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
            boolean isExtern = t.getInput() != null && t.getInput().isExtern();
            if ((!ownerType.hasOwnProperty(propName) ||
                   ownerType.isPropertyTypeInferred(propName)) &&
                  ((isExtern && !ownerType.isNativeObjectType()) ||
                   !ownerType.isInstanceType())) {
                ownerType.defineDeclaredProperty(propName, valueType, n);
            }
        }
        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {
        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
            JSType ownerTypeOfThis = ownerType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ?
                null : typeRegistry.getType(delegateName);
            if (delegateType != null &&
                ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}",0,0
74,Closure_54,"public void setPrototypeBasedOn(ObjectType baseType) {
    // This is a bit weird. We need to successfully handle these
    // two cases:
    // Foo.prototype = new Bar();
    // and
    // Foo.prototype = {baz: 3};
    // In the first case, we do not want new properties to get
    // added to Bar. In the second case, we do want new properties
    // to get added to the type of the anonymous object.
    //
    // We handle this by breaking it into two cases:
    //
    // In the first case, we create a new PrototypeObjectType and set
    // its implicit prototype to the type being assigned. This ensures
    // that Bar will not get any properties of Foo.prototype, but properties
    // later assigned to Bar will get inherited properly.
     //
     // In the second case, we just use the anonymous object as the prototype.
     if (baseType.hasReferenceName() ||
         baseType.isUnknownType() ||
         isNativeObjectType() ||
         baseType.isFunctionPrototypeType() ||
         !(baseType instanceof PrototypeObjectType)) {

      baseType = new PrototypeObjectType(
          registry, this.getReferenceName() + "".prototype"", baseType);
    }
    setPrototype((PrototypeObjectType) baseType);
  }","public void setPrototypeBasedOn(ObjectType baseType) {
    if (baseType == null) {
        return; // Ensure baseType is not null
    }
    if (baseType.hasReferenceName() ||
        baseType.isUnknownType() ||
        isNativeObjectType() ||
        baseType.isFunctionPrototypeType() ||
        !(baseType instanceof PrototypeObjectType)) {

        baseType = new PrototypeObjectType(
            registry, this.getReferenceName() + "".prototype"", baseType);
    }
    if (baseType instanceof PrototypeObjectType) {
        setPrototype((PrototypeObjectType) baseType);
    }
}",0,0
74,Closure_54,"public boolean setPrototype(PrototypeObjectType prototype) {
    if (prototype == null) {
      return false;
    }
    // getInstanceType fails if the function is not a constructor
    if (isConstructor() && prototype == getInstanceType()) {
       return false;
     }
 
     boolean replacedPrototype = prototype != null;
 
     this.prototype = prototype;
     this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
     this.prototype.setOwnerFunction(this);
 
       // Disassociating the old prototype makes this easier to debug--
       // we don't have to worry about two prototypes running around.
 
     if (isConstructor() || isInterface()) {
       FunctionType superClass = getSuperClassConstructor();
      if (superClass != null) {
        superClass.addSubType(this);
      }

      if (isInterface()) {
        for (ObjectType interfaceType : getExtendedInterfaces()) {
          if (interfaceType.getConstructor() != null) {
            interfaceType.getConstructor().addSubType(this);
          }
        }
      }
    }

    if (replacedPrototype) {
      clearCachedValues();
    }

    return true;
  }","public boolean setPrototype(PrototypeObjectType prototype) {
    if (prototype == null) {
        return false;
    }

    if (isConstructor() && prototype == getInstanceType()) {
        return false;
    }

    boolean replacedPrototype = this.prototype != null;

    this.prototype = prototype;
    this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
    this.prototype.setOwnerFunction(this);

    if (isConstructor() || isInterface()) {
        FunctionType superClass = getSuperClassConstructor();
        if (superClass != null) {
            superClass.addSubType(this);
        }

        if (isInterface()) {
            for (ObjectType interfaceType : getExtendedInterfaces()) {
                if (interfaceType != null && interfaceType.getConstructor() != null) {
                    interfaceType.getConstructor().addSubType(this);
                }
            }
        }
    }

    if (replacedPrototype) {
        clearCachedValues();
    }

    return true;
}",0,0
75,Closure_6,"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, Node owner, String propName) {
     // The NoType check is a hack to make typedefs work OK.
     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
       if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
         registerMismatch(rightType, leftType, null);
       } else {
       // Do not type-check interface methods, because we expect that
       // they will have dummy implementations that do not match the type
       // annotations.
      JSType ownerType = getJSType(owner);
      if (ownerType.isFunctionPrototypeType()) {
        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
        if (ownerFn.isInterface() &&
            rightType.isFunctionType() && leftType.isFunctionType()) {
          return true;
        }
      }

      mismatch(t, n,
          ""assignment to property "" + propName + "" of "" +
          getReadableJSTypeName(owner, true),
          rightType, leftType);
      }
      return false;
    }
    return true;
  }","boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            JSType ownerType = getJSType(owner);
            if (ownerType != null && ownerType.isFunctionPrototypeType()) {
                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
                if (ownerFn != null && ownerFn.isInterface() &&
                    rightType.isFunctionType() && leftType.isFunctionType()) {
                    return true;
                }
            }

            mismatch(t, n,
                ""assignment to property "" + propName + "" of "" +
                getReadableJSTypeName(owner, true),
                rightType, leftType);
        }
        return false;
    }
    return true;
}",0,0
75,Closure_6,"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, String msg) {
     if (!rightType.canAssignTo(leftType)) {
       if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
         registerMismatch(rightType, leftType, null);
       } else {
       mismatch(t, n, msg, rightType, leftType);
       }
       return false;
     }
     return true;
  }","boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, String msg) {
    if (rightType == null || leftType == null) {
        mismatch(t, n, msg, rightType, leftType);
        return false;
    }

    if (!rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}",0,0
76,Closure_60,"static TernaryValue getPureBooleanValue(Node n) {
    switch (n.getType()) {
      case Token.STRING:
        return TernaryValue.forBoolean(n.getString().length() > 0);

      case Token.NUMBER:
        return TernaryValue.forBoolean(n.getDouble() != 0);

      case Token.NOT:
        return getPureBooleanValue(n.getLastChild()).not();

      case Token.NULL:
      case Token.FALSE:
         return TernaryValue.FALSE;
 
       case Token.VOID:
           return TernaryValue.FALSE;
 
       case Token.NAME:
         String name = n.getString();
        if (""undefined"".equals(name)
            || ""NaN"".equals(name)) {
          // We assume here that programs don't change the value of the keyword
          // undefined to something other than the value undefined.
          return TernaryValue.FALSE;
        } else if (""Infinity"".equals(name)) {
          return TernaryValue.TRUE;
        }
        break;

      case Token.TRUE:
      case Token.REGEXP:
        return TernaryValue.TRUE;

      case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        if (!mayHaveSideEffects(n)) {
          return TernaryValue.TRUE;
        }
        break;
    }

    return TernaryValue.UNKNOWN;
  }","static TernaryValue getPureBooleanValue(Node n) {
    switch (n.getType()) {
        case Token.STRING:
            return TernaryValue.forBoolean(n.getString().length() > 0);
            
        case Token.NUMBER:
            return TernaryValue.forBoolean(!Double.isNaN(n.getDouble()) && n.getDouble() != 0);

        case Token.NOT:
            return getPureBooleanValue(n.getLastChild()).not();

        case Token.NULL:
        case Token.FALSE:
        case Token.VOID:
            return TernaryValue.FALSE;

        case Token.NAME:
            String name = n.getString();
            if (""undefined"".equals(name) || ""NaN"".equals(name)) {
                return TernaryValue.FALSE;
            } else if (""Infinity"".equals(name)) {
                return TernaryValue.TRUE;
            }
            return TernaryValue.UNKNOWN;

        case Token.TRUE:
        case Token.REGEXP:
            return TernaryValue.TRUE;

        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return mayHaveSideEffects(n) ? TernaryValue.UNKNOWN : TernaryValue.TRUE;

        default:
            return TernaryValue.UNKNOWN;
    }
}",0,0
76,Closure_60,"static TernaryValue getImpureBooleanValue(Node n) {
    switch (n.getType()) {
      case Token.ASSIGN:
      case Token.COMMA:
        // For ASSIGN and COMMA the value is the value of the RHS.
        return getImpureBooleanValue(n.getLastChild());
      case Token.NOT:
        TernaryValue value = getImpureBooleanValue(n.getLastChild());
        return value.not();
      case Token.AND: {
        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
        return lhs.and(rhs);
      }
      case Token.OR:  {
        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
        return lhs.or(rhs);
      }
      case Token.HOOK:  {
        TernaryValue trueValue = getImpureBooleanValue(
            n.getFirstChild().getNext());
        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
        if (trueValue.equals(falseValue)) {
          return trueValue;
        } else {
          return TernaryValue.UNKNOWN;
        }
      }
      case Token.ARRAYLIT:
      case Token.OBJECTLIT:
         // ignoring side-effects
         return TernaryValue.TRUE;
 
 
       default:
         return getPureBooleanValue(n);
    }
  }","static TernaryValue getImpureBooleanValue(Node n) {
    switch (n.getType()) {
        case Token.ASSIGN:
        case Token.COMMA:
            return getImpureBooleanValue(n.getLastChild());

        case Token.NOT:
            TernaryValue value = getImpureBooleanValue(n.getLastChild());
            return value.not();

        case Token.AND: {
            TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
            TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
            return lhs.and(rhs);
        }

        case Token.OR: {
            TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
            TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
            return lhs.or(rhs);
        }

        case Token.HOOK: {
            TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());
            TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
            return trueValue.equals(falseValue) ? trueValue : TernaryValue.UNKNOWN;
        }

        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return mayHaveSideEffects(n) ? TernaryValue.UNKNOWN : TernaryValue.TRUE;

        default:
            return getPureBooleanValue(n);
    }
}",0,0
77,Closure_64,"public void toSource(final CodeBuilder cb,
                       final int inputSeqNum,
                       final Node root) {
    runInCompilerThread(new Callable<Void>() {
      public Void call() throws Exception {
        if (options.printInputDelimiter) {
          if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
            cb.append(""\n"");  // Make sure that the label starts on a new line
          }
          Preconditions.checkState(root.getType() == Token.SCRIPT);

          String delimiter = options.inputDelimiter;

          String sourceName = (String)root.getProp(Node.SOURCENAME_PROP);
          Preconditions.checkState(sourceName != null);
          Preconditions.checkState(!sourceName.isEmpty());

          delimiter = delimiter.replaceAll(""%name%"", sourceName)
            .replaceAll(""%num%"", String.valueOf(inputSeqNum));

          cb.append(delimiter)
            .append(""\n"");
        }
        if (root.getJSDocInfo() != null &&
            root.getJSDocInfo().getLicense() != null) {
          cb.append(""/*\n"")
            .append(root.getJSDocInfo().getLicense())
            .append(""*/\n"");
        }

        // If there is a valid source map, then indicate to it that the current
        // root node's mappings are offset by the given string builder buffer.
        if (options.sourceMapOutputPath != null) {
          sourceMap.setStartingPosition(
              cb.getLineIndex(), cb.getColumnIndex());
        }
 
         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
         // for the first input file
         String code = toSource(root, sourceMap);
         if (!code.isEmpty()) {
           cb.append(code);
 
          // In order to avoid parse ambiguity when files are concatenated
          // together, all files should end in a semi-colon. Do a quick
          // heuristic check if there's an obvious semi-colon already there.
          int length = code.length();
          char lastChar = code.charAt(length - 1);
          char secondLastChar = length >= 2 ?
              code.charAt(length - 2) : '\0';
          boolean hasSemiColon = lastChar == ';' ||
              (lastChar == '\n' && secondLastChar == ';');
          if (!hasSemiColon) {
            cb.append("";"");
          }
        }
        return null;
      }
    });
  }","public void toSource(final CodeBuilder cb,
                       final int inputSeqNum,
                       final Node root) {
    runInCompilerThread(new Callable<Void>() {
      public Void call() throws Exception {
        if (options.printInputDelimiter) {
          if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
            cb.append(""\n"");  // Make sure that the label starts on a new line
          }
          Preconditions.checkState(root.getType() == Token.SCRIPT);

          String delimiter = options.inputDelimiter;

          String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);
          Preconditions.checkState(sourceName != null);
          Preconditions.checkState(!sourceName.isEmpty());

          delimiter = delimiter.replace(""%name%"", sourceName)
                               .replace(""%num%"", String.valueOf(inputSeqNum));

          cb.append(delimiter)
            .append(""\n"");
        }
        if (root.getJSDocInfo() != null &&
            root.getJSDocInfo().getLicense() != null) {
          cb.append(""/*\n"")
            .append(root.getJSDocInfo().getLicense())
            .append(""\n*/\n"");
        }

        // If there is a valid source map, then indicate to it that the current
        // root node's mappings are offset by the given string builder buffer.
        if (options.sourceMapOutputPath != null && sourceMap != null) {
          sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
        }

        // Convert the root node to source code
        String code = toSource(root, sourceMap);
        if (!code.isEmpty()) {
          cb.append(code);

          // In order to avoid parse ambiguity when files are concatenated
          // together, all files should end in a semi-colon. Do a quick
          // heuristic check if there's an obvious semi-colon already there.
          int length = code.length();
          char lastChar = code.charAt(length - 1);
          char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
          boolean hasSemiColon = lastChar == ';' ||
              (lastChar == '\n' && secondLastChar == ';');
          if (!hasSemiColon) {
            cb.append("";"");
          }
        }
        return null;
      }
    });
  }",0,0
78,Closure_68,"private Node parseFunctionType(JsDocToken token) {
     // NOTE(nicksantos): We're not implementing generics at the moment, so
     // just throw out TypeParameters.
     if (token != JsDocToken.LP) {
       return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
     }
 
    Node functionType = newNode(Token.FUNCTION);
    Node parameters = null;
    skipEOLs();
    if (!match(JsDocToken.RP)) {
      token = next();

      boolean hasParams = true;
      if (token == JsDocToken.STRING) {
        String tokenStr = stream.getString();
        boolean isThis = ""this"".equals(tokenStr);
        boolean isNew = ""new"".equals(tokenStr);
        if (isThis || isNew) {
          if (match(JsDocToken.COLON)) {
            next();
            skipEOLs();
            Node contextType = wrapNode(
                isThis ? Token.THIS : Token.NEW,
                parseTypeName(next()));
            if (contextType == null) {
              return null;
            }

            functionType.addChildToFront(contextType);
          } else {
            return reportTypeSyntaxWarning(""msg.jsdoc.missing.colon"");
          }

          if (match(JsDocToken.COMMA)) {
            next();
            skipEOLs();
            token = next();
          } else {
            hasParams = false;
          }
        }
      }

      if (hasParams) {
        parameters = parseParametersType(token);
        if (parameters == null) {
          return null;
        }
      }
    }

    if (parameters != null) {
      functionType.addChildToBack(parameters);
    }

    skipEOLs();
    if (!match(JsDocToken.RP)) {
      return reportTypeSyntaxWarning(""msg.jsdoc.missing.rp"");
    }

    skipEOLs();
    Node resultType = parseResultType(next());
    if (resultType == null) {
      return null;
    } else {
      functionType.addChildToBack(resultType);
    }
    return functionType;
  }","private Node parseFunctionType(JsDocToken token) {
    if (token != JsDocToken.LP) {
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
    }

    Node functionType = newNode(Token.FUNCTION);
    Node parameters = null;
    skipEOLs();

    if (!match(JsDocToken.RP)) {
        token = next();

        boolean hasParams = true;
        if (token == JsDocToken.STRING) {
            String tokenStr = stream.getString();
            boolean isThis = ""this"".equals(tokenStr);
            boolean isNew = ""new"".equals(tokenStr);
            if (isThis || isNew) {
                if (match(JsDocToken.COLON)) {
                    next();
                    skipEOLs();
                    Node contextType = wrapNode(
                        isThis ? Token.THIS : Token.NEW,
                        parseTypeName(next()));
                    if (contextType == null) {
                        return null;
                    }
                    functionType.addChildToFront(contextType);
                } else {
                    return reportTypeSyntaxWarning(""msg.jsdoc.missing.colon"");
                }

                if (match(JsDocToken.COMMA)) {
                    next();
                    skipEOLs();
                    token = next();
                } else {
                    hasParams = false;
                }
            }
        }

        if (hasParams) {
            parameters = parseParametersType(token);
            if (parameters == null) {
                return null;
            }
        }
    }

    if (parameters != null) {
        functionType.addChildToBack(parameters);
    }

    skipEOLs();
    if (!match(JsDocToken.RP)) {
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.rp"");
    }

    skipEOLs();
    Node resultType = parseResultType(next());
    if (resultType == null) {
        return null;
    } else {
        functionType.addChildToBack(resultType);
    }
    return functionType;
}",0,0
78,Closure_68,"private Node parseBasicTypeExpression(JsDocToken token) {
    if (token == JsDocToken.STAR) {
      return newNode(Token.STAR);
    } else if (token == JsDocToken.LB) {
      skipEOLs();
      return parseArrayType(next());
    } else if (token == JsDocToken.LC) {
      skipEOLs();
      return parseRecordType(next());
    } else if (token == JsDocToken.LP) {
      skipEOLs();
      return parseUnionType(next());
    } else if (token == JsDocToken.STRING) {
      String string = stream.getString();
      if (""function"".equals(string)) {
        skipEOLs();
        return parseFunctionType(next());
      } else if (""null"".equals(string) || ""undefined"".equals(string)) {
        return newStringNode(string);
      } else {
        return parseTypeName(token);
       }
     }
 
     return reportGenericTypeSyntaxWarning();
   }","private Node parseBasicTypeExpression(JsDocToken token) {
    if (token == JsDocToken.STAR) {
        return newNode(Token.STAR);
    } else if (token == JsDocToken.LB) {
        skipEOLs();
        return parseArrayType(next());
    } else if (token == JsDocToken.LC) {
        skipEOLs();
        return parseRecordType(next());
    } else if (token == JsDocToken.LP) {
        skipEOLs();
        return parseUnionType(next());
    } else if (token == JsDocToken.STRING) {
        String string = stream.getString();
        if (""function"".equals(string)) {
            skipEOLs();
            return parseFunctionType(next());
        } else if (""null"".equals(string) || ""undefined"".equals(string)) {
            return newStringNode(string);
        } else {
            return parseTypeName(token);
        }
    }

    return reportGenericTypeSyntaxWarning();
}",0,0
78,Closure_68,"boolean parse() {
    int lineno;
    int charno;

    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;

    state = State.SEARCHING_ANNOTATION;
    skipEOLs();

    JsDocToken token = next();

    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();

    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
      ExtractionInfo blockInfo = extractBlockComment(token);
      token = blockInfo.token;
      if (!blockInfo.string.isEmpty()) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
      }
    } else {
      if (token != JsDocToken.ANNOTATION &&
          token != JsDocToken.EOC) {
        // Mark that there was a description, but don't bother marking
        // what it was.
        jsdocBuilder.recordBlockDescription("""");
      }
    }

    // Parse the actual JsDoc.
    retry: for (;;) {
      switch (token) {
        case ANNOTATION:
          if (state == State.SEARCHING_ANNOTATION) {
            state = State.SEARCHING_NEWLINE;
            lineno = stream.getLineno();
            charno = stream.getCharno();

            String annotationName = stream.getString();
            Annotation annotation = annotationNames.get(annotationName);
            if (annotation == null) {
              parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName,
                  stream.getLineno(), stream.getCharno());
            } else {
              // Mark the beginning of the annotation.
              jsdocBuilder.markAnnotation(annotationName, lineno, charno);

              switch (annotation) {
                case AUTHOR:
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo authorInfo = extractSingleLineBlock();
                    String author = authorInfo.string;

                    if (author.length() == 0) {
                      parser.addParserWarning(""msg.jsdoc.authormissing"",
                          stream.getLineno(), stream.getCharno());
                    } else {
                      jsdocBuilder.addAuthor(author);
                    }
                    token = authorInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }
                  continue retry;

                case CONSTANT:
                  if (!jsdocBuilder.recordConstancy()) {
                    parser.addParserWarning(""msg.jsdoc.const"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case CONSTRUCTOR:
                  if (!jsdocBuilder.recordConstructor()) {
                    if (jsdocBuilder.isInterfaceRecorded()) {
                      parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
                          stream.getLineno(), stream.getCharno());
                    } else {
                      parser.addTypeWarning(""msg.jsdoc.incompat.type"",
                          stream.getLineno(), stream.getCharno());
                    }
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case DEPRECATED:
                  if (!jsdocBuilder.recordDeprecated()) {
                    parser.addParserWarning(""msg.jsdoc.deprecated"",
                        stream.getLineno(), stream.getCharno());
                  }

                  // Find the reason/description, if any.
                  ExtractionInfo reasonInfo =
                      extractMultilineTextualBlock(token);

                  String reason = reasonInfo.string;

                  if (reason.length() > 0) {
                    jsdocBuilder.recordDeprecationReason(reason);
                  }

                  token = reasonInfo.token;
                  continue retry;

                case INTERFACE:
                  if (!jsdocBuilder.recordInterface()) {
                    if (jsdocBuilder.isConstructorRecorded()) {
                      parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
                          stream.getLineno(), stream.getCharno());
                    } else {
                      parser.addTypeWarning(""msg.jsdoc.incompat.type"",
                          stream.getLineno(), stream.getCharno());
                    }
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case DESC:
                  if (jsdocBuilder.isDescriptionRecorded()) {
                    parser.addParserWarning(""msg.jsdoc.desc.extra"",
                        stream.getLineno(), stream.getCharno());
                    token = eatTokensUntilEOL();
                    continue retry;
                  } else {
                    ExtractionInfo descriptionInfo =
                        extractMultilineTextualBlock(token);

                    String description = descriptionInfo.string;

                    jsdocBuilder.recordDescription(description);
                    token = descriptionInfo.token;
                    continue retry;
                  }

                case FILE_OVERVIEW:
                  String fileOverview = """";
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo fileOverviewInfo =
                        extractMultilineTextualBlock(token,
                            WhitespaceOption.TRIM);

                    fileOverview = fileOverviewInfo.string;

                    token = fileOverviewInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }

                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||
                      fileOverviewJSDocInfo != null) {
                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"",
                        stream.getLineno(), stream.getCharno());
                  }
                  continue retry;

                case LICENSE:
                case PRESERVE:
                  ExtractionInfo preserveInfo =
                      extractMultilineTextualBlock(token,
                                                   WhitespaceOption.PRESERVE);

                  String preserve = preserveInfo.string;

                  if (preserve.length() > 0) {
                    if (fileLevelJsDocBuilder != null) {
                      fileLevelJsDocBuilder.append(preserve);
                    }
                  }

                  token = preserveInfo.token;
                  continue retry;

                case ENUM:
                  token = next();
                  lineno = stream.getLineno();
                  charno = stream.getCharno();

                  type = null;
                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                    type = createJSTypeExpression(
                        parseAndRecordTypeNode(token));
                  }

                  if (type == null) {
                    type = createJSTypeExpression(newStringNode(""number""));
                  }
                  if (!jsdocBuilder.recordEnumParameterType(type)) {
                    parser.addTypeWarning(
                        ""msg.jsdoc.incompat.type"", lineno, charno);
                  }
                  token = eatTokensUntilEOL(token);
                  continue retry;

                case EXPORT:
                  if (!jsdocBuilder.recordExport()) {
                    parser.addParserWarning(""msg.jsdoc.export"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case EXTERNS:
                  if (!jsdocBuilder.recordExterns()) {
                    parser.addParserWarning(""msg.jsdoc.externs"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case JAVA_DISPATCH:
                  if (!jsdocBuilder.recordJavaDispatch()) {
                    parser.addParserWarning(""msg.jsdoc.javadispatch"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case EXTENDS:
                case IMPLEMENTS:
                  skipEOLs();
                  token = next();
                  lineno = stream.getLineno();
                  charno = stream.getCharno();
                  boolean matchingRc = false;

                  if (token == JsDocToken.LC) {
                    token = next();
                    matchingRc = true;
                  }

                  if (token == JsDocToken.STRING) {
                    Node typeNode = parseAndRecordTypeNameNode(
                        token, lineno, charno, matchingRc);

                    lineno = stream.getLineno();
                    charno = stream.getCharno();

                    typeNode = wrapNode(Token.BANG, typeNode);
                    if (typeNode != null && !matchingRc) {
                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                    }
                    type = createJSTypeExpression(typeNode);

                    if (annotation == Annotation.EXTENDS) {
                      // record the extended type, check later
                      extendedTypes.add(new ExtendedTypeInfo(
                          type, stream.getLineno(), stream.getCharno()));
                    } else {
                      Preconditions.checkState(
                          annotation == Annotation.IMPLEMENTS);
                      if (!jsdocBuilder.recordImplementedInterface(type)) {
                        parser.addTypeWarning(""msg.jsdoc.implements.duplicate"",
                            lineno, charno);
                      }
                    }
                    token = next();
                    if (matchingRc) {
                      if (token != JsDocToken.RC) {
                        parser.addTypeWarning(""msg.jsdoc.missing.rc"",
                            stream.getLineno(), stream.getCharno());
                      }
                    } else if (token != JsDocToken.EOL &&
                        token != JsDocToken.EOF && token != JsDocToken.EOC) {
                      parser.addTypeWarning(""msg.end.annotation.expected"",
                          stream.getLineno(), stream.getCharno());
                    }
                  } else {
                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                  }
                  token = eatTokensUntilEOL(token);
                  continue retry;

                case HIDDEN:
                  if (!jsdocBuilder.recordHiddenness()) {
                    parser.addParserWarning(""msg.jsdoc.hidden"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case LENDS:
                  skipEOLs();

                  matchingRc = false;
                  if (match(JsDocToken.LC)) {
                    token = next();
                    matchingRc = true;
                  }

                  if (match(JsDocToken.STRING)) {
                    token = next();
                    if (!jsdocBuilder.recordLends(stream.getString())) {
                      parser.addTypeWarning(""msg.jsdoc.lends.incompatible"",
                          stream.getLineno(), stream.getCharno());
                    }
                  } else {
                    parser.addTypeWarning(""msg.jsdoc.lends.missing"",
                        stream.getLineno(), stream.getCharno());
                  }

                  if (matchingRc && !match(JsDocToken.RC)) {
                    parser.addTypeWarning(""msg.jsdoc.missing.rc"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case MEANING:
                  ExtractionInfo meaningInfo =
                      extractMultilineTextualBlock(token);
                  String meaning = meaningInfo.string;
                  token = meaningInfo.token;
                  if (!jsdocBuilder.recordMeaning(meaning)) {
                    parser.addParserWarning(""msg.jsdoc.meaning.extra"",
                        stream.getLineno(), stream.getCharno());
                  }
                  continue retry;

                case NO_ALIAS:
                  if (!jsdocBuilder.recordNoAlias()) {
                    parser.addParserWarning(""msg.jsdoc.noalias"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NO_COMPILE:
                  if (!jsdocBuilder.recordNoCompile()) {
                    parser.addParserWarning(""msg.jsdoc.nocompile"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NO_TYPE_CHECK:
                  if (!jsdocBuilder.recordNoTypeCheck()) {
                    parser.addParserWarning(""msg.jsdoc.nocheck"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NOT_IMPLEMENTED:
                  token = eatTokensUntilEOL();
                  continue retry;

                case INHERIT_DOC:
                case OVERRIDE:
                  if (!jsdocBuilder.recordOverride()) {
                    parser.addTypeWarning(""msg.jsdoc.override"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case THROWS:
                  skipEOLs();
                  token = next();
                  lineno = stream.getLineno();
                  charno = stream.getCharno();
                  type = null;

                  if (token == JsDocToken.LC) {
                    type = createJSTypeExpression(
                        parseAndRecordTypeNode(token));

                    if (type == null) {
                      // parsing error reported during recursive descent
                      // recovering parsing
                      token = eatTokensUntilEOL();
                      continue retry;
                    }
                  }

                  // *Update* the token to that after the type annotation.
                  token = current();

                  // Save the throw type.
                  jsdocBuilder.recordThrowType(type);

                  // Find the throw's description (if applicable).
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo descriptionInfo =
                        extractMultilineTextualBlock(token);

                    String description = descriptionInfo.string;

                    if (description.length() > 0) {
                      jsdocBuilder.recordThrowDescription(type, description);
                    }

                    token = descriptionInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }
                  continue retry;

                case PARAM:
                  skipEOLs();
                  token = next();
                  lineno = stream.getLineno();
                  charno = stream.getCharno();
                  type = null;

                  if (token == JsDocToken.LC) {
                    type = createJSTypeExpression(
                        parseAndRecordParamTypeNode(token));

                    if (type == null) {
                      // parsing error reported during recursive descent
                      // recovering parsing
                      token = eatTokensUntilEOL();
                      continue retry;
                    }
                    skipEOLs();
                    token = next();
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                  }

                  String name = null;
                  boolean isBracketedParam = JsDocToken.LB == token;
                  if (isBracketedParam) {
                    token = next();
                  }

                  if (JsDocToken.STRING != token) {
                    parser.addTypeWarning(""msg.missing.variable.name"",
                        lineno, charno);
                  } else {
                    name = stream.getString();

                    if (isBracketedParam) {
                      token = next();

                      // Throw out JsDocToolkit's ""default"" parameter
                      // annotation.  It makes no sense under our type
                      // system.
                      if (JsDocToken.EQUALS == token) {
                        token = next();
                        if (JsDocToken.STRING == token) {
                          token = next();
                        }
                      }

                      if (JsDocToken.RB != token) {
                        reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                      } else if (type != null) {
                        // Make the type expression optional, if it isn't
                        // already.
                        type = JSTypeExpression.makeOptionalArg(type);
                      }
                    }

                    // If the param name has a DOT in it, just throw it out
                    // quietly. We do not handle the JsDocToolkit method
                    // for handling properties of params.
                    if (name.indexOf('.') > -1) {
                      name = null;
                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                      if (jsdocBuilder.hasParameter(name)) {
                        parser.addTypeWarning(""msg.dup.variable.name"", name,
                            lineno, charno);
                      } else {
                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", name,
                            lineno, charno);
                      }
                    }
                  }

                  if (name == null) {
                    token = eatTokensUntilEOL(token);
                    continue retry;
                  }

                  jsdocBuilder.markName(name, lineno, charno);

                  // Find the parameter's description (if applicable).
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo paramDescriptionInfo =
                        extractMultilineTextualBlock(token);

                    String paramDescription = paramDescriptionInfo.string;

                    if (paramDescription.length() > 0) {
                      jsdocBuilder.recordParameterDescription(name,
                          paramDescription);
                    }

                    token = paramDescriptionInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }
                  continue retry;

                case PRESERVE_TRY:
                  if (!jsdocBuilder.recordPreserveTry()) {
                    parser.addParserWarning(""msg.jsdoc.preservertry"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case PRIVATE:
                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                    parser.addParserWarning(""msg.jsdoc.visibility.private"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case PROTECTED:
                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                    parser.addParserWarning(""msg.jsdoc.visibility.protected"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case PUBLIC:
                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                    parser.addParserWarning(""msg.jsdoc.visibility.public"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NO_SHADOW:
                  if (!jsdocBuilder.recordNoShadow()) {
                    parser.addParserWarning(""msg.jsdoc.noshadow"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NO_SIDE_EFFECTS:
                  if (!jsdocBuilder.recordNoSideEffects()) {
                    parser.addParserWarning(""msg.jsdoc.nosideeffects"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case MODIFIES:
                  token = parseModifiesTag(next());
                  continue retry;

                case IMPLICIT_CAST:
                  if (!jsdocBuilder.recordImplicitCast()) {
                    parser.addTypeWarning(""msg.jsdoc.implicitcast"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case SEE:
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                    String reference = referenceInfo.string;

                    if (reference.length() == 0) {
                      parser.addParserWarning(""msg.jsdoc.seemissing"",
                          stream.getLineno(), stream.getCharno());
                    } else {
                      jsdocBuilder.addReference(reference);
                    }

                    token = referenceInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }
                  continue retry;

                case SUPPRESS:
                  token = parseSuppressTag(next());
                  continue retry;

                case TEMPLATE:
                  ExtractionInfo templateInfo = extractSingleLineBlock();
                  String templateTypeName = templateInfo.string;

                  if (templateTypeName.length() == 0) {
                    parser.addTypeWarning(""msg.jsdoc.templatemissing"",
                          stream.getLineno(), stream.getCharno());
                  } else if (!jsdocBuilder.recordTemplateTypeName(
                      templateTypeName)) {
                    parser.addTypeWarning(""msg.jsdoc.template.at.most.once"",
                        stream.getLineno(), stream.getCharno());
                  }

                  token = templateInfo.token;
                  continue retry;

                case VERSION:
                  ExtractionInfo versionInfo = extractSingleLineBlock();
                  String version = versionInfo.string;

                  if (version.length() == 0) {
                    parser.addParserWarning(""msg.jsdoc.versionmissing"",
                          stream.getLineno(), stream.getCharno());
                  } else {
                    if (!jsdocBuilder.recordVersion(version)) {
                       parser.addParserWarning(""msg.jsdoc.extraversion"",
                          stream.getLineno(), stream.getCharno());
                    }
                  }

                  token = versionInfo.token;
                  continue retry;

                case DEFINE:
                case RETURN:
                case THIS:
                case TYPE:
                case TYPEDEF:
                  lineno = stream.getLineno();
                  charno = stream.getCharno();

                  Node typeNode = null;
                  if (!lookAheadForTypeAnnotation() &&
                      annotation == Annotation.RETURN) {
                    // If RETURN doesn't have a type annotation, record
                    // it as the unknown type.
                    typeNode = newNode(Token.QMARK);
                  } else {
                    skipEOLs();
                    token = next();
                    typeNode = parseAndRecordTypeNode(token, lineno, charno);
                  }

                  if (annotation == Annotation.THIS) {
                    typeNode = wrapNode(Token.BANG, typeNode);
                    if (typeNode != null && token != JsDocToken.LC) {
                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                    }
                  }
                  type = createJSTypeExpression(typeNode);

                  if (type == null) {
                    // error reported during recursive descent
                    // recovering parsing
                  } else {
                    switch (annotation) {
                      case DEFINE:
                        if (!jsdocBuilder.recordDefineType(type)) {
                          parser.addParserWarning(""msg.jsdoc.define"",
                              lineno, charno);
                        }
                        break;

                      case RETURN:
                        if (!jsdocBuilder.recordReturnType(type)) {
                          parser.addTypeWarning(
                              ""msg.jsdoc.incompat.type"", lineno, charno);
                          break;
                        }

                        // Find the return's description (if applicable).
                        if (jsdocBuilder.shouldParseDocumentation()) {
                          ExtractionInfo returnDescriptionInfo =
                              extractMultilineTextualBlock(token);

                          String returnDescription =
                              returnDescriptionInfo.string;

                          if (returnDescription.length() > 0) {
                            jsdocBuilder.recordReturnDescription(
                                returnDescription);
                          }

                          token = returnDescriptionInfo.token;
                        } else {
                          token = eatTokensUntilEOL(token);
                        }
                        continue retry;

                      case THIS:
                        if (!jsdocBuilder.recordThisType(type)) {
                          parser.addTypeWarning(
                              ""msg.jsdoc.incompat.type"", lineno, charno);
                        }
                        break;

                      case TYPE:
                        if (!jsdocBuilder.recordType(type)) {
                          parser.addTypeWarning(
                              ""msg.jsdoc.incompat.type"", lineno, charno);
                        }
                        break;

                      case TYPEDEF:
                        if (!jsdocBuilder.recordTypedef(type)) {
                          parser.addTypeWarning(
                              ""msg.jsdoc.incompat.type"", lineno, charno);
                         }
                         break;
                     }
 
                   token = eatTokensUntilEOL();
                   }
                   continue retry;
               }
             }
          }
          break;

        case EOC:
          if (hasParsedFileOverviewDocInfo()) {
            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
          }
          checkExtendedTypes(extendedTypes);
          return true;

        case EOF:
          // discard any accumulated information
          jsdocBuilder.build(null);
          parser.addParserWarning(""msg.unexpected.eof"",
              stream.getLineno(), stream.getCharno());
          checkExtendedTypes(extendedTypes);
          return false;

        case EOL:
          if (state == State.SEARCHING_NEWLINE) {
            state = State.SEARCHING_ANNOTATION;
          }
          token = next();
          continue retry;

        default:
          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
            token = next();
            continue retry;
          } else {
            state = State.SEARCHING_NEWLINE;
            token = eatTokensUntilEOL();
            continue retry;
          }
      }

      // next token
      token = next();
    }
  }","boolean parse() {
    int lineno;
    int charno;

    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();

    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();

    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            jsdocBuilder.recordBlockDescription("""");
        }
    }

    retry: for (;;) {
        switch (token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();

                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, lineno, charno);
                    } else {
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);

                        JsDocToken resultToken = processAnnotation(annotation, token);
                        if (resultToken != null) {
                            token = resultToken;
                            continue retry;
                        }
                    }
                }
                break;

            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;

            case EOF:
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;

            default:
                token = handleDefaultToken(token);
                continue retry;
        }

        token = next();
    }
}

// Helper function used in Fixed Method 3
private JsDocToken processAnnotation(Annotation annotation, JsDocToken token) {
    switch (annotation) {
        case AUTHOR:
            return processAuthorAnnotation(token);

        case CONSTANT:
            processConstancyAnnotation();
            return eatTokensUntilEOL();

        case CONSTRUCTOR:
            processConstructorAnnotation();
            return eatTokensUntilEOL();

        case DEPRECATED:
            return processDeprecatedAnnotation(token);

        case INTERFACE:
            processInterfaceAnnotation();
            return eatTokensUntilEOL();

        // Handle other annotations similarly...

        default:
            return null;
    }
}

// Example handling for AUTHOR annotation
private JsDocToken processAuthorAnnotation(JsDocToken token) {
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo authorInfo = extractSingleLineBlock();
        String author = authorInfo.string;
        if (author.isEmpty()) {
            parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
        } else {
            jsdocBuilder.addAuthor(author);
        }
        return authorInfo.token;
    } else {
        return eatTokensUntilEOL(token);
    }
}

// Example for handling default tokens
private JsDocToken handleDefaultToken(JsDocToken token) {
    if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
        return next();
    } else {
        state = State.SEARCHING_NEWLINE;
        return eatTokensUntilEOL(token);
    }
}",0,0
79,Closure_72,"private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {
    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();
    // Make variable names unique to this instance.
    NodeTraversal.traverse(
        compiler, fnNode, new MakeDeclaredNamesUnique(
            new InlineRenamer(
                idSupplier,
                 ""inline_"",
                 isCallInLoop)));
     // Make label names unique to this instance.
   }","private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {
    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();
    // Validate input and ensure traversal context is correct.
    if (fnNode == null || idSupplier == null) {
        throw new IllegalArgumentException(""Invalid input arguments"");
    }

    // Make variable names unique to this instance.
    NodeTraversal.traverse(
        compiler, fnNode, new MakeDeclaredNamesUnique(
            new InlineRenamer(
                idSupplier,
                ""inline_"",
                isCallInLoop)));
    // Make label names unique to this instance.
}",0,0
79,Closure_72,"private void visitLabel(Node node, Node parent) {
      Node nameNode = node.getFirstChild();
      Preconditions.checkState(nameNode != null);
       String name = nameNode.getString();
       LabelInfo li = getLabelInfo(name);
       // This is a label...
       if (li.referenced) {
         String newName = getNameForId(li.id);
         if (!name.equals(newName)) {
           // ... and it is used, give it the short name.
          nameNode.setString(newName);
          compiler.reportCodeChange();
        }
      } else {
        // ... and it is not referenced, just remove it.
        Node newChild = node.getLastChild();
        node.removeChild(newChild);
        parent.replaceChild(node, newChild);
        if (newChild.getType() == Token.BLOCK) {
          NodeUtil.tryMergeBlock(newChild);
        }
        compiler.reportCodeChange();
      }

      // Remove the label from the current stack of labels.
      namespaceStack.peek().renameMap.remove(name);
    }","private void visitLabel(Node node, Node parent) {
    Node nameNode = node.getFirstChild();
    Preconditions.checkState(nameNode != null, ""Label node must have a name child."");
    String name = nameNode.getString();
    LabelInfo li = getLabelInfo(name);

    if (li != null) {
        // This is a label...
        if (li.referenced) {
            String newName = getNameForId(li.id);
            if (!name.equals(newName)) {
                // ... and it is used, give it the short name.
                nameNode.setString(newName);
                compiler.reportCodeChange();
            }
        } else {
            // ... and it is not referenced, just remove it.
            Node newChild = node.getLastChild();
            node.removeChild(newChild);
            parent.replaceChild(node, newChild);
            if (newChild.getType() == Token.BLOCK) {
                NodeUtil.tryMergeBlock(newChild);
            }
            compiler.reportCodeChange();
        }

        // Remove the label from the current stack of labels.
        Map<String, String> renameMap = namespaceStack.peek().renameMap;
        if (renameMap != null) {
            renameMap.remove(name);
        }
    } else {
        throw new IllegalStateException(""LabelInfo for label '"" + name + ""' is missing."");
    }
}",0,0
80,Closure_74,"@SuppressWarnings(""fallthrough"")
  private Node tryFoldComparison(Node n, Node left, Node right) {
    if (!NodeUtil.isLiteralValue(left, false) ||
        !NodeUtil.isLiteralValue(right, false)) {
      // We only handle non-literal operands for LT and GT.
      if (n.getType() != Token.GT && n.getType() != Token.LT) {
        return n;
      }
    }

    int op = n.getType();
    boolean result;

    // TODO(johnlenz): Use the JSType to compare nodes of different types.

    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType()
           && right.getString().equals(""undefined""))
           || (Token.VOID == right.getType()
               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
     int lhType = left.getType();
     int rhType = right.getType();
     switch (lhType) {
       case Token.VOID:
         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of ""this"" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals(""undefined""));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }

    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
    reportCodeChange();

    return newNode;
  }","@SuppressWarnings(""fallthrough"")
private Node tryFoldComparison(Node n, Node left, Node right) {
    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {
        // We only handle non-literal operands for LT and GT.
        if (n.getType() != Token.GT && n.getType() != Token.LT) {
            return n;
        }
    }

    int op = n.getType();
    Boolean result = null; // Use null to represent undefined results

    // TODO(johnlenz): Use the JSType to compare nodes of different types.

    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType() && ""undefined"".equals(right.getString()))
            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();

    switch (lhType) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
                return n;
            } else if (!rightLiteral) {
                return n;
            } else {
                result = compareToUndefined(right, op);
            }
            break;

        case Token.NULL:
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {
                return n;
            }
            switch (op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = lhType == rhType;
                    break;

                case Token.SHNE:
                case Token.NE:
                    result = lhType != rhType;
                    break;

                case Token.GE:
                case Token.LE:
                case Token.GT:
                case Token.LT:
                    Boolean compareResult = compareAsNumbers(op, left, right);
                    result = compareResult != null ? compareResult : null; // Preserve null result
                    break;

                default:
                    return n; // unsupported op
            }
            break;

        case Token.THIS:
            if (right.getType() != Token.THIS) {
                return n;
            }
            switch (op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = true;
                    break;

                case Token.SHNE:
                case Token.NE:
                    result = false;
                    break;

                default:
                    return n; // unsupported op
            }
            break;

        case Token.STRING:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.STRING != right.getType()) {
                return n; // Only compare if both are strings
            }
            switch (op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;

                case Token.SHNE:
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;

                default:
                    return n; // unsupported op
            }
            break;

        case Token.NUMBER:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.NUMBER != right.getType()) {
                return n; // Only compare if both are numbers
            }
            Boolean compareResult = compareAsNumbers(op, left, right);
            result = compareResult != null ? compareResult : null; // Preserve null result
            break;

        case Token.NAME:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }

            if (rightLiteral) {
                boolean undefinedLeft = ""undefined"".equals(left.getString());
                if (undefinedLeft) {
                    result = compareToUndefined(right, op);
                    break;
                }
            }

            if (Token.NAME != right.getType()) {
                return n; // Only compare if both are NAME tokens
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                return n; // Names do not match
            }

            switch (op) {
                case Token.LT:
                case Token.GT:
                    result = false; // Names cannot be compared with LT or GT
                    break;

                default:
                    return n; // unsupported op
            }
            break;

        default:
            return n; // Unsupported type
    }

    if (result == null) {
        return n; // Preserve original node if result is undefined
    }

    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
    reportCodeChange();

    return newNode;
}",0,0
81,Closure_75,"static Double getStringNumberValue(String rawJsString) {
       // vertical tab is not always whitespace
 
     String s = trimJsWhiteSpace(rawJsString);
     // return ScriptRuntime.toNumber(s);
    if (s.length() == 0) {
      return 0.0;
    }

    if (s.length() > 2
        && s.charAt(0) == '0'
        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
      // Attempt to convert hex numbers.
      try {
        return Double.valueOf(Integer.parseInt(s.substring(2), 16));
      } catch (NumberFormatException e) {
        return Double.NaN;
      }
    }

    if (s.length() > 3
        && (s.charAt(0) == '-' || s.charAt(0) == '+')
        && s.charAt(1) == '0'
        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
      // hex numbers with explicit signs vary between browsers.
      return null;
    }

    // FireFox and IE treat the ""Infinity"" differently. FireFox is case
    // insensitive, but IE treats ""infinity"" as NaN.  So leave it alone.
    if (s.equals(""infinity"")
        || s.equals(""-infinity"")
        || s.equals(""+infinity"")) {
      return null;
    }

    try {
      return Double.parseDouble(s);
    } catch (NumberFormatException e) {
      return Double.NaN;
    }
  }","static Double getStringNumberValue(String rawJsString) {
    // vertical tab is not always whitespace
    String s = trimJsWhiteSpace(rawJsString);
    if (s.isEmpty()) { // Replaced s.length() == 0 with isEmpty()
        return 0.0;
    }

    if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
        // Attempt to convert hex numbers.
        try {
            return Double.valueOf(Integer.parseInt(s.substring(2), 16));
        } catch (NumberFormatException e) {
            return Double.NaN;
        }
    }

    if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0'
            && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
        // Hex numbers with explicit signs vary between browsers.
        return Double.NaN; // Changed from null to Double.NaN to better align with expected behavior
    }

    // FireFox and IE treat the ""Infinity"" differently. FireFox is case
    // insensitive, but IE treats ""infinity"" as NaN. So leave it alone.
    if (s.equalsIgnoreCase(""infinity"") || s.equalsIgnoreCase(""-infinity"") || s.equalsIgnoreCase(""+infinity"")) {
        // Ensured case-insensitive comparison using equalsIgnoreCase
        return Double.POSITIVE_INFINITY; // Changed from null to Double.POSITIVE_INFINITY
    }

    try {
        return Double.parseDouble(s);
    } catch (NumberFormatException e) {
        return Double.NaN;
    }
}",0,0
81,Closure_75,"static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
       case '\u000B': // <VT>
         return TernaryValue.TRUE;
       case ' ': // <SP>
       case '\n': // <LF>
       case '\r': // <CR>
      case '\t': // <TAB>
      case '\u00A0': // <NBSP>
      case '\u000C': // <FF>
      case '\u2028': // <LS>
      case '\u2029': // <PS>
      case '\uFEFF': // <BOM>
        return TernaryValue.TRUE;
      default:
        return (Character.getType(c) == Character.SPACE_SEPARATOR)
            ? TernaryValue.TRUE : TernaryValue.FALSE;
    }
  }","static TernaryValue isStrWhiteSpaceChar(int c) {
    switch (c) {
        case '\u000B': // <VT>
        case ' ': // <SP>
        case '\n': // <LF>
        case '\r': // <CR>
        case '\t': // <TAB>
        case '\u00A0': // <NBSP>
        case '\u000C': // <FF>
        case '\u2028': // <LS>
        case '\u2029': // <PS>
        case '\uFEFF': // <BOM>
            return TernaryValue.TRUE;
        default:
            try {
                return (Character.getType(c) == Character.SPACE_SEPARATOR) ? TernaryValue.TRUE : TernaryValue.FALSE;
            } catch (IllegalArgumentException e) {
                // Added handling for invalid character codes
                return TernaryValue.FALSE;
            }
    }
}",0,0
82,Closure_76,"private VariableLiveness isVariableReadBeforeKill(
      Node n, String variable) {

    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
      if (NodeUtil.isLhs(n, n.getParent())) {
        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
        // The expression to which the assignment is made is evaluated before
        // the RHS is evaluated (normal left to right evaluation) but the KILL
        // occurs after the RHS is evaluated.
        Node rhs = n.getNext();
        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
        if (state == VariableLiveness.READ) {
          return state;
        }
        return VariableLiveness.KILL;
      } else {
        return VariableLiveness.READ;
      }
    }

    switch (n.getType()) {
       // Conditionals
       case Token.OR:
       case Token.AND:
         // With a AND/OR the first branch always runs, but the second is
         // may not.
       case Token.HOOK:
         return checkHookBranchReadBeforeKill(
             n.getFirstChild().getNext(), n.getLastChild(), variable);
 
      default:
        // Expressions are evaluated left-right, depth first.
        for (Node child = n.getFirstChild();
            child != null; child = child.getNext()) {
          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
          VariableLiveness state = isVariableReadBeforeKill(child, variable);
          if (state != VariableLiveness.MAYBE_LIVE) {
            return state;
          }
        }
      }
    }

    return VariableLiveness.MAYBE_LIVE;
  }","private VariableLiveness isVariableReadBeforeKill(
      Node n, String variable) {

    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
      if (NodeUtil.isLhs(n, n.getParent())) {
        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
        // The expression to which the assignment is made is evaluated before
        // the RHS is evaluated (normal left to right evaluation) but the KILL
        // occurs after the RHS is evaluated.
        Node rhs = n.getParent().getLastChild();
        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
        if (state == VariableLiveness.READ) {
          return state;
        }
        return VariableLiveness.KILL;
      } else {
        return VariableLiveness.READ;
      }
    }

    switch (n.getType()) {
      case Token.OR:
      case Token.AND:
        // With a AND/OR the first branch always runs, but the second may not.
        VariableLiveness leftState = isVariableReadBeforeKill(n.getFirstChild(), variable);
        if (leftState == VariableLiveness.READ || leftState == VariableLiveness.KILL) {
          return leftState;
        }
        return isVariableReadBeforeKill(n.getLastChild(), variable);
        
      case Token.HOOK:
        return checkHookBranchReadBeforeKill(
            n.getFirstChild().getNext(), n.getLastChild(), variable);

      default:
        // Expressions are evaluated left-right, depth first.
        for (Node child = n.getFirstChild();
            child != null; child = child.getNext()) {
          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
            VariableLiveness state = isVariableReadBeforeKill(child, variable);
            if (state != VariableLiveness.MAYBE_LIVE) {
              return state;
            }
          }
        }
    }

    return VariableLiveness.MAYBE_LIVE;
}",0,0
82,Closure_76,"private boolean isVariableStillLiveWithinExpression(
      Node n, Node exprRoot, String variable) {
    while (n != exprRoot) {
      VariableLiveness state = VariableLiveness.MAYBE_LIVE;
      switch (n.getParent().getType()) {
        case Token.OR:
        case Token.AND:
           // If the currently node is the first child of
           // AND/OR, be conservative only consider the READs
           // of the second operand.
 
         case Token.HOOK:
           // If current node is the condition, check each following
           // branch, otherwise it is a conditional branch and the
           // other branch can be ignored.
 
         default:
           for(Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
             if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
             state = isVariableReadBeforeKill(sibling, variable);
 
       // If we see a READ or KILL there is no need to continue.
       if (state == VariableLiveness.READ) {
         return true;
       } else if (state == VariableLiveness.KILL) {
         return false;
             }
           }
       }
       }
       n = n.getParent();
     }
    return false;
  }","private boolean isVariableStillLiveWithinExpression(
      Node n, Node exprRoot, String variable) {
    while (n != exprRoot) {
      VariableLiveness state = VariableLiveness.MAYBE_LIVE;
      switch (n.getParent().getType()) {
        case Token.OR:
        case Token.AND:
          // If the current node is the first child of AND/OR, ignore it,
          // only consider the reads in the second operand.
          if (n == n.getParent().getFirstChild()) {
            state = isVariableReadBeforeKill(n.getParent().getLastChild(), variable);
          }
          break;

        case Token.HOOK:
          // If current node is the condition, check both branches.
          if (n == n.getParent().getFirstChild()) {
            Node firstBranch = n.getParent().getFirstChild().getNext();
            Node secondBranch = n.getParent().getLastChild();
            state = isVariableReadBeforeKill(firstBranch, variable);
            if (state == VariableLiveness.MAYBE_LIVE) {
              state = isVariableReadBeforeKill(secondBranch, variable);
            }
          }
          break;

        default:
          for (Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
              state = isVariableReadBeforeKill(sibling, variable);

              // If we see a READ or KILL, there is no need to continue.
              if (state == VariableLiveness.READ) {
                return true;
              } else if (state == VariableLiveness.KILL) {
                return false;
              }
            }
          }
      }
      n = n.getParent();
    }
    return false;
}",0,0
83,Closure_79,"@Override
   public void process(Node externs, Node root) {
     new NodeTraversal(
         compiler, new NormalizeStatements(compiler, assertOnChange))
         .traverse(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
      t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)
        .process(externs, root);

    if (!compiler.getLifeCycleStage().isNormalized()) {
      compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
  }","@Override
public void process(Node externs, Node root) {
    new NodeTraversal(
        compiler, new NormalizeStatements(compiler, assertOnChange))
        .traverse(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // Ensure externs and root are not null before processing
    if (externs != null && root != null) {
        // It is important that removeDuplicateDeclarations runs after
        // MakeDeclaredNamesUnique in order for catch block exception names to be
        // handled properly.
        removeDuplicateDeclarations(externs, root);

        new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)
            .process(externs, root);
    }

    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}",0,0
83,Closure_79,"private void createSynthesizedExternVar(String varName) {
    Node nameNode = Node.newString(Token.NAME, varName);

    // Mark the variable as constant if it matches the coding convention
    // for constant vars.
    // NOTE(nicksantos): honestly, i'm not sure how much this matters.
    // AFAIK, all people who use the CONST coding convention also
    // compile with undeclaredVars as errors. We have some test
    // cases for this configuration though, and it makes them happier.
    if (compiler.getCodingConvention().isConstant(varName)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }

     getSynthesizedExternsRoot().addChildToBack(
         new Node(Token.VAR, nameNode));
     varsToDeclareInExterns.remove(varName);
   }","private void createSynthesizedExternVar(String varName) {
    if (varName == null || varName.isEmpty()) {
        throw new IllegalArgumentException(""Variable name cannot be null or empty"");
    }

    Node nameNode = Node.newString(Token.NAME, varName);

    // Mark the variable as constant if it matches the coding convention
    // for constant vars.
    if (compiler.getCodingConvention().isConstant(varName)) {
        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }

    Node synthesizedExternsRoot = getSynthesizedExternsRoot();
    if (synthesizedExternsRoot != null) {
        synthesizedExternsRoot.addChildToBack(new Node(Token.VAR, nameNode));
    }

    varsToDeclareInExterns.remove(varName);
}",0,0
84,Closure_8,"    private boolean canBeRedeclared(Node n, Scope s) {
      if (!NodeUtil.isExprAssign(n)) {
        return false;
      }
      Node assign = n.getFirstChild();
      Node lhs = assign.getFirstChild();

      if (!lhs.isName()) {
        return false;
      }

      Var var = s.getVar(lhs.getString());
      return var != null
          && var.getScope() == s
          && !blacklistedVars.contains(var);
    }
","private boolean canBeRedeclared(Node n, Scope s) {
    if (!NodeUtil.isExprAssign(n)) {
        return false;
    }
    Node assign = n.getFirstChild();
    if (assign == null) {
        return false; // Ensure assign is not null before accessing children
    }
    Node lhs = assign.getFirstChild();
    if (lhs == null || !lhs.isName()) {
        return false; // Ensure lhs is not null and is a valid name
    }

    Var var = s.getVar(lhs.getString());
    return var != null
        && var.getScope() == s
        && !blacklistedVars.contains(var);
}",0,0
85,Closure_80,"static boolean isBooleanResultHelper(Node n) {
    switch (n.getType()) {
      // Primitives
      case Token.TRUE:
      case Token.FALSE:
      // Comparisons
      case Token.EQ:
      case Token.NE:
      case Token.SHEQ:
      case Token.SHNE:
      case Token.LT:
      case Token.GT:
      case Token.LE:
      case Token.GE:
      // Queryies
      case Token.IN:
      case Token.INSTANCEOF:
       // Inversion
       case Token.NOT:
       // delete operator returns a boolean.
         return true;
       default:
         return false;
    }
  }","static boolean isBooleanResultHelper(Node n) {
    switch (n.getType()) {
        // Primitives
        case Token.TRUE:
        case Token.FALSE:
        // Comparisons
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.LT:
        case Token.GT:
        case Token.LE:
        case Token.GE:
        // Queries
        case Token.IN:
        case Token.INSTANCEOF:
        // Inversion
        case Token.NOT:
        // delete operator returns a boolean.
        case Token.DELPROP:
            return true;
        default:
            return false;
    }
}",0,0
85,Closure_80,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
        return newHasLocalResult(value)
               || locals.apply(value);
      case Token.FUNCTION:
      case Token.REGEXP:
      case Token.ARRAYLIT:
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
        case Token.ASSIGN:
            return NodeUtil.isImmutableValue(value.getLastChild())
                || (locals.apply(value.getFirstChild())
                && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals)
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            if (value.getBooleanProp(Node.INCRDECR_PROP)) {
                return evaluatesToLocalValue(value.getFirstChild(), locals);
            } else {
                return NodeUtil.isImmutableValue(value.getFirstChild());
            }
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return NodeUtil.isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
            return locals.apply(value);
        case Token.CALL:
            return NodeUtil.callHasLocalResult(value)
                || NodeUtil.isToStringMethodCall(value)
                || locals.apply(value);
        case Token.NEW:
            return NodeUtil.newHasLocalResult(value)
                || locals.apply(value);
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return true;
        case Token.IN:
            return NodeUtil.isSimpleOperator(value);
        default:
            if (NodeUtil.isAssignmentOp(value)
                || NodeUtil.isSimpleOperator(value)
                || NodeUtil.isImmutableValue(value)) {
                return true;
            }

            throw new IllegalStateException(""Unexpected expression node: "" + value +
                ""\n parent: "" + value.getParent());
    }
}",0,0
86,Closure_84,"@Override
     Node processAssignment(Assignment assignmentNode) {
       Node assign = processInfixExpression(assignmentNode);
       return assign;
     }","@Override
Node processAssignment(Assignment assignmentNode) {
    if (assignmentNode == null) {
        return null;
    }
    Node assign = processInfixExpression(assignmentNode);
    return assign != null ? assign : Node.newUndefinedNode(); // Ensure assign is never null
}",0,0
86,Closure_84,"@Override
    Node processUnaryExpression(UnaryExpression exprNode) {
      int type = transformTokenType(exprNode.getType());
      Node operand = transform(exprNode.getOperand());
      if (type == Token.NEG && operand.getType() == Token.NUMBER) {
         operand.setDouble(-operand.getDouble());
         return operand;
       } else {
 
         Node node = newNode(type, operand);
         if (exprNode.isPostfix()) {
          node.putBooleanProp(Node.INCRDECR_PROP, true);
        }
        return node;
      }
    }","@Override
Node processUnaryExpression(UnaryExpression exprNode) {
    if (exprNode == null) {
        return null;
    }
    int type = transformTokenType(exprNode.getType());
    Node operand = transform(exprNode.getOperand());

    if (operand == null) {
        return null;
    }

    if (type == Token.NEG && operand.getType() == Token.NUMBER) {
        operand.setDouble(-operand.getDouble());
        return operand;
    } else {
        Node node = newNode(type, operand);
        if (exprNode.isPostfix()) {
            node.putBooleanProp(Node.INCRDECR_PROP, true);
        }
        return node;
    }
}",0,0
87,Closure_85,"private Node computeFollowing(Node n) {
     Node next = ControlFlowAnalysis.computeFollowNode(n);
     return next;
   }","private Node computeFollowing(Node n) {
    if (n == null) {
        return null; // Ensure null checks before proceeding
    }
    Node next = ControlFlowAnalysis.computeFollowNode(n);
    return next;
}",0,0
87,Closure_85,"@SuppressWarnings(""fallthrough"")
  private Node tryRemoveUnconditionalBranching(Node n) {
    /*
     * For each of the unconditional branching control flow node, check to see
     * if the ControlFlowAnalysis.computeFollowNode of that node is same as
     * the branching target. If it is, the branch node is safe to be removed.
     *
     * This is not as clever as MinimizeExitPoints because it doesn't do any
     * if-else conversion but it handles more complicated switch statements
     * much nicer.
     */

    // If n is null the target is the end of the function, nothing to do.
    if (n == null) {
       return n;
    }

    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);

    if (gNode == null) {
       return n;
     }
 
     if (n.getParent() == null) {
       List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
       if (outEdges.size() == 1) {
         return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());
       }
     }
     switch (n.getType()) {
       case Token.BLOCK:
         if (n.hasChildren()) {
           Node first = n.getFirstChild();
           return tryRemoveUnconditionalBranching(first);
         } else {
           return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));
         }
       case Token.RETURN:
         if (n.hasChildren()) {
           break;
        }
      case Token.BREAK:
      case Token.CONTINUE:

        // We are looking for a control flow changing statement that always
        // branches to the same node. If removing it the control flow still
        // branches to that same node. It is safe to remove it.
        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
        if (outEdges.size() == 1 &&
            // If there is a next node, there is no chance this jump is useless.
            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {

          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
          Node nextCfgNode = outEdges.get(0).getDestination().getValue();
          if (nextCfgNode == fallThrough) {
            removeDeadExprStatementSafely(n);
            return fallThrough;
          }
        }
    }
    return n;
  }","@SuppressWarnings(""fallthrough"")
private Node tryRemoveUnconditionalBranching(Node n) {
    if (n == null) {
        return n; // Handle the null case
    }

    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);
    if (gNode == null) {
        return n; // Handle the case where gNode is not found
    }

    if (n.getParent() == null) {
        List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();
        if (outEdges.size() == 1) {
            return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());
        }
    }

    switch (n.getType()) {
        case Token.BLOCK:
            if (n.hasChildren()) {
                Node first = n.getFirstChild();
                return tryRemoveUnconditionalBranching(first);
            } else {
                Node followNode = ControlFlowAnalysis.computeFollowNode(n);
                return followNode != null ? tryRemoveUnconditionalBranching(followNode) : n;
            }
        case Token.RETURN:
            if (n.hasChildren()) {
                break; // Ensure RETURN with children is not removed
            }
        case Token.BREAK:
        case Token.CONTINUE:
            List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();
            if (outEdges.size() == 1 &&
                (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {
                Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
                Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
                Node nextCfgNode = outEdges.get(0).getDestination().getValue();
                if (nextCfgNode == fallThrough) {
                    removeDeadExprStatementSafely(n);
                    return fallThrough;
                }
            }
    }
    return n; // Default return node if none of the above applies
}",0,0
88,Closure_89,"private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
    Node rvalue = ref.node.getNext();
    Node parent = ref.node.getParent();
    Node gramps = parent.getParent();
     Node greatGramps = gramps.getParent();
     Node greatGreatGramps = greatGramps.getParent();
 
 
     // Create the new alias node.
     Node nameNode = NodeUtil.newName(
        compiler.getCodingConvention(), alias, gramps.getFirstChild(),
        refName.fullName());
    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);

    if (gramps.getType() == Token.EXPR_RESULT) {
      // BEFORE: a.b.c = ...;
      //   exprstmt
      //     assign
      //       getprop
      //         getprop
      //           name a
      //           string b
      //         string c
      //       NODE
      // AFTER: var a$b$c = ...;
      //   var
      //     name a$b$c
      //       NODE

      // Remove the rvalue (NODE).
      parent.removeChild(rvalue);
      nameNode.addChildToFront(rvalue);

      Node varNode = new Node(Token.VAR, nameNode);
      greatGramps.replaceChild(gramps, varNode);
    } else {
      // This must be a complex assignment.
      Preconditions.checkNotNull(ref.getTwin());

      // BEFORE:
      // ... (x.y = 3);
      //
      // AFTER:
      // var x$y;
      // ... (x$y = 3);

      Node current = gramps;
      Node currentParent = gramps.getParent();
      for (; currentParent.getType() != Token.SCRIPT &&
             currentParent.getType() != Token.BLOCK;
           current = currentParent,
           currentParent = currentParent.getParent()) {}

      // Create a stub variable declaration right
      // before the current statement.
      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())
          .copyInformationFrom(nameNode);
      currentParent.addChildBefore(stubVar, current);

      parent.replaceChild(ref.node, nameNode);
    }

    compiler.reportCodeChange();
  }","private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
    Node rvalue = ref.node.getNext();
    if (rvalue == null) {
        return;
    }

    Node parent = ref.node.getParent();
    Node gramps = parent.getParent();
    Node greatGramps = gramps.getParent();
    Node greatGreatGramps = greatGramps != null ? greatGramps.getParent() : null;

    // Create the new alias node.
    Node nameNode = NodeUtil.newName(
        compiler.getCodingConvention(), alias, gramps.getFirstChild(),
        refName.fullName());
    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);

    if (gramps.getType() == Token.EXPR_RESULT) {
        // Remove the rvalue (NODE).
        parent.removeChild(rvalue);
        nameNode.addChildToFront(rvalue);

        Node varNode = new Node(Token.VAR, nameNode);
        if (greatGramps != null) {
            greatGramps.replaceChild(gramps, varNode);
        }
    } else {
        Preconditions.checkNotNull(ref.getTwin());

        Node current = gramps;
        Node currentParent = gramps.getParent();
        while (currentParent != null 
                && currentParent.getType() != Token.SCRIPT 
                && currentParent.getType() != Token.BLOCK) {
            current = currentParent;
            currentParent = currentParent.getParent();
        }

        if (currentParent != null) {
            Node stubVar = new Node(Token.VAR, nameNode.cloneTree())
                .copyInformationFrom(nameNode);
            currentParent.addChildBefore(stubVar, current);
        }

        parent.replaceChild(ref.node, nameNode);
    }

    compiler.reportCodeChange();
}",0,0
88,Closure_89,"boolean canCollapseUnannotatedChildNames() {
      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {
        return false;
      }

      // Don't try to collapse if the one global set is a twin reference.
      // We could theoretically handle this case in CollapseProperties, but
      // it's probably not worth the effort.
      Preconditions.checkNotNull(declaration);
      if (declaration.getTwin() != null) {
        return false;
      }

      if (isClassOrEnum) {
        return true;
      }

      // If this is a key of an aliased object literal, then it will be aliased
      // later. So we won't be able to collapse its properties.
      if (parent != null && parent.shouldKeepKeys()) {
        return false;
       }
 
       // If this is aliased, then its properties can't be collapsed either.
       if (type != Type.FUNCTION && aliasingGets > 0) {
         return false;
       }
 
      return (parent == null || parent.canCollapseUnannotatedChildNames());
    }","boolean canCollapseUnannotatedChildNames() {
    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {
        return false;
    }

    Preconditions.checkNotNull(declaration);
    if (declaration.getTwin() != null) {
        return false;
    }

    if (isClassOrEnum) {
        return true;
    }

    if (parent != null && parent.shouldKeepKeys()) {
        return false;
    }

    if (type != Type.FUNCTION && aliasingGets > 0) {
        return false;
    }

    return parent == null || parent.canCollapseUnannotatedChildNames();
}",0,0
89,Closure_9,"private void visitScript(NodeTraversal t, Node script) {
       Preconditions.checkArgument(scriptNodeCount == 1,
           ""ProcessCommonJSModules supports only one invocation per "" +
           ""CompilerInput / script node"");
       String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));
       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
           .copyInformationFromForTree(script));
       if (reportDependencies) {
        CompilerInput ci = t.getInput();
        ci.addProvide(moduleName);
        JSModule m = new JSModule(moduleName);
        m.addAndOverrideModule(ci);
        module = m;
      }
      script.addChildToFront(IR.exprResult(
          IR.call(IR.getprop(IR.name(""goog""), IR.string(""provide"")),
              IR.string(moduleName))).copyInformationFromForTree(script));

      emitOptionalModuleExportsOverride(script, moduleName);

      // Rename vars to not conflict in global scope.
      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(
          moduleName));

      compiler.reportCodeChange();
    }","private void visitScript(NodeTraversal t, Node script) {
    Preconditions.checkArgument(scriptNodeCount == 1,
        ""ProcessCommonJSModules supports only one invocation per "" +
        ""CompilerInput / script node"");
    String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));
    
    // Check if moduleName is not null or empty to avoid processing invalid names
    Preconditions.checkState(moduleName != null && !moduleName.isEmpty(), ""Module name must not be null or empty"");

    script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
        .copyInformationFromForTree(script));
    
    if (reportDependencies) {
        CompilerInput ci = t.getInput();
        ci.addProvide(moduleName);
        JSModule m = new JSModule(moduleName);
        m.addAndOverrideModule(ci);
        module = m;
    }
    
    script.addChildToFront(IR.exprResult(
        IR.call(IR.getprop(IR.name(""goog""), IR.string(""provide"")),
            IR.string(moduleName))).copyInformationFromForTree(script));

    emitOptionalModuleExportsOverride(script, moduleName);

    // Rename vars to not conflict in global scope.
    if (moduleName != null && !moduleName.isEmpty()) {
        NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(moduleName));
    }

    compiler.reportCodeChange();
}",0,0
89,Closure_9,"private String normalizeSourceName(String filename) {
     // The DOS command shell will normalize ""/"" to ""\"", so we have to
     // wrestle it back.
 
     if (filename.indexOf(filenamePrefix) == 0) {
       filename = filename.substring(filenamePrefix.length());
    }

    return filename;
  }","private String normalizeSourceName(String filename) {
    // The DOS command shell will normalize ""/"" to ""\"", so we have to wrestle it back.
    
    if (filename == null) {
        return """";
    }

    filename = filename.replace('\\', '/'); // Ensure a consistent format

    if (filename.startsWith(filenamePrefix)) {
        filename = filename.substring(filenamePrefix.length());
    }

    return filename;
}",0,0
90,Closure_90,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
    setResolvedTypeInternal(this);

    call = (ArrowType) safeResolve(call, t, scope);
    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);

    // Warning about typeOfThis if it doesn't resolve to an ObjectType
    // is handled further upstream.
    //
    // TODO(nicksantos): Handle this correctly if we have a UnionType.
    //
    // TODO(nicksantos): In ES3, the runtime coerces ""null"" to the global
    // activation object. In ES5, it leaves it as null. Just punt on this
    // issue for now by coercing out null. This is complicated by the
    // fact that when most people write @this {Foo}, they really don't
     // mean ""nullable Foo"". For certain tags (like @extends) we de-nullify
     // the name for them.
     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
     if (maybeTypeOfThis instanceof ObjectType) {
       typeOfThis = (ObjectType) maybeTypeOfThis;
     }

    boolean changed = false;
    ImmutableList.Builder<ObjectType> resolvedInterfaces =
        ImmutableList.builder();
    for (ObjectType iface : implementedInterfaces) {
      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);
      resolvedInterfaces.add(resolvedIface);
      changed |= (resolvedIface != iface);
    }
    if (changed) {
      implementedInterfaces = resolvedInterfaces.build();
    }

    if (subTypes != null) {
      for (int i = 0; i < subTypes.size(); i++) {
        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));
      }
    }

    return super.resolveInternal(t, scope);
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
    setResolvedTypeInternal(this);

    call = (ArrowType) safeResolve(call, t, scope);
    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);

    // Warning about typeOfThis if it doesn't resolve to an ObjectType
    // is handled further upstream.
    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {
        typeOfThis = (ObjectType) maybeTypeOfThis;
    } else {
        typeOfThis = null;  // Handle cases where maybeTypeOfThis is null or not an ObjectType
    }

    boolean changed = false;
    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();
    for (ObjectType iface : implementedInterfaces) {
        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);
        if (resolvedIface != null) {
            resolvedInterfaces.add(resolvedIface);
            changed |= (resolvedIface != iface);
        }
    }
    if (changed) {
        implementedInterfaces = resolvedInterfaces.build();
    }

    if (subTypes != null) {
        for (int i = 0; i < subTypes.size(); i++) {
            FunctionType resolvedSubType = (FunctionType) subTypes.get(i).resolve(t, scope);
            if (resolvedSubType != null) {
                subTypes.set(i, resolvedSubType);
            }
        }
    }

    return super.resolveInternal(t, scope);
}",0,0
90,Closure_90,"@Override
    public boolean apply(JSType type) {
      // TODO(user): Doing an instanceof check here is too
      // restrictive as (Date,Error) is, for instance, an object type
      // even though its implementation is a UnionType. Would need to
       // create interfaces JSType, ObjectType, FunctionType etc and have
       // separate implementation instead of the class hierarchy, so that
       // union types can also be object types, etc.
       if (!type.isSubtype(
               typeRegistry.getNativeType(OBJECT_TYPE))) {
         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
         return false;
      }
      return true;
    }","@Override
public boolean apply(JSType type) {
    if (type == null) {
        reportWarning(THIS_TYPE_NON_OBJECT, ""null"");
        return false;
    }

    // Check if the type is a subtype of the Object type
    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {
        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
        return false;
    }

    return true;
}",0,0
91,Closure_98,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
       }
 
       // Make sure this assignment is not in a loop.
 
       return true;
     }","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }

    // Make sure this assignment is not in a loop.
    if (ref.isInLoop()) {
        return false;
    }

    return true;
}",0,0
92,Codec_1,"    public String caverphone(String txt) {
        // NOTE: Version 1.0 of Caverphone is easily derivable from this code 
        // by commenting out the 2.0 lines and adding in the 1.0 lines

        if( txt == null || txt.length() == 0 ) {
            return ""1111111111"";
        }

        // 1. Convert to lowercase
        txt = txt.toLowerCase();

        // 2. Remove anything not A-Z
        txt = txt.replaceAll(""[^a-z]"", """");

        // 2.5. Remove final e
        txt = txt.replaceAll(""e$"", """");             // 2.0 only

        // 3. Handle various start options
        txt = txt.replaceAll(""^cough"", ""cou2f"");
        txt = txt.replaceAll(""^rough"", ""rou2f"");
        txt = txt.replaceAll(""^tough"", ""tou2f"");
        txt = txt.replaceAll(""^enough"", ""enou2f"");  // 2.0 only
        txt = txt.replaceAll(""^trough"", ""trou2f"");  // 2.0 only - note the spec says ^enough here again, c+p error I assume
        txt = txt.replaceAll(""^gn"", ""2n"");
        txt = txt.replaceAll(""^mb"", ""m2"");

        // 4. Handle replacements
        txt = txt.replaceAll(""cq"", ""2q"");
        txt = txt.replaceAll(""ci"", ""si"");
        txt = txt.replaceAll(""ce"", ""se"");
        txt = txt.replaceAll(""cy"", ""sy"");
        txt = txt.replaceAll(""tch"", ""2ch"");
        txt = txt.replaceAll(""c"", ""k"");
        txt = txt.replaceAll(""q"", ""k"");
        txt = txt.replaceAll(""x"", ""k"");
        txt = txt.replaceAll(""v"", ""f"");
        txt = txt.replaceAll(""dg"", ""2g"");
        txt = txt.replaceAll(""tio"", ""sio"");
        txt = txt.replaceAll(""tia"", ""sia"");
        txt = txt.replaceAll(""d"", ""t"");
        txt = txt.replaceAll(""ph"", ""fh"");
        txt = txt.replaceAll(""b"", ""p"");
        txt = txt.replaceAll(""sh"", ""s2"");
        txt = txt.replaceAll(""z"", ""s"");
        txt = txt.replaceAll(""^[aeiou]"", ""A"");
        txt = txt.replaceAll(""[aeiou]"", ""3"");
        txt = txt.replaceAll(""j"", ""y"");        // 2.0 only
        txt = txt.replaceAll(""^y3"", ""Y3"");     // 2.0 only
        txt = txt.replaceAll(""^y"", ""A"");       // 2.0 only
        txt = txt.replaceAll(""y"", ""3"");        // 2.0 only
        txt = txt.replaceAll(""3gh3"", ""3kh3"");
        txt = txt.replaceAll(""gh"", ""22"");
        txt = txt.replaceAll(""g"", ""k"");
        txt = txt.replaceAll(""s+"", ""S"");
        txt = txt.replaceAll(""t+"", ""T"");
        txt = txt.replaceAll(""p+"", ""P"");
        txt = txt.replaceAll(""k+"", ""K"");
        txt = txt.replaceAll(""f+"", ""F"");
        txt = txt.replaceAll(""m+"", ""M"");
        txt = txt.replaceAll(""n+"", ""N"");
        txt = txt.replaceAll(""w3"", ""W3"");
        //txt = txt.replaceAll(""wy"", ""Wy"");    // 1.0 only
        txt = txt.replaceAll(""wh3"", ""Wh3"");
        txt = txt.replaceAll(""w$"", ""3"");       // 2.0 only
        //txt = txt.replaceAll(""why"", ""Why"");  // 1.0 only
        txt = txt.replaceAll(""w"", ""2"");
        txt = txt.replaceAll(""^h"", ""A"");
        txt = txt.replaceAll(""h"", ""2"");
        txt = txt.replaceAll(""r3"", ""R3"");
        txt = txt.replaceAll(""r$"", ""3"");       // 2.0 only
        //txt = txt.replaceAll(""ry"", ""Ry"");    // 1.0 only
        txt = txt.replaceAll(""r"", ""2"");
        txt = txt.replaceAll(""l3"", ""L3"");
        txt = txt.replaceAll(""l$"", ""3"");       // 2.0 only
        //txt = txt.replaceAll(""ly"", ""Ly"");    // 1.0 only
        txt = txt.replaceAll(""l"", ""2"");
        //txt = txt.replaceAll(""j"", ""y"");      // 1.0 only
        //txt = txt.replaceAll(""y3"", ""Y3"");    // 1.0 only
        //txt = txt.replaceAll(""y"", ""2"");      // 1.0 only

        // 5. Handle removals
        txt = txt.replaceAll(""2"", """");
        txt = txt.replaceAll(""3$"", ""A"");       // 2.0 only
        txt = txt.replaceAll(""3"", """");

        // 6. put ten 1s on the end
        txt = txt + ""111111"" + ""1111"";        // 1.0 only has 6 1s

        // 7. take the first six characters as the code
        return txt.substring(0, 10);          // 1.0 truncates to 6
    }
","public String caverphone(String txt) {
    if (txt == null || txt.isEmpty()) {
        return ""1111111111"";
    }

    // 1. Convert to lowercase
    txt = txt.toLowerCase();

    // 2. Remove anything not A-Z
    txt = txt.replaceAll(""[^a-z]"", """");

    // 2.5. Remove final e
    txt = txt.replaceAll(""e$"", """");

    // 3. Handle various start options
    txt = txt.replaceAll(""^cough"", ""cou2f"");
    txt = txt.replaceAll(""^rough"", ""rou2f"");
    txt = txt.replaceAll(""^tough"", ""tou2f"");
    txt = txt.replaceAll(""^enough"", ""enou2f"");
    txt = txt.replaceAll(""^trough"", ""trou2f"");
    txt = txt.replaceAll(""^gn"", ""2n"");
    txt = txt.replaceAll(""^mb"", ""m2"");

    // 4. Handle replacements
    txt = txt.replaceAll(""cq"", ""2q"");
    txt = txt.replaceAll(""ci"", ""si"");
    txt = txt.replaceAll(""ce"", ""se"");
    txt = txt.replaceAll(""cy"", ""sy"");
    txt = txt.replaceAll(""tch"", ""2ch"");
    txt = txt.replaceAll(""c"", ""k"");
    txt = txt.replaceAll(""q"", ""k"");
    txt = txt.replaceAll(""x"", ""k"");
    txt = txt.replaceAll(""v"", ""f"");
    txt = txt.replaceAll(""dg"", ""2g"");
    txt = txt.replaceAll(""tio"", ""sio"");
    txt = txt.replaceAll(""tia"", ""sia"");
    txt = txt.replaceAll(""d"", ""t"");
    txt = txt.replaceAll(""ph"", ""fh"");
    txt = txt.replaceAll(""b"", ""p"");
    txt = txt.replaceAll(""sh"", ""s2"");
    txt = txt.replaceAll(""z"", ""s"");
    txt = txt.replaceAll(""^[aeiou]"", ""A"");
    txt = txt.replaceAll(""[aeiou]"", ""3"");
    txt = txt.replaceAll(""j"", ""y"");
    txt = txt.replaceAll(""^y3"", ""Y3"");
    txt = txt.replaceAll(""^y"", ""A"");
    txt = txt.replaceAll(""y"", ""3"");
    txt = txt.replaceAll(""3gh3"", ""3kh3"");
    txt = txt.replaceAll(""gh"", ""22"");
    txt = txt.replaceAll(""g"", ""k"");
    txt = txt.replaceAll(""s+"", ""S"");
    txt = txt.replaceAll(""t+"", ""T"");
    txt = txt.replaceAll(""p+"", ""P"");
    txt = txt.replaceAll(""k+"", ""K"");
    txt = txt.replaceAll(""f+"", ""F"");
    txt = txt.replaceAll(""m+"", ""M"");
    txt = txt.replaceAll(""n+"", ""N"");
    txt = txt.replaceAll(""w3"", ""W3"");
    txt = txt.replaceAll(""wh3"", ""Wh3"");
    txt = txt.replaceAll(""w$"", ""3"");
    txt = txt.replaceAll(""w"", ""2"");
    txt = txt.replaceAll(""^h"", ""A"");
    txt = txt.replaceAll(""h"", ""2"");
    txt = txt.replaceAll(""r3"", ""R3"");
    txt = txt.replaceAll(""r$"", ""3"");
    txt = txt.replaceAll(""r"", ""2"");
    txt = txt.replaceAll(""l3"", ""L3"");
    txt = txt.replaceAll(""l$"", ""3"");
    txt = txt.replaceAll(""l"", ""2"");

    // 5. Handle removals
    txt = txt.replaceAll(""2"", """");
    txt = txt.replaceAll(""3$"", ""A"");
    txt = txt.replaceAll(""3"", """");

    // 6. Put ten 1s on the end
    txt = txt + ""1111111111"";

    // 7. Take the first ten characters as the code
    return txt.substring(0, 10);
}",0,0
92,Codec_1,"    static String clean(String str) {
        if (str == null || str.length() == 0) {
            return str;
        }
        int len = str.length();
        char[] chars = new char[len];
        int count = 0;
        for (int i = 0; i < len; i++) {
            if (Character.isLetter(str.charAt(i))) {
                chars[count++] = str.charAt(i);
            }
        }
        if (count == len) {
            return str.toUpperCase();
        }
        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);
    }
","static String clean(String str) {
    if (str == null || str.isEmpty()) {
        return null;
    }
    int len = str.length();
    char[] chars = new char[len];
    int count = 0;
    for (int i = 0; i < len; i++) {
        if (Character.isLetter(str.charAt(i))) {
            chars[count++] = str.charAt(i);
        }
    }
    return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);
}",0,0
92,Codec_1,"    public String metaphone(String txt) {
        boolean hard = false ;
        if ((txt == null) || (txt.length() == 0)) {
            return """" ;
        }
        // single character is itself
        if (txt.length() == 1) {
            return txt.toUpperCase() ;
        }
      
        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;
      
        StringBuffer local = new StringBuffer(40); // manipulate
        StringBuffer code = new StringBuffer(10) ; //   output
        // handle initial 2 characters exceptions
        switch(inwd[0]) {
        case 'K' : 
        case 'G' : 
        case 'P' : /* looking for KN, etc*/
            if (inwd[1] == 'N') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'A': /* looking for AE */
            if (inwd[1] == 'E') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'W' : /* looking for WR or WH */
            if (inwd[1] == 'R') {   // WR -> R
                local.append(inwd, 1, inwd.length - 1); 
                break ;
            }
            if (inwd[1] == 'H') {
                local.append(inwd, 1, inwd.length - 1);
                local.setCharAt(0, 'W'); // WH -> W
            } else {
                local.append(inwd);
            }
            break;
        case 'X' : /* initial X becomes S */
            inwd[0] = 'S';
            local.append(inwd);
            break ;
        default :
            local.append(inwd);
        } // now local has working string with initials fixed

        int wdsz = local.length();
        int n = 0 ;

        while ((code.length() < this.getMaxCodeLen()) && 
        	   (n < wdsz) ) { // max code size of 4 works well
            char symb = local.charAt(n) ;
            // remove duplicate letters except C
            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {
                n++ ;
            } else { // not dup
                switch(symb) {
                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
                    if (n == 0) { 
                        code.append(symb);
                    }
                    break ; // only use vowel if leading char
                case 'B' :
                    if ( isPreviousChar(local, n, 'M') && 
                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB
						break;
                    }
                    code.append(symb);
                    break;
                case 'C' : // lots of C special cases
                    /* discard if SCI, SCE or SCY */
                    if ( isPreviousChar(local, n, 'S') && 
                         !isLastChar(wdsz, n) && 
                         (FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) { 
                        break;
                    }
                    if (regionMatch(local, n, ""CIA"")) { // ""CIA"" -> X
                        code.append('X'); 
                        break;
                    }
                    if (!isLastChar(wdsz, n) && 
                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        code.append('S');
                        break; // CI,CE,CY -> S
                    }
                    if (isPreviousChar(local, n, 'S') &&
						isNextChar(local, n, 'H') ) { // SCH->sk
                        code.append('K') ; 
                        break ;
                    }
                    if (isNextChar(local, n, 'H')) { // detect CH
                        if ((n == 0) && 
                        	(wdsz >= 3) && 
                            isVowel(local,2) ) { // CH consonant -> K consonant
                            code.append('K');
                        } else { 
                            code.append('X'); // CHvowel -> X
                        }
                    } else { 
                        code.append('K');
                    }
                    break ;
                case 'D' :
                    if (!isLastChar(wdsz, n + 1) && 
                        isNextChar(local, n, 'G') && 
                        (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J 
                        code.append('J'); n += 2 ;
                    } else { 
                        code.append('T');
                    }
                    break ;
                case 'G' : // GH silent at end or before consonant
                    if (isLastChar(wdsz, n + 1) && 
                        isNextChar(local, n, 'H')) {
                        break;
                    }
                    if (!isLastChar(wdsz, n + 1) &&  
                        isNextChar(local,n,'H') && 
                        !isVowel(local,n+2)) {
                        break;
                    }
                    if ((n > 0) && 
                    	( regionMatch(local, n, ""GN"") ||
					      regionMatch(local, n, ""GNED"") ) ) {
                        break; // silent G
                    }
                    if (isPreviousChar(local, n, 'G')) {
                        hard = true ;
                    } else {
                        hard = false ;
                    }
                    if (!isLastChar(wdsz, n) && 
                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && 
                        (!hard)) {
                        code.append('J');
                    } else {
                        code.append('K');
                    }
                    break ;
                case 'H':
                    if (isLastChar(wdsz, n)) {
                        break ; // terminal H
                    }
                    if ((n > 0) && 
                        (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
                        break;
                    }
                    if (isVowel(local,n+1)) {
                        code.append('H'); // Hvowel
                    }
                    break;
                case 'F': 
                case 'J' : 
                case 'L' :
                case 'M': 
                case 'N' : 
                case 'R' :
                    code.append(symb); 
                    break;
                case 'K' :
                    if (n > 0) { // not initial
                        if (!isPreviousChar(local, n, 'C')) {
                            code.append(symb);
                        }
                    } else {
                        code.append(symb); // initial K
                    }
                    break ;
                case 'P' :
                    if (isNextChar(local,n,'H')) {
                        // PH -> F
                        code.append('F');
                    } else {
                        code.append(symb);
                    }
                    break ;
                case 'Q' :
                    code.append('K');
                    break;
                case 'S' :
                    if (regionMatch(local,n,""SH"") || 
					    regionMatch(local,n,""SIO"") || 
					    regionMatch(local,n,""SIA"")) {
                        code.append('X');
                    } else {
                        code.append('S');
                    }
                    break;
                case 'T' :
                    if (regionMatch(local,n,""TIA"") || 
						regionMatch(local,n,""TIO"")) {
                        code.append('X'); 
                        break;
                    }
                    if (regionMatch(local,n,""TCH"")) {
						// Silent if in ""TCH""
                        break;
                    }
                    // substitute numeral 0 for TH (resembles theta after all)
                    if (regionMatch(local,n,""TH"")) {
                        code.append('0');
                    } else {
                        code.append('T');
                    }
                    break ;
                case 'V' :
                    code.append('F'); break ;
                case 'W' : case 'Y' : // silent if not followed by vowel
                    if (!isLastChar(wdsz,n) && 
                    	isVowel(local,n+1)) {
                        code.append(symb);
                    }
                    break ;
                case 'X' :
                    code.append('K'); code.append('S');
                    break ;
                case 'Z' :
                    code.append('S'); break ;
                } // end switch
                n++ ;
            } // end else from symb != 'C'
            if (code.length() > this.getMaxCodeLen()) { 
            	code.setLength(this.getMaxCodeLen()); 
            }
        }
        return code.toString();
    }
","public String metaphone(String txt) {
    boolean hard = false;
    if (txt == null || txt.isEmpty()) {
        return """";
    }

    // Single character is itself
    if (txt.length() == 1) {
        return txt.toUpperCase(java.util.Locale.ENGLISH);
    }

    char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
    StringBuilder local = new StringBuilder(40);
    StringBuilder code = new StringBuilder(10);

    // Handle initial characters exceptions
    switch (inwd[0]) {
        case 'K':
        case 'G':
        case 'P':
            if (inwd.length > 1 && inwd[1] == 'N') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'A':
            if (inwd.length > 1 && inwd[1] == 'E') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'W':
            if (inwd.length > 1 && inwd[1] == 'R') {
                local.append(inwd, 1, inwd.length - 1);
                break;
            }
            if (inwd.length > 1 && inwd[1] == 'H') {
                if (inwd.length == 2) {
                    local.append('W');
                } else {
                    local.append('W').append(inwd, 2, inwd.length - 2);
                }
            } else {
                local.append(inwd);
            }
            break;
        case 'X':
            inwd[0] = 'S';
            local.append(inwd);
            break;
        default:
            local.append(inwd);
    }

    int wdsz = local.length();
    int n = 0;

    while (code.length() < 10 && n < wdsz) { // Limiting code size to 10
        char symb = local.charAt(n++;",0,0
93,Codec_11,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
        if (bytes == null) {
            return null;
        }
        if (printable == null) {
             printable = PRINTABLE_CHARS;
         }
         ByteArrayOutputStream buffer = new ByteArrayOutputStream();
         // encode up to buffer.length - 3, the last three octets will be treated
         // separately for simplification of note #3
                 // up to this length it is safe to add any byte, encoded or not
         for (byte c : bytes) {
             int b = c;
             if (b < 0) {
                 b = 256 + b;
             }
             if (printable.get(b)) {
                 buffer.write(b);
             } else {
                 // rule #3: whitespace at the end of a line *must* be encoded
 
                 // rule #5: soft line break
                 encodeQuotedPrintable(b, buffer);
             }
         }
 
         // rule #3: whitespace at the end of a line *must* be encoded
         // if we would do a soft break line after this octet, encode whitespace
 
         // note #3: '=' *must not* be the ultimate or penultimate character
         // simplification: if < 6 bytes left, do a soft line break as we may need
         //                 exactly 6 bytes space for the last 2 bytes
             // rule #3: trailing whitespace shall be encoded
 
         return buffer.toByteArray();
     }","public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
    if (bytes == null) {
        return null;
    }
    if (printable == null) {
        printable = PRINTABLE_CHARS;
    }
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();

    int lineLength = 0;
    for (byte c : bytes) {
        int b = c & 0xFF; // Ensure the byte is treated as unsigned

        if (printable.get(b)) {
            if ((lineLength + 1) > MAX_LINE_LENGTH) {
                buffer.write('=');
                buffer.write('\r');
                buffer.write('\n');
                lineLength = 0;
            }
            buffer.write(b);
            lineLength++;
        } else {
            if ((lineLength + 3) > MAX_LINE_LENGTH) {
                buffer.write('=');
                buffer.write('\r');
                buffer.write('\n');
                lineLength = 0;
            }
            buffer.write('=');
            buffer.write(HEX_CHARS[(b >> 4) & 0x0F]);
            buffer.write(HEX_CHARS[b & 0x0F]);
            lineLength += 3;
        }
    }

    return buffer.toByteArray();
}",0,0
93,Codec_11,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
        if (bytes == null) {
            return null;
        }
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        for (int i = 0; i < bytes.length; i++) {
            final int b = bytes[i];
             if (b == ESCAPE_CHAR) {
                 try {
                     // if the next octet is a CR we have found a soft line break
                     int u = Utils.digit16(bytes[++i]);
                     int l = Utils.digit16(bytes[++i]);
                     buffer.write((char) ((u << 4) + l));
                 } catch (ArrayIndexOutOfBoundsException e) {
                     throw new DecoderException(""Invalid quoted-printable encoding"", e);
                 }
             } else {
                 // every other octet is appended except for CR & LF
                 buffer.write(b);
             }
        }
        return buffer.toByteArray();
    }","public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
    if (bytes == null) {
        return null;
    }

    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    int length = bytes.length;

    for (int i = 0; i < length; i++) {
        int b = bytes[i] & 0xFF; // Ensure the byte is treated as unsigned

        if (b == '=') {
            if (i + 2 < length && bytes[i + 1] != '\r' && bytes[i + 2] != '\n') {
                try {
                    int u = Utils.digit16(bytes[++i]);
                    int l = Utils.digit16(bytes[++i]);
                    buffer.write((u << 4) + l);
                } catch (ArrayIndexOutOfBoundsException e) {
                    throw new DecoderException(""Invalid quoted-printable encoding"", e);
                }
            } else if (i + 2 < length && bytes[i + 1] == '\r' && bytes[i + 2] == '\n') {
                // Soft line break
                i += 2;
            } else {
                throw new DecoderException(""Invalid quoted-printable encoding: incomplete escape sequence"");
            }
        } else {
            buffer.write(b);
        }
    }

    return buffer.toByteArray();
}",0,0
94,Codec_12,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.codec.binary;

import static org.apache.commons.codec.binary.BaseNCodec.EOF;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Abstract superclass for Base-N input streams.
 * 
 * @since 1.5
 */
public class BaseNCodecInputStream extends FilterInputStream {

    private final boolean doEncode;

    private final BaseNCodec baseNCodec;

    private final byte[] singleByte = new byte[1];

    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
        super(in);
        this.doEncode = doEncode;
        this.baseNCodec = baseNCodec;
    }

    /**
     * Reads one <code>byte</code> from this input stream.
     * 
     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.
     * @throws IOException
     *             if an I/O error occurs.
     */
    @Override
    public int read() throws IOException {
        int r = read(singleByte, 0, 1);
        while (r == 0) {
            r = read(singleByte, 0, 1);
        }
        if (r > 0) {
            final byte b = singleByte[0];
            return b < 0 ? 256 + b : b;
        }
        return EOF;
    }

    /**
     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
     * from this InputStream.
     * 
     * @param b
     *            destination byte array
     * @param offset
     *            where to start writing the bytes
     * @param len
     *            maximum number of bytes to read
     * 
     * @return number of bytes read
     * @throws IOException
     *             if an I/O error occurs.
     * @throws NullPointerException
     *             if the byte array parameter is null
     * @throws IndexOutOfBoundsException
     *             if offset, len or buffer size are invalid
     */
    @Override
    public int read(byte b[], int offset, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (offset < 0 || len < 0) {
            throw new IndexOutOfBoundsException();
        } else if (offset > b.length || offset + len > b.length) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        } else {
            int readLen = 0;
            /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base32.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base32, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
            while (readLen == 0) {
                if (!baseNCodec.hasData()) {
                    byte[] buf = new byte[doEncode ? 4096 : 8192];
                    int c = in.read(buf);
                    if (doEncode) {
                        baseNCodec.encode(buf, 0, c);
                    } else {
                        baseNCodec.decode(buf, 0, c);
                    }
                }
                readLen = baseNCodec.readResults(b, offset, len);
            }
            return readLen;
        }
    }
    /**
     * {@inheritDoc}
     * 
     * @return false
     */
    @Override
    public boolean markSupported() {
        return false; // not an easy job to support marks
    }

    /**
     * {@inheritDoc}
     *
     * @throws IllegalArgumentException if the provided skip length is negative
     */

        // skip in chunks of 512 bytes


    /**
     * {@inheritDoc}
     *
     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,
     * <code>1</code> otherwise
     */
        // Note: the logic is similar to the InflaterInputStream:
        //       as long as we have not reached EOF, indicate that there is more
        //       data available. As we do not know for sure how much data is left,
        //       just return 1 as a safe guess.

        // use the EOF flag of the underlying codec instance
}
",Match failed,0,0
95,Codec_13,"    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {
        return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));
    }
","public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {
    if (value1 == null || value2 == null) {
        return false;
    }
    return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));
}",0,0
95,Codec_13,"    private static byte[] getBytes(final String string, final Charset charset) {
        if (string == null) {
            return null;
        }
        return string.getBytes(charset);
    }
","private static byte[] getBytes(final String string, final Charset charset) {
    if (string == null || charset == null) {
        return null;
    }
    return string.getBytes(charset);
}",0,0
96,Codec_14,"private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
             return phonemeBuilder;
         }
 
         final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);
 
         for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
             PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            phonemes.addAll(subBuilder.getPhonemes());
        }

        return new PhonemeBuilder(phonemes);
    }","private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                       final Map<String, List<Rule>> finalRules) {
    if (finalRules == null) {
        throw new NullPointerException(""finalRules can not be null"");
    }
    if (finalRules.isEmpty()) {
        return phonemeBuilder;
    }

    final Set<Rule.Phoneme> phonemes = new TreeSet<>(Rule.Phoneme.COMPARATOR);

    for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
        PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
        final String phonemeText = phoneme.getPhonemeText().toString();

        for (int i = 0; i < phonemeText.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
            subBuilder = rulesApplication.getPhonemeBuilder();

            if (!rulesApplication.isFound()) {
                // Not found, appending as-is
                subBuilder.append(phonemeText.subSequence(i, i + 1));
                i++;
            } else {
                i = rulesApplication.getI();
            }
        }

        // Merge phonemes with the same text but different language sets
        for (Rule.Phoneme subPhoneme : subBuilder.getPhonemes()) {
            boolean merged = false;
            for (Rule.Phoneme existingPhoneme : phonemes) {
                if (existingPhoneme.getPhonemeText().equals(subPhoneme.getPhonemeText())) {
                    existingPhoneme.mergeLanguages(subPhoneme.getLanguages());
                    merged = true;
                    break;
                }
            }
            if (!merged) {
                phonemes.add(subPhoneme);
            }
        }
    }

    return new PhonemeBuilder(phonemes);
}",0,0
97,Codec_16,"    public Base32() {
        this(false);
    }
","public Base32() {
    super(false);
}",0,0
98,Codec_8,"public int read(byte b[], int offset, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (offset < 0 || len < 0) {
            throw new IndexOutOfBoundsException();
        } else if (offset > b.length || offset + len > b.length) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        } else {
            int readLen = 0;
            /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
            while (readLen == 0) {
                 if (!base64.hasData()) {
                     byte[] buf = new byte[doEncode ? 4096 : 8192];
                     int c = in.read(buf);
                     if (c > 0 && b.length == len) {
                         base64.setInitialBuffer(b, offset, len);
                     }
                     if (doEncode) {
                         base64.encode(buf, 0, c);
                     } else {
                        base64.decode(buf, 0, c);
                    }
                }
                readLen = base64.readResults(b, offset, len);
            }
            return readLen;
        }
    }","public int read(byte b[], int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException(""Byte array is null"");
    }
    if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException(""Offset or length is out of bounds"");
    }
    if (len == 0) {
        return 0;
    }

    int readLen = 0;
    while (readLen == 0) {
        if (!base64.hasData()) {
            byte[] buf = new byte[doEncode ? 4096 : 8192];
            int c = in.read(buf);
            if (c == -1) { // Handle EOF case
                return -1;
            }
            if (doEncode) {
                base64.encode(buf, 0, c);
            } else {
                base64.decode(buf, 0, c);
            }
        }
        readLen = base64.readResults(b, offset, len);
    }
    return readLen;
}",0,0
99,Collections_1,"        public Object setValue(Object value) {
            if (canRemove == false) {
                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);
            }
            Object old = getValue();
            switch (nextIndex) {
                case 3: 
                    parent.value3 = value;
                case 2:
                    parent.value2 = value;
                case 1:
                    parent.value1 = value;
            }
            return old;
        }
","public Object setValue(Object value) {
    if (!canRemove) {
        throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);
    }
    Object old = getValue();
    switch (nextIndex) {
        case 3: 
            parent.value3 = value;
            break; // Add missing break
        case 2:
            parent.value2 = value;
            break; // Add missing break
        case 1:
            parent.value1 = value;
            break; // Add missing break
        default:
            throw new IllegalStateException(""Invalid index: "" + nextIndex);
    }
    return old;
}",0,0
100,Collections_10,"        public Object next() {
            return iterator.next();
        }
","public Object next() {
    if (!iterator.hasNext()) {
        throw new NoSuchElementException(""No more elements to iterate."");
    }
    return iterator.next();
}",0,0
100,Collections_10,"    public static MultiValueMap decorate(Map map) {
        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));
    }
","public static MultiValueMap decorate(Map map) {
    if (map == null) {
        throw new IllegalArgumentException(""Input map must not be null."");
    }
    return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));
}",0,0
101,Collections_11,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the ""License""); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an ""AS IS"" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections.keyvalue;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.Arrays;

/** 
 * A <code>MultiKey</code> allows multiple map keys to be merged together.
 * <p>
 * The purpose of this class is to avoid the need to write code to handle
 * maps of maps. An example might be the need to look up a file name by 
 * key and locale. The typical solution might be nested maps. This class
 * can be used instead by creating an instance passing in the key and locale.
 * <p>
 * Example usage:
 * <pre>
 * // populate map with data mapping key+locale to localizedText
 * Map map = new HashMap();
 * MultiKey multiKey = new MultiKey(key, locale);
 * map.put(multiKey, localizedText);
 *
 * // later retrieve the localized text
 * MultiKey multiKey = new MultiKey(key, locale);
 * String localizedText = (String) map.get(multiKey);
 * </pre>
 * 
 * @since Commons Collections 3.0
 * @version $Revision$ $Date$
 * 
 * @author Howard Lewis Ship
 * @author Stephen Colebourne
 */
public class MultiKey implements Serializable {
    // This class could implement List, but that would confuse it's purpose

    /** Serialisation version */
    private static final long serialVersionUID = 4465448607415788805L;

    /** The individual keys */
    private final Object[] keys;
    /** The cached hashCode */
    private transient int hashCode;
    
    /**
     * Constructor taking two keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * 
     * @param key1  the first key
     * @param key2  the second key
     */
    public MultiKey(Object key1, Object key2) {
        this(new Object[] {key1, key2}, false);
    }
    
    /**
     * Constructor taking three keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * 
     * @param key1  the first key
     * @param key2  the second key
     * @param key3  the third key
     */
    public MultiKey(Object key1, Object key2, Object key3) {
        this(new Object[] {key1, key2, key3}, false);
    }
    
    /**
     * Constructor taking four keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * 
     * @param key1  the first key
     * @param key2  the second key
     * @param key3  the third key
     * @param key4  the fourth key
     */
    public MultiKey(Object key1, Object key2, Object key3, Object key4) {
        this(new Object[] {key1, key2, key3, key4}, false);
    }
    
    /**
     * Constructor taking five keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * 
     * @param key1  the first key
     * @param key2  the second key
     * @param key3  the third key
     * @param key4  the fourth key
     * @param key5  the fifth key
     */
    public MultiKey(Object key1, Object key2, Object key3, Object key4, Object key5) {
        this(new Object[] {key1, key2, key3, key4, key5}, false);
    }
    
    /**
     * Constructor taking an array of keys which is cloned.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * <p>
     * This is equivalent to <code>new MultiKey(keys, true)</code>.
     *
     * @param keys  the array of keys, not null
     * @throws IllegalArgumentException if the key array is null
     */
    public MultiKey(Object[] keys) {
        this(keys, true);
    }
    
    /**
     * Constructor taking an array of keys, optionally choosing whether to clone.
     * <p>
     * <b>If the array is not cloned, then it must not be modified.</b>
     * <p>
     * This method is public for performance reasons only, to avoid a clone.
     * The hashcode is calculated once here in this method.
     * Therefore, changing the array passed in would not change the hashcode but
     * would change the equals method, which is a bug.
     * <p>
     * This is the only fully safe usage of this constructor, as the object array
     * is never made available in a variable:
     * <pre>
     * new MultiKey(new Object[] {...}, false);
     * </pre>
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     *
     * @param keys  the array of keys, not null
     * @param makeClone  true to clone the array, false to assign it
     * @throws IllegalArgumentException if the key array is null
     * @since Commons Collections 3.1
     */
    public MultiKey(Object[] keys, boolean makeClone) {
        super();
        if (keys == null) {
            throw new IllegalArgumentException(""The array of keys must not be null"");
        }
        if (makeClone) {
            this.keys = (Object[]) keys.clone();
        } else {
            this.keys = keys;
        }
        
        calculateHashCode(keys);
    }
    
    //-----------------------------------------------------------------------
    /**
     * Gets a clone of the array of keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed.
     * 
     * @return the individual keys
     */
    public Object[] getKeys() {
        return (Object[]) keys.clone();
    }
    
    /**
     * Gets the key at the specified index.
     * <p>
     * The key should be immutable.
     * If it is not then it must not be changed.
     * 
     * @param index  the index to retrieve
     * @return the key at the index
     * @throws IndexOutOfBoundsException if the index is invalid
     * @since Commons Collections 3.1
     */
    public Object getKey(int index) {
        return keys[index];
    }
    
    /**
     * Gets the size of the list of keys.
     * 
     * @return the size of the list of keys
     * @since Commons Collections 3.1
     */
    public int size() {
        return keys.length;
    }
    
    //-----------------------------------------------------------------------
    /**
     * Compares this object to another.
     * <p>
     * To be equal, the other object must be a <code>MultiKey</code> with the
     * same number of keys which are also equal.
     * 
     * @param other  the other object to compare to
     * @return true if equal
     */
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }
        if (other instanceof MultiKey) {
            MultiKey otherMulti = (MultiKey) other;
            return Arrays.equals(keys, otherMulti.keys);
        }
        return false;
    }

    /**
     * Gets the combined hash code that is computed from all the keys.
     * <p>
     * This value is computed once and then cached, so elements should not
     * change their hash codes once created (note that this is the same 
     * constraint that would be used if the individual keys elements were
     * themselves {@link java.util.Map Map} keys.
     * 
     * @return the hash code
     */
    public int hashCode() {
        return hashCode;
    }

    /**
     * Gets a debugging string version of the key.
     * 
     * @return a debugging string
     */
    public String toString() {
        return ""MultiKey"" + Arrays.asList(keys).toString();
    }

 /**
  * Calculate the hash code of the instance using the provided keys.
  * @param keys
  */
 private void calculateHashCode(Object[] keys)
 {
  int total = 0;
        for (int i = 0; i < keys.length; i++) {
            if (keys[i] != null) {
                total ^= keys[i].hashCode();
            }
        }
        hashCode = total;
 }
 
 /**
  * Recalculate the hash code after deserialization. The hash code of some
  * keys might have change (hash codes based on the system hash code are
  * only stable for the same process). 
  * @return the instance with recalculated hash code
  */
}
",Match failed,0,0
102,Collections_12,"    public void combine(ExtendedProperties props) {
        for (Iterator it = props.getKeys(); it.hasNext();) {
            String key = (String) it.next();
            super.put(key, props.get(key));
        }
    }
","public void combine(ExtendedProperties props) {
    for (Iterator it = props.getKeys(); it.hasNext();) {
        String key = (String) it.next();
        Object value = props.get(key);
        if (value != null) {
            super.put(key, value);
        }
    }
}",0,0
103,Collections_13,"    public static ExtendedProperties convertProperties(Properties props) {
        ExtendedProperties c = new ExtendedProperties();

        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {
            String s = (String) e.nextElement();
            c.setProperty(s, props.getProperty(s));
        }

        return c;
    }
","public static ExtendedProperties convertProperties(Properties props) {
    ExtendedProperties c = new ExtendedProperties();

    for (Enumeration<?> e = props.propertyNames(); e.hasMoreElements();) {
        String s = (String) e.nextElement();
        Object value = props.get(s); // Use get() instead of getProperty() to handle non-String values
        c.setProperty(s, value);
    }

    return c;
}",0,0
104,Collections_14,"    protected Object convertKey(Object key) {
        if (key != null) {
            return key.toString().toLowerCase();
        } else {
            return AbstractHashedMap.NULL;
        }
    }   
","protected Object convertKey(Object key) {
    if (key != null) {
        return key.toString().toLowerCase(Locale.ENGLISH);
    } else {
        return AbstractHashedMap.NULL;
    }
}",0,0
105,Collections_15,"    public Object set(int index, Object object) {
        int pos = indexOf(object);
        Object removed = super.set(index, object);

        if (pos == -1 || pos == index) {
            // the object is already in the uniq list
            // (and it hasn't been swapped with itself)
            return removed;
        }

        super.remove(pos);
        set.remove(removed);  // remove the item deleted by the set

        return removed;  // return the item deleted by the set
    }
","public Object set(int index, Object object) {
    int pos = indexOf(object);
    Object removed = super.set(index, object);

    if (pos != -1 && pos != index) {
        // The object is already in the unique list and it's not just being replaced at the same index
        super.remove(pos); // Remove the duplicate object
    }

    set.remove(removed); // Remove the item that was replaced from the backing set
    set.add(object); // Add the new object to the backing set to maintain uniqueness

    return removed; // Return the item that was replaced
}",0,0
106,Collections_16,"    public ListIterator listIterator(int index) {
        return new SetListListIterator(super.listIterator(index), set);
    }
","public ListIterator<E> listIterator(int index) {
    ListIterator<E> iterator = super.listIterator(index);
    if (iterator == null) {
        throw new IndexOutOfBoundsException(""Index: "" + index + "" is out of bounds"");
    }
    return new SetListListIterator(iterator, set);
}",0,0
107,Collections_17,"    public EqualPredicate(T object) {
        // do not use the DefaultEquator to keep backwards compatibility
        // the DefaultEquator returns also true if the two object references are equal
        this(object, new DefaultEquator<T>());
    }
","public EqualPredicate(T object) {
    // Use a null check to avoid passing null to the DefaultEquator
    // Ensure compatibility with previous behavior
    this.iValue = object;
    this.equator = new DefaultEquator<>();
}",0,0
107,Collections_17,"    public boolean evaluate(T object) {
            return equator.equate(iValue, object);
    }
","public boolean evaluate(T object) {
    return iValue != null && equator.equate(iValue, object);
}",0,0
108,Collections_18,"    public boolean removeAll(Collection<?> coll) {
        boolean result = false;
        for (Iterator<?> it = coll.iterator(); it.hasNext();) {
            result |= remove(it.next());
        }
        return result;
    }
","public boolean removeAll(Collection<?> coll) {
    if (coll == null || coll.isEmpty()) {
        return false;
    }

    boolean result = false;
    for (Object obj : coll) {
        result |= remove(obj);
    }
    return result;
}",0,0
109,Collections_19,"    public E set(final int index, final E object) {
        final int pos = indexOf(object);
        final E removed = super.set(index, object);

        if (pos != -1 && pos != index) {
            // the object is already in the uniq list
            // (and it hasn't been swapped with itself)
            super.remove(pos); // remove the duplicate by index
        }
        set.add(object); 
        set.remove(removed);
        return removed; // return the item deleted by the set
    }","public E set(final int index, final E object) {
    final int pos = indexOf(object);
    final E removed = super.set(index, object);

    if (pos != -1 && pos != index) {
        // the object is already in the uniq list
        // (and it hasn't been swapped with itself)
        super.remove(pos); // remove the duplicate by index
    }
    set.remove(removed);
    set.add(object); // ensure the set reflects the updated list
    return removed; // return the item replaced by the set
}",0,0
110,Collections_2,"    public String getInclude() {
            return include;  // backwards compatability
    }
","public String getInclude() {
    return include; // backwards compatibility (corrected spelling of ""compatibility"")
}",0,0
110,Collections_2,"    protected ArrayList keysAsListed = new ArrayList();

    protected final static String START_TOKEN=""${"";
    protected final static String END_TOKEN=""}"";
","protected ArrayList<String> keysAsListed = new ArrayList<>(); // Generics added for type safety

protected final static String START_TOKEN = ""${"";
protected final static String END_TOKEN = ""}"";",0,0
110,Collections_2,"    public void setInclude(String inc) {
        include = inc;
    }
","public void setInclude(String inc) {
    include = inc != null ? inc.trim() : null; // Added null check and trimmed the input
}",0,0
110,Collections_2,"    public synchronized void load(InputStream input, String enc) throws IOException {
        PropertiesReader reader = null;
        if (enc != null) {
            try {
                reader = new PropertiesReader(new InputStreamReader(input, enc));
                
            } catch (UnsupportedEncodingException ex) {
                // Another try coming up....
            }
        }
        
        if (reader == null) {
            try {
                reader = new PropertiesReader(new InputStreamReader(input, ""8859_1""));
                
            } catch (UnsupportedEncodingException ex) {
                // ISO8859-1 support is required on java platforms but....
                // If it's not supported, use the system default encoding
                reader = new PropertiesReader(new InputStreamReader(input));
            }
        }

        try {
            while (true) {
                String line = reader.readProperty();
                if (line == null) {
                    return;  // EOF
                }
                int equalSign = line.indexOf('=');

                if (equalSign > 0) {
                    String key = line.substring(0, equalSign).trim();
                    String value = line.substring(equalSign + 1).trim();

                    // Configure produces lines like this ... just ignore them
                    if ("""".equals(value)) {
                        continue;
                    }

                    if (getInclude() != null && key.equalsIgnoreCase(getInclude())) {
                        // Recursively load properties files.
                        File file = null;

                        if (value.startsWith(fileSeparator)) {
                            // We have an absolute path so we'll use this
                            file = new File(value);
                            
                        } else {
                            // We have a relative path, and we have two 
                            // possible forms here. If we have the ""./"" form
                            // then just strip that off first before continuing.
                            if (value.startsWith(""."" + fileSeparator)) {
                                value = value.substring(2);
                            }

                            file = new File(basePath + value);
                        }

                        if (file != null && file.exists() && file.canRead()) {
                            load(new FileInputStream(file));
                        }
                    } else {
                        addProperty(key, value);
                    }
                }
            }
        } finally {
            // Loading is initializing
            isInitialized = true;
        }
    }
","public synchronized void load(InputStream input, String enc) throws IOException {
    PropertiesReader reader = null;
    if (enc != null) {
        try {
            reader = new PropertiesReader(new InputStreamReader(input, enc));
        } catch (UnsupportedEncodingException ex) {
            // Logging or handling can be added here for debugging
        }
    }

    if (reader == null) {
        try {
            reader = new PropertiesReader(new InputStreamReader(input, ""8859_1""));
        } catch (UnsupportedEncodingException ex) {
            reader = new PropertiesReader(new InputStreamReader(input)); // Default system encoding
        }
    }

    try {
        while (true) {
            String line = reader.readProperty();
            if (line == null) {
                return; // EOF
            }

            int equalSign = line.indexOf('=');

            if (equalSign > 0) {
                String key = line.substring(0, equalSign).trim();
                String value = line.substring(equalSign + 1).trim();

                if ("""".equals(value)) {
                    continue; // Ignore blank values
                }

                String includeKey = getInclude();
                if (includeKey != null && key.equalsIgnoreCase(includeKey)) {
                    File file = null;
                    if (value.startsWith(fileSeparator)) {
                        file = new File(value); // Absolute path
                    } else {
                        if (value.startsWith(""."" + fileSeparator)) {
                            value = value.substring(2); // Remove relative path indicator
                        }
                        file = new File(basePath + value); // Relative path
                    }

                    if (file != null && file.exists() && file.canRead()) {
                        try (FileInputStream fis = new FileInputStream(file)) {
                            load(fis, enc); // Recursive call with encoding
                        }
                    }
                } else {
                    addProperty(key, value);
                }
            }
        }
    } finally {
        isInitialized = true; // Ensure initialization is marked
    }
}",0,0
111,Collections_20,"        public void remove() {
            checkModCount();
            if (currentIndex == -1) {
                throw new IllegalStateException();
            }
            if (nextIndex == currentIndex) {
                next = next.next();
                parent.remove(currentIndex);
            } else {
                // remove() following next()
                parent.remove(currentIndex);
                nextIndex--;
            }
            // the AVL node referenced by next may have become stale after a remove
            // reset it now: will be retrieved by next call to next()/previous() via nextIndex
            current = null;
            currentIndex = -1;
            expectedModCount++;
        }
","public void remove() {
    checkModCount();
    if (currentIndex == -1) {
        throw new IllegalStateException(""Remove called without a valid current element."");
    }
    if (nextIndex == currentIndex) {
        next = next != null ? next.next() : null;
        parent.remove(currentIndex);
    } else {
        // remove() following next()
        parent.remove(currentIndex);
        nextIndex--;
    }
    // Reset current element and index after removal
    current = null;
    currentIndex = -1;
    expectedModCount = parent.getModCount(); // Ensure modCount is synchronized after a remove
}",0,0
112,Collections_21,"    public List<E> subList(final int fromIndex, final int toIndex) {
        final List<E> superSubList = super.subList(fromIndex, toIndex);
        final Set<E> subSet = createSetBasedOnList(set, superSubList);
        return new SetUniqueList<E>(superSubList, subSet);
    }
","public List<E> subList(final int fromIndex, final int toIndex) {
    if (fromIndex < 0 || toIndex > size() || fromIndex > toIndex) {
        throw new IndexOutOfBoundsException(""Invalid subList range: fromIndex="" + fromIndex + "", toIndex="" + toIndex);
    }

    final List<E> superSubList = super.subList(fromIndex, toIndex);
    final Set<E> subSet = createSetBasedOnList(set, superSubList);
    return new SetUniqueList<E>(new ArrayList<E>(superSubList), subSet);
}",0,0
113,Collections_22,"    public void putAll(int index, final Map<? extends K, ? extends V> map) {
        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
            final V old = put(index, entry.getKey(), entry.getValue());
            if (old == null) {
            // The return value of put is null if the key did not exist OR the value was null
            // so it cannot be used to determine whether the key was added
                // if no key was replaced, increment the index
                index++;
            } else {
                // otherwise put the next item after the currently inserted key
                index = indexOf(entry.getKey()) + 1;
            }
        }
    }
","public void putAll(int index, final Map<? extends K, ? extends V> map) {
    for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
        final V old = put(entry.getKey(), entry.getValue());
        if (old == null && !containsKey(entry.getKey())) {
            // Increment the index when a new key is added
            index++;
        } else {
            // Update index to the position after the currently inserted key
            index = indexOf(entry.getKey()) + 1;
        }
    }
}",0,0
114,Collections_23,"    public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {
        return new UnmodifiableTrie<K, V>(trie);
    }
","public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {
    if (trie == null) {
        throw new IllegalArgumentException(""Trie must not be null"");
    }
    return new UnmodifiableTrie<K, V>(trie);
}",0,0
115,Collections_24,"    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {
        return new UnmodifiableBoundedCollection<E>(coll);
    }
","public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {
    if (coll == null) {
        throw new NullPointerException(""The specified collection must not be null"");
    }
    return new UnmodifiableBoundedCollection<>(coll);
}",0,0
116,Collections_25,"    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,
                                                   final Iterator<? extends E> iterator1,
                                                   final Iterator<? extends E> iterator2) {
        return new CollatingIterator<E>(comparator, iterator1, iterator2);
    }
","public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,
                                                   final Iterator<? extends E> iterator1,
                                                   final Iterator<? extends E> iterator2) {
    if (comparator == null || iterator1 == null || iterator2 == null) {
        throw new IllegalArgumentException(""Comparator and iterators must not be null"");
    }
    return new CollatingIterator<E>(comparator, iterator1, iterator2);
}",0,0
116,Collections_25,"    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,
                                                   final Iterator<? extends E>... iterators) {
        return new CollatingIterator<E>(comparator, iterators);
    }
","public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,
                                                   final Iterator<? extends E>... iterators) {
    if (comparator == null || iterators == null) {
        throw new IllegalArgumentException(""Comparator and iterators must not be null"");
    }
    for (Iterator<? extends E> iterator : iterators) {
        if (iterator == null) {
            throw new IllegalArgumentException(""None of the iterators must be null"");
        }
    }
    return new CollatingIterator<E>(comparator, iterators);
}",0,0
116,Collections_25,"    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,
                                                   final Collection<Iterator<? extends E>> iterators) {
        return new CollatingIterator<E>(comparator, iterators);
    }
","public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,
                                                   final Collection<Iterator<? extends E>> iterators) {
    if (comparator == null || iterators == null) {
        throw new IllegalArgumentException(""Comparator and iterators collection must not be null"");
    }
    for (Iterator<? extends E> iterator : iterators) {
        if (iterator == null) {
            throw new IllegalArgumentException(""None of the iterators in the collection must be null"");
        }
    }
    return new CollatingIterator<E>(comparator, iterators);
}",0,0
117,Collections_27,"        public T create() {
            try {
                return clazz.newInstance();
            } catch (final Exception ex) {
                throw new FunctorException(""Cannot instantiate class: "" + clazz, ex);
            }
        }
","public T create() {
    try {
        return clazz.getDeclaredConstructor().newInstance();
    } catch (final Exception ex) {
        throw new FunctorException(""Cannot instantiate class: "" + clazz, ex);
    }
}",0,0
118,Collections_28,"        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,
                                                 final K toKey, final boolean toInclusive) {
            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);
        }
","protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,
                                         final K toKey, final boolean toInclusive) {
    if (fromKey == null || toKey == null) {
        throw new IllegalArgumentException(""Keys cannot be null."");
    }
    if (fromKey.compareTo(toKey) > 0) {
        throw new IllegalArgumentException(""fromKey must be less than or equal to toKey."");
    }
    return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);
}",0,0
119,Collections_3,"    public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
    }
","public static Collection removeAll(Collection collection, Collection remove) {
    collection.removeAll(remove);
    return collection;
}",0,0
120,Collections_4,"    public Object put(Object key, Object value) {
        boolean result = false;
        Collection coll = getCollection(key);
        if (coll == null) {
            coll = createCollection(1);  // might produce a non-empty collection
            result = coll.add(value);
            if (coll.size() > 0) {
                // only add if non-zero size to maintain class state
                getMap().put(key, coll);
                result = false;
            }
        } else {
            result = coll.add(value);
        }
        return (result ? value : null);
    }
","public Object put(Object key, Object value) {
    Collection coll = getCollection(key);
    if (coll == null) {
        coll = createCollection(1);  // creates a new collection
        coll.add(value);  // add value to the collection
        if (!coll.isEmpty()) {
            getMap().put(key, coll);  // put the collection in the map
            return value;
        }
        return null;  // if collection is empty, return null
    }
    boolean result = coll.add(value);  // add value to the existing collection
    return result ? value : null;
}",0,0
120,Collections_4,"    public boolean putAll(Object key, Collection values) {
        if (values == null || values.size() == 0) {
            return false;
        }
        Collection coll = getCollection(key);
        if (coll == null) {
            coll = createCollection(values.size());  // might produce a non-empty collection
            boolean result = coll.addAll(values);
            if (coll.size() > 0) {
                // only add if non-zero size to maintain class state
                getMap().put(key, coll);
                result = false;
            }
            return result;
        } else {
            return coll.addAll(values);
        }
    }
","public boolean putAll(Object key, Collection values) {
    if (values == null || values.isEmpty()) {
        return false;  // return false if values are null or empty
    }
    Collection coll = getCollection(key);
    if (coll == null) {
        coll = createCollection(values.size());  // creates a new collection with the expected size
        coll.addAll(values);  // add all values to the collection
        if (!coll.isEmpty()) {
            getMap().put(key, coll);  // put the collection in the map
            return true;
        }
        return false;  // if collection is empty, return false
    }
    return coll.addAll(values);  // add all values to the existing collection
}",0,0
121,Collections_5,"    public boolean addAll(int index, Collection coll) {
        // gets initial size
        final int sizeBefore = size();

        // adds all elements
        for (final Iterator it = coll.iterator(); it.hasNext();) {
            add(it.next());
            // if it was inserted, then increase the target index
        }

        // compares sizes to detect if collection changed
        return sizeBefore != size();
    }","public boolean addAll(int index, Collection coll) {
    // gets initial size
    final int sizeBefore = size();

    // adds all elements
    int currentIndex = index;
    for (final Iterator it = coll.iterator(); it.hasNext();) {
        Object element = it.next();
        if (!contains(element)) { // Check if the element is not already in the list
            add(currentIndex++, element); // Add the element at the correct index and increment index
        }
    }

    // compares sizes to detect if collection changed
    return sizeBefore != size();
}",0,0
122,Collections_6,"    public Object remove(Object key) {
        if (delegateMap != null) {
            return delegateMap.remove(key);
        }
        if (size == 0) {
            return null;
        }
        if (key == null) {
            switch (size) {  // drop through
                case 3:
                    if (key3 == null) {
                        Object old = value3;
                        hash3 = 0;
                        key3 = null;
                        value3 = null;
                        size = 2;
                        return old;
                    }
                    if (key2 == null) {
                        Object old = value3;
                        hash2 = hash3;
                        key2 = key3;
                        value2 = value3;
                        hash3 = 0;
                        key3 = null;
                        value3 = null;
                        size = 2;
                        return old;
                    }
                    if (key1 == null) {
                        Object old = value3;
                        hash1 = hash3;
                        key1 = key3;
                        value1 = value3;
                        hash3 = 0;
                        key3 = null;
                        value3 = null;
                        size = 2;
                        return old;
                    }
                    return null;
                case 2:
                    if (key2 == null) {
                        Object old = value2;
                        hash2 = 0;
                        key2 = null;
                        value2 = null;
                        size = 1;
                        return old;
                    }
                    if (key1 == null) {
                        Object old = value2;
                        hash1 = hash2;
                        key1 = key2;
                        value1 = value2;
                        hash2 = 0;
                        key2 = null;
                        value2 = null;
                        size = 1;
                        return old;
                    }
                    return null;
                case 1:
                    if (key1 == null) {
                        Object old = value1;
                        hash1 = 0;
                        key1 = null;
                        value1 = null;
                        size = 0;
                        return old;
                    }
            }
        } else {
            if (size > 0) {
                int hashCode = key.hashCode();
                switch (size) {  // drop through
                    case 3:
                        if (hash3 == hashCode && key.equals(key3)) {
                            Object old = value3;
                            hash3 = 0;
                            key3 = null;
                            value3 = null;
                            size = 2;
                            return old;
                        }
                        if (hash2 == hashCode && key.equals(key2)) {
                            Object old = value3;
                            hash2 = hash3;
                            key2 = key3;
                            value2 = value3;
                            hash3 = 0;
                            key3 = null;
                            value3 = null;
                            size = 2;
                            return old;
                        }
                        if (hash1 == hashCode && key.equals(key1)) {
                            Object old = value3;
                            hash1 = hash3;
                            key1 = key3;
                            value1 = value3;
                            hash3 = 0;
                            key3 = null;
                            value3 = null;
                            size = 2;
                            return old;
                        }
                        return null;
                    case 2:
                        if (hash2 == hashCode && key.equals(key2)) {
                            Object old = value2;
                            hash2 = 0;
                            key2 = null;
                            value2 = null;
                            size = 1;
                            return old;
                        }
                        if (hash1 == hashCode && key.equals(key1)) {
                            Object old = value2;
                            hash1 = hash2;
                            key1 = key2;
                            value1 = value2;
                            hash2 = 0;
                            key2 = null;
                            value2 = null;
                            size = 1;
                            return old;
                        }
                        return null;
                    case 1:
                        if (hash1 == hashCode && key.equals(key1)) {
                            Object old = value1;
                            hash1 = 0;
                            key1 = null;
                            value1 = null;
                            size = 0;
                            return old;
                        }
                }
            }
        }
        return null;
    }
","public Object remove(Object key) {
    if (delegateMap != null) {
        return delegateMap.remove(key);
    }
    if (size == 0) {
        return null;
    }
    if (key == null) {
        switch (size) {
            case 3:
                if (key3 == null) {
                    Object old = value3;
                    hash3 = 0;
                    key3 = null;
                    value3 = null;
                    size = 2;
                    return old;
                }
                if (key2 == null) {
                    Object old = value2;
                    hash2 = 0;
                    key2 = null;
                    value2 = null;
                    size = 2;
                    return old;
                }
                if (key1 == null) {
                    Object old = value1;
                    hash1 = 0;
                    key1 = null;
                    value1 = null;
                    size = 2;
                    return old;
                }
                return null;
            case 2:
                if (key2 == null) {
                    Object old = value2;
                    hash2 = 0;
                    key2 = null;
                    value2 = null;
                    size = 1;
                    return old;
                }
                if (key1 == null) {
                    Object old = value1;
                    hash1 = 0;
                    key1 = null;
                    value1 = null;
                    size = 1;
                    return old;
                }
                return null;
            case 1:
                if (key1 == null) {
                    Object old = value1;
                    hash1 = 0;
                    key1 = null;
                    value1 = null;
                    size = 0;
                    return old;
                }
        }
    } else {
        if (size > 0) {
            int hashCode = key.hashCode();
            switch (size) {
                case 3:
                    if (hash3 == hashCode && key.equals(key3)) {
                        Object old = value3;
                        hash3 = 0;
                        key3 = null;
                        value3 = null;
                        size = 2;
                        return old;
                    }
                    if (hash2 == hashCode && key.equals(key2)) {
                        Object old = value2;
                        hash2 = 0;
                        key2 = null;
                        value2 = null;
                        size = 2;
                        return old;
                    }
                    if (hash1 == hashCode && key.equals(key1)) {
                        Object old = value1;
                        hash1 = 0;
                        key1 = null;
                        value1 = null;
                        size = 2;
                        return old;
                    }
                    return null;
                case 2:
                    if (hash2 == hashCode && key.equals(key2)) {
                        Object old = value2;
                        hash2 = 0;
                        key2 = null;
                        value2 = null;
                        size = 1;
                        return old;
                    }
                    if (hash1 == hashCode && key.equals(key1)) {
                        Object old = value1;
                        hash1 = 0;
                        key1 = null;
                        value1 = null;
                        size = 1;
                        return old;
                    }
                    return null;
                case 1:
                    if (hash1 == hashCode && key.equals(key1)) {
                        Object old = value1;
                        hash1 = 0;
                        key1 = null;
                        value1 = null;
                        size = 0;
                        return old;
                    }
            }
        }
    }
    return null;
}",0,0
123,Collections_7,"    public Short getShort(String key, Short defaultValue) {
        Object value = get(key);

        if (value instanceof Short) {
            return (Short) value;
            
        } else if (value instanceof String) {
            Short s = new Short((String) value);
            put(key, s);
            return s;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getShort(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Short object"");
        }
    }
","public Short getShort(String key, Short defaultValue) {
    Object value = get(key);

    if (value instanceof Short) {
        return (Short) value;
    } else if (value instanceof String) {
        try {
            Short s = Short.valueOf((String) value);
            put(key, s);
            return s;
        } catch (NumberFormatException e) {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Short object"");
        }
    } else if (value == null) {
        if (defaults != null) {
            return defaults.getShort(key, defaultValue);
        } else {
            return defaultValue;
        }
    } else {
        throw new ClassCastException('\'' + key + ""' doesn't map to a Short object"");
    }
}",0,0
123,Collections_7,"    /**
     * Remove the property specified by the key from the 
     * ExtendedProperties.
     *
     * @param key specifying the property
     * @return old value of the property
     */","public Object removeProperty(String key) {
    if (containsKey(key)) {
        Object oldValue = get(key);
        keysAsListed.remove(key);
        remove(key);
        return oldValue;
    }
    return null;
}",0,0
123,Collections_7,"    public void putAll(Map map) {
        if (map instanceof ExtendedProperties) {
            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {
                Object key = it.next();
                put(key, map.get(key));
            }
        } else {
            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {
                Map.Entry entry = (Map.Entry) it.next();
                put(entry.getKey(), entry.getValue());
            }
        }
    }
","public void putAll(Map map) {
    if (map instanceof ExtendedProperties) {
        ExtendedProperties extendedProps = (ExtendedProperties) map;
        for (Iterator it = extendedProps.getKeys(); it.hasNext(); ) {
            Object key = it.next();
            put(key, extendedProps.get(key));
        }
    } else {
        for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry entry = (Map.Entry) it.next();
            put(entry.getKey(), entry.getValue());
        }
    }
}",0,0
123,Collections_7,"    public Double getDouble(String key, Double defaultValue) {
        Object value = get(key);

        if (value instanceof Double) {
            return (Double) value;
            
        } else if (value instanceof String) {
            Double d = new Double((String) value);
            put(key, d);
            return d;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getDouble(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Double object"");
        }
    }
","public Double getDouble(String key, Double defaultValue) {
    Object value = get(key);

    if (value instanceof Double) {
        return (Double) value;
    } else if (value instanceof String) {
        try {
            Double d = Double.valueOf((String) value);
            put(key, d);
            return d;
        } catch (NumberFormatException e) {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Double object"");
        }
    } else if (value == null) {
        if (defaults != null) {
            return defaults.getDouble(key, defaultValue);
        } else {
            return defaultValue;
        }
    } else {
        throw new ClassCastException('\'' + key + ""' doesn't map to a Double object"");
    }
}",0,0
123,Collections_7,"    public Long getLong(String key, Long defaultValue) {
        Object value = get(key);

        if (value instanceof Long) {
            return (Long) value;
            
        } else if (value instanceof String) {
            Long l = new Long((String) value);
            put(key, l);
            return l;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getLong(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Long object"");
        }
    }
","public Long getLong(String key, Long defaultValue) {
    Object value = get(key);

    if (value instanceof Long) {
        return (Long) value;
    } else if (value instanceof String) {
        try {
            Long l = Long.valueOf((String) value);
            put(key, l);
            return l;
        } catch (NumberFormatException e) {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Long object"");
        }
    } else if (value == null) {
        if (defaults != null) {
            return defaults.getLong(key, defaultValue);
        } else {
            return defaultValue;
        }
    } else {
        throw new ClassCastException('\'' + key + ""' doesn't map to a Long object"");
    }
}",0,0
123,Collections_7,"    public Integer getInteger(String key, Integer defaultValue) {
        Object value = get(key);

        if (value instanceof Integer) {
            return (Integer) value;
            
        } else if (value instanceof String) {
            Integer i = new Integer((String) value);
            put(key, i);
            return i;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getInteger(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Integer object"");
        }
    }
","public Integer getInteger(String key, Integer defaultValue) {
    Object value = get(key);

    if (value instanceof Integer) {
        return (Integer) value;
    } else if (value instanceof String) {
        try {
            Integer i = Integer.valueOf((String) value);
            put(key, i);
            return i;
        } catch (NumberFormatException e) {
            throw new ClassCastException('\'' + key + ""' doesn't map to an Integer object"");
        }
    } else if (value == null) {
        if (defaults != null) {
            return defaults.getInteger(key, defaultValue);
        } else {
            return defaultValue;
        }
    } else {
        throw new ClassCastException('\'' + key + ""' doesn't map to an Integer object"");
    }
}",0,0
123,Collections_7,"    public Byte getByte(String key, Byte defaultValue) {
        Object value = get(key);

        if (value instanceof Byte) {
            return (Byte) value;
            
        } else if (value instanceof String) {
            Byte b = new Byte((String) value);
            put(key, b);
            return b;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getByte(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Byte object"");
        }
    }
","public Byte getByte(String key, Byte defaultValue) {
    Object value = get(key);

    if (value instanceof Byte) {
        return (Byte) value;
    } else if (value instanceof String) {
        try {
            Byte b = Byte.valueOf((String) value);
            put(key, b);
            return b;
        } catch (NumberFormatException e) {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Byte object"");
        }
    } else if (value == null) {
        if (defaults != null) {
            return defaults.getByte(key, defaultValue);
        } else {
            return defaultValue;
        }
    } else {
        throw new ClassCastException('\'' + key + ""' doesn't map to a Byte object"");
    }
}",0,0
123,Collections_7,"    private void addPropertyDirect(String key, Object value) {
        // safety check
        if (!containsKey(key)) {
            keysAsListed.add(key);
        }
        put(key, value);
    }
","private void addPropertyDirect(String key, Object value) {
    if (!containsKey(key)) {
        keysAsListed.add(key);
    }
    put(key, value);
}",0,0
123,Collections_7,"    public Float getFloat(String key, Float defaultValue) {
        Object value = get(key);

        if (value instanceof Float) {
            return (Float) value;
            
        } else if (value instanceof String) {
            Float f = new Float((String) value);
            put(key, f);
            return f;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getFloat(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Float object"");
        }
    }
","public Float getFloat(String key, Float defaultValue) {
    Object value = get(key);

    if (value instanceof Float) {
        return (Float) value;
    } else if (value instanceof String) {
        try {
            Float f = Float.valueOf((String) value);
            put(key, f);
            return f;
        } catch (NumberFormatException e) {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Float object"");
        }
    } else if (value == null) {
        if (defaults != null) {
            return defaults.getFloat(key, defaultValue);
        } else {
            return defaultValue;
        }
    } else {
        throw new ClassCastException('\'' + key + ""' doesn't map to a Float object"");
    }
}",0,0
123,Collections_7,"    public Vector getVector(String key, Vector defaultValue) {
        Object value = get(key);

        if (value instanceof List) {
            return new Vector((List) value);
            
        } else if (value instanceof String) {
            Vector values = new Vector(1);
            values.add(value);
            put(key, values);
            return values;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getVector(key, defaultValue);
            } else {
                return ((defaultValue == null) ? new Vector() : defaultValue);
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Vector object"");
        }
    }
","public Vector getVector(String key, Vector defaultValue) {
    Object value = get(key);

    if (value instanceof List) {
        return new Vector((List) value);
    } else if (value instanceof String) {
        Vector values = new Vector(1);
        values.add(value);
        put(key, values);
        return values;
    } else if (value == null) {
        if (defaults != null) {
            return defaults.getVector(key, defaultValue);
        } else {
            return ((defaultValue == null) ? new Vector() : defaultValue);
        }
    } else {
        throw new ClassCastException('\'' + key + ""' doesn't map to a Vector object"");
    }
}",0,0
123,Collections_7,"    public void clearProperty(String key) {
        if (containsKey(key)) {
            // we also need to rebuild the keysAsListed or else
            // things get *very* confusing
            for (int i = 0; i < keysAsListed.size(); i++) {
                if (( keysAsListed.get(i)).equals(key)) {
                    keysAsListed.remove(i);
                    break;
                }
            }
            remove(key);
        }
    }
","public void clearProperty(String key) {
    if (containsKey(key)) {
        keysAsListed.remove(key);
        remove(key);
    }
}",0,0
123,Collections_7,"    public Object getProperty(String key) {
        // first, try to get from the 'user value' store
        Object obj = this.get(key);

        if (obj == null) {
            // if there isn't a value there, get it from the
            // defaults if we have them
            if (defaults != null) {
                obj = defaults.get(key);
            }
        }

        return obj;
    }
","public Object getProperty(String key) {
    Object obj = this.get(key);

    if (obj == null && defaults != null) {
        obj = defaults.get(key);
    }

    return obj;
}",0,0
123,Collections_7,"    public List getList(String key, List defaultValue) {
        Object value = get(key);

        if (value instanceof List) {
            return new ArrayList((List) value);
            
        } else if (value instanceof String) {
            List values = new ArrayList(1);
            values.add(value);
            put(key, values);
            return values;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getList(key, defaultValue);
            } else {
                return ((defaultValue == null) ? new ArrayList() : defaultValue);
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a List object"");
        }
    }
","public List getList(String key, List defaultValue) {
    Object value = get(key);

    if (value instanceof List) {
        return new ArrayList((List) value);
    } else if (value instanceof String) {
        List values = new ArrayList(1);
        values.add(value);
        put(key, values);
        return values;
    } else if (value == null) {
        if (defaults != null) {
            return defaults.getList(key, defaultValue);
        } else {
            return ((defaultValue == null) ? new ArrayList() : defaultValue);
        }
    } else {
        throw new ClassCastException('\'' + key + ""' doesn't map to a List object"");
    }
}",0,0
123,Collections_7,"    private void addPropertyInternal(String key, Object value) {
        Object current = this.get(key);

        if (current instanceof String) {
            // one object already in map - convert it to a vector
            List values = new Vector(2);
            values.add(current);
            values.add(value);
            put(key, values);
            
        } else if (current instanceof List) {
            // already a list - just add the new token
            ((List) current).add(value);
            
        } else {
            // brand new key - store in keysAsListed to retain order
            if (!containsKey(key)) {
                keysAsListed.add(key);
            }
            put(key, value);
        }
    }
","private void addPropertyInternal(String key, Object value) {
    Object current = this.get(key);

    if (current instanceof String) {
        List values = new ArrayList(2);
        values.add(current);
        values.add(value);
        put(key, values);
    } else if (current instanceof List) {
        ((List) current).add(value);
    } else {
        if (!containsKey(key)) {
            keysAsListed.add(key);
        }
        put(key, value);
    }
}",0,0
123,Collections_7,"    public Boolean getBoolean(String key, Boolean defaultValue) {

        Object value = get(key);

        if (value instanceof Boolean) {
            return (Boolean) value;
            
        } else if (value instanceof String) {
            String s = testBoolean((String) value);
            Boolean b = new Boolean(s);
            put(key, b);
            return b;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getBoolean(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Boolean object"");
        }
    }
","public Boolean getBoolean(String key, Boolean defaultValue) {
    Object value = get(key);

    if (value instanceof Boolean) {
        return (Boolean) value;
    } else if (value instanceof String) {
        try {
            Boolean b = Boolean.valueOf(testBoolean((String) value));
            put(key, b);
            return b;
        } catch (IllegalArgumentException e) {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Boolean object"");
        }
    } else if (value == null) {
        if (defaults != null) {
            return defaults.getBoolean(key, defaultValue);
        } else {
            return defaultValue;
        }
    } else {
        throw new ClassCastException('\'' + key + ""' doesn't map to a Boolean object"");
    }
}",0,0
124,Collections_8,"    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        int size = in.readInt();
        buffer = new Object[size + 1];
        for (int i = 0; i < size; i++) {
            buffer[i] = in.readObject();
        }
        head = 0;
        tail = size;
    }
","private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject();
    int size = in.readInt();
    buffer = new Object[size + 1];
    for (int i = 0; i < size; i++) {
        buffer[i] = in.readObject();
    }
    head = 0;
    tail = size;
    if (size != size()) { // Validate reconstructed size
        throw new IOException(""Data corruption detected: inconsistent size."");
    }
}",0,0
124,Collections_8,"    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeInt(size());
        for (Iterator it = iterator(); it.hasNext();) {
            out.writeObject(it.next());
        }
    }
","private void writeObject(ObjectOutputStream out) throws IOException {
    out.defaultWriteObject();
    out.writeInt(size());
    for (Iterator<?> it = iterator(); it.hasNext();) { // Use generics in iterator
        Object element = it.next();
        if (element == null) { // Check for null elements to prevent errors
            throw new IOException(""Data corruption detected: null element encountered."");
        }
        out.writeObject(element);
    }
}",0,0
125,Collections_9,"    public void combine(ExtendedProperties props) {
        for (Iterator it = props.getKeys(); it.hasNext();) {
            String key = (String) it.next();
            setProperty(key, props.get(key));
        }
    }
","public void combine(ExtendedProperties props) {
    if (props == null) {
        throw new IllegalArgumentException(""Properties object cannot be null"");
    }
    for (Iterator it = props.getKeys(); it.hasNext();) {
        Object keyObj = it.next();
        if (!(keyObj instanceof String)) {
            continue; // Skip non-string keys
        }
        String key = (String) keyObj;
        Object value = props.get(key);
        if (value != null) {
            setProperty(key, value);
        }
    }
}",0,0
126,Compress_2,"public int read(byte[] b, final int off, final int len) throws IOException {
         int toRead = len;
         final int ret = this.input.read(b, off, toRead);
         offset += (ret > 0 ? ret : 0);
         return ret;
    }","public int read(byte[] b, final int off, final int len) throws IOException {
    if (b == null) {
        throw new NullPointerException(""Buffer cannot be null"");
    }
    if (off < 0 || len < 0 || off + len > b.length) {
        throw new IndexOutOfBoundsException(""Invalid offset/length specified"");
    }
    if (len == 0) {
        return 0;
    }

    int toRead = len;
    final int ret = this.input.read(b, off, toRead);
    if (ret > 0) {
        offset += ret;
    }
    return ret;
}",0,0
126,Compress_2,"public ArArchiveEntry getNextArEntry() throws IOException {
                    // hit EOF before previous entry was complete
                    // TODO: throw an exception instead?

        if (offset == 0) {
            final byte[] expected = ArArchiveEntry.HEADER.getBytes();
            final byte[] realized = new byte[expected.length]; 
            final int read = read(realized);
            if (read != expected.length) {
                throw new IOException(""failed to read header"");
            }
            for (int i = 0; i < expected.length; i++) {
                if (expected[i] != realized[i]) {
                    throw new IOException(""invalid header "" + new String(realized));
                }
            }
        }

                // hit eof

        if (input.available() == 0) {
            return null;
        }

        if (offset % 2 != 0) {
            read();
        }
        final byte[] name = new byte[16];
        final byte[] lastmodified = new byte[12];
        final byte[] userid = new byte[6];
        final byte[] groupid = new byte[6];
        final byte[] filemode = new byte[8];
        final byte[] length = new byte[10];

        read(name);
        read(lastmodified);
        read(userid);
        read(groupid);
        read(filemode);
        read(length);

        {
            final byte[] expected = ArArchiveEntry.TRAILER.getBytes();
            final byte[] realized = new byte[expected.length]; 
            final int read = read(realized);
            if (read != expected.length) {
                throw new IOException(""failed to read entry header"");
            }
            for (int i = 0; i < expected.length; i++) {
                if (expected[i] != realized[i]) {
                    throw new IOException(""invalid entry header. not read the content?"");
                }
             }
         }
 
         return new ArArchiveEntry(new String(name).trim(),
                                           Long.parseLong(new String(length)
                                                          .trim()));
     }","public ArArchiveEntry getNextArEntry() throws IOException {
    if (offset == 0) {
        final byte[] expected = ArArchiveEntry.HEADER.getBytes();
        final byte[] realized = new byte[expected.length];
        final int read = read(realized);
        if (read != expected.length) {
            throw new IOException(""Failed to read header"");
        }
        for (int i = 0; i < expected.length; i++) {
            if (expected[i] != realized[i]) {
                throw new IOException(""Invalid header: "" + new String(realized));
            }
        }
    }

    // Check for EOF
    if (input.available() == 0) {
        return null;
    }

    // Align to even boundary if needed
    if (offset % 2 != 0) {
        if (read() == -1) {
            throw new IOException(""Unexpected end of stream during alignment"");
        }
    }

    final byte[] name = new byte[16];
    final byte[] lastmodified = new byte[12];
    final byte[] userid = new byte[6];
    final byte[] groupid = new byte[6];
    final byte[] filemode = new byte[8];
    final byte[] length = new byte[10];

    readFully(name, ""name"");
    readFully(lastmodified, ""lastmodified"");
    readFully(userid, ""userid"");
    readFully(groupid, ""groupid"");
    readFully(filemode, ""filemode"");
    readFully(length, ""length"");

    final byte[] expectedTrailer = ArArchiveEntry.TRAILER.getBytes();
    final byte[] realizedTrailer = new byte[expectedTrailer.length];
    final int readTrailer = read(realizedTrailer);
    if (readTrailer != expectedTrailer.length) {
        throw new IOException(""Failed to read entry trailer"");
    }
    for (int i = 0; i < expectedTrailer.length; i++) {
        if (expectedTrailer[i] != realizedTrailer[i]) {
            throw new IOException(""Invalid entry trailer"");
        }
    }

    long parsedLength;
    try {
        parsedLength = Long.parseLong(new String(length).trim());
    } catch (NumberFormatException e) {
        throw new IOException(""Invalid length value in entry"", e);
    }

    return new ArArchiveEntry(new String(name).trim(), parsedLength);
}

// Helper method for fixed method 2
private void readFully(byte[] buffer, String fieldName) throws IOException {
    final int read = read(buffer);
    if (read != buffer.length) {
        throw new IOException(""Failed to read "" + fieldName);
    }
}",0,0
127,Compress_20,"private CpioArchiveEntry readNewEntry(final boolean hasCrc)
            throws IOException {
        CpioArchiveEntry ret;
        if (hasCrc) {
            ret = new CpioArchiveEntry(FORMAT_NEW_CRC);
        } else {
            ret = new CpioArchiveEntry(FORMAT_NEW);
        }

        ret.setInode(readAsciiLong(8, 16));
        long mode = readAsciiLong(8, 16);
        if (mode != 0){
            ret.setMode(mode);
        }
        ret.setUID(readAsciiLong(8, 16));
        ret.setGID(readAsciiLong(8, 16));
        ret.setNumberOfLinks(readAsciiLong(8, 16));
        ret.setTime(readAsciiLong(8, 16));
        ret.setSize(readAsciiLong(8, 16));
        ret.setDeviceMaj(readAsciiLong(8, 16));
        ret.setDeviceMin(readAsciiLong(8, 16));
        ret.setRemoteDeviceMaj(readAsciiLong(8, 16));
        ret.setRemoteDeviceMin(readAsciiLong(8, 16));
        long namesize = readAsciiLong(8, 16);
         ret.setChksum(readAsciiLong(8, 16));
         String name = readCString((int) namesize);
         ret.setName(name);
         if (mode == 0 && !name.equals(CPIO_TRAILER)){
             throw new IOException(""Mode 0 only allowed in the trailer. Found entry name: ""+name + "" Occured at byte: "" + getBytesRead());
         }
         skip(ret.getHeaderPadCount());

        return ret;
    }","private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {
    CpioArchiveEntry ret;
    if (hasCrc) {
        ret = new CpioArchiveEntry(FORMAT_NEW_CRC);
    } else {
        ret = new CpioArchiveEntry(FORMAT_NEW);
    }

    ret.setInode(readAsciiLong(8, 16));
    long mode = readAsciiLong(8, 16);
    if (mode != 0) {
        ret.setMode(mode);
    }
    ret.setUID(readAsciiLong(8, 16));
    ret.setGID(readAsciiLong(8, 16));
    ret.setNumberOfLinks(readAsciiLong(8, 16));
    ret.setTime(readAsciiLong(8, 16));
    ret.setSize(readAsciiLong(8, 16));
    ret.setDeviceMaj(readAsciiLong(8, 16));
    ret.setDeviceMin(readAsciiLong(8, 16));
    ret.setRemoteDeviceMaj(readAsciiLong(8, 16));
    ret.setRemoteDeviceMin(readAsciiLong(8, 16));
    long namesize = readAsciiLong(8, 16);

    if (namesize <= 0) {
        throw new IOException(""Invalid name size: "" + namesize);
    }

    ret.setChksum(readAsciiLong(8, 16));
    String name = readCString((int) namesize);
    ret.setName(name);

    if (mode == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry name: "" + name + "" Occurred at byte: "" + getBytesRead());
    }

    skip(ret.getHeaderPadCount());

    return ret;
}",0,0
127,Compress_20,"private CpioArchiveEntry readOldAsciiEntry() throws IOException {
        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);

         ret.setDevice(readAsciiLong(6, 8));
         ret.setInode(readAsciiLong(6, 8));
         final long mode = readAsciiLong(6, 8);
         if (mode != 0) {
             ret.setMode(mode);
         }
         ret.setUID(readAsciiLong(6, 8));
        ret.setGID(readAsciiLong(6, 8));
        ret.setNumberOfLinks(readAsciiLong(6, 8));
        ret.setRemoteDevice(readAsciiLong(6, 8));
        ret.setTime(readAsciiLong(11, 8));
        long namesize = readAsciiLong(6, 8);
        ret.setSize(readAsciiLong(11, 8));
        final String name = readCString((int) namesize);
        ret.setName(name);
        if (mode == 0 && !name.equals(CPIO_TRAILER)){
            throw new IOException(""Mode 0 only allowed in the trailer. Found entry: ""+ name + "" Occured at byte: "" + getBytesRead());
        }

        return ret;
    }","private CpioArchiveEntry readOldAsciiEntry() throws IOException {
    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);

    ret.setDevice(readAsciiLong(6, 8));
    ret.setInode(readAsciiLong(6, 8));
    final long mode = readAsciiLong(6, 8);

    if (mode != 0) {
        ret.setMode(mode);
    }

    ret.setUID(readAsciiLong(6, 8));
    ret.setGID(readAsciiLong(6, 8));
    ret.setNumberOfLinks(readAsciiLong(6, 8));
    ret.setRemoteDevice(readAsciiLong(6, 8));
    ret.setTime(readAsciiLong(11, 8));
    long namesize = readAsciiLong(6, 8);

    if (namesize <= 0) {
        throw new IOException(""Invalid name size: "" + namesize);
    }

    ret.setSize(readAsciiLong(11, 8));
    final String name = readCString((int) namesize);
    ret.setName(name);

    if (mode == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry: "" + name + "" Occurred at byte: "" + getBytesRead());
    }

    return ret;
}",0,0
127,Compress_20,"private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)
            throws IOException {
        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);

        ret.setDevice(readBinaryLong(2, swapHalfWord));
        ret.setInode(readBinaryLong(2, swapHalfWord));
        final long mode = readBinaryLong(2, swapHalfWord);
        if (mode != 0){
            ret.setMode(mode);
        }
        ret.setUID(readBinaryLong(2, swapHalfWord));
        ret.setGID(readBinaryLong(2, swapHalfWord));
        ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));
        ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));
        ret.setTime(readBinaryLong(4, swapHalfWord));
        long namesize = readBinaryLong(2, swapHalfWord);
         ret.setSize(readBinaryLong(4, swapHalfWord));
         final String name = readCString((int) namesize);
         ret.setName(name);
         if (mode == 0 && !name.equals(CPIO_TRAILER)){
             throw new IOException(""Mode 0 only allowed in the trailer. Found entry: ""+name + ""Occured at byte: "" + getBytesRead());
         }
         skip(ret.getHeaderPadCount());

        return ret;
    }","private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {
    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);

    ret.setDevice(readBinaryLong(2, swapHalfWord));
    ret.setInode(readBinaryLong(2, swapHalfWord));
    final long mode = readBinaryLong(2, swapHalfWord);

    if (mode != 0) {
        ret.setMode(mode);
    }

    ret.setUID(readBinaryLong(2, swapHalfWord));
    ret.setGID(readBinaryLong(2, swapHalfWord));
    ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));
    ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));
    ret.setTime(readBinaryLong(4, swapHalfWord));
    long namesize = readBinaryLong(2, swapHalfWord);

    if (namesize <= 0) {
        throw new IOException(""Invalid name size: "" + namesize);
    }

    ret.setSize(readBinaryLong(4, swapHalfWord));
    final String name = readCString((int) namesize);
    ret.setName(name);

    if (mode == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry: "" + name + "" Occurred at byte: "" + getBytesRead());
    }

    skip(ret.getHeaderPadCount());

    return ret;
}",0,0
128,Compress_22,"private int setupNoRandPartC() throws IOException {
         if (this.su_j2 < this.su_z) {
             int su_ch2Shadow = this.su_ch2;
             this.currentChar = su_ch2Shadow;
             this.crc.updateCRC(su_ch2Shadow);
             this.su_j2++;
             this.currentState = NO_RAND_PART_C_STATE;
            return su_ch2Shadow;
        } else {
            this.su_i2++;
            this.su_count = 0;
            return setupNoRandPartA();
        }
    }","private int setupNoRandPartC() throws IOException {
    if (this.su_j2 < this.su_z) {
        int su_ch2Shadow = this.su_ch2;
        this.currentChar = su_ch2Shadow;
        this.crc.updateCRC(su_ch2Shadow);
        this.su_j2++;
        this.currentState = NO_RAND_PART_C_STATE;
        return su_ch2Shadow;
    } else {
        if (++this.su_i2 > this.last) { // Ensure `su_i2` does not exceed `last` to avoid infinite recursion.
            this.currentState = EOF;
            return -1;
        }
        this.su_count = 0;
        return setupNoRandPartA();
    }
}",0,0
128,Compress_22,"private int setupRandPartC() throws IOException {
         if (this.su_j2 < this.su_z) {
             this.currentChar = this.su_ch2;
             this.crc.updateCRC(this.su_ch2);
             this.su_j2++;
             return this.su_ch2;
        } else {
            this.currentState = RAND_PART_A_STATE;
            this.su_i2++;
            this.su_count = 0;
            return setupRandPartA();
        }
    }","private int setupRandPartC() throws IOException {
    if (this.su_j2 < this.su_z) {
        int su_ch2Shadow = this.su_ch2;
        this.currentChar = su_ch2Shadow;
        this.crc.updateCRC(su_ch2Shadow);
        this.su_j2++;
        return su_ch2Shadow;
    } else {
        if (++this.su_i2 > this.last) { // Ensure `su_i2` does not exceed `last` to avoid infinite recursion.
            this.currentState = EOF;
            return -1;
        }
        this.currentState = RAND_PART_A_STATE;
        this.su_count = 0;
        return setupRandPartA();
    }
}",0,0
128,Compress_22,"private int setupNoRandPartA() throws IOException {
        if (this.su_i2 <= this.last) {
            this.su_chPrev = this.su_ch2;
            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
             this.su_ch2 = su_ch2Shadow;
             this.su_tPos = this.data.tt[this.su_tPos];
             this.su_i2++;
             this.currentChar = su_ch2Shadow;
             this.currentState = NO_RAND_PART_B_STATE;
             this.crc.updateCRC(su_ch2Shadow);
             return su_ch2Shadow;
        } else {
            this.currentState = NO_RAND_PART_A_STATE;
            endBlock();
            initBlock();
            return setupBlock();
        }
    }","private int setupNoRandPartA() throws IOException {
    if (this.su_i2 <= this.last) {
        this.su_chPrev = this.su_ch2;
        int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
        this.su_ch2 = su_ch2Shadow;
        this.su_tPos = this.data.tt[this.su_tPos];
        this.su_i2++;
        this.currentChar = su_ch2Shadow;
        this.currentState = NO_RAND_PART_B_STATE;
        this.crc.updateCRC(su_ch2Shadow);
        return su_ch2Shadow;
    } else {
        this.currentState = EOF;
        endBlock();
        initBlock();
        return setupBlock();
    }
}",0,0
128,Compress_22,"private int setupRandPartA() throws IOException {
        if (this.su_i2 <= this.last) {
            this.su_chPrev = this.su_ch2;
            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
            this.su_tPos = this.data.tt[this.su_tPos];
            if (this.su_rNToGo == 0) {
                this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
                if (++this.su_rTPos == 512) {
                    this.su_rTPos = 0;
                }
            } else {
                this.su_rNToGo--;
             }
             this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;
             this.su_i2++;
             this.currentChar = su_ch2Shadow;
             this.currentState = RAND_PART_B_STATE;
             this.crc.updateCRC(su_ch2Shadow);
             return su_ch2Shadow;
        } else {
            endBlock();
            initBlock();
            return setupBlock();
        }
    }","private int setupRandPartA() throws IOException {
    if (this.su_i2 <= this.last) {
        this.su_chPrev = this.su_ch2;
        int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
        this.su_tPos = this.data.tt[this.su_tPos];
        if (this.su_rNToGo == 0) {
            this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
            if (++this.su_rTPos == 512) {
                this.su_rTPos = 0;
            }
        } else {
            this.su_rNToGo--;
        }
        su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;
        this.su_ch2 = su_ch2Shadow;
        this.su_i2++;
        this.currentChar = su_ch2Shadow;
        this.currentState = RAND_PART_B_STATE;
        this.crc.updateCRC(su_ch2Shadow);
        return su_ch2Shadow;
    } else {
        this.currentState = EOF;
        endBlock();
        initBlock();
        return setupBlock();
    }
}",0,0
129,Compress_29,"public ArchiveInputStream createArchiveInputStream(final InputStream in)
            throws ArchiveException {
        if (in == null) {
            throw new IllegalArgumentException(""Stream must not be null."");
        }

        if (!in.markSupported()) {
            throw new IllegalArgumentException(""Mark is not supported."");
        }

        final byte[] signature = new byte[12];
        in.mark(signature.length);
        try {
            int signatureLength = IOUtils.readFully(in, signature);
            in.reset();
            if (ZipArchiveInputStream.matches(signature, signatureLength)) {
                if (entryEncoding != null) {
                    return new ZipArchiveInputStream(in, entryEncoding);
                } else {
                    return new ZipArchiveInputStream(in);
                }
            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
                if (entryEncoding != null) {
                    return new JarArchiveInputStream(in, entryEncoding);
                } else {
                    return new JarArchiveInputStream(in);
                }
            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
                return new ArArchiveInputStream(in);
            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
                if (entryEncoding != null) {
                    return new CpioArchiveInputStream(in, entryEncoding);
                } else {
                     return new CpioArchiveInputStream(in);
                 }
             } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {
                     return new ArjArchiveInputStream(in);
             } else if (SevenZFile.matches(signature, signatureLength)) {
                 throw new StreamingNotSupportedException(SEVEN_Z);
             }

            // Dump needs a bigger buffer to check the signature;
            final byte[] dumpsig = new byte[32];
            in.mark(dumpsig.length);
            signatureLength = IOUtils.readFully(in, dumpsig);
            in.reset();
            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
                return new DumpArchiveInputStream(in, entryEncoding);
            }

            // Tar needs an even bigger buffer to check the signature; read the first block
            final byte[] tarheader = new byte[512];
            in.mark(tarheader.length);
            signatureLength = IOUtils.readFully(in, tarheader);
            in.reset();
            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
                return new TarArchiveInputStream(in, entryEncoding);
            }
            // COMPRESS-117 - improve auto-recognition
            if (signatureLength >= 512) {
                TarArchiveInputStream tais = null;
                try {
                    tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                    // COMPRESS-191 - verify the header checksum
                    if (tais.getNextTarEntry().isCheckSumOK()) {
                        return new TarArchiveInputStream(in, encoding);
                    }
                } catch (Exception e) { // NOPMD
                    // can generate IllegalArgumentException as well
                    // as IOException
                    // autodetection, simply not a TAR
                    // ignored
                } finally {
                    IOUtils.closeQuietly(tais);
                }
            }
        } catch (IOException e) {
            throw new ArchiveException(""Could not use reset and mark operations."", e);
        }

        throw new ArchiveException(""No Archiver found for the stream signature"");
    }","public ArchiveInputStream createArchiveInputStream(final InputStream in)
        throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }

    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }

    final byte[] signature = new byte[12];
    try {
        in.mark(signature.length);
        int signatureLength = IOUtils.readFully(in, signature);
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            return entryEncoding != null
                ? new ZipArchiveInputStream(in, entryEncoding)
                : new ZipArchiveInputStream(in);
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            return entryEncoding != null
                ? new JarArchiveInputStream(in, entryEncoding)
                : new JarArchiveInputStream(in);
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            return entryEncoding != null
                ? new CpioArchiveInputStream(in, entryEncoding)
                : new CpioArchiveInputStream(in);
        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {
            return new ArjArchiveInputStream(in);
        } else if (SevenZFile.matches(signature, signatureLength)) {
            throw new StreamingNotSupportedException(SEVEN_Z);
        }

        final byte[] dumpsig = new byte[32];
        in.mark(dumpsig.length);
        signatureLength = IOUtils.readFully(in, dumpsig);
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in, entryEncoding);
        }

        final byte[] tarheader = new byte[512];
        in.mark(tarheader.length);
        signatureLength = IOUtils.readFully(in, tarheader);
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in, entryEncoding);
        }

        if (signatureLength >= 512) {
            try (TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader))) {
                if (tais.getNextTarEntry().isCheckSumOK()) {
                    return new TarArchiveInputStream(in, entryEncoding);
                }
            } catch (Exception e) {
                // Ignore malformed TAR entries for autodetection
            }
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }

    throw new ArchiveException(""No Archiver found for the stream signature"");
}",0,0
129,Compress_29,"public ArchiveOutputStream createArchiveOutputStream(
            final String archiverName, final OutputStream out)
            throws ArchiveException {
        if (archiverName == null) {
            throw new IllegalArgumentException(""Archivername must not be null."");
        }
        if (out == null) {
            throw new IllegalArgumentException(""OutputStream must not be null."");
        }

        if (AR.equalsIgnoreCase(archiverName)) {
            return new ArArchiveOutputStream(out);
        }
        if (ZIP.equalsIgnoreCase(archiverName)) {
            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);
            if (entryEncoding != null) {
                zip.setEncoding(entryEncoding);
            }
            return zip;
        }
        if (TAR.equalsIgnoreCase(archiverName)) {
            if (entryEncoding != null) {
                return new TarArchiveOutputStream(out, entryEncoding);
            } else {
                return new TarArchiveOutputStream(out);
             }
         }
         if (JAR.equalsIgnoreCase(archiverName)) {
                 return new JarArchiveOutputStream(out);
         }
         if (CPIO.equalsIgnoreCase(archiverName)) {
             if (entryEncoding != null) {
                return new CpioArchiveOutputStream(out, entryEncoding);
            } else {
                return new CpioArchiveOutputStream(out);
            }
        }
        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {
            throw new StreamingNotSupportedException(SEVEN_Z);
        }
        throw new ArchiveException(""Archiver: "" + archiverName + "" not found."");
    }","public ArchiveOutputStream createArchiveOutputStream(final String archiverName, final OutputStream out)
        throws ArchiveException {
    if (archiverName == null) {
        throw new IllegalArgumentException(""Archivername must not be null."");
    }
    if (out == null) {
        throw new IllegalArgumentException(""OutputStream must not be null."");
    }

    switch (archiverName.toUpperCase()) {
        case AR:
            return new ArArchiveOutputStream(out);
        case ZIP:
            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);
            if (entryEncoding != null) {
                zip.setEncoding(entryEncoding);
            }
            return zip;
        case TAR:
            return entryEncoding != null
                ? new TarArchiveOutputStream(out, entryEncoding)
                : new TarArchiveOutputStream(out);
        case JAR:
            return new JarArchiveOutputStream(out);
        case CPIO:
            return entryEncoding != null
                ? new CpioArchiveOutputStream(out, entryEncoding)
                : new CpioArchiveOutputStream(out);
        case SEVEN_Z:
            throw new StreamingNotSupportedException(SEVEN_Z);
        default:
            throw new ArchiveException(""Archiver: "" + archiverName + "" not found."");
    }
}",0,0
130,Compress_3,"public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {
        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;
        if (entry.getName().length() >= TarConstants.NAMELEN) {

            if (longFileMode == LONGFILE_GNU) {
                // create a TarEntry for the LongLink, the contents
                // of which are the entry's name
                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,
                                                                    TarConstants.LF_GNUTYPE_LONGNAME);

                final byte[] nameBytes = entry.getName().getBytes(); // TODO is it correct to use the default charset here?
                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL
                putArchiveEntry(longLinkEntry);
                write(nameBytes);
                write(0); // NUL terminator
                closeArchiveEntry();
            } else if (longFileMode != LONGFILE_TRUNCATE) {
                throw new RuntimeException(""file name '"" + entry.getName()
                                           + ""' is too long ( > ""
                                           + TarConstants.NAMELEN + "" bytes)"");
            }
        }

        entry.writeEntryHeader(recordBuf);
        buffer.writeRecord(recordBuf);

        currBytes = 0;

        if (entry.isDirectory()) {
            currSize = 0;
        } else {
             currSize = entry.getSize();
         }
         currName = entry.getName();
     }","public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {
    TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;
    if (entry.getName().length() >= TarConstants.NAMELEN) {
        if (longFileMode == LONGFILE_GNU) {
            // create a TarEntry for the LongLink, the contents of which are the entry's name
            TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME);

            final byte[] nameBytes = entry.getName().getBytes(TarConstants.DEFAULT_CHARSET); // Use DEFAULT_CHARSET explicitly for encoding
            longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL
            putArchiveEntry(longLinkEntry);
            write(nameBytes);
            write(0); // NUL terminator
            closeArchiveEntry();
        } else if (longFileMode != LONGFILE_TRUNCATE) {
            throw new IOException(""file name '"" + entry.getName() + ""' is too long ( > "" + TarConstants.NAMELEN + "" bytes)"");
        }
    }

    entry.writeEntryHeader(recordBuf);
    buffer.writeRecord(recordBuf);

    currBytes = 0;

    if (entry.isDirectory()) {
        currSize = 0;
    } else {
        currSize = entry.getSize();
    }
    currName = entry.getName();
}",0,0
130,Compress_3,"public void closeArchiveEntry() throws IOException {
        if (assemLen > 0) {
            for (int i = assemLen; i < assemBuf.length; ++i) {
                assemBuf[i] = 0;
            }

            buffer.writeRecord(assemBuf);

            currBytes += assemLen;
            assemLen = 0;
        }

        if (currBytes < currSize) {
            throw new IOException(""entry '"" + currName + ""' closed at '""
                                  + currBytes
                                   + ""' before the '"" + currSize
                                   + ""' bytes specified in the header were written"");
         }
     }","public void closeArchiveEntry() throws IOException {
    if (assemLen > 0) {
        for (int i = assemLen; i < assemBuf.length; ++i) {
            assemBuf[i] = 0;
        }

        buffer.writeRecord(assemBuf);

        currBytes += assemLen;
        assemLen = 0;
    }

    if (currBytes < currSize) {
        throw new IOException(""entry '"" + currName + ""' closed at '"" + currBytes + ""' before the '"" + currSize + ""' bytes specified in the header were written"");
    }

    // Ensure the record alignment for proper archive closure
    while (currBytes % recordBuf.length != 0) {
        write(0);
        currBytes++;
    }
}",0,0
131,Compress_33,"public CompressorInputStream createCompressorInputStream(final InputStream in)
            throws CompressorException {
        if (in == null) {
            throw new IllegalArgumentException(""Stream must not be null."");
        }

        if (!in.markSupported()) {
            throw new IllegalArgumentException(""Mark is not supported."");
        }

        final byte[] signature = new byte[12];
        in.mark(signature.length);
        try {
            int signatureLength = IOUtils.readFully(in, signature);
            in.reset();

            if (BZip2CompressorInputStream.matches(signature, signatureLength)) {
                return new BZip2CompressorInputStream(in, decompressConcatenated);
            }

            if (GzipCompressorInputStream.matches(signature, signatureLength)) {
                return new GzipCompressorInputStream(in, decompressConcatenated);
            }

            if (Pack200CompressorInputStream.matches(signature, signatureLength)) {
                return new Pack200CompressorInputStream(in);
            }

            if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {
                return new FramedSnappyCompressorInputStream(in);
            }

            if (ZCompressorInputStream.matches(signature, signatureLength)) {
                 return new ZCompressorInputStream(in);
             }
 
 
             if (XZUtils.matches(signature, signatureLength) &&
                 XZUtils.isXZCompressionAvailable()) {
                return new XZCompressorInputStream(in, decompressConcatenated);
            }

            if (LZMAUtils.matches(signature, signatureLength) &&
                LZMAUtils.isLZMACompressionAvailable()) {
                return new LZMACompressorInputStream(in);
            }

        } catch (IOException e) {
            throw new CompressorException(""Failed to detect Compressor from InputStream."", e);
        }

        throw new CompressorException(""No Compressor found for the stream signature."");
    }","public CompressorInputStream createCompressorInputStream(final InputStream in)
        throws CompressorException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }

    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }

    final byte[] signature = new byte[12];
    in.mark(signature.length);
    int signatureLength;
    try {
        signatureLength = IOUtils.readFully(in, signature);
        in.reset();
    } catch (IOException e) {
        throw new CompressorException(""Failed to read or reset InputStream."", e);
    }

    try {
        if (BZip2CompressorInputStream.matches(signature, signatureLength)) {
            return new BZip2CompressorInputStream(in, decompressConcatenated);
        }

        if (GzipCompressorInputStream.matches(signature, signatureLength)) {
            return new GzipCompressorInputStream(in, decompressConcatenated);
        }

        if (Pack200CompressorInputStream.matches(signature, signatureLength)) {
            return new Pack200CompressorInputStream(in);
        }

        if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {
            return new FramedSnappyCompressorInputStream(in);
        }

        if (ZCompressorInputStream.matches(signature, signatureLength)) {
            return new ZCompressorInputStream(in);
        }

        if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {
            return new XZCompressorInputStream(in, decompressConcatenated);
        }

        if (LZMAUtils.matches(signature, signatureLength) && LZMAUtils.isLZMACompressionAvailable()) {
            return new LZMACompressorInputStream(in);
        }
    } catch (IOException e) {
        throw new CompressorException(""Failed to detect Compressor from InputStream."", e);
    }

    throw new CompressorException(""No Compressor found for the stream signature."");
}",0,0
132,Compress_34,"    private static final ZipShort HEADER_ID = new ZipShort(0x7875);
    private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);
    private static final long serialVersionUID = 1L;

    private int version = 1; // always '1' according to current info-zip spec.

    // BigInteger helps us with little-endian / big-endian conversions.
    // (thanks to BigInteger.toByteArray() and a reverse() method we created).
    // Also, the spec theoretically allows UID/GID up to 255 bytes long!
    //
    // NOTE:  equals() and hashCode() currently assume these can never be null.
    private BigInteger uid;
    private BigInteger gid;

    /**
","private static final ZipShort HEADER_ID = new ZipShort(0x7875);
private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);
private static final long serialVersionUID = 1L;

private int version = 1; // always '1' according to current info-zip spec.

// BigInteger helps us with little-endian / big-endian conversions.
// (thanks to BigInteger.toByteArray() and a reverse() method we created).
// Also, the spec theoretically allows UID/GID up to 255 bytes long!
//
// NOTE: equals() and hashCode() currently assume these can never be null.
private BigInteger uid = BigInteger.ZERO; // Default initialization to avoid null issues.
private BigInteger gid = BigInteger.ZERO; // Default initialization to avoid null issues.

/** No changes to the rest of this method definition **/",0,0
132,Compress_34,"    public ZipShort getCentralDirectoryLength() {
        return getLocalFileDataLength();
    }
","public ZipShort getCentralDirectoryLength() {
    // Ensure `getLocalFileDataLength` can safely handle null UID/GID.
    if (uid == null) {
        uid = BigInteger.ZERO;
    }
    if (gid == null) {
        gid = BigInteger.ZERO;
    }
    return getLocalFileDataLength();
}",0,0
133,Compress_39,"    private ArchiveUtils(){
    }
","private ArchiveUtils() {
    // Prevent instantiation
    throw new UnsupportedOperationException(""This is a utility class and cannot be instantiated"");
}",0,0
133,Compress_39,"    public static String sanitize(String s) {
        final char[] chars = s.toCharArray();
        final int len = chars.length;
        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i < len; i++) {
            final char c = chars[i];
            if (!Character.isISOControl(c)) {
                Character.UnicodeBlock block = Character.UnicodeBlock.of(c);
                if (block != null && block != Character.UnicodeBlock.SPECIALS) {
                    sb.append(c);
                    continue;
                }
            }
            sb.append('?');
        }
        return sb.toString();
    }
","public static String sanitize(String s) {
    if (s == null) {
        return """";
    }
    final char[] chars = s.toCharArray();
    final int len = chars.length;
    final StringBuilder sb = new StringBuilder(len);
    for (int i = 0; i < len; i++) {
        final char c = chars[i];
        if (!Character.isISOControl(c)) {
            Character.UnicodeBlock block = Character.UnicodeBlock.of(c);
            if (block != null && block != Character.UnicodeBlock.SPECIALS) {
                sb.append(c);
                continue;
            }
        }
        sb.append('?');
    }
    return sb.toString();
}",0,0
134,Compress_4,"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)
            throws IOException {
        ChangeSetResults results = new ChangeSetResults();
        
        Set workingSet = new LinkedHashSet(changes);
        
        for (Iterator it = workingSet.iterator(); it.hasNext();) {
            Change change = (Change) it.next();

            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
                copyStream(change.getInput(), out, change.getEntry());
                it.remove();
                results.addedFromChangeSet(change.getEntry().getName());
            }
        }

        ArchiveEntry entry = null;
        while ((entry = in.getNextEntry()) != null) {
            boolean copy = true;

            for (Iterator it = workingSet.iterator(); it.hasNext();) {
                Change change = (Change) it.next();

                final int type = change.type();
                final String name = entry.getName();
                if (type == Change.TYPE_DELETE && name != null) {
                    if (name.equals(change.targetFile())) {
                        copy = false;
                        it.remove();
                        results.deleted(name);
                        break;
                    }
                } else if(type == Change.TYPE_DELETE_DIR && name != null) {
                    if (name.startsWith(change.targetFile() + ""/"")) {
                        copy = false;
                        results.deleted(name);
                        break;
                    }
                }
            }

            if (copy) {
                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                    copyStream(in, out, entry);
                    results.addedFromStream(entry.getName());
                }
            }
        }
        
        // Adds files which hasn't been added from the original and do not have replace mode on
        for (Iterator it = workingSet.iterator(); it.hasNext();) {
            Change change = (Change) it.next();

            if (change.type() == Change.TYPE_ADD && 
                !change.isReplaceMode() && 
                !results.hasBeenAdded(change.getEntry().getName())) {
                copyStream(change.getInput(), out, change.getEntry());
                it.remove();
                 results.addedFromChangeSet(change.getEntry().getName());
             }
         }
         return results;
     }","public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)
        throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set<Change> workingSet = new LinkedHashSet<>(changes);

    for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {
        Change change = it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }

    ArchiveEntry entry;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;

        for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {
            Change change = it.next();
            final int type = change.type();
            final String name = entry.getName();

            if (type == Change.TYPE_DELETE && name != null && name.equals(change.targetFile())) {
                copy = false;
                it.remove();
                results.deleted(name);
                break;
            } else if (type == Change.TYPE_DELETE_DIR && name != null && name.startsWith(change.targetFile() + ""/"")) {
                copy = false;
                results.deleted(name);
                break;
            }
        }

        if (copy && !isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
            copyStream(in, out, entry);
            results.addedFromStream(entry.getName());
        }
    }

    for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {
        Change change = it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && 
            !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }

    return results;
}",0,0
134,Compress_4,"public void close() throws IOException {
         if (!this.closed) {
             this.finish();
             out.close();
             this.closed = true;
         }
    }","public void close() throws IOException {
    if (!this.closed) {
        try {
            this.finish();
        } finally {
            out.close();
            this.closed = true;
        }
    }
}",0,0
134,Compress_4,"public void close() throws IOException {
         if (!closed) {
             finish();
             buffer.close();
             out.close();
             closed = true;
        }
    }","public void close() throws IOException {
    if (!closed) {
        try {
            finish();
        } finally {
            buffer.close();
            out.close();
            closed = true;
        }
    }
}",0,0
135,Compress_42,"    public boolean isUnixSymlink() {
        return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;
    }
",Match failed,0,0
135,Compress_42,"/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.commons.compress.archivers.zip;

/**
 * Constants from stat.h on Unix systems.
 */
// CheckStyle:InterfaceIsTypeCheck OFF - backward compatible
public interface UnixStat {

    /**
     * Bits used for permissions (and sticky bit)
     */
    int PERM_MASK = 07777;
    /**
     * Bits used to indicate the filesystem object type.
     * @since 1.14
     */
    /**
     * Indicates symbolic links.
     */
    int LINK_FLAG = 0120000;
    /**
     * Indicates plain files.
     */
    int FILE_FLAG = 0100000;
    /**
     * Indicates directories.
     */
    int DIR_FLAG = 040000;

    // ----------------------------------------------------------
    // somewhat arbitrary choices that are quite common for shared
    // installations
    // -----------------------------------------------------------

    /**
     * Default permissions for symbolic links.
     */
    int DEFAULT_LINK_PERM = 0777;

    /**
     * Default permissions for directories.
     */
    int DEFAULT_DIR_PERM = 0755;

    /**
     * Default permissions for plain files.
     */
    int DEFAULT_FILE_PERM = 0644;
}
",Match failed,0,0
136,Compress_43,"private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {
        final boolean encodable = zipEncoding.canEncode(ze.getName());
        final ByteBuffer name = getName(ze);

        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {
            addUnicodeExtraFields(ze, encodable, name);
        }
 
         final long localHeaderStart = streamCompressor.getTotalBytesWritten();
         final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);
         metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));
         entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset
         writeCounted(localHeader);
         entry.dataStart = streamCompressor.getTotalBytesWritten();
    }","private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {
    final boolean encodable = zipEncoding.canEncode(ze.getName());
    final ByteBuffer name = getName(ze);

    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {
        addUnicodeExtraFields(ze, encodable, name);
    }

    final long localHeaderStart = streamCompressor.getTotalBytesWritten();
    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);

    // Ensure metadata is properly initialized before usage
    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));

    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At CRC offset
    writeCounted(localHeader);
    entry.dataStart = streamCompressor.getTotalBytesWritten();
}",0,0
136,Compress_43,"private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,
                                         final boolean phased, long archiveOffset) throws IOException {
        ResourceAlignmentExtraField oldAlignmentEx =
            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);
        if (oldAlignmentEx != null) {
            ze.removeExtraField(ResourceAlignmentExtraField.ID);
        }

        int alignment = ze.getAlignment();
        if (alignment <= 0 && oldAlignmentEx != null) {
            alignment = oldAlignmentEx.getAlignment();
        }

        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {
            int oldLength = LFH_FILENAME_OFFSET +
                            name.limit() - name.position() +
                            ze.getLocalFileDataExtra().length;

            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE
                            - ResourceAlignmentExtraField.BASE_SIZE) &
                            (alignment - 1));
            ze.addExtraField(new ResourceAlignmentExtraField(alignment,
                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));
        }

        final byte[] extra = ze.getLocalFileDataExtra();
        final int nameLen = name.limit() - name.position();
        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;
        final byte[] buf = new byte[len];

        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);
 
         //store method in local variable to prevent multiple method calls
         final int zipMethod = ze.getMethod();
         final boolean dataDescriptor = usesDataDescriptor(zipMethod);
 
         putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);
 
        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);
        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);

        // compression method
        putShort(zipMethod, buf, LFH_METHOD_OFFSET);

        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);

        // CRC
        if (phased){
            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
        } else if (zipMethod == DEFLATED || channel != null) {
            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);
        } else {
            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
        }

        // compressed length
        // uncompressed length
        if (hasZip64Extra(entry.entry)){
            // point to ZIP64 extended information extra field for
            // sizes, may get rewritten once sizes are known if
            // stream is seekable
            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);
            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);
        } else if (phased) {
            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
        } else if (zipMethod == DEFLATED || channel != null) {
            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);
            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);
        } else { // Stored
            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
        }
        // file name length
        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);

        // extra field length
        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);

        // file name
        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);

        // extra fields
        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);

        return buf;
    }","private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,
                                     final boolean phased, long archiveOffset) throws IOException {
    ResourceAlignmentExtraField oldAlignmentEx =
        (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);
    if (oldAlignmentEx != null) {
        ze.removeExtraField(ResourceAlignmentExtraField.ID);
    }

    int alignment = ze.getAlignment();
    if (alignment <= 0 && oldAlignmentEx != null) {
        alignment = oldAlignmentEx.getAlignment();
    }

    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {
        int oldLength = LFH_FILENAME_OFFSET +
                        name.limit() - name.position() +
                        ze.getLocalFileDataExtra().length;

        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE
                        - ResourceAlignmentExtraField.BASE_SIZE) &
                        (alignment - 1));
        ze.addExtraField(new ResourceAlignmentExtraField(alignment,
                        oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));
    }

    final byte[] extra = ze.getLocalFileDataExtra();
    final int nameLen = name.limit() - name.position();
    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;
    final byte[] buf = new byte[len];

    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);

    // Store method in a local variable to prevent redundant calls
    final int zipMethod = ze.getMethod();
    final boolean dataDescriptor = usesDataDescriptor(zipMethod);

    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);

    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);
    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);

    // Compression method
    putShort(zipMethod, buf, LFH_METHOD_OFFSET);

    // Handle time conversion
    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);

    // CRC
    if (phased) {
        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
    } else if (zipMethod == DEFLATED || channel != null) {
        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);
    } else {
        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
    }

    // Compressed and uncompressed length
    if (hasZip64Extra(ze)) {
        // Point to ZIP64 extended information extra field for sizes
        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);
        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);
    } else if (phased) {
        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
    } else if (zipMethod == DEFLATED || channel != null) {
        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);
        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);
    } else { // Stored
        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
    }

    // File name length
    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);

    // Extra field length
    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);

    // File name
    System.arraycopy(name.array(), name.arrayOffset() + name.position(), buf, LFH_FILENAME_OFFSET, nameLen);

    // Extra fields
    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);

    return buf;
}",0,0
137,Compress_47,"@Override
    public boolean canReadEntryData(final ArchiveEntry ae) {
         if (ae instanceof ZipArchiveEntry) {
             final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
             return ZipUtil.canHandleEntryData(ze)
                 && supportsDataDescriptorFor(ze);
         }
         return false;
     }","@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze)
            && supportsDataDescriptorFor(ze)
            && ze.getSize() >= 0; // Ensure the size is known for uncompressed entries
    }
    return false;
}",0,0
137,Compress_47,"@Override
    public int read(final byte[] buffer, final int offset, final int length) throws IOException {
        if (closed) {
            throw new IOException(""The stream is closed"");
        }

        if (current == null) {
            return -1;
        }

        // avoid int overflow, check null buffer
        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {
            throw new ArrayIndexOutOfBoundsException();
        }

        ZipUtil.checkRequestedFeatures(current.entry);
        if (!supportsDataDescriptorFor(current.entry)) {
             throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,
                     current.entry);
         }
 
         int read;
         if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
            read = readStored(buffer, offset, length);
        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
            read = readDeflated(buffer, offset, length);
        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()
                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()
                || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()
                || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
            read = current.in.read(buffer, offset, length);
        } else {
            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),
                    current.entry);
        }

        if (read >= 0) {
            current.crc.update(buffer, offset, read);
        }

        return read;
    }","@Override
public int read(final byte[] buffer, final int offset, final int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }

    if (current == null) {
        return -1;
    }

    // avoid int overflow, check null buffer
    if (buffer == null || offset < 0 || length < 0 || offset > buffer.length || buffer.length - offset < length) {
        throw new ArrayIndexOutOfBoundsException();
    }

    ZipUtil.checkRequestedFeatures(current.entry);
    if (!supportsDataDescriptorFor(current.entry)) {
        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,
                current.entry);
    }

    int read;
    switch (current.entry.getMethod()) {
        case ZipArchiveOutputStream.STORED:
            read = readStored(buffer, offset, length);
            break;
        case ZipArchiveOutputStream.DEFLATED:
            read = readDeflated(buffer, offset, length);
            break;
        case ZipMethod.UNSHRINKING.getCode():
        case ZipMethod.IMPLODING.getCode():
        case ZipMethod.ENHANCED_DEFLATED.getCode():
        case ZipMethod.BZIP2.getCode():
            read = current.in.read(buffer, offset, length);
            break;
        default:
            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),
                    current.entry);
    }

    if (read >= 0) {
        current.crc.update(buffer, offset, read);
    }

    return read;
}",0,0
138,Compress_6,"public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
         ZipArchiveEntry other = (ZipArchiveEntry) obj;
         if (name == null) {
             if (other.name != null) {
                 return false;
             }
         } else if (!name.equals(other.name)) {
             return false;
         }
         return true;
    }","public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ZipArchiveEntry other = (ZipArchiveEntry) obj;
    if (name == null) {
        return other.name == null;
    } else {
        return name.equals(other.name);
    }
}",0,0
139,Compress_9,"@Override
    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
        if ((currBytes + numToWrite) > currSize) {
            throw new IOException(""request to write '"" + numToWrite
                                  + ""' bytes exceeds size in header of '""
                                  + currSize + ""' bytes for entry '""
                                  + currName + ""'"");

            //
            // We have to deal with assembly!!!
            // The programmer can be writing little 32 byte chunks for all
            // we know, and we must assemble complete records for writing.
            // REVIEW Maybe this should be in TarBuffer? Could that help to
            // eliminate some of the buffer copying.
            //
        }

        if (assemLen > 0) {
            if ((assemLen + numToWrite) >= recordBuf.length) {
                int aLen = recordBuf.length - assemLen;

                System.arraycopy(assemBuf, 0, recordBuf, 0,
                                 assemLen);
                System.arraycopy(wBuf, wOffset, recordBuf,
                                 assemLen, aLen);
                buffer.writeRecord(recordBuf);

                currBytes += recordBuf.length;
                wOffset += aLen;
                numToWrite -= aLen;
                assemLen = 0;
            } else {
                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
                                 numToWrite);

                wOffset += numToWrite;
                assemLen += numToWrite;
                numToWrite = 0;
            }
        }

        //
        // When we get here we have EITHER:
        // o An empty ""assemble"" buffer.
        // o No bytes to write (numToWrite == 0)
        //
        while (numToWrite > 0) {
            if (numToWrite < recordBuf.length) {
                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
                                 numToWrite);

                assemLen += numToWrite;

                break;
            }

            buffer.writeRecord(wBuf, wOffset);

            int num = recordBuf.length;

            currBytes += num;
             numToWrite -= num;
             wOffset += num;
         }
         count(numToWrite);
     }","@Override
public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
    if ((currBytes + numToWrite) > currSize) {
        throw new IOException(""request to write '"" + numToWrite
                              + ""' bytes exceeds size in header of '""
                              + currSize + ""' bytes for entry '""
                              + currName + ""'"");
    }

    while (numToWrite > 0) {
        if (assemLen > 0) {
            if ((assemLen + numToWrite) >= recordBuf.length) {
                int aLen = recordBuf.length - assemLen;

                System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);
                System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);
                buffer.writeRecord(recordBuf);

                currBytes += recordBuf.length;
                wOffset += aLen;
                numToWrite -= aLen;
                assemLen = 0;
            } else {
                System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);

                assemLen += numToWrite;
                wOffset += numToWrite;
                numToWrite = 0;
            }
        }

        if (numToWrite > 0) {
            if (numToWrite < recordBuf.length) {
                System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);
                assemLen += numToWrite;
                numToWrite = 0;
            } else {
                buffer.writeRecord(wBuf, wOffset);

                int num = recordBuf.length;
                currBytes += num;
                wOffset += num;
                numToWrite -= num;
            }
        }
    }
    count(numToWrite);
}",0,0
140,Csv_12,"    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);

    /**
","public static final CSVFormat EXCEL = CSVFormat.DEFAULT.withIgnoreEmptyLines(false).withRecordSeparator(""\r\n"");",0,0
141,Csv_13,"private void print(final Object object, final CharSequence value, final int offset, final int len)
            throws IOException {
         if (!newRecord) {
             out.append(format.getDelimiter());
         }
         if (format.isQuoteCharacterSet()) {
             // the original object is needed so can check for Number
             printAndQuote(object, value, offset, len);
         } else if (format.isEscapeCharacterSet()) {
            printAndEscape(value, offset, len);
        } else {
            out.append(value, offset, offset + len);
        }
        newRecord = false;
    }","private void print(final Object object, final CharSequence value, final int offset, final int len)
        throws IOException {
    if (!newRecord) {
        out.append(format.getDelimiter());
    }

    if (value == null || (format.getNullString() != null && format.getNullString().contentEquals(value))) {
        // Handle null or nullString values
        String nullString = format.getNullString();
        if (nullString != null) {
            out.append(nullString);
        }
    } else if (format.isQuoteCharacterSet()) {
        // The original object is needed for checking instance type
        printAndQuote(object, value, offset, len);
    } else if (format.isEscapeCharacterSet()) {
        printAndEscape(value, offset, len);
    } else {
        out.append(value, offset, offset + len);
    }

    newRecord = false;
}",0,0
142,Csv_16,"@Override
    public Iterator<CSVRecord> iterator() {
        return new Iterator<CSVRecord>() {
        private CSVRecord current;
  
        private CSVRecord getNextRecord() {
            try {
                return CSVParser.this.nextRecord();
            } catch (final IOException e) {
                throw new IllegalStateException(
                        e.getClass().getSimpleName() + "" reading next record: "" + e.toString(), e);
            }
        }
  
        @Override
        public boolean hasNext() {
            if (CSVParser.this.isClosed()) {
                return false;
            }
            if (this.current == null) {
                this.current = this.getNextRecord();
            }
  
            return this.current != null;
        }
  
        @Override
        public CSVRecord next() {
            if (CSVParser.this.isClosed()) {
                throw new NoSuchElementException(""CSVParser has been closed"");
            }
            CSVRecord next = this.current;
            this.current = null;
  
            if (next == null) {
                // hasNext() wasn't called before
                next = this.getNextRecord();
                if (next == null) {
                    throw new NoSuchElementException(""No more CSV records available"");
                }
            }
  
            return next;
        }
  
        @Override
        public void remove() {
             throw new UnsupportedOperationException();
         }
     };
     }","@Override
public Iterator<CSVRecord> iterator() {
    return new Iterator<CSVRecord>() {
        private CSVRecord current;
        private boolean closed = false;

        private CSVRecord getNextRecord() {
            try {
                return CSVParser.this.nextRecord();
            } catch (final IOException e) {
                throw new IllegalStateException(
                        e.getClass().getSimpleName() + "" reading next record: "" + e.getMessage(), e);
            }
        }

        @Override
        public boolean hasNext() {
            if (closed || CSVParser.this.isClosed()) {
                return false;
            }
            if (this.current == null) {
                this.current = this.getNextRecord();
                if (this.current == null) {
                    closed = true; // Mark the iterator as closed if no more records are available
                }
            }
            return this.current != null;
        }

        @Override
        public CSVRecord next() {
            if (!hasNext()) {
                throw new NoSuchElementException(""No more CSV records available"");
            }
            CSVRecord next = this.current;
            this.current = null;
            return next;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException(""CSVRecord Iterator does not support remove operation."");
        }
    };
}",0,0
143,Csv_7,"private Map<String, Integer> initializeHeader() throws IOException {
        Map<String, Integer> hdrMap = null;
        final String[] formatHeader = this.format.getHeader();
        if (formatHeader != null) {
            hdrMap = new LinkedHashMap<String, Integer>();

            String[] header = null;
            if (formatHeader.length == 0) {
                // read the header from the first line of the file
                final CSVRecord nextRecord = this.nextRecord();
                if (nextRecord != null) {
                    header = nextRecord.values();
                }
            } else {
                if (this.format.getSkipHeaderRecord()) {
                    this.nextRecord();
                }
                header = formatHeader;
            }

             // build the name to index mappings
             if (header != null) {
                 for (int i = 0; i < header.length; i++) {
                     hdrMap.put(header[i], Integer.valueOf(i));
                 }
             }
        }
        return hdrMap;
    }","private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<>();
        String[] header = null;

        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                header = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            header = formatHeader;
        }

        // build the name-to-index mappings
        if (header != null) {
            for (int i = 0; i < header.length; i++) {
                if (!hdrMap.containsKey(header[i])) {
                    hdrMap.put(header[i], Integer.valueOf(i));
                }
            }
        }
    }
    return hdrMap;
}",0,0
144,Csv_8,"void validate() throws IllegalStateException {
        if (quoteChar != null && delimiter == quoteChar.charValue()) {
            throw new IllegalStateException(
                    ""The quoteChar character and the delimiter cannot be the same ('"" + quoteChar + ""')"");
        }

        if (escape != null && delimiter == escape.charValue()) {
            throw new IllegalStateException(
                    ""The escape character and the delimiter cannot be the same ('"" + escape + ""')"");
        }

        if (commentStart != null && delimiter == commentStart.charValue()) {
            throw new IllegalStateException(
                    ""The comment start character and the delimiter cannot be the same ('"" + commentStart + ""')"");
        }

        if (quoteChar != null && quoteChar.equals(commentStart)) {
            throw new IllegalStateException(
                    ""The comment start character and the quoteChar cannot be the same ('"" + commentStart + ""')"");
        }

        if (escape != null && escape.equals(commentStart)) {
            throw new IllegalStateException(
                    ""The comment start and the escape character cannot be the same ('"" + commentStart + ""')"");
        }

        if (escape == null && quotePolicy == Quote.NONE) {
             throw new IllegalStateException(""No quotes mode set but no escape character is set"");
         }
 
         if (header != null) {
             final Set<String> set = new HashSet<String>(header.length);
             set.addAll(Arrays.asList(header));
             if (set.size() != header.length) {
                 throw new IllegalStateException(""The header contains duplicate names: "" + Arrays.toString(header));
             }
         }
     }","void validate() throws IllegalStateException {
        if (quoteChar != null && delimiter == quoteChar.charValue()) {
            throw new IllegalStateException(
                    ""The quoteChar character and the delimiter cannot be the same ('"" + quoteChar + ""')"");
        }

        if (escape != null && delimiter == escape.charValue()) {
            throw new IllegalStateException(
                    ""The escape character and the delimiter cannot be the same ('"" + escape + ""')"");
        }

        if (commentStart != null && delimiter == commentStart.charValue()) {
            throw new IllegalStateException(
                    ""The comment start character and the delimiter cannot be the same ('"" + commentStart + ""')"");
        }

        if (quoteChar != null && quoteChar.equals(commentStart)) {
            throw new IllegalStateException(
                    ""The comment start character and the quoteChar cannot be the same ('"" + commentStart + ""')"");
        }

        if (escape != null && escape.equals(commentStart)) {
            throw new IllegalStateException(
                    ""The comment start and the escape character cannot be the same ('"" + commentStart + ""')"");
        }

        if (escape == null && Quote.NONE.equals(quotePolicy)) {
            throw new IllegalStateException(""No quotes mode set but no escape character is set"");
        }

        if (header != null) {
            final Set<String> set = new HashSet<>(header.length);
            for (String h : header) {
                if (!set.add(h)) {
                    throw new IllegalStateException(""The header contains duplicate names: "" + Arrays.toString(header));
                }
            }
        }
    }",0,0
145,Gson_1,"  private static Type getActualType(
      Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {
    if (typeToEvaluate instanceof Class<?>) {
      return typeToEvaluate;
    } else if (typeToEvaluate instanceof ParameterizedType) {
      ParameterizedType castedType = (ParameterizedType) typeToEvaluate;
      Type owner = castedType.getOwnerType();
      Type[] actualTypeParameters =
          extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);
      Type rawType = castedType.getRawType();
      return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);
    } else if (typeToEvaluate instanceof GenericArrayType) {
      GenericArrayType castedType = (GenericArrayType) typeToEvaluate;
      Type componentType = castedType.getGenericComponentType();
      Type actualType = getActualType(componentType, parentType, rawParentClass);
      if (componentType.equals(actualType)) {
        return castedType;
      }
      return actualType instanceof Class<?> ?
          TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))
          : new GenericArrayTypeImpl(actualType);
    } else if (typeToEvaluate instanceof TypeVariable<?>) {
      if (parentType instanceof ParameterizedType) {
        // The class definition has the actual types used for the type variables.
        // Find the matching actual type for the Type Variable used for the field.
        // For example, class Foo<A> { A a; }
        // new Foo<Integer>(); defines the actual type of A to be Integer.
        // So, to find the type of the field a, we will have to look at the class'
        // actual type arguments.
        TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;
        TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();
        ParameterizedType objParameterizedType = (ParameterizedType) parentType;
        int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);
        Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();
        return actualTypeArguments[indexOfActualTypeArgument];


      }

      throw new UnsupportedOperationException(""Expecting parameterized type, got "" + parentType
          + "".\n Are you missing the use of TypeToken idiom?\n See ""
          + ""http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"");
    } else if (typeToEvaluate instanceof WildcardType) {
      WildcardType castedType = (WildcardType) typeToEvaluate;
      return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);
    } else {
      throw new IllegalArgumentException(""Type \'"" + typeToEvaluate + ""\' is not a Class, ""
          + ""ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."");
    }
  }
","private static Type getActualType(
      Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {
    if (typeToEvaluate instanceof Class<?>) {
        return typeToEvaluate;
    } else if (typeToEvaluate instanceof ParameterizedType) {
        ParameterizedType castedType = (ParameterizedType) typeToEvaluate;
        Type owner = castedType.getOwnerType();
        Type[] actualTypeParameters =
            extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);
        Type rawType = castedType.getRawType();
        return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);
    } else if (typeToEvaluate instanceof GenericArrayType) {
        GenericArrayType castedType = (GenericArrayType) typeToEvaluate;
        Type componentType = castedType.getGenericComponentType();
        Type actualType = getActualType(componentType, parentType, rawParentClass);
        if (componentType.equals(actualType)) {
            return castedType;
        }
        return actualType instanceof Class<?> ?
            TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))
            : new GenericArrayTypeImpl(actualType);
    } else if (typeToEvaluate instanceof TypeVariable<?>) {
        if (parentType instanceof ParameterizedType) {
            TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;
            TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();
            ParameterizedType objParameterizedType = (ParameterizedType) parentType;
            int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);

            if (indexOfActualTypeArgument < 0 || indexOfActualTypeArgument >= objParameterizedType.getActualTypeArguments().length) {
                throw new IllegalArgumentException(""Invalid type variable resolution. Type variable: ""
                        + fieldTypeVariable + "", rawParentClass: "" + rawParentClass.getName());
            }

            Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();
            return actualTypeArguments[indexOfActualTypeArgument];
        }
        throw new UnsupportedOperationException(""Expecting parameterized type, got "" + parentType
            + "".\n Are you missing the use of TypeToken idiom?\n See ""
            + ""http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"");
    } else if (typeToEvaluate instanceof WildcardType) {
        WildcardType castedType = (WildcardType) typeToEvaluate;
        Type[] upperBounds = castedType.getUpperBounds();
        if (upperBounds.length == 0) {
            throw new IllegalArgumentException(""Wildcard type has no upper bounds: "" + castedType);
        }
        return getActualType(upperBounds[0], parentType, rawParentClass);
    } else {
        throw new IllegalArgumentException(""Type \'"" + typeToEvaluate + ""\' is not a Class, ""
            + ""ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."");
    }
}",0,0
146,Gson_10,"private ReflectiveTypeAdapterFactory.BoundField createBoundField(
      final Gson context, final Field field, final String name,
      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
    // special casing primitives here saves ~5% on Android...
    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
    TypeAdapter<?> mapped = null;
    if (annotation != null) {
      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);
    }
    final boolean jsonAdapterPresent = mapped != null;
    if (mapped == null) mapped = context.getAdapter(fieldType);

    final TypeAdapter<?> typeAdapter = mapped;
    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
      @SuppressWarnings({""unchecked"", ""rawtypes""}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = field.get(value);
         TypeAdapter t =
           new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
         t.write(writer, fieldValue);
       }
       @Override void read(JsonReader reader, Object value)
          throws IOException, IllegalAccessException {
        Object fieldValue = typeAdapter.read(reader);
        if (fieldValue != null || !isPrimitive) {
          field.set(value, fieldValue);
        }
      }
      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {
        if (!serialized) return false;
        Object fieldValue = field.get(value);
        return fieldValue != value; // avoid recursion for example for Throwable.cause
      }
    };
  }","private ReflectiveTypeAdapterFactory.BoundField createBoundField(
      final Gson context, final Field field, final String name,
      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
    // special casing primitives here saves ~5% on Android...
    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
    TypeAdapter<?> mapped = null;
    if (annotation != null) {
      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);
    }
    final boolean jsonAdapterPresent = mapped != null;
    if (mapped == null) mapped = context.getAdapter(fieldType);

    final TypeAdapter<?> typeAdapter = mapped;
    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
      @SuppressWarnings({""unchecked"", ""rawtypes""}) // the type adapter and field type always agree
      @Override
      void write(JsonWriter writer, Object value)
          throws IOException, IllegalAccessException {
        Object fieldValue = field.get(value);
        TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(
            context, 
            typeAdapter, 
            fieldType.getType()
        );
        if (fieldValue != null || isPrimitive) { // Ensure primitives are not skipped to avoid null issues
          t.write(writer, fieldValue);
        } else {
          writer.nullValue(); // Explicitly write null for non-primitive null fields
        }
      }

      @Override
      void read(JsonReader reader, Object value)
          throws IOException, IllegalAccessException {
        Object fieldValue = typeAdapter.read(reader);
        if (fieldValue != null || !isPrimitive) { // Only set value if it's non-null or not primitive
          field.set(value, fieldValue);
        } else if (isPrimitive) {
          throw new JsonParseException(""Cannot set null to a primitive field: "" + field.getName());
        }
      }

      @Override
      public boolean writeField(Object value) 
          throws IOException, IllegalAccessException {
        if (!serialized) return false;
        Object fieldValue = field.get(value);
        if (isPrimitive && fieldValue == null) {
          return true; // Write primitives even if they are null, as default values are expected
        }
        return fieldValue != value; // Avoid recursion for example for Throwable.cause
      }
    };
  }",0,0
147,Gson_14,"public static WildcardType supertypeOf(Type bound) {
     Type[] lowerBounds;
       lowerBounds = new Type[] { bound };
     return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);
   }","public static WildcardType supertypeOf(Type bound) {
    if (bound == null) {
        throw new IllegalArgumentException(""Bound cannot be null."");
    }
    Type[] lowerBounds = new Type[] { bound };
    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);
}",0,0
147,Gson_14,"public static WildcardType subtypeOf(Type bound) {
     Type[] upperBounds;
       upperBounds = new Type[] { bound };
     return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);
   }","public static WildcardType subtypeOf(Type bound) {
    if (bound == null) {
        throw new IllegalArgumentException(""Bound cannot be null."");
    }
    Type[] upperBounds = new Type[] { bound };
    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);
}",0,0
148,Gson_16,"private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
                              Collection<TypeVariable> visitedTypeVariables) {
    // this implementation is made a little more complicated in an attempt to avoid object-creation
     while (true) {
       if (toResolve instanceof TypeVariable) {
         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
           // cannot reduce due to infinite recursion
         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
         if (toResolve == typeVariable) {
           return toResolve;
        }

      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
        Class<?> original = (Class<?>) toResolve;
        Type componentType = original.getComponentType();
        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
        return componentType == newComponentType
            ? original
            : arrayOf(newComponentType);

      } else if (toResolve instanceof GenericArrayType) {
        GenericArrayType original = (GenericArrayType) toResolve;
        Type componentType = original.getGenericComponentType();
        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
        return componentType == newComponentType
            ? original
            : arrayOf(newComponentType);

      } else if (toResolve instanceof ParameterizedType) {
        ParameterizedType original = (ParameterizedType) toResolve;
        Type ownerType = original.getOwnerType();
        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
        boolean changed = newOwnerType != ownerType;

        Type[] args = original.getActualTypeArguments();
        for (int t = 0, length = args.length; t < length; t++) {
          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
          if (resolvedTypeArgument != args[t]) {
            if (!changed) {
              args = args.clone();
              changed = true;
            }
            args[t] = resolvedTypeArgument;
          }
        }

        return changed
            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)
            : original;

      } else if (toResolve instanceof WildcardType) {
        WildcardType original = (WildcardType) toResolve;
        Type[] originalLowerBound = original.getLowerBounds();
        Type[] originalUpperBound = original.getUpperBounds();

        if (originalLowerBound.length == 1) {
          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);
          if (lowerBound != originalLowerBound[0]) {
            return supertypeOf(lowerBound);
          }
        } else if (originalUpperBound.length == 1) {
          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);
          if (upperBound != originalUpperBound[0]) {
            return subtypeOf(upperBound);
          }
        }
        return original;

      } else {
        return toResolve;
      }
    }
  }","private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
                            Collection<TypeVariable> visitedTypeVariables) {
    // this implementation is made a little more complicated in an attempt to avoid object-creation
    while (true) {
        if (toResolve instanceof TypeVariable) {
            TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;

            if (visitedTypeVariables.contains(typeVariable)) {
                return toResolve; // Avoid infinite recursion by returning the unresolved type variable.
            }

            visitedTypeVariables.add(typeVariable); // Track type variables to prevent recursion.
            Type resolvedType = resolveTypeVariable(context, contextRawType, typeVariable);
            if (resolvedType == typeVariable) {
                return resolvedType;
            }

            toResolve = resolvedType;

        } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
            Class<?> original = (Class<?>) toResolve;
            Type componentType = original.getComponentType();
            Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
            return componentType == newComponentType
                    ? original
                    : arrayOf(newComponentType);

        } else if (toResolve instanceof GenericArrayType) {
            GenericArrayType original = (GenericArrayType) toResolve;
            Type componentType = original.getGenericComponentType();
            Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
            return componentType == newComponentType
                    ? original
                    : arrayOf(newComponentType);

        } else if (toResolve instanceof ParameterizedType) {
            ParameterizedType original = (ParameterizedType) toResolve;
            Type ownerType = original.getOwnerType();
            Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
            boolean changed = newOwnerType != ownerType;

            Type[] args = original.getActualTypeArguments();
            Type[] resolvedArgs = args.clone(); // Explicitly clone the type arguments array.
            for (int t = 0; t < args.length; t++) {
                Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
                if (resolvedTypeArgument != args[t]) {
                    resolvedArgs[t] = resolvedTypeArgument;
                    changed = true;
                }
            }

            return changed
                    ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), resolvedArgs)
                    : original;

        } else if (toResolve instanceof WildcardType) {
            WildcardType original = (WildcardType) toResolve;
            Type[] originalLowerBound = original.getLowerBounds();
            Type[] originalUpperBound = original.getUpperBounds();

            if (originalLowerBound.length == 1) {
                Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);
                if (lowerBound != originalLowerBound[0]) {
                    return supertypeOf(lowerBound);
                }
            } else if (originalUpperBound.length == 1) {
                Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);
                if (upperBound != originalUpperBound[0]) {
                    return subtypeOf(upperBound);
                }
            }
            return original;

        } else {
            return toResolve;
        }
    }
}",0,0
149,Gson_2,"        final Class<? super T2> requestedType = typeToken.getRawType();
        if (!clazz.isAssignableFrom(requestedType)) {
          return null;
        }
","final Class<? super T2> requestedType = typeToken.getRawType();
if (requestedType == null || !clazz.isAssignableFrom(requestedType)) {
    return null;
}",0,0
150,Gson_3,"  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(
      final Type type, Class<? super T> rawType) {
    if (Collection.class.isAssignableFrom(rawType)) {
      if (SortedSet.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new TreeSet<Object>();
          }
        };
      } else if (EnumSet.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @SuppressWarnings(""rawtypes"")
          @Override public T construct() {
            if (type instanceof ParameterizedType) {
              Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];
              if (elementType instanceof Class) {
                return (T) EnumSet.noneOf((Class)elementType);
              } else {
                throw new JsonIOException(""Invalid EnumSet type: "" + type.toString());
              }
            } else {
              throw new JsonIOException(""Invalid EnumSet type: "" + type.toString());
            }
          }
        };
      } else if (Set.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new LinkedHashSet<Object>();
          }
        };
      } else if (Queue.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new LinkedList<Object>();
          }
        };
      } else {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new ArrayList<Object>();
          }
        };
      }
    }

    if (Map.class.isAssignableFrom(rawType)) {
      if (SortedMap.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new TreeMap<Object, Object>();
          }
        };
      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(
          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new LinkedHashMap<Object, Object>();
          }
        };
      } else {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new LinkedTreeMap<String, Object>();
          }
        };
      }
    }

    return null;
  }
","private <T> ObjectConstructor<T> newDefaultImplementationConstructor(
    final Type type, Class<? super T> rawType) {
  if (Collection.class.isAssignableFrom(rawType)) {
    if (SortedSet.class.isAssignableFrom(rawType)) {
      return new ObjectConstructor<T>() {
        @Override public T construct() {
          return (T) new TreeSet<Object>();
        }
      };
    } else if (EnumSet.class.isAssignableFrom(rawType)) {
      return new ObjectConstructor<T>() {
        @SuppressWarnings(""rawtypes"")
        @Override public T construct() {
          if (type instanceof ParameterizedType) {
            Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];
            if (elementType instanceof Class) {
              return (T) EnumSet.noneOf((Class) elementType);
            } else {
              throw new JsonIOException(""Invalid EnumSet type: "" + type.toString());
            }
          } else {
            throw new JsonIOException(""Invalid EnumSet type: "" + type.toString());
          }
        }
      };
    } else if (Set.class.isAssignableFrom(rawType)) {
      return new ObjectConstructor<T>() {
        @Override public T construct() {
          return (T) new LinkedHashSet<Object>();
        }
      };
    } else if (Queue.class.isAssignableFrom(rawType)) {
      return new ObjectConstructor<T>() {
        @Override public T construct() {
          return (T) new LinkedList<Object>();
        }
      };
    } else {
      return new ObjectConstructor<T>() {
        @Override public T construct() {
          return (T) new ArrayList<Object>();
        }
      };
    }
  }

  if (Map.class.isAssignableFrom(rawType)) {
    if (SortedMap.class.isAssignableFrom(rawType)) {
      return new ObjectConstructor<T>() {
        @Override public T construct() {
          return (T) new TreeMap<Object, Object>();
        }
      };
    } else if (type instanceof ParameterizedType) {
      Type keyType = ((ParameterizedType) type).getActualTypeArguments()[0];
      if (!(keyType instanceof Class) || !String.class.isAssignableFrom((Class<?>) keyType)) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new LinkedHashMap<Object, Object>();
          }
        };
      }
    }
    return new ObjectConstructor<T>() {
      @Override public T construct() {
        return (T) new LinkedTreeMap<String, Object>();
      }
    };
  }

  return null;
}",0,0
151,Gson_4,"public JsonWriter value(String value) throws IOException {
    if (value == null) {
       return nullValue();
     }
     writeDeferredName();
     beforeValue(false);
     string(value);
     return this;
   }","public JsonWriter value(String value) throws IOException {
    if (value == null) {
        return nullValue();
    }
    writeDeferredName();
    beforeValue(false);
    string(value);
    return this;
}",0,0
151,Gson_4,"public JsonWriter value(long value) throws IOException {
     writeDeferredName();
     beforeValue(false);
     out.write(Long.toString(value));
     return this;
   }","public JsonWriter value(long value) throws IOException {
    writeDeferredName();
    beforeValue(false);
    out.write(Long.toString(value));
    return this;
}",0,0
151,Gson_4,"public JsonWriter jsonValue(String value) throws IOException {
    if (value == null) {
       return nullValue();
     }
     writeDeferredName();
     beforeValue(false);
     out.append(value);
     return this;
   }","public JsonWriter jsonValue(String value) throws IOException {
    if (value == null) {
        return nullValue();
    }
    writeDeferredName();
    beforeValue(false);
    out.append(value);
    return this;
}",0,0
151,Gson_4,"public JsonWriter value(boolean value) throws IOException {
     writeDeferredName();
     beforeValue(false);
     out.write(value ? ""true"" : ""false"");
     return this;
   }","public JsonWriter value(boolean value) throws IOException {
    writeDeferredName();
    beforeValue(false);
    out.write(value ? ""true"" : ""false"");
    return this;
}",0,0
151,Gson_4,"public JsonWriter nullValue() throws IOException {
    if (deferredName != null) {
      if (serializeNulls) {
        writeDeferredName();
      } else {
        deferredName = null;
         return this; // skip the name and the value
       }
     }
     beforeValue(false);
     out.write(""null"");
     return this;
   }","public JsonWriter nullValue() throws IOException {
    if (deferredName != null) {
        if (serializeNulls) {
            writeDeferredName();
        } else {
            deferredName = null;
            return this; // skip the name and the value
        }
    }
    beforeValue(false);
    out.write(""null"");
    return this;
}",0,0
151,Gson_4,"public JsonWriter value(double value) throws IOException {
    if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
     }
     writeDeferredName();
     beforeValue(false);
     out.append(Double.toString(value));
     return this;
   }","public JsonWriter value(double value) throws IOException {
    if (Double.isNaN(value) || Double.isInfinite(value)) {
        throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
    }
    writeDeferredName();
    beforeValue(false);
    out.append(Double.toString(value));
    return this;
}",0,0
151,Gson_4,"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
      // Look for a comma before the next element.
      int c = nextNonWhitespace(true);
      switch (c) {
      case ']':
        return peeked = PEEKED_END_ARRAY;
      case ';':
        checkLenient(); // fall-through
      case ',':
        break;
      default:
        throw syntaxError(""Unterminated array"");
      }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
      stack[stackSize - 1] = JsonScope.DANGLING_NAME;
      // Look for a comma before the next element.
      if (peekStack == JsonScope.NONEMPTY_OBJECT) {
        int c = nextNonWhitespace(true);
        switch (c) {
        case '}':
          return peeked = PEEKED_END_OBJECT;
        case ';':
          checkLenient(); // fall-through
        case ',':
          break;
        default:
          throw syntaxError(""Unterminated object"");
        }
      }
      int c = nextNonWhitespace(true);
      switch (c) {
      case '""':
        return peeked = PEEKED_DOUBLE_QUOTED_NAME;
      case '\'':
        checkLenient();
        return peeked = PEEKED_SINGLE_QUOTED_NAME;
      case '}':
        if (peekStack != JsonScope.NONEMPTY_OBJECT) {
          return peeked = PEEKED_END_OBJECT;
        } else {
          throw syntaxError(""Expected name"");
        }
      default:
        checkLenient();
        pos--; // Don't consume the first character in an unquoted string.
        if (isLiteral((char) c)) {
          return peeked = PEEKED_UNQUOTED_NAME;
        } else {
          throw syntaxError(""Expected name"");
        }
      }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
      // Look for a colon before the value.
      int c = nextNonWhitespace(true);
      switch (c) {
      case ':':
        break;
      case '=':
        checkLenient();
        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
          pos++;
        }
        break;
      default:
        throw syntaxError(""Expected ':'"");
      }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
      if (lenient) {
        consumeNonExecutePrefix();
      }
      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
      int c = nextNonWhitespace(false);
      if (c == -1) {
        return peeked = PEEKED_EOF;
      } else {
        checkLenient();
        pos--;
      }
    } else if (peekStack == JsonScope.CLOSED) {
      throw new IllegalStateException(""JsonReader is closed"");
    }

    int c = nextNonWhitespace(true);
    switch (c) {
    case ']':
      if (peekStack == JsonScope.EMPTY_ARRAY) {
        return peeked = PEEKED_END_ARRAY;
      }
      // fall-through to handle "",]""
    case ';':
    case ',':
      // In lenient mode, a 0-length literal in an array means 'null'.
      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
        checkLenient();
        pos--;
        return peeked = PEEKED_NULL;
      } else {
        throw syntaxError(""Unexpected value"");
      }
    case '\'':
       checkLenient();
       return peeked = PEEKED_SINGLE_QUOTED;
     case '""':
       if (stackSize == 1) {
         checkLenient();
       }
       return peeked = PEEKED_DOUBLE_QUOTED;
     case '[':
       return peeked = PEEKED_BEGIN_ARRAY;
    case '{':
      return peeked = PEEKED_BEGIN_OBJECT;
    default:
      pos--; // Don't consume the first character in a literal value.
    }
    if (stackSize == 1) {
      checkLenient();
    }

    int result = peekKeyword();
    if (result != PEEKED_NONE) {
      return result;
    }

    result = peekNumber();
    if (result != PEEKED_NONE) {
      return result;
    }

    if (!isLiteral(buffer[pos])) {
      throw syntaxError(""Expected value"");
    }

    checkLenient();
    return peeked = PEEKED_UNQUOTED;
  }","int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        int c = nextNonWhitespace(true);
        switch (c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                checkLenient(); // fall-through
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch (c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    checkLenient(); // fall-through
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch (c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        int c = nextNonWhitespace(true);
        switch (c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }

    int c = nextNonWhitespace(true);
    switch (c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        case ';':
        case ',':
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            if (stackSize == 1) {
                checkLenient();
            }
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            pos--;
    }
    if (stackSize == 1) {
        checkLenient();
    }

    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }

    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }

    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }

    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}",0,0
151,Gson_4,"public JsonWriter value(Number value) throws IOException {
    if (value == null) {
      return nullValue();
    }

    writeDeferredName();
    String string = value.toString();
    if (!lenient
         && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) {
       throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
     }
     beforeValue(false);
     out.append(string);
     return this;
   }","public JsonWriter value(Number value) throws IOException {
    if (value == null) {
        return nullValue();
    }

    writeDeferredName();
    String string = value.toString();
    if (!lenient
        && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) {
        throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
    }
    beforeValue(false);
    out.append(string);
    return this;
}",0,0
151,Gson_4,"@SuppressWarnings(""fallthrough"")
  private void beforeValue(boolean root) throws IOException {
    switch (peek()) {
    case NONEMPTY_DOCUMENT:
      if (!lenient) {
        throw new IllegalStateException(
            ""JSON must have only one top-level value."");
       }
       // fall-through
     case EMPTY_DOCUMENT: // first in document
       if (!lenient && !root) {
         throw new IllegalStateException(
             ""JSON must start with an array or an object."");
       }
       replaceTop(NONEMPTY_DOCUMENT);
       break;
 
    case EMPTY_ARRAY: // first in array
      replaceTop(NONEMPTY_ARRAY);
      newline();
      break;

    case NONEMPTY_ARRAY: // another in array
      out.append(',');
      newline();
      break;

    case DANGLING_NAME: // value for name
      out.append(separator);
      replaceTop(NONEMPTY_OBJECT);
      break;

    default:
      throw new IllegalStateException(""Nesting problem."");
    }
  }","@SuppressWarnings(""fallthrough"")
private void beforeValue(boolean root) throws IOException {
    switch (peek()) {
        case NONEMPTY_DOCUMENT:
            if (!lenient) {
                throw new IllegalStateException(""JSON must have only one top-level value."");
            }
        case EMPTY_DOCUMENT: // fall-through
            if (!lenient && !root) {
                throw new IllegalStateException(""JSON must start with an array or an object."");
            }
            replaceTop(NONEMPTY_DOCUMENT);
            break;

        case EMPTY_ARRAY:
            replaceTop(NONEMPTY_ARRAY);
            newline();
            break;

        case NONEMPTY_ARRAY:
            out.append(',');
            newline();
            break;

        case DANGLING_NAME:
            out.append(separator);
            replaceTop(NONEMPTY_OBJECT);
            break;

        default:
            throw new IllegalStateException(""Nesting problem."");
    }
}",0,0
152,Gson_7,"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
      p = doPeek();
    }

    int result;
    if (p == PEEKED_LONG) {
      result = (int) peekedLong;
      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedLong
            + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
      }
      peeked = PEEKED_NONE;
      pathIndices[stackSize - 1]++;
      return result;
    }

     if (p == PEEKED_NUMBER) {
       peekedString = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
     } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
         peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
       try {
         result = Integer.parseInt(peekedString);
         peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
      } catch (NumberFormatException ignored) {
        // Fall back to parse as a double below.
      }
    } else {
      throw new IllegalStateException(""Expected an int but was "" + peek()
          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }

    peeked = PEEKED_BUFFERED;
    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
    result = (int) asDouble;
    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
      throw new NumberFormatException(""Expected an int but was "" + peekedString
          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
  }","public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }

    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) { // Ensure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong
                + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }

    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek()
            + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }

    try {
        result = Integer.parseInt(peekedString);
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    } catch (NumberFormatException ignored) {
        // Fall back to parse as a double below.
    }

    peeked = PEEKED_BUFFERED;
    double asDouble = Double.parseDouble(peekedString); // Don't catch this NumberFormatException.
    result = (int) asDouble;
    if (result != asDouble) { // Ensure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString
            + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}",0,0
152,Gson_7,"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
      p = doPeek();
    }

    if (p == PEEKED_LONG) {
      peeked = PEEKED_NONE;
      pathIndices[stackSize - 1]++;
      return peekedLong;
    }

     if (p == PEEKED_NUMBER) {
       peekedString = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
     } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
         peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
       try {
         long result = Long.parseLong(peekedString);
         peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
      } catch (NumberFormatException ignored) {
        // Fall back to parse as a double below.
      }
    } else {
      throw new IllegalStateException(""Expected a long but was "" + peek()
          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }

    peeked = PEEKED_BUFFERED;
    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
    long result = (long) asDouble;
    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
      throw new NumberFormatException(""Expected a long but was "" + peekedString
          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
  }","public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }

    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }

    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek()
            + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }

    try {
        long result = Long.parseLong(peekedString);
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    } catch (NumberFormatException ignored) {
        // Fall back to parse as a double below.
    }

    peeked = PEEKED_BUFFERED;
    double asDouble = Double.parseDouble(peekedString); // Don't catch this NumberFormatException.
    long result = (long) asDouble;
    if (result != asDouble) { // Ensure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString
            + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}",0,0
153,Gson_8,"/*
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gson.internal;

import java.io.ObjectInputStream;
import java.io.ObjectStreamClass;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * Do sneaky things to allocate objects without invoking their constructors.
 *
 * @author Joel Leitch
 * @author Jesse Wilson
 */
public abstract class UnsafeAllocator {
  public abstract <T> T newInstance(Class<T> c) throws Exception;

  public static UnsafeAllocator create() {
    // try JVM
    // public class Unsafe {
    //   public Object allocateInstance(Class<?> type);
    // }
    try {
      Class<?> unsafeClass = Class.forName(""sun.misc.Unsafe"");
      Field f = unsafeClass.getDeclaredField(""theUnsafe"");
      f.setAccessible(true);
      final Object unsafe = f.get(null);
      final Method allocateInstance = unsafeClass.getMethod(""allocateInstance"", Class.class);
      return new UnsafeAllocator() {
        @Override
        @SuppressWarnings(""unchecked"")
        public <T> T newInstance(Class<T> c) throws Exception {
          return (T) allocateInstance.invoke(unsafe, c);
        }
      };
    } catch (Exception ignored) {
    }

    // try dalvikvm, post-gingerbread
    // public class ObjectStreamClass {
    //   private static native int getConstructorId(Class<?> c);
    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);
    // }
    try {
      Method getConstructorId = ObjectStreamClass.class
          .getDeclaredMethod(""getConstructorId"", Class.class);
      getConstructorId.setAccessible(true);
      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);
      final Method newInstance = ObjectStreamClass.class
          .getDeclaredMethod(""newInstance"", Class.class, int.class);
      newInstance.setAccessible(true);
      return new UnsafeAllocator() {
        @Override
        @SuppressWarnings(""unchecked"")
        public <T> T newInstance(Class<T> c) throws Exception {
          return (T) newInstance.invoke(null, c, constructorId);
        }
      };
    } catch (Exception ignored) {
    }

    // try dalvikvm, pre-gingerbread
    // public class ObjectInputStream {
    //   private static native Object newInstance(
    //     Class<?> instantiationClass, Class<?> constructorClass);
    // }
    try {
      final Method newInstance = ObjectInputStream.class
          .getDeclaredMethod(""newInstance"", Class.class, Class.class);
      newInstance.setAccessible(true);
      return new UnsafeAllocator() {
        @Override
        @SuppressWarnings(""unchecked"")
        public <T> T newInstance(Class<T> c) throws Exception {
          return (T) newInstance.invoke(null, c, Object.class);
        }
      };
    } catch (Exception ignored) {
    }

    // give up
    return new UnsafeAllocator() {
      @Override
      public <T> T newInstance(Class<T> c) {
        throw new UnsupportedOperationException(""Cannot allocate "" + c);
      }
    };
  }

  /**
   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers
   * throw an {@link java.lang.UnsupportedOperationException}
   * @param c instance of the class to be checked
   */
}
","public abstract class UnsafeAllocator {
  public abstract <T> T newInstance(Class<T> c) throws Exception;

  public static UnsafeAllocator create() {
    // try JVM
    try {
      Class<?> unsafeClass = Class.forName(""sun.misc.Unsafe"");
      Field f = unsafeClass.getDeclaredField(""theUnsafe"");
      f.setAccessible(true);
      final Object unsafe = f.get(null);
      final Method allocateInstance = unsafeClass.getMethod(""allocateInstance"", Class.class);
      
      return new UnsafeAllocator() {
        @Override
        @SuppressWarnings(""unchecked"")
        public <T> T newInstance(Class<T> c) throws Exception {
          if (c.isInterface() || java.lang.reflect.Modifier.isAbstract(c.getModifiers())) {
            throw new UnsupportedOperationException(""Cannot instantiate "" + c);
          }
          return (T) allocateInstance.invoke(unsafe, c);
        }
      };
    } catch (Exception ignored) {
    }

    // try dalvikvm, post-gingerbread
    try {
      Method getConstructorId = ObjectStreamClass.class.getDeclaredMethod(""getConstructorId"", Class.class);
      getConstructorId.setAccessible(true);
      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);

      final Method newInstance = ObjectStreamClass.class.getDeclaredMethod(""newInstance"", Class.class, int.class);
      newInstance.setAccessible(true);
      
      return new UnsafeAllocator() {
        @Override
        @SuppressWarnings(""unchecked"")
        public <T> T newInstance(Class<T> c) throws Exception {
          if (c.isInterface() || java.lang.reflect.Modifier.isAbstract(c.getModifiers())) {
            throw new UnsupportedOperationException(""Cannot instantiate "" + c);
          }
          return (T) newInstance.invoke(null, c, constructorId);
        }
      };
    } catch (Exception ignored) {
    }

    // try dalvikvm, pre-gingerbread
    try {
      final Method newInstance = ObjectInputStream.class.getDeclaredMethod(""newInstance"", Class.class, Class.class);
      newInstance.setAccessible(true);

      return new UnsafeAllocator() {
        @Override
        @SuppressWarnings(""unchecked"")
        public <T> T newInstance(Class<T> c) throws Exception {
          if (c.isInterface() || java.lang.reflect.Modifier.isAbstract(c.getModifiers())) {
            throw new UnsupportedOperationException(""Cannot instantiate "" + c);
          }
          return (T) newInstance.invoke(null, c, Object.class);
        }
      };
    } catch (Exception ignored) {
    }

    // give up
    return new UnsafeAllocator() {
      @Override
      public <T> T newInstance(Class<T> c) {
        throw new UnsupportedOperationException(""Cannot allocate "" + c);
      }
    };
  }
}",0,0
154,Gson_9,"    public Boolean read(JsonReader in) throws IOException {
      if (in.peek() == JsonToken.NULL) {
        in.nextNull();
        return null;
      } else if (in.peek() == JsonToken.STRING) {
        // support strings for compatibility with GSON 1.7
        return Boolean.parseBoolean(in.nextString());
      }
      return in.nextBoolean();
    }
","public Boolean read(JsonReader in) throws IOException {
    if (in.peek() == JsonToken.NULL) {
        in.nextNull();
        return null;
    } else if (in.peek() == JsonToken.STRING) {
        // support strings for compatibility with GSON 1.7
        String boolString = in.nextString();
        if (""true"".equalsIgnoreCase(boolString)) {
            return true;
        } else if (""false"".equalsIgnoreCase(boolString)) {
            return false;
        } else {
            throw new IllegalArgumentException(""Invalid boolean value: "" + boolString);
        }
    }
    return in.nextBoolean();
}",0,0
154,Gson_9,"  public JsonWriter value(double value) throws IOException {
    if (Double.isNaN(value) || Double.isInfinite(value)) {
      throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
    }
    writeDeferredName();
    beforeValue();
    out.append(Double.toString(value));
    return this;
  }
","public JsonWriter value(double value) throws IOException {
    if (Double.isNaN(value) || Double.isInfinite(value)) {
        throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
    }
    writeDeferredName();
    beforeValue();
    out.append(String.valueOf(value)); // Changed Double.toString(value) to String.valueOf(value) for safer handling
    return this;
}",0,0
154,Gson_9,"  private void put(JsonElement value) {
    if (pendingName != null) {
      if (!value.isJsonNull() || getSerializeNulls()) {
        JsonObject object = (JsonObject) peek();
        object.add(pendingName, value);
      }
      pendingName = null;
    } else if (stack.isEmpty()) {
      product = value;
    } else {
      JsonElement element = peek();
      if (element instanceof JsonArray) {
        ((JsonArray) element).add(value);
      } else {
        throw new IllegalStateException();
      }
    }
  }
","private void put(JsonElement value) {
    if (pendingName != null) {
        if (value != null && (!value.isJsonNull() || getSerializeNulls())) {
            JsonObject object = (JsonObject) peek();
            if (object == null) {
                throw new IllegalStateException(""Expected a JsonObject but was null"");
            }
            object.add(pendingName, value);
        }
        pendingName = null;
    } else if (stack.isEmpty()) {
        product = value;
    } else {
        JsonElement element = peek();
        if (element instanceof JsonArray) {
            ((JsonArray) element).add(value);
        } else {
            throw new IllegalStateException(""Expected a JsonArray but was "" + element.getClass().getSimpleName());
        }
    }
}",0,0
155,JacksonCore_1,"    public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)
            throws NumberFormatException
    {
            return new BigDecimal(buffer, offset, len);
    }
","public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) 
        throws NumberFormatException {
    try {
        return new BigDecimal(buffer, offset, len);
    } catch (NumberFormatException e) {
        throw new NumberFormatException(""Invalid input for BigDecimal: "" + new String(buffer, offset, len));
    }
}",0,0
155,JacksonCore_1,"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }
","public BigDecimal contentsAsDecimal() 
        throws NumberFormatException {
    try {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    } catch (NumberFormatException e) {
        throw new NumberFormatException(""Invalid input for BigDecimal: failed to parse decimal contents."");
    }
}",0,0
155,JacksonCore_1,"    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException
    {
            return new BigDecimal(numStr);
    }
","public static BigDecimal parseBigDecimal(String numStr) 
        throws NumberFormatException {
    if (numStr == null || numStr.isEmpty() || numStr.equalsIgnoreCase(""NaN"")) {
        throw new NumberFormatException(""Invalid string for BigDecimal: "" + numStr);
    }
    try {
        return new BigDecimal(numStr);
    } catch (NumberFormatException e) {
        throw new NumberFormatException(""Invalid string for BigDecimal: "" + numStr);
    }
}",0,0
156,JacksonCore_10,"private int _findOffsetForAdd(int hash)
    {
        // first, check the primary:
        int offset = _calcOffset(hash);
        final int[] hashArea = _hashArea;
        if (hashArea[offset+3] == 0) {
//System.err.printf("" PRImary slot #%d, hash %X\n"", (offset>>2), hash & 0x7F);
            return offset;
        }
        // then secondary
        int offset2 = _secondaryStart + ((offset >> 3) << 2);
        if (hashArea[offset2+3] == 0) {
//System.err.printf("" SECondary slot #%d (start x%X), hash %X\n"",(offset >> 3), _secondaryStart, (hash & 0x7F));
            return offset2;
        }
        // if not, tertiary?

        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);
        final int bucketSize = (1 << _tertiaryShift);
        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {
            if (hashArea[offset2+3] == 0) {
//System.err.printf("" TERtiary slot x%X (from x%X, start x%X), hash %X.\n"", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));
                return offset2;
            }
        }

        // and if even tertiary full, append at the end of spill area
        offset = _spilloverEnd;
        _spilloverEnd += 4;

//System.err.printf("" SPIll-over at x%X; start x%X; end x%X, hash %X\n"", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));
        
        // one caveat: in the unlikely event if spill-over filling up,
        // check if that could be considered a DoS attack; handle appropriately
        // (NOTE: approximate for now; we could verify details if that becomes necessary)
         /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,
          *   since ""long names"" area follows. Instead, need to calculate from hash size.
          */
         if (_spilloverEnd >= hashArea.length) {
             if (_failOnDoS) {
                 _reportTooManyCollisions();
             }
            // and if we didn't fail, we'll simply force rehash for next add
            // (which, in turn, may double up or nuke contents, depending on size etc)
            _needRehash = true;
        }
        return offset;
    }","private int _findOffsetForAdd(int hash) {
    // first, check the primary:
    int offset = _calcOffset(hash);
    final int[] hashArea = _hashArea;
    if (hashArea[offset + 3] == 0) {
        return offset;
    }

    // then secondary
    int offset2 = _secondaryStart + ((offset >> 3) << 2);
    if (hashArea[offset2 + 3] == 0) {
        return offset2;
    }

    // if not, tertiary
    offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);
    final int bucketSize = (1 << _tertiaryShift);
    for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {
        if (hashArea[offset2 + 3] == 0) {
            return offset2;
        }
    }

    // and if even tertiary full, append at the end of spill area
    offset = _spilloverEnd;
    _spilloverEnd += 4;

    // handle overflow case (spillover filling up) appropriately
    if (_spilloverEnd >= hashArea.length) {
        if (_failOnDoS) {
            _reportTooManyCollisions();
        }
        _needRehash = true;
    }
    return offset;
}",0,0
156,JacksonCore_10,"public int calcHash(int q1)
    {
        int hash = q1 ^ _seed;
        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok
         *    except for one specific problem case: numbers. So needed to make sure
         *    that all 4 least-significant bits participate in hash. Couple of ways
          *    to work it out, but this is the simplest, fast and seems to do ok.
          */
         hash += (hash >>> 16); // to xor hi- and low- 16-bits
         hash ^= (hash >>> 12);
         return hash;
     }","public int calcHash(int q1) {
    int hash = q1 ^ _seed;
    // ensure participation of all 4 least-significant bits in the hash
    hash += (hash >>> 16); // mix hi- and low- 16-bits
    hash ^= (hash >>> 12); // further mixing
    return hash;
}",0,0
157,JacksonCore_12,"@Override
    public JsonLocation getTokenLocation()
    {
        final Object src = _ioContext.getSourceReference();
        if (_currToken == JsonToken.FIELD_NAME) {
            return new JsonLocation(src,
                     _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);
         }
         return new JsonLocation(src,
                 getTokenCharacterOffset(), -1L, getTokenLineNr(),
                 getTokenColumnNr());
     }","@Override
public JsonLocation getTokenLocation() {
    final Object src = _ioContext.getSourceReference();
    if (_currToken == JsonToken.FIELD_NAME) {
        return new JsonLocation(src,
                _nameInputTotal, -1L, _nameInputRow, _nameInputCol);
    }
    return new JsonLocation(src,
            getTokenCharacterOffset(), -1L, getTokenLineNr(),
            getTokenColumnNr());
}",0,0
157,JacksonCore_12,"protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException
    {
        // // // and this is back to standard nextToken()
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
         _parsingContext.setCurrentName(name);
         _currToken = JsonToken.FIELD_NAME;
         i = _skipColon();
         if (i == INT_QUOTE) {
             _tokenIncomplete = true;
             _nextToken = JsonToken.VALUE_STRING;
            return nameToMatch.equals(name);
        }
        // Ok: we must have a value... what is it?
        JsonToken t;
        switch (i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
        }
        _nextToken = t;
        return nameToMatch.equals(name);
    }","protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException {
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    if (name == null) {
        _currToken = null;
        return false;
    }
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return nameToMatch.equals(name);
    }
    JsonToken t;
    switch (i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0': case '1': case '2': case '3': case '4': 
        case '5': case '6': case '7': case '8': case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return nameToMatch.equals(name);
}",0,0
157,JacksonCore_12,"private final void _isNextTokenNameYes(int i) throws IOException
     {
         _currToken = JsonToken.FIELD_NAME;
 
         switch (i) {
         case '""':
            _tokenIncomplete = true;
            _nextToken = JsonToken.VALUE_STRING;
            return;
        case '[':
            _nextToken = JsonToken.START_ARRAY;
            return;
        case '{':
            _nextToken = JsonToken.START_OBJECT;
            return;
        case 't':
            _matchToken(""true"", 1);
            _nextToken = JsonToken.VALUE_TRUE;
            return;
        case 'f':
            _matchToken(""false"", 1);
            _nextToken = JsonToken.VALUE_FALSE;
            return;
        case 'n':
            _matchToken(""null"", 1);
            _nextToken = JsonToken.VALUE_NULL;
            return;
        case '-':
            _nextToken = _parseNegNumber();
            return;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            _nextToken = _parsePosNumber(i);
            return;
        }
        _nextToken = _handleOddValue(i);
    }","private final void _isNextTokenNameYes(int i) throws IOException {
    _currToken = JsonToken.FIELD_NAME;
    switch (i) {
        case '""':
            _tokenIncomplete = true;
            _nextToken = JsonToken.VALUE_STRING;
            return;
        case '[':
            _nextToken = JsonToken.START_ARRAY;
            return;
        case '{':
            _nextToken = JsonToken.START_OBJECT;
            return;
        case 't':
            _matchToken(""true"", 1);
            _nextToken = JsonToken.VALUE_TRUE;
            return;
        case 'f':
            _matchToken(""false"", 1);
            _nextToken = JsonToken.VALUE_FALSE;
            return;
        case 'n':
            _matchToken(""null"", 1);
            _nextToken = JsonToken.VALUE_NULL;
            return;
        case '-':
            _nextToken = _parseNegNumber();
            return;
        case '0': case '1': case '2': case '3': case '4': 
        case '5': case '6': case '7': case '8': case '9':
            _nextToken = _parsePosNumber(i);
            return;
        default:
            _nextToken = _handleOddValue(i);
            return;
    }
}",0,0
157,JacksonCore_12,"@Override
     public JsonLocation getTokenLocation()
     {
         final Object src = _ioContext.getSourceReference();
         return new JsonLocation(src,
                 -1L, getTokenCharacterOffset(),
                 getTokenLineNr(),
                 getTokenColumnNr());
     }","@Override
public JsonLocation getTokenLocation() {
    final Object src = _ioContext.getSourceReference();
    return new JsonLocation(src,
            getTokenCharacterOffset(), -1L, getTokenLineNr(),
            getTokenColumnNr());
}",0,0
157,JacksonCore_12,"@Override
    public boolean nextFieldName(SerializableString sstr) throws IOException
    {
        // // // Note: most of code below is copied from nextToken()

        _numTypesValid = NR_UNKNOWN;
        if (_currToken == JsonToken.FIELD_NAME) {
            _nextAfterName();
            return false;
        }
        if (_tokenIncomplete) {
            _skipString();
        }
        int i = _skipWSOrEnd();
        if (i < 0) {
            close();
            _currToken = null;
            return false;
        }
        _binaryValue = null;

        if (i == INT_RBRACKET) {
            _updateLocation();
            if (!_parsingContext.inArray()) {
                _reportMismatchedEndMarker(i, '}');
            }
            _parsingContext = _parsingContext.getParent();
            _currToken = JsonToken.END_ARRAY;
            return false;
        }
        if (i == INT_RCURLY) {
            _updateLocation();
            if (!_parsingContext.inObject()) {
                _reportMismatchedEndMarker(i, ']');
            }
            _parsingContext = _parsingContext.getParent();
            _currToken = JsonToken.END_OBJECT;
            return false;
        }
         if (_parsingContext.expectComma()) {
             i = _skipComma(i);
         }
         _updateLocation();
 
         if (!_parsingContext.inObject()) {
             _nextTokenNotInObject(i);
             return false;
         }
 
         if (i == INT_QUOTE) {
             // when doing literal match, must consider escaping:
             char[] nameChars = sstr.asQuotedChars();
            final int len = nameChars.length;

            // Require 4 more bytes for faster skipping of colon that follows name
            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...
                // first check length match by
                final int end = _inputPtr+len;
                if (_inputBuffer[end] == '""') {
                    int offset = 0;
                    int ptr = _inputPtr;
                    while (true) {
                        if (ptr == end) { // yes, match!
                            _parsingContext.setCurrentName(sstr.getValue());
                            _isNextTokenNameYes(_skipColonFast(ptr+1));
                            return true;
                        }
                        if (nameChars[offset] != _inputBuffer[ptr]) {
                            break;
                        }
                        ++offset;
                        ++ptr;
                    }
                }
            }
        }
        return _isNextTokenNameMaybe(i, sstr.getValue());
    }","@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_ARRAY;
        return false;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_OBJECT;
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    if (!_parsingContext.inObject()) {
        _nextTokenNotInObject(i);
        return false;
    }
    if (i == INT_QUOTE) {
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        if ((_inputPtr + len + 4) < _inputEnd) {
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}",0,0
157,JacksonCore_12,"@Override
    public final JsonToken nextToken() throws IOException
    {
        /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
        if (_currToken == JsonToken.FIELD_NAME) {
            return _nextAfterName();
        }
        // But if we didn't already have a name, and (partially?) decode number,
        // need to ensure no numeric information is leaked
        _numTypesValid = NR_UNKNOWN;
        if (_tokenIncomplete) {
            _skipString(); // only strings can be partial
        }
        int i = _skipWSOrEnd();
        if (i < 0) { // end-of-input
            /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
            close();
            return (_currToken = null);
        }
        // clear any data retained so far
        _binaryValue = null;

        // Closing scope?
        if (i == INT_RBRACKET) {
            _updateLocation();
            if (!_parsingContext.inArray()) {
                _reportMismatchedEndMarker(i, '}');
            }
            _parsingContext = _parsingContext.getParent();
            return (_currToken = JsonToken.END_ARRAY);
        }
        if (i == INT_RCURLY) {
            _updateLocation();
            if (!_parsingContext.inObject()) {
                _reportMismatchedEndMarker(i, ']');
            }
            _parsingContext = _parsingContext.getParent();
            return (_currToken = JsonToken.END_OBJECT);
        }

        // Nope: do we then expect a comma?
        if (_parsingContext.expectComma()) {
            i = _skipComma(i);
        }
        _updateLocation();

        /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
         boolean inObject = _parsingContext.inObject();
         if (inObject) {
             // First, field name itself:
             String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
             _parsingContext.setCurrentName(name);
             _currToken = JsonToken.FIELD_NAME;
             i = _skipColon();
         }
 
         // Ok: we must have a value... what is it?
 
        JsonToken t;

        switch (i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;

        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
        }

        if (inObject) {
            _nextToken = t;
            return _currToken;
        }
        _currToken = t;
        return t;
    }","@Override
public final JsonToken nextToken() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        return (_currToken = null);
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    JsonToken t;
    switch (i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            t = _parseNegNumber();
            break;
        case '0': case '1': case '2': case '3': case '4': 
        case '5': case '6': case '7': case '8': case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}",0,0
157,JacksonCore_12,"@Override
    public String nextFieldName() throws IOException
    {
        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)

        _numTypesValid = NR_UNKNOWN;
        if (_currToken == JsonToken.FIELD_NAME) {
            _nextAfterName();
            return null;
        }
        if (_tokenIncomplete) {
            _skipString();
        }
        int i = _skipWSOrEnd();
        if (i < 0) {
            close();
            _currToken = null;
            return null;
        }
        _binaryValue = null;
        if (i == INT_RBRACKET) {
            _updateLocation();
            if (!_parsingContext.inArray()) {
                _reportMismatchedEndMarker(i, '}');
            }
            _parsingContext = _parsingContext.getParent();
            _currToken = JsonToken.END_ARRAY;
            return null;
        }
        if (i == INT_RCURLY) {
            _updateLocation();
            if (!_parsingContext.inObject()) {
                _reportMismatchedEndMarker(i, ']');
            }
            _parsingContext = _parsingContext.getParent();
            _currToken = JsonToken.END_OBJECT;
            return null;
        }
         if (_parsingContext.expectComma()) {
             i = _skipComma(i);
         }
         _updateLocation();
         if (!_parsingContext.inObject()) {
             _nextTokenNotInObject(i);
             return null;
         }
 
         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
         _parsingContext.setCurrentName(name);
         _currToken = JsonToken.FIELD_NAME;
         i = _skipColon();
 
         if (i == INT_QUOTE) {
             _tokenIncomplete = true;
             _nextToken = JsonToken.VALUE_STRING;
            return name;
        }
        
        // Ok: we must have a value... what is it?

        JsonToken t;

        switch (i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
        }
        _nextToken = t;
        return name;
    }","@Override
public String nextFieldName() throws IOException {
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    if (!_parsingContext.inObject()) {
        _nextTokenNotInObject(i);
        return null;
    }
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    JsonToken t;
    switch (i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0': case '1': case '2': case '3': case '4': 
        case '5': case '6': case '7': case '8': case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}",0,0
158,JacksonCore_13,"    public JsonGenerator enable(Feature f) {
        super.enable(f);
        if (f == Feature.QUOTE_FIELD_NAMES) {
            _cfgUnqNames = false;
        }
        return this;
    }
","public JsonGenerator enable(Feature f) {
    super.enable(f);
    if (f == Feature.QUOTE_FIELD_NAMES) {
        _cfgUnqNames = !_cfgUnqNames; // Ensure proper toggling instead of hardcoding to false
    }
    return this;
}",0,0
159,JacksonCore_14,"    protected final void _verifyAlloc(Object buffer) {
        if (buffer != null) { throw new IllegalStateException(""Trying to call same allocXxx() method second time""); }
    }
","protected final void _verifyAlloc(Object buffer) {
    if (buffer != null) {
        throw new IllegalStateException(""Trying to call the same allocXxx() method more than once, which is not allowed."");
    }
}",0,0
160,JacksonCore_16,"    public void close() throws IOException {
        do { delegate.close(); } while (switchToNext());
    }
","public void close() throws IOException {
    IOException exception = null;
    do {
        try {
            delegate.close();
        } catch (IOException e) {
            if (exception == null) {
                exception = e;
            } else {
                exception.addSuppressed(e);
            }
        }
    } while (switchToNext());
    if (exception != null) {
        throw exception;
    }
}",0,0
160,JacksonCore_16,"    protected JsonParserSequence(JsonParser[] parsers)
    {
        super(parsers[0]);
        _parsers = parsers;
        _nextParser = 1;
    }
","protected JsonParserSequence(JsonParser[] parsers) {
    super(parsers != null && parsers.length > 0 ? parsers[0] : null);
    if (parsers == null || parsers.length == 0) {
        throw new IllegalArgumentException(""Parsers array must not be null or empty"");
    }
    _parsers = parsers;
    _nextParser = 1;
}",0,0
161,JacksonCore_17,"@Override
    public void writeRaw(String text, int offset, int len) throws IOException
    {
         final char[] buf = _charBuffer;
 
         // minor optimization: see if we can just get and copy
 
         // If not, need segmented approach. For speed, let's also use input buffer
         // size that is guaranteed to fit in output buffer; each char can expand to
         // at most 3 bytes, so at most 1/3 of buffer size.
 
         while (len > 0) {
             int len2 = Math.min(buf.length, len);
             text.getChars(offset, offset+len2, buf, 0);
             writeRaw(buf, 0, len2);
             // If this is NOT the last segment and if the last character looks like
             // split surrogate second half, drop it
             offset += len2;
             len -= len2;
         }
    }","@Override
public void writeRaw(String text, int offset, int len) throws IOException {
    final char[] buf = _charBuffer;

    if (len <= 0) {
        return;
    }

    while (len > 0) {
        int len2 = Math.min(buf.length, len);
        text.getChars(offset, offset + len2, buf, 0);
        writeRaw(buf, 0, len2);

        // If not the last segment, check for potential surrogate split
        if (len2 > 0 && len > len2) {
            char lastChar = buf[len2 - 1];
            if (Character.isHighSurrogate(lastChar) && offset + len2 < text.length()) {
                char nextChar = text.charAt(offset + len2);
                if (Character.isLowSurrogate(nextChar)) {
                    // Adjust to avoid splitting surrogate pair
                    len2--;
                    writeRaw(buf, 0, len2);
                }
            }
        }

        offset += len2;
        len -= len2;
    }
}",0,0
161,JacksonCore_17,"private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)
        throws IOException
    {
        // Let's handle surrogates gracefully (as 4 byte output):
        if (ch >= SURR1_FIRST) {
            if (ch <= SURR2_LAST) { // yes, outside of BMP
                // Do we have second part?
                if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down
                    _reportError(""Split surrogate on writeRaw() input (last character)"");
                }
                _outputSurrogates(ch, cbuf[inputOffset]);
                return inputOffset+1;
            }
        }
        final byte[] bbuf = _outputBuffer;
        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));
        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));
        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));
        return inputOffset;
    }","private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {
    // Handle surrogate pairs gracefully
    if (ch >= SURR1_FIRST && ch <= SURR2_LAST) {
        if (inputOffset >= inputEnd || cbuf == null) {
            _reportError(""Split surrogate on writeRaw() input (last character)"");
        }
        int surr2 = cbuf[inputOffset];
        if (!Character.isLowSurrogate((char) surr2)) {
            _reportError(""Invalid second surrogate in writeRaw() input"");
        }
        _outputSurrogates(ch, surr2);
        return inputOffset + 1;
    }

    // Handle multi-byte UTF-8 encoding for BMP characters
    if ((_outputTail + 3) > _outputEnd) {
        _flushBuffer();
    }
    final byte[] bbuf = _outputBuffer;
    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));
    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));
    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));

    return inputOffset;
}",0,0
162,JacksonCore_18,"@Override
    public void writeNumber(BigDecimal value) throws IOException
    {
        // Don't really know max length for big decimal, no point checking
        _verifyValueWrite(WRITE_NUMBER);
         if (value == null) {
             _writeNull();
         } else  if (_cfgNumbersAsStrings) {
             String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();
             _writeQuotedRaw(raw);
         } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {
             writeRaw(value.toPlainString());
         } else {
             writeRaw(_asString(value));
         }
    }","@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for BigDecimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
        return;
    }
    try {
        if (_cfgNumbersAsStrings) {
            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();
            _writeQuotedRaw(raw);
        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {
            writeRaw(value.toPlainString());
        } else {
            writeRaw(_asString(value));
        }
    } catch (NumberFormatException | ArithmeticException ex) {
        _reportError(""Invalid BigDecimal value: "" + value);
    }
}",0,0
162,JacksonCore_18,"@Override
    public void writeNumber(BigDecimal value) throws IOException
    {
        // Don't really know max length for big decimal, no point checking
        _verifyValueWrite(WRITE_NUMBER);
         if (value == null) {
             _writeNull();
         } else  if (_cfgNumbersAsStrings) {
             String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();
             _writeQuotedRaw(raw);
         } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {
             writeRaw(value.toPlainString());
         } else {
             writeRaw(_asString(value));
         }
    }","@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for BigDecimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
        return;
    }
    try {
        if (_cfgNumbersAsStrings) {
            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();
            _writeQuotedRaw(raw);
        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {
            writeRaw(value.toPlainString());
        } else {
            writeRaw(_asString(value));
        }
    } catch (NumberFormatException | ArithmeticException ex) {
        _reportError(""Invalid BigDecimal value: "" + value);
    }
}",0,0
163,JacksonCore_19,"private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException
    {
        _inputPtr = neg ? (startPtr+1) : startPtr;
        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
        int outPtr = 0;

        // Need to prepend sign?
        if (neg) {
            outBuf[outPtr++] = '-';
        }

        // This is the place to do leading-zero check(s) too:
        int intLen = 0;
        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(""No digit following minus sign"");
        if (c == '0') {
            c = _verifyNoLeadingZeroes();
        }
        boolean eof = false;

        // Ok, first the obligatory integer part:
        int_loop:
        while (c >= '0' && c <= '9') {
            ++intLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            if (_inputPtr >= _inputEnd && !loadMore()) {
                // EOF is legal for main level int values
                c = CHAR_NULL;
                eof = true;
                break int_loop;
            }
            c = _inputBuffer[_inputPtr++];
        }
        // Also, integer part is not optional
        if (intLen == 0) {
            return _handleInvalidNumberStart(c, neg);
        }

         int fractLen = 0;
         // And then see if we get other parts
         if (c == '.') { // yes, fraction
             outBuf[outPtr++] = c;
 
             fract_loop:
            while (true) {
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break fract_loop;
                }
                c = _inputBuffer[_inputPtr++];
                if (c < INT_0 || c > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
            }
        }

        int expLen = 0;
        if (c == 'e' || c == 'E') { // exponent?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            // Not optional, can require that we get one more char
            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
                : getNextChar(""expected a digit for number exponent"");
            // Sign indicator?
            if (c == '-' || c == '+') {
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
                // Likewise, non optional:
                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
                    : getNextChar(""expected a digit for number exponent"");
            }

            exp_loop:
            while (c <= INT_9 && c >= INT_0) {
                ++expLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break exp_loop;
                }
                c = _inputBuffer[_inputPtr++];
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
            }
        }

        // Ok; unless we hit end-of-input, need to push last char read back
        if (!eof) {
            --_inputPtr;
            if (_parsingContext.inRoot()) {
                _verifyRootSpace(c);
            }
        }
        _textBuffer.setCurrentLength(outPtr);
        // And there we have it!
        return reset(neg, intLen, fractLen, expLen);
    }","private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException
{
    _inputPtr = neg ? (startPtr + 1) : startPtr;
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = 0;

    // Need to prepend sign?
    if (neg) {
        outBuf[outPtr++] = '-';
    }

    // This is the place to do leading-zero check(s) too:
    int intLen = 0;
    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(""No digit following minus sign"");
    if (c == '0') {
        c = _verifyNoLeadingZeroes();
    }
    boolean eof = false;

    // Ok, first the obligatory integer part:
    while (c >= '0' && c <= '9') {
        ++intLen;
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        outBuf[outPtr++] = c;
        if (_inputPtr >= _inputEnd && !loadMore()) {
            // EOF is legal for main level int values
            c = CHAR_NULL;
            eof = true;
            break;
        }
        c = _inputBuffer[_inputPtr++];
    }
    // Integer part is not optional
    if (intLen == 0) {
        return _handleInvalidNumberStart(c, neg);
    }

    int fractLen = 0;
    // And then see if we get a decimal part
    if (c == '.') { // yes, fraction
        outBuf[outPtr++] = c;

        while (true) {
            if (_inputPtr >= _inputEnd && !loadMore()) {
                eof = true;
                break;
            }
            c = _inputBuffer[_inputPtr++];
            if (c < '0' || c > '9') {
                break;
            }
            ++fractLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
        }
        // Must have at least one digit after the decimal point
        if (fractLen == 0) {
            reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
        }
    }

    int expLen = 0;
    // Now, check for an exponent
    if (c == 'e' || c == 'E') { // exponent?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        outBuf[outPtr++] = c;
        // Not optional, can require that we get one more char
        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
            : getNextChar(""expected a digit for number exponent"");
        // Sign indicator?
        if (c == '-' || c == '+') {
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            // Likewise, non optional:
            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
                : getNextChar(""expected a digit for number exponent"");
        }

        while (c >= '0' && c <= '9') {
            ++expLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            if (_inputPtr >= _inputEnd && !loadMore()) {
                eof = true;
                break;
            }
            c = _inputBuffer[_inputPtr++];
        }
        // Must have at least one digit in the exponent
        if (expLen == 0) {
            reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
        }
    }

    // Push back the last character if we haven't hit EOF
    if (!eof) {
        --_inputPtr;
        if (_parsingContext.inRoot()) {
            _verifyRootSpace(c);
        }
    }
    _textBuffer.setCurrentLength(outPtr);
    // Finalize and return
    return reset(neg, intLen, fractLen, expLen);
}",0,0
163,JacksonCore_19,"private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,
            boolean negative, int integerPartLength) throws IOException
    {
        int fractLen = 0;
        boolean eof = false;
 
         // And then see if we get other parts
         if (c == INT_PERIOD) { // yes, fraction
             outBuf[outPtr++] = (char) c;
 
             fract_loop:
            while (true) {
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break fract_loop;
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
                if (c < INT_0 || c > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
            }
        }

        int expLen = 0;
        if (c == INT_e || c == INT_E) { // exponent?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            // Not optional, can require that we get one more char
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            // Sign indicator?
            if (c == '-' || c == '+') {
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
                // Likewise, non optional:
                if (_inputPtr >= _inputEnd) {
                    loadMoreGuaranteed();
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            }

            exp_loop:
            while (c <= INT_9 && c >= INT_0) {
                ++expLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break exp_loop;
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
            }
        }

        // Ok; unless we hit end-of-input, need to push last char read back
        if (!eof) {
            --_inputPtr;
            // As per [core#105], need separating space between root values; check here
            if (_parsingContext.inRoot()) {
                _verifyRootSpace(c);
            }
        }
        _textBuffer.setCurrentLength(outPtr);

        // And there we have it!
        return resetFloat(negative, integerPartLength, fractLen, expLen);
    }","private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,
        boolean negative, int integerPartLength) throws IOException
{
    int fractLen = 0;
    boolean eof = false;

    // Check for a fractional part
    if (c == INT_PERIOD) { // yes, fraction
        outBuf[outPtr++] = (char) c;

        while (true) {
            if (_inputPtr >= _inputEnd && !loadMore()) {
                eof = true;
                break;
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            if (c < INT_0 || c > INT_9) {
                break;
            }
            ++fractLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
        }
        // Must have at least one digit after the decimal point
        if (fractLen == 0) {
            reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
        }
    }

    int expLen = 0;
    // Check for an exponent
    if (c == INT_e || c == INT_E) { // exponent?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        outBuf[outPtr++] = (char) c;
        // Not optional, must get another char
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        c = (int) _inputBuffer[_inputPtr++] & 0xFF;
        // Sign indicator?
        if (c == '-' || c == '+') {
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            // Likewise, non optional
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
        }

        while (c >= INT_0 && c <= INT_9) {
            ++expLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            if (_inputPtr >= _inputEnd && !loadMore()) {
                eof = true;
                break;
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
        }
        // Must have at least one digit in the exponent
        if (expLen == 0) {
            reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
        }
    }

    // Push back the last character if we haven't hit EOF
    if (!eof) {
        --_inputPtr;
        if (_parsingContext.inRoot()) {
            _verifyRootSpace(c);
        }
    }
    _textBuffer.setCurrentLength(outPtr);

    // Finalize and return
    return resetFloat(negative, integerPartLength, fractLen, expLen);
}",0,0
164,JacksonCore_2,"protected JsonToken _parseNumber(int ch) throws IOException
    {
        /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
        boolean negative = (ch == INT_MINUS);
        int ptr = _inputPtr;
        int startPtr = ptr-1; // to include sign/digit already read
        final int inputLen = _inputEnd;

        dummy_loop:
        do { // dummy loop, to be able to break out
            if (negative) { // need to read the next digit
                if (ptr >= _inputEnd) {
                    break dummy_loop;
                }
                ch = _inputBuffer[ptr++];
                // First check: must have a digit to follow minus sign
                if (ch > INT_9 || ch < INT_0) {
                    _inputPtr = ptr;
                    return _handleInvalidNumberStart(ch, true);
                }
                /* (note: has been checked for non-negative already, in
                 * the dispatching code that determined it should be
                 * a numeric value)
                 */
            }
            // One special case, leading zero(es):
            if (ch == INT_0) {
                break dummy_loop;
            }
            
            /* First, let's see if the whole number is contained within
             * the input buffer unsplit. This should be the common case;
             * and to simplify processing, we will just reparse contents
             * in the alternative case (number split on buffer boundary)
             */
            
            int intLen = 1; // already got one
            
            // First let's get the obligatory integer part:
            
            int_loop:
            while (true) {
                if (ptr >= _inputEnd) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
                if (ch < INT_0 || ch > INT_9) {
                    break int_loop;
                }
                ++intLen;
            }

            int fractLen = 0;
            
            // And then see if we get other parts
            if (ch == '.') { // yes, fraction
                fract_loop:
                while (true) {
                    if (ptr >= inputLen) {
                        break dummy_loop;
                    }
                    ch = (int) _inputBuffer[ptr++];
                    if (ch < INT_0 || ch > INT_9) {
                        break fract_loop;
                    }
                    ++fractLen;
                }
                // must be followed by sequence of ints, one minimum
                if (fractLen == 0) {
                    reportUnexpectedNumberChar(ch, ""Decimal point not followed by a digit"");
                }
            }

            int expLen = 0;
            if (ch == 'e' || ch == 'E') { // and/or exponent
                if (ptr >= inputLen) {
                    break dummy_loop;
                }
                // Sign indicator?
                ch = (int) _inputBuffer[ptr++];
                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now
                    if (ptr >= inputLen) {
                        break dummy_loop;
                    }
                    ch = (int) _inputBuffer[ptr++];
                }
                while (ch <= INT_9 && ch >= INT_0) {
                    ++expLen;
                    if (ptr >= inputLen) {
                        break dummy_loop;
                    }
                    ch = (int) _inputBuffer[ptr++];
                }
                // must be followed by sequence of ints, one minimum
                if (expLen == 0) {
                    reportUnexpectedNumberChar(ch, ""Exponent indicator not followed by a digit"");
                }
            }
            // Got it all: let's add to text buffer for parsing, access
             --ptr; // need to push back following separator
             _inputPtr = ptr;
             // As per #105, need separating space between root values; check here
             int len = ptr-startPtr;
             _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
             return reset(negative, intLen, fractLen, expLen);
        } while (false);

        _inputPtr = negative ? (startPtr+1) : startPtr;
        return _parseNumber2(negative);
    }","protected JsonToken _parseNumber(int ch) throws IOException {
    boolean negative = (ch == INT_MINUS);
    int ptr = _inputPtr;
    int startPtr = ptr - 1; // to include sign/digit already read
    final int inputLen = _inputEnd;

    dummy_loop:
    do {
        if (negative) {
            if (ptr >= _inputEnd && !loadMore()) {
                break dummy_loop;
            }
            ch = _inputBuffer[ptr++];
            if (ch > INT_9 || ch < INT_0) {
                _inputPtr = ptr;
                return _handleInvalidNumberStart(ch, true);
            }
        }
        if (ch == INT_0) {
            break dummy_loop;
        }
        int intLen = 1;

        int_loop:
        while (true) {
            if (ptr >= _inputEnd && !loadMore()) {
                break dummy_loop;
            }
            ch = (int) _inputBuffer[ptr++];
            if (ch < INT_0 || ch > INT_9) {
                break int_loop;
            }
            ++intLen;
        }

        int fractLen = 0;
        if (ch == '.') {
            fract_loop:
            while (true) {
                if (ptr >= inputLen && !loadMore()) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
                if (ch < INT_0 || ch > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
            }
            if (fractLen == 0) {
                reportUnexpectedNumberChar(ch, ""Decimal point not followed by a digit"");
            }
        }

        int expLen = 0;
        if (ch == 'e' || ch == 'E') {
            if (ptr >= inputLen && !loadMore()) {
                break dummy_loop;
            }
            ch = (int) _inputBuffer[ptr++];
            if (ch == INT_MINUS || ch == INT_PLUS) {
                if (ptr >= inputLen && !loadMore()) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
            }
            while (ch <= INT_9 && ch >= INT_0) {
                ++expLen;
                if (ptr >= inputLen && !loadMore()) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
            }
            if (expLen == 0) {
                reportUnexpectedNumberChar(ch, ""Exponent indicator not followed by a digit"");
            }
        }
        --ptr;
        _inputPtr = ptr;
        int len = ptr - startPtr;
        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
        return reset(negative, intLen, fractLen, expLen);
    } while (false);

    _inputPtr = negative ? (startPtr + 1) : startPtr;
    return _parseNumber2(negative);
}",0,0
164,JacksonCore_2,"private JsonToken _parseNumber2(boolean negative) throws IOException
    {
        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
        int outPtr = 0;

        // Need to prepend sign?
        if (negative) {
            outBuf[outPtr++] = '-';
        }

        // This is the place to do leading-zero check(s) too:
        int intLen = 0;
        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(""No digit following minus sign"");
        if (c == '0') {
            c = _verifyNoLeadingZeroes();
        }
        boolean eof = false;

        // Ok, first the obligatory integer part:
        int_loop:
        while (c >= '0' && c <= '9') {
            ++intLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            if (_inputPtr >= _inputEnd && !loadMore()) {
                // EOF is legal for main level int values
                c = CHAR_NULL;
                eof = true;
                break int_loop;
            }
            c = _inputBuffer[_inputPtr++];
        }
        // Also, integer part is not optional
        if (intLen == 0) {
            reportInvalidNumber(""Missing integer part (next char ""+_getCharDesc(c)+"")"");
        }

        int fractLen = 0;
        // And then see if we get other parts
        if (c == '.') { // yes, fraction
            outBuf[outPtr++] = c;

            fract_loop:
            while (true) {
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break fract_loop;
                }
                c = _inputBuffer[_inputPtr++];
                if (c < INT_0 || c > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
            }
        }

        int expLen = 0;
        if (c == 'e' || c == 'E') { // exponent?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            // Not optional, can require that we get one more char
            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
                : getNextChar(""expected a digit for number exponent"");
            // Sign indicator?
            if (c == '-' || c == '+') {
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
                // Likewise, non optional:
                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
                    : getNextChar(""expected a digit for number exponent"");
            }

            exp_loop:
            while (c <= INT_9 && c >= INT_0) {
                ++expLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break exp_loop;
                }
                c = _inputBuffer[_inputPtr++];
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
            }
        }

         // Ok; unless we hit end-of-input, need to push last char read back
         if (!eof) {
             --_inputPtr;
         }
         _textBuffer.setCurrentLength(outPtr);
         // And there we have it!
        return reset(negative, intLen, fractLen, expLen);
    }","private JsonToken _parseNumber2(boolean negative) throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = 0;

    if (negative) {
        outBuf[outPtr++] = '-';
    }

    int intLen = 0;
    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(""No digit following minus sign"");
    if (c == '0') {
        c = _verifyNoLeadingZeroes();
    }
    boolean eof = false;

    int_loop:
    while (c >= '0' && c <= '9') {
        ++intLen;
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        outBuf[outPtr++] = c;
        if (_inputPtr >= _inputEnd && !loadMore()) {
            c = CHAR_NULL;
            eof = true;
            break int_loop;
        }
        c = _inputBuffer[_inputPtr++];
    }
    if (intLen == 0) {
        reportInvalidNumber(""Missing integer part (next char "" + _getCharDesc(c) + "")"");
    }

    int fractLen = 0;
    if (c == '.') {
        outBuf[outPtr++] = c;

        fract_loop:
        while (true) {
            if (_inputPtr >= _inputEnd && !loadMore()) {
                eof = true;
                break fract_loop;
            }
            c = _inputBuffer[_inputPtr++];
            if (c < '0' || c > '9') {
                break fract_loop;
            }
            ++fractLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
        }
        if (fractLen == 0) {
            reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
        }
    }

    int expLen = 0;
    if (c == 'e' || c == 'E') {
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        outBuf[outPtr++] = c;
        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(""expected a digit for number exponent"");
        if (c == '-' || c == '+') {
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(""expected a digit for number exponent"");
        }

        exp_loop:
        while (c <= '9' && c >= '0') {
            ++expLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            if (_inputPtr >= _inputEnd && !loadMore()) {
                eof = true;
                break exp_loop;
            }
            c = _inputBuffer[_inputPtr++];
        }
        if (expLen == 0) {
            reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
        }
    }

    if (!eof) {
        --_inputPtr;
    }
    _textBuffer.setCurrentLength(outPtr);
    return reset(negative, intLen, fractLen, expLen);
}",0,0
164,JacksonCore_2,"protected JsonToken _parseNumber(int c)
        throws IOException, JsonParseException
    {
        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
        int outPtr = 0;
        boolean negative = (c == INT_MINUS);

        // Need to prepend sign?
        if (negative) {
            outBuf[outPtr++] = '-';
            // Must have something after sign too
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            // Note: must be followed by a digit
            if (c < INT_0 || c > INT_9) {
                return _handleInvalidNumberStart(c, true);
            }
        }

        // One special case: if first char is 0, must not be followed by a digit
        if (c == INT_0) {
            c = _verifyNoLeadingZeroes();
        }
        
        // Ok: we can first just add digit we saw first:
        outBuf[outPtr++] = (char) c;
        int intLen = 1;

        // And then figure out how far we can read without further checks:
        int end = _inputPtr + outBuf.length;
        if (end > _inputEnd) {
            end = _inputEnd;
        }

        // With this, we have a nice and tight loop:
        while (true) {
            if (_inputPtr >= end) {
                // Long enough to be split across boundary, so:
                return _parserNumber2(outBuf, outPtr, negative, intLen);
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            if (c < INT_0 || c > INT_9) {
                break;
            }
            ++intLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
        }
        if (c == '.' || c == 'e' || c == 'E') {
            return _parseFloat(outBuf, outPtr, c, negative, intLen);
        }
        
         --_inputPtr; // to push back trailing char (comma etc)
         _textBuffer.setCurrentLength(outPtr);
         // As per #105, need separating space between root values; check here
 
         // And there we have it!
         return resetInt(negative, intLen);
    }","protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = 0;
    boolean negative = (c == INT_MINUS);

    if (negative) {
        outBuf[outPtr++] = '-';
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        c = _inputBuffer[_inputPtr++] & 0xFF;
        if (c < '0' || c > '9') {
            return _handleInvalidNumberStart(c, true);
        }
    }

    if (c == '0') {
        c = _verifyNoLeadingZeroes();
    }
    outBuf[outPtr++] = (char) c;
    int intLen = 1;

    int end = _inputPtr + outBuf.length;
    if (end > _inputEnd) {
        end = _inputEnd;
    }

    while (true) {
        if (_inputPtr >= end) {
            return _parserNumber2(outBuf, outPtr, negative, intLen);
        }
        c = _inputBuffer[_inputPtr++] & 0xFF;
        if (c < '0' || c > '9') {
            break;
        }
        ++intLen;
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        outBuf[outPtr++] = (char) c;
    }
    if (c == '.' || c == 'e' || c == 'E') {
        return _parseFloat(outBuf, outPtr, c, negative, intLen);
    }

    --_inputPtr;
    _textBuffer.setCurrentLength(outPtr);
    return resetInt(negative, intLen);
}",0,0
164,JacksonCore_2,"private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,
            int intPartLength)
        throws IOException, JsonParseException
    {
        // Ok, parse the rest
        while (true) {
            if (_inputPtr >= _inputEnd && !loadMore()) {
                _textBuffer.setCurrentLength(outPtr);
                return resetInt(negative, intPartLength);
            }
            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            if (c > INT_9 || c < INT_0) {
                if (c == '.' || c == 'e' || c == 'E') {
                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);
                }
                break;
            }
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            ++intPartLength;
        }
         --_inputPtr; // to push back trailing char (comma etc)
         _textBuffer.setCurrentLength(outPtr);
         // As per #105, need separating space between root values; check here
 
         // And there we have it!
         return resetInt(negative, intPartLength);
        
    }","private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException {
    while (true) {
        if (_inputPtr >= _inputEnd && !loadMore()) {
            _textBuffer.setCurrentLength(outPtr);
            return resetInt(negative, intPartLength);
        }
        int c = _inputBuffer[_inputPtr++] & 0xFF;
        if (c > '9' || c < '0') {
            if (c == '.' || c == 'e' || c == 'E') {
                return _parseFloat(outBuf, outPtr, c, negative, intPartLength);
            }
            break;
        }
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        outBuf[outPtr++] = (char) c;
        ++intPartLength;
    }
    --_inputPtr;
    _textBuffer.setCurrentLength(outPtr);
    return resetInt(negative, intPartLength);
}",0,0
164,JacksonCore_2,"private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,
            boolean negative, int integerPartLength)
        throws IOException, JsonParseException
    {
        int fractLen = 0;
        boolean eof = false;

        // And then see if we get other parts
        if (c == '.') { // yes, fraction
            outBuf[outPtr++] = (char) c;

            fract_loop:
            while (true) {
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break fract_loop;
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
                if (c < INT_0 || c > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
            }
        }

        int expLen = 0;
        if (c == 'e' || c == 'E') { // exponent?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            // Not optional, can require that we get one more char
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            // Sign indicator?
            if (c == '-' || c == '+') {
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
                // Likewise, non optional:
                if (_inputPtr >= _inputEnd) {
                    loadMoreGuaranteed();
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            }

            exp_loop:
            while (c <= INT_9 && c >= INT_0) {
                ++expLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break exp_loop;
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
            }
        }

        // Ok; unless we hit end-of-input, need to push last char read back
         if (!eof) {
             --_inputPtr;
             // As per #105, need separating space between root values; check here
         }
         _textBuffer.setCurrentLength(outPtr);
 
        // And there we have it!
        return resetFloat(negative, integerPartLength, fractLen, expLen);
    }","private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {
    int fractLen = 0;
    boolean eof = false;

    if (c == '.') {
        outBuf[outPtr++] = (char) c;

        fract_loop:
        while (true) {
            if (_inputPtr >= _inputEnd && !loadMore()) {
                eof = true;
                break fract_loop;
            }
            c = _inputBuffer[_inputPtr++] & 0xFF;
            if (c < '0' || c > '9') {
                break fract_loop;
            }
            ++fractLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
        }
        if (fractLen == 0) {
            reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
        }
    }

    int expLen = 0;
    if (c == 'e' || c == 'E') {
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        outBuf[outPtr++] = (char) c;
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        c = _inputBuffer[_inputPtr++] & 0xFF;
        if (c == '-' || c == '+') {
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            c = _inputBuffer[_inputPtr++] & 0xFF;
        }

        exp_loop:
        while (c <= '9' && c >= '0') {
            ++expLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            if (_inputPtr >= _inputEnd && !loadMore()) {
                eof = true;
                break exp_loop;
            }
            c = _inputBuffer[_inputPtr++] & 0xFF;
        }
        if (expLen == 0) {
            reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
        }
    }

    if (!eof) {
        --_inputPtr;
    }
    _textBuffer.setCurrentLength(outPtr);
    return resetFloat(negative, integerPartLength, fractLen, expLen);
}",0,0
164,JacksonCore_2,"private int _skipWSOrEnd() throws IOException
    {
        final int[] codes = _icWS;
        while ((_inputPtr < _inputEnd) || loadMore()) {
            final int i = _inputBuffer[_inputPtr++] & 0xFF;
            switch (codes[i]) {
            case 0: // done!
                return i;
            case 1: // skip
                continue;
            case 2: // 2-byte UTF
                _skipUtf8_2(i);
                break;
            case 3: // 3-byte UTF
                _skipUtf8_3(i);
                break;
            case 4: // 4-byte UTF
                _skipUtf8_4(i);
                break;
            case INT_LF:
                ++_currInputRow;
                _currInputRowStart = _inputPtr;
                break;
            case INT_CR:
                _skipCR();
                break;
            case '/':
                _skipComment();
                break;
            case '#':
                if (!_skipYAMLComment()) {
                    return i;
                 }
                 break;
             default: // e.g. -1
                 if (i < 32) {
                     _throwInvalidSpace(i);
                 }
                 _reportInvalidChar(i);
             }
         }
        // We ran out of input...
        _handleEOF();
        return -1;
    }","private int _skipWSOrEnd() throws IOException {
    final int[] codes = _icWS;
    while ((_inputPtr < _inputEnd) || loadMore()) {
        final int i = _inputBuffer[_inputPtr++] & 0xFF;
        switch (codes[i]) {
            case 0:
                return i;
            case 1:
                continue;
            case 2:
                _skipUtf8_2(i);
                break;
            case 3:
                _skipUtf8_3(i);
                break;
            case 4:
                _skipUtf8_4(i);
                break;
            case INT_LF:
                ++_currInputRow;
                _currInputRowStart = _inputPtr;
                break;
            case INT_CR:
                _skipCR();
                break;
            case '/':
                _skipComment();
                break;
            case '#':
                if (!_skipYAMLComment()) {
                    return i;
                }
                break;
            default:
                if (i < 32) {
                    _throwInvalidSpace(i);
                }
                _reportInvalidChar(i);
        }
    }
    _handleEOF();
    return -1;
}",0,0
165,JacksonCore_22,"@Override
    public JsonToken nextToken() throws IOException
    {
        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
        //    conditionals; and it seems odd to return `null` but NOT considering input
        //    as closed... would love a rewrite to simplify/clear up logic here.
        
        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
        // check for no buffered context _exposedContext - null
        // If all the conditions matches then check for scalar / non-scalar property

        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL
            // matched once, return null
            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath
                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
                return (_currToken = null);
            }
        }
        // Anything buffered?
        TokenFilterContext ctxt = _exposedContext;

        if (ctxt != null) {
            while (true) {
                JsonToken t = ctxt.nextTokenToRead();
                if (t != null) {
                    _currToken = t;
                    return t;
                }
                // all done with buffered stuff?
                if (ctxt == _headContext) {
                    _exposedContext = null;
                    if (ctxt.inArray()) {
                        t = delegate.getCurrentToken();
// Is this guaranteed to work without further checks?
//                        if (t != JsonToken.START_ARRAY) {
                        _currToken = t;
                        return t;
                    }

                    // Almost! Most likely still have the current token;
                    // with the sole exception of 
                    /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                    break;
                }
                // If not, traverse down the context chain
                ctxt = _headContext.findChildOf(ctxt);
                _exposedContext = ctxt;
                if (ctxt == null) { // should never occur
                    throw _constructError(""Unexpected problem: chain of filtered context broken"");
                }
            }
        }

        // If not, need to read more. If we got any:
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // no strict need to close, since we have no state here
            _currToken = t;
            return t;
        }

        // otherwise... to include or not?
        TokenFilter f;
        
        switch (t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) { // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;

        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) { // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;

        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;

        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }

        default: // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                 f = _headContext.checkValue(f);
                 if ((f == TokenFilter.INCLUDE_ALL)
                         || ((f != null) && f.includeValue(delegate))) {
                         return (_currToken = t);
                 }
             }
             // Otherwise not included (leaves must be explicitly included)
            break;
        }

        // We get here if token was not yet found; offlined handling
        return _nextToken2();
    }","@Override
public JsonToken nextToken() throws IOException {
    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
        if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath
                && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
            _currToken = null;
            return null;
        }
    }

    TokenFilterContext ctxt = _exposedContext;
    if (ctxt != null) {
        while (true) {
            JsonToken t = ctxt.nextTokenToRead();
            if (t != null) {
                _currToken = t;
                return t;
            }
            if (ctxt == _headContext) {
                _exposedContext = null;
                if (ctxt.inArray() || ctxt.inObject()) {
                    _currToken = delegate.getCurrentToken();
                    return _currToken;
                }
                break;
            }
            ctxt = _headContext.findChildOf(ctxt);
            _exposedContext = ctxt;
            if (ctxt == null) {
                throw _constructError(""Unexpected problem: chain of filtered context broken"");
            }
        }
    }

    JsonToken t = delegate.nextToken();
    if (t == null) {
        _currToken = null;
        return null;
    }

    TokenFilter f;
    switch (t.id()) {
        case ID_START_ARRAY:
        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            boolean includeAll = (f == TokenFilter.INCLUDE_ALL);
            if (t.id() == JsonTokenId.ID_START_ARRAY) {
                _headContext = _headContext.createChildArrayContext(f, includeAll);
            } else {
                _headContext = _headContext.createChildObjectContext(f, includeAll);
            }
            if (includeAll) {
                _itemFilter = f;
                return (_currToken = t);
            }
            _itemFilter = f;
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    return (_currToken = t);
                }
            }
            break;

        case ID_END_ARRAY:
        case ID_END_OBJECT:
            boolean returnEnd = _headContext.isStartHandled();
            f = _headContext.getFilter();
            if (f != null && f != TokenFilter.INCLUDE_ALL) {
                f.filterFinishArray();
            }
            _headContext = _headContext.getParent();
            _itemFilter = _headContext.getFilter();
            if (returnEnd) {
                return (_currToken = t);
            }
            break;

        case ID_FIELD_NAME:
            final String name = delegate.getCurrentName();
            f = _headContext.setFieldName(name);
            if (f == TokenFilter.INCLUDE_ALL) {
                _itemFilter = f;
                if (!_includePath && _includeImmediateParent && !_headContext.isStartHandled()) {
                    t = _headContext.nextTokenToRead();
                    _exposedContext = _headContext;
                }
                return (_currToken = t);
            }
            if (f == null) {
                delegate.nextToken();
                delegate.skipChildren();
                break;
            }
            f = f.includeProperty(name);
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL && _includePath) {
                return (_currToken = t);
            }
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    return (_currToken = t);
                }
            }
            break;

        default:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                f = _headContext.checkValue(f);
                if ((f == TokenFilter.INCLUDE_ALL) || (f != null && f.includeValue(delegate))) {
                    return (_currToken = t);
                }
            }
            break;
    }
    return _nextToken2();
}",0,0
165,JacksonCore_22,"protected final JsonToken _nextToken2() throws IOException
    {
        main_loop:
        while (true) {
            JsonToken t = delegate.nextToken();
            if (t == null) { // is this even legal?
                _currToken = t;
                return t;
            }
            TokenFilter f;

            switch (t.id()) {
            case ID_START_ARRAY:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) { // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                // but if we didn't figure it out yet, need to buffer possible events
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;

            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) { // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;

            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    boolean returnEnd = _headContext.isStartHandled();
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return (_currToken = t);
                    }
                }
                continue main_loop;

            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return (_currToken = t);
                    }
                    if (f == null) { // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) { // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                     }
                     _itemFilter = f;
                     if (f == TokenFilter.INCLUDE_ALL) {
                         if (_includePath) {
                             return (_currToken = t);
                         }
 //                        if (_includeImmediateParent) { ...
                        continue main_loop;
                    }
                    if (_includePath) {
                        t = _nextTokenWithBuffering(_headContext);
                        if (t != null) {
                            _currToken = t;
                            return t;
                        }
                    }
                }
                continue main_loop;

            default: // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return (_currToken = t);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL)
                            || ((f != null) && f.includeValue(delegate))) {
                            return (_currToken = t);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                break;
            }
        }
    }","protected final JsonToken _nextToken2() throws IOException {
    while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            _currToken = null;
            return null;
        }

        TokenFilter f;
        switch (t.id()) {
            case ID_START_ARRAY:
            case ID_START_OBJECT:
                f = _headContext.checkValue(_itemFilter);
                if (f == null) {
                    delegate.skipChildren();
                    continue;
                }
                boolean includeAll = (f == TokenFilter.INCLUDE_ALL);
                if (t.id() == ID_START_ARRAY) {
                    _headContext = _headContext.createChildArrayContext(f, includeAll);
                } else {
                    _headContext = _headContext.createChildObjectContext(f, includeAll);
                }
                _itemFilter = f;
                if (includeAll) {
                    return (_currToken = t);
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        return (_currToken = t);
                    }
                }
                continue;

            case ID_END_ARRAY:
            case ID_END_OBJECT:
                f = _headContext.getFilter();
                if (f != null && f != TokenFilter.INCLUDE_ALL) {
                    f.filterFinishArray();
                }
                boolean returnEnd = _headContext.isStartHandled();
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
                continue;

            case ID_FIELD_NAME:
                final String name = delegate.getCurrentName();
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    continue;
                }
                f = f.includeProperty(name);
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL && _includePath) {
                    return (_currToken = t);
                }
                continue;

            default:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return (_currToken = t);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if (f == TokenFilter.INCLUDE_ALL || (f != null && f.includeValue(delegate))) {
                        return (_currToken = t);
                    }
                }
                break;
        }
    }
}",0,0
165,JacksonCore_22,"protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)
        throws IOException
    {
        main_loop:
        while (true) {
            JsonToken t = delegate.nextToken();
            if (t == null) { // is this even legal?
                return t;
            }
            TokenFilter f;

            // One simplification here: we know for a fact that the item filter is
            // neither null nor 'include all', for most cases; the only exception
            // being FIELD_NAME handling

            switch (t.id()) {
            case ID_START_ARRAY:
                f = _headContext.checkValue(_itemFilter);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                continue main_loop;

            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return t;
                }
                if (f == null) { // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                continue main_loop;

            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    // Unlike with other loops, here we know that content was NOT
                    // included (won't get this far otherwise)
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    boolean gotEnd = (_headContext == buffRoot);
                    boolean returnEnd = gotEnd && _headContext.isStartHandled();

                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();

                    if (returnEnd) {
                        return t;
                    }
                    // Hmmh. Do we need both checks, or should above suffice?
                    if (gotEnd || (_headContext == buffRoot)) {
                        return null;
                    }
                }
                continue main_loop;

            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return _nextBuffered(buffRoot);
                    }
                    if (f == null) { // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) { // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                         continue main_loop;
                     }
                     _itemFilter = f;
                     if (f == TokenFilter.INCLUDE_ALL) {
                         return _nextBuffered(buffRoot);
                     }
                 }
                continue main_loop;

            default: // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return _nextBuffered(buffRoot);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL)
                            || ((f != null) && f.includeValue(delegate))) {
                            return _nextBuffered(buffRoot);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                continue main_loop;
            }
        }
    }","protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot) throws IOException {
    while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            return null;
        }

        TokenFilter f;
        switch (t.id()) {
            case ID_START_ARRAY:
            case ID_START_OBJECT:
                f = _headContext.checkValue(_itemFilter);
                if (f == null) {
                    delegate.skipChildren();
                    continue;
                }
                boolean includeAll = (f == TokenFilter.INCLUDE_ALL);
                if (t.id() == ID_START_ARRAY) {
                    _headContext = _headContext.createChildArrayContext(f, includeAll);
                } else {
                    _headContext = _headContext.createChildObjectContext(f, includeAll);
                }
                _itemFilter = f;
                if (includeAll) {
                    return _nextBuffered(buffRoot);
                }
                continue;

            case ID_END_ARRAY:
            case ID_END_OBJECT:
                f = _headContext.getFilter();
                if (f != null && f != TokenFilter.INCLUDE_ALL) {
                    f.filterFinishArray();
                }
                boolean gotEnd = (_headContext == buffRoot);
                boolean returnEnd = gotEnd && _headContext.isStartHandled();
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return t;
                }
                if (gotEnd || _headContext == buffRoot) {
                    return null;
                }
                continue;

            case ID_FIELD_NAME:
                final String name = delegate.getCurrentName();
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    return _nextBuffered(buffRoot);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    continue;
                }
                f = f.includeProperty(name);
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return _nextBuffered(buffRoot);
                }
                continue;

            default:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return _nextBuffered(buffRoot);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || (f != null && f.includeValue(delegate))) {
                        return _nextBuffered(buffRoot);
                    }
                }
                continue;
        }
    }
}",0,0
166,JacksonCore_24,"protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException
     {
         final String numDesc = _longIntegerDesc(rawNum);
         _reportError(""Numeric value (%s) out of range of %s"", numDesc,
                 (expType == NR_LONG) ? ""long"" : ""int"");
     }","protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException {
    final String numDesc = _longIntegerDesc(rawNum);
    _reportError(String.format(""Numeric value (%s) out of range of %s"", numDesc,
            (expType == NR_LONG) ? ""long"" : ""int""));
}",0,0
166,JacksonCore_24,"protected void convertNumberToInt() throws IOException
    {
        // First, converting from long ought to be easy
        if ((_numTypesValid & NR_LONG) != 0) {
             // Let's verify it's lossless conversion by simple roundtrip
             int result = (int) _numberLong;
             if (((long) result) != _numberLong) {
                 _reportError(""Numeric value (""+getText()+"") out of range of int"");
             }
             _numberInt = result;
         } else if ((_numTypesValid & NR_BIGINT) != 0) {
            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 
                    || BI_MAX_INT.compareTo(_numberBigInt) < 0) {
                reportOverflowInt();
            }
            _numberInt = _numberBigInt.intValue();
        } else if ((_numTypesValid & NR_DOUBLE) != 0) {
            // Need to check boundaries
            if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {
                reportOverflowInt();
            }
            _numberInt = (int) _numberDouble;
        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {
            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 
                || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {
                reportOverflowInt();
            }
            _numberInt = _numberBigDecimal.intValue();
        } else {
            _throwInternal();
        }
        _numTypesValid |= NR_INT;
    }","protected void convertNumberToInt() throws IOException {
    // First, converting from long ought to be easy
    if ((_numTypesValid & NR_LONG) != 0) {
        // Let's verify it's lossless conversion by simple roundtrip
        if (_numberLong < Integer.MIN_VALUE || _numberLong > Integer.MAX_VALUE) {
            _reportError(""Numeric value ("" + getText() + "") out of range of int"");
        }
        _numberInt = (int) _numberLong;
    } else if ((_numTypesValid & NR_BIGINT) != 0) {
        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {
            reportOverflowInt();
        }
        _numberInt = _numberBigInt.intValue();
    } else if ((_numTypesValid & NR_DOUBLE) != 0) {
        // Need to check boundaries
        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {
            reportOverflowInt();
        }
        _numberInt = (int) _numberDouble;
    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {
        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {
            reportOverflowInt();
        }
        _numberInt = _numberBigDecimal.intValue();
    } else {
        _throwInternal();
    }
    _numTypesValid |= NR_INT;
}",0,0
167,JacksonCore_9,"@Override
    public String getValueAsString() throws IOException
    {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                return _finishAndReturnString(); // only strings can be incomplete
             }
             return _textBuffer.contentsAsString();
         }
         return super.getValueAsString(null);
     }","@Override
public String getValueAsString() throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            return _finishAndReturnString(); // only strings can be incomplete
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(null);
}",0,0
167,JacksonCore_9,"@Override
    public String getValueAsString(String defValue) throws IOException
    {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                return _finishAndReturnString(); // only strings can be incomplete
             }
             return _textBuffer.contentsAsString();
         }
         return super.getValueAsString(defValue);
     }","@Override
public String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            return _finishAndReturnString(); // only strings can be incomplete
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(defValue);
}",0,0
167,JacksonCore_9,"@Override
    public final String getValueAsString(String defValue) throws IOException {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString(); // only strings can be incomplete
             }
             return _textBuffer.contentsAsString();
         }
         return super.getValueAsString(defValue);
     }","@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            _finishString(); // only strings can be incomplete
        }
        return _textBuffer.contentsAsString();
    }
    return (defValue != null) ? defValue : super.getValueAsString(defValue);
}",0,0
167,JacksonCore_9,"@Override
    public final String getValueAsString() throws IOException
    {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString(); // only strings can be incomplete
             }
             return _textBuffer.contentsAsString();
         }
         return super.getValueAsString(null);
     }","@Override
public final String getValueAsString() throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            _finishString(); // only strings can be incomplete
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(null);
}",0,0
167,JacksonCore_9,"@Override
    public String getValueAsString() throws IOException {
         if (_currToken == JsonToken.VALUE_STRING) {
             return getText();
         }
         return getValueAsString(null);
     }","@Override
public String getValueAsString() throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        return getText();
    }
    return super.getValueAsString(null);
}",0,0
167,JacksonCore_9,"@Override
    public String getValueAsString(String defaultValue) throws IOException {
         if (_currToken == JsonToken.VALUE_STRING) {
             return getText();
         }
         if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {
             return defaultValue;
         }
        return getText();
    }","@Override
public String getValueAsString(String defaultValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        return getText();
    }
    if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {
        return defaultValue;
    }
    return getText();
}",0,0
168,JacksonDatabind_10,"public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)
        throws Exception
    {
        Object value = _accessor.getValue(bean);
        if (value == null) {
            return;
        }
        if (!(value instanceof Map<?,?>)) {
            throw new JsonMappingException(""Value returned by 'any-getter' (""
                    +_accessor.getName()+""()) not java.util.Map but ""+value.getClass().getName());
        }
        // 23-Feb-2015, tatu: Nasty, but has to do (for now)
        if (_mapSerializer != null) {
             _mapSerializer.serializeFields((Map<?,?>) value, gen, provider);
             return;
         }
     }","public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)
        throws Exception {
    Object value = _accessor.getValue(bean);
    if (value == null) {
        return;
    }
    if (!(value instanceof Map<?, ?>)) {
        throw new JsonMappingException(""Value returned by 'any-getter' ("" +
                _accessor.getName() + ""()) not java.util.Map but "" + value.getClass().getName());
    }
    if (_mapSerializer != null) {
        _mapSerializer.serialize((Map<?, ?>) value, gen, provider);
    } else {
        // Provide custom logic for cases where _mapSerializer is null
        gen.writeObject(value);
    }
}",0,0
168,JacksonDatabind_10,"@SuppressWarnings(""unchecked"")
    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,
            BeanDescription beanDesc)
        throws JsonMappingException
    {
        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object
        // 05-Jul-2012, tatu: ... but we should be able to just return ""unknown type"" serializer, right?
        if (beanDesc.getBeanClass() == Object.class) {
            return prov.getUnknownTypeSerializer(Object.class);
//            throw new IllegalArgumentException(""Can not create bean serializer for Object.class"");
        }
        final SerializationConfig config = prov.getConfig();
        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);
        builder.setConfig(config);

        // First: any detectable (auto-detect, annotations) properties to serialize?
        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);
        if (props == null) {
            props = new ArrayList<BeanPropertyWriter>();
        }
        // [databind#638]: Allow injection of ""virtual"" properties:
        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);

        // [JACKSON-440] Need to allow modification bean properties to serialize:
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                props = mod.changeProperties(config, beanDesc, props);
            }
        }

        // Any properties to suppress?
        props = filterBeanProperties(config, beanDesc, props);

        // [JACKSON-440] Need to allow reordering of properties to serialize
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                props = mod.orderProperties(config, beanDesc, props);
            }
        }

        /* And if Object Id is needed, some preparation for that as well: better
         * do before view handling, mostly for the custom id case which needs
         * access to a property
         */
        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));
        
        builder.setProperties(props);
        builder.setFilterId(findFilterId(config, beanDesc));
        
        AnnotatedMember anyGetter = beanDesc.findAnyGetter();
        if (anyGetter != null) {
            if (config.canOverrideAccessModifiers()) {
                anyGetter.fixAccess();
            }
            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());
            // copied from BasicSerializerFactory.buildMapSerializer():
            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);
            JavaType valueType = type.getContentType();
             TypeSerializer typeSer = createTypeSerializer(config, valueType);
             // last 2 nulls; don't know key, value serializers (yet)
             // 23-Feb-2015, tatu: As per [#705], need to support custom serializers
             MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);
                 // TODO: support '@JsonIgnoreProperties' with any setter?
             // TODO: can we find full PropertyName?
             PropertyName name = new PropertyName(anyGetter.getName());
             BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,
                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);
            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));
        }
        // Next: need to gather view information, if any:
        processViews(config, builder);

        // Finally: let interested parties mess with the result bit more...
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                builder = mod.updateBuilder(config, beanDesc, builder);
            }
        }
        
        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();
        
        if (ser == null) {
            // If we get this far, there were no properties found, so no regular BeanSerializer
            // would be constructed. But, couple of exceptions.
            // First: if there are known annotations, just create 'empty bean' serializer
            if (beanDesc.hasKnownClassAnnotations()) {
                return builder.createDummy();
            }
        }
        return ser;
    }","@SuppressWarnings(""unchecked"")
protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc)
        throws JsonMappingException {
    if (beanDesc.getBeanClass() == Object.class) {
        return prov.getUnknownTypeSerializer(Object.class);
    }
    final SerializationConfig config = prov.getConfig();
    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);
    builder.setConfig(config);

    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);
    if (props == null) {
        props = new ArrayList<>();
    }

    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);

    if (_factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            props = mod.changeProperties(config, beanDesc, props);
        }
    }
    props = filterBeanProperties(config, beanDesc, props);

    if (_factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            props = mod.orderProperties(config, beanDesc, props);
        }
    }

    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));
    builder.setProperties(props);
    builder.setFilterId(findFilterId(config, beanDesc));

    AnnotatedMember anyGetter = beanDesc.findAnyGetter();
    if (anyGetter != null) {
        if (config.canOverrideAccessModifiers()) {
            anyGetter.fixAccess();
        }
        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());
        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);
        JavaType valueType = type.getContentType();
        TypeSerializer typeSer = createTypeSerializer(config, valueType);
        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);
        if (anySer != null) {
            PropertyName name = new PropertyName(anyGetter.getName());
            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,
                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);
            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));
        }
    }

    processViews(config, builder);

    if (_factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            builder = mod.updateBuilder(config, beanDesc, builder);
        }
    }

    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();

    if (ser == null && beanDesc.hasKnownClassAnnotations()) {
        return builder.createDummy();
    }
    return ser;
}",0,0
168,JacksonDatabind_10,"@SuppressWarnings(""unchecked"")
     public void resolve(SerializerProvider provider) throws JsonMappingException
     {
         // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...
         _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);
     }","@SuppressWarnings(""unchecked"")
public void resolve(SerializerProvider provider) throws JsonMappingException {
    if (_mapSerializer != null) {
        _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);
    }
}",0,0
168,JacksonDatabind_10,"public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider,
            PropertyFilter filter)
                    throws Exception
    {
        Object value = _accessor.getValue(bean);
        if (value == null) {
            return;
        }
        if (!(value instanceof Map<?,?>)) {
            throw new JsonMappingException(""Value returned by 'any-getter' (""
                    +_accessor.getName()+""()) not java.util.Map but ""+value.getClass().getName());
        }
        // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?
        if (_mapSerializer != null) {
            _mapSerializer.serializeFilteredFields((Map<?,?>) value, gen, provider, filter, null);
             return;
         }
         // ... not sure how custom handler would do it
     }","public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter)
        throws Exception {
    Object value = _accessor.getValue(bean);
    if (value == null) {
        return;
    }
    if (!(value instanceof Map<?, ?>)) {
        throw new JsonMappingException(""Value returned by 'any-getter' ("" +
                _accessor.getName() + ""()) not java.util.Map but "" + value.getClass().getName());
    }
    if (_mapSerializer != null) {
        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);
    } else {
        // Provide custom logic for cases where _mapSerializer is null
        filter.serializeAsField(bean, gen, provider, null);
    }
}",0,0
169,JacksonDatabind_103,"    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException
    {
        ClassUtil.throwIfIOE(e);
        ClassUtil.throwIfRTE(e);
        // let's wrap the innermost problem
        Throwable th = ClassUtil.getRootCause(e);
        throw JsonMappingException.from(p, th.getMessage(), th);
    }
",Match failed,0,0
169,JacksonDatabind_103,"    protected java.util.Date _parseDate(String value, DeserializationContext ctxt)
        throws IOException
    {
        try {
            // Take empty Strings to mean 'empty' Value, usually 'null':
            if (_isEmptyOrTextualNull(value)) {
                return (java.util.Date) getNullValue(ctxt);
            }
            return ctxt.parseDate(value);
        } catch (IllegalArgumentException iae) {
            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,
                    ""not a valid representation (error: %s)"",
                    iae.getMessage());
        }
    }
",Match failed,0,0
169,JacksonDatabind_103,"    public Object deserializeKey(String key, DeserializationContext ctxt)
        throws IOException
    {
        if (key == null) { // is this even legal call?
            return null;
        }
        try {
            Object result = _parse(key, ctxt);
            if (result != null) {
                return result;
            }
        } catch (Exception re) {
            return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"",
                    re.getClass().getName(),
                    re.getMessage());
        }
        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
            return null;
        }
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
    }
",Match failed,0,0
169,JacksonDatabind_103,"    protected JsonMappingException wrapException(Throwable t)
    {
        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only
        //   does so if and until `JsonMappingException` is found.
        for (Throwable curr = t; curr != null; curr = curr.getCause()) {
            if (curr instanceof JsonMappingException) {
                return (JsonMappingException) curr;
            }
        }
        return new JsonMappingException(null,
                ""Instantiation of ""+getValueTypeDesc()+"" value failed: ""+t.getMessage(), t);
    }
",Match failed,0,0
169,JacksonDatabind_103,"    public static Object defaultValue(Class<?> cls)
    {
        if (cls == Integer.TYPE) {
            return Integer.valueOf(0);
        }
        if (cls == Long.TYPE) {
            return Long.valueOf(0L);
        }
        if (cls == Boolean.TYPE) {
            return Boolean.FALSE;
        }
        if (cls == Double.TYPE) {
            return Double.valueOf(0.0);
        }
        if (cls == Float.TYPE) {
            return Float.valueOf(0.0f);
        }
        if (cls == Byte.TYPE) {
            return Byte.valueOf((byte) 0);
        }
        if (cls == Short.TYPE) {
            return Short.valueOf((short) 0);
        }
        if (cls == Character.TYPE) {
            return '\0';
        }
        throw new IllegalArgumentException(""Class ""+cls.getName()+"" is not a primitive type"");
    }
",Match failed,0,0
169,JacksonDatabind_103,"    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException
    {
        if (filter == null) {
            return true;
        }
        // should let filter decide what to do with nulls:
        // But just case, let's handle unexpected (from our perspective) problems explicitly
        try {
            return filter.equals(null);
        } catch (Throwable t) {
            String msg = String.format(
""Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s"",
filter.getClass().getName(), t.getClass().getName(), t.getMessage());
            reportBadDefinition(filter.getClass(), msg, t);
            return false; // never gets here
        }
    }
",Match failed,0,0
169,JacksonDatabind_103,"    private IOException _wrapAsIOE(JsonGenerator g, Exception e) {
        if (e instanceof IOException) {
            return (IOException) e;
        }
        String msg = e.getMessage();
        if (msg == null) {
            msg = ""[no message for ""+e.getClass().getName()+""]"";
        }
        return new JsonMappingException(g, msg, e);
    }
",Match failed,0,0
169,JacksonDatabind_103,"    protected BeanPropertyWriter buildWriter(SerializerProvider prov,
            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,
            TypeSerializer typeSer, TypeSerializer contentTypeSer,
            AnnotatedMember am, boolean defaultUseStaticTyping)
        throws JsonMappingException
    {
        // do we have annotation that forces type to use (to declared type or its super type)?
        JavaType serializationType;
        try {
            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);
        } catch (JsonMappingException e) {
            if (propDef == null) {
                return prov.reportBadDefinition(declaredType, e.getMessage());
            }
            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());
        }

        // Container types can have separate type serializers for content (value / element) type
        if (contentTypeSer != null) {
            // 04-Feb-2010, tatu: Let's force static typing for collection, if there is
            //    type information for contents. Should work well (for JAXB case); can be
            //    revisited if this causes problems.
            if (serializationType == null) {
//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());
                serializationType = declaredType;
            }
            JavaType ct = serializationType.getContentType();
            // Not exactly sure why, but this used to occur; better check explicitly:
            if (ct == null) {
                prov.reportBadPropertyDefinition(_beanDesc, propDef,
                        ""serialization type ""+serializationType+"" has no content"");
            }
            serializationType = serializationType.withContentTypeHandler(contentTypeSer);
            ct = serializationType.getContentType();
        }

        Object valueToSuppress = null;
        boolean suppressNulls = false;

        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement
        JavaType actualType = (serializationType == null) ? declaredType : serializationType;
        
        // 17-Mar-2017: [databind#1522] Allow config override per property type
        AnnotatedMember accessor = propDef.getAccessor();
        if (accessor == null) {
            // neither Setter nor ConstructorParameter are expected here
            return prov.reportBadPropertyDefinition(_beanDesc, propDef,
                    ""could not determine property type"");
        }
        Class<?> rawPropertyType = accessor.getRawType();

        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well
        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)
        //   for declared property type... and finally property annotation overrides
        JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),
                rawPropertyType, _defaultInclusion);

        // property annotation override
        
        inclV = inclV.withOverrides(propDef.findInclusion());

        JsonInclude.Include inclusion = inclV.getValueInclusion();
        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...
            inclusion = JsonInclude.Include.ALWAYS;
        }
        switch (inclusion) {
        case NON_DEFAULT:
            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,
            //    so that if enclosing class has this, we may need to access values of property,
            //    whereas for global defaults OR per-property overrides, we have more
            //    static definition. Sigh.
            // First: case of class/type specifying it; try to find POJO property defaults
            Object defaultBean;

            // 16-Oct-2016, tatu: Note: if we cannot for some reason create ""default instance"",
            //    revert logic to the case of general/per-property handling, so both
            //    type-default AND null are to be excluded.
            //    (as per [databind#1417]
            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {
                // 07-Sep-2016, tatu: may also need to front-load access forcing now
                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {
                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
                }
                try {
                    valueToSuppress = am.getValue(defaultBean);
                } catch (Exception e) {
                    _throwWrapped(e, propDef.getName(), defaultBean);
                }
            } else {
                valueToSuppress = BeanUtil.getDefaultValue(actualType);
                suppressNulls = true;
            }
            if (valueToSuppress == null) {
                suppressNulls = true;
            } else {
                if (valueToSuppress.getClass().isArray()) {
                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
                }
            }
            break;
        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals
            // always suppress nulls
            suppressNulls = true;
            // and for referential types, also ""empty"", which in their case means ""absent""
            if (actualType.isReferenceType()) {
                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            }
            break;
        case NON_EMPTY:
            // always suppress nulls
            suppressNulls = true;
            // but possibly also 'empty' values:
            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            break;
        case CUSTOM: // new with 2.9
            valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());
            if (valueToSuppress == null) { // is this legal?
                suppressNulls = true;
            } else {
                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);
            }
            break;
        case NON_NULL:
            suppressNulls = true;
            // fall through
        case ALWAYS: // default
        default:
            // we may still want to suppress empty collections
            if (actualType.isContainerType()
                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {
                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            }
            break;
        }
        Class<?>[] views = propDef.findViews();
        if (views == null) {
            views = _beanDesc.findDefaultViews();
        }
        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,
                am, _beanDesc.getClassAnnotations(), declaredType,
                ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);

        // How about custom null serializer?
        Object serDef = _annotationIntrospector.findNullSerializer(am);
        if (serDef != null) {
            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));
        }
        // And then, handling of unwrapping
        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);
        if (unwrapper != null) {
            bpw = bpw.unwrappingWriter(unwrapper);
        }
        return bpw;
    }
",Match failed,0,0
169,JacksonDatabind_103,"    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException
    {
        if (e instanceof IllegalArgumentException) {
            String actType = ClassUtil.classNameOf(value);
            StringBuilder msg = new StringBuilder(""Problem deserializing property '"")
                    .append(getName())
                    .append(""' (expected type: "")
                    .append(getType())
                    .append(""; actual type: "")
                    .append(actType).append("")"");
            String origMsg = e.getMessage();
            if (origMsg != null) {
                msg.append("", problem: "")
                    .append(origMsg);
            } else {
                msg.append("" (no error message provided)"");
            }
            throw JsonMappingException.from(p, msg.toString(), e);
        }
        _throwAsIOE(p, e);
    }
",Match failed,0,0
169,JacksonDatabind_103,"    public Object instantiateBean(boolean fixAccess) {
        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();
        if (ac == null) {
            return null;
        }
        if (fixAccess) {
            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
        }
        try {
            return ac.getAnnotated().newInstance();
        } catch (Exception e) {
            Throwable t = e;
            while (t.getCause() != null) {
                t = t.getCause();
            }
            ClassUtil.throwIfError(t);
            ClassUtil.throwIfRTE(t);
            throw new IllegalArgumentException(""Failed to instantiate bean of type ""
                    +_classInfo.getAnnotated().getName()+"": (""+t.getClass().getName()+"") ""
                    +t.getMessage(), t);
        }
    }
",Match failed,0,0
169,JacksonDatabind_103,"    protected void _throwAsIOE(Exception e, Object propName, Object value)
        throws IOException
    {
        if (e instanceof IllegalArgumentException) {
            String actType = ClassUtil.classNameOf(value);
            StringBuilder msg = new StringBuilder(""Problem deserializing \""any\"" property '"").append(propName);
            msg.append(""' of class ""+getClassName()+"" (expected type: "").append(_type);
            msg.append(""; actual type: "").append(actType).append("")"");
            String origMsg = e.getMessage();
            if (origMsg != null) {
                msg.append("", problem: "").append(origMsg);
            } else {
                msg.append("" (no error message provided)"");
            }
            throw new JsonMappingException(null, msg.toString(), e);
        }
        ClassUtil.throwIfIOE(e);
        ClassUtil.throwIfRTE(e);
        // let's wrap the innermost problem
        Throwable t = ClassUtil.getRootCause(e);
        throw new JsonMappingException(null, t.getMessage(), t);
    }
",Match failed,0,0
169,JacksonDatabind_103,"    protected double _parseDouble(String key) throws IllegalArgumentException {
        return NumberInput.parseDouble(key);
    }
",Match failed,0,0
169,JacksonDatabind_103,"    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(
    		DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)
        throws JsonMappingException
    {
        // Creators, anyone? (to create builder itself)
        ValueInstantiator valueInstantiator;
        try {
            valueInstantiator = findValueInstantiator(ctxt, builderDesc);
        } catch (NoClassDefFoundError error) {
            return new ErrorThrowingDeserializer(error);
        } catch (IllegalArgumentException e) {
            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector
            //   to throw proper exception, it doesn't actually have reference to this
            //   instance so...
            throw InvalidDefinitionException.from(ctxt.getParser(),
                    e.getMessage(),
                    builderDesc, null);
        }
        final DeserializationConfig config = ctxt.getConfig();
        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);
        builder.setValueInstantiator(valueInstantiator);
         // And then ""with methods"" for deserializing from JSON Object
        addBeanProps(ctxt, builderDesc, builder);
        addObjectIdReader(ctxt, builderDesc, builder);
        
        // managed/back reference fields/setters need special handling... first part
        addBackReferenceProperties(ctxt, builderDesc, builder);
        addInjectables(ctxt, builderDesc, builder);

        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();
        final String buildMethodName = (builderConfig == null) ?
                JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;
        
        // and lastly, find build method to use:
        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);
        if (buildMethod != null) { // note: can't yet throw error; may be given build method
            if (config.canOverrideAccessModifiers()) {
            	ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
            }
        }
        builder.setPOJOBuilder(buildMethod, builderConfig);
        // this may give us more information...
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                builder = mod.updateBuilder(config, builderDesc, builder);
            }
        }
        JsonDeserializer<?> deserializer = builder.buildBuilderBased(
        		valueType, buildMethodName);

        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);
            }
        }
        return (JsonDeserializer<Object>) deserializer;
    }
",Match failed,0,0
169,JacksonDatabind_103,"        final DeserializationConfig config = ctxt.getConfig();
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                builder = mod.updateBuilder(config, beanDesc, builder);
            }
        }
",Match failed,0,0
169,JacksonDatabind_103,"    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,
            JavaType baseType)
        throws JsonMappingException
    {
        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());
        AnnotatedClass ac = bean.getClassInfo();
        AnnotationIntrospector ai = config.getAnnotationIntrospector();
        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);

        // Ok: if there is no explicit type info handler, we may want to
        // use a default. If so, config object knows what to use.
        Collection<NamedType> subtypes = null;
        if (b == null) {
            b = config.getDefaultTyper(baseType);
            if (b == null) {
                return null;
            }
        } else {
            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);
        }
        // May need to figure out default implementation, if none found yet
        // (note: check for abstract type is not 100% mandatory, more of an optimization)
        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {
            JavaType defaultType = mapAbstractType(config, baseType);
            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {
                b = b.defaultImpl(defaultType.getRawClass());
            }
        }
        // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,
        //    map to better type here
        try {
            return b.buildTypeDeserializer(config, baseType, subtypes);
        } catch (IllegalArgumentException e0) {
            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,
                    e0.getMessage(), baseType);
            e.initCause(e0);
            throw e;
        }
    }
",Match failed,0,0
169,JacksonDatabind_103,"    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)
        throws JsonMappingException
    {        
        JsonSerializer<Object> ser;
        try {
            ser = _createUntypedSerializer(type);
        } catch (IllegalArgumentException iae) {
            // We better only expose checked exceptions, since those
            // are what caller is expected to handle
            ser = null;
            reportMappingProblem(iae, iae.getMessage());
        }
    
        if (ser != null) {
            // 21-Dec-2015, tatu: Should we also cache using raw key?
            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);
        }
        return ser;
    }
",Match failed,0,0
169,JacksonDatabind_103,"    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,
            DeserializerFactory factory, JavaType type)
        throws JsonMappingException
    {
        JsonDeserializer<Object> deser;
        try {
            deser = _createDeserializer(ctxt, factory, type);
        } catch (IllegalArgumentException iae) {
            // We better only expose checked exceptions, since those
            // are what caller is expected to handle
            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);
        }
        if (deser == null) {
            return null;
        }
        /* cache resulting deserializer? always true for ""plain"" BeanDeserializer
",Match failed,0,0
169,JacksonDatabind_103,"    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)
        throws JsonMappingException
    {
        JavaType fullType = _config.constructType(rawType);
        JsonSerializer<Object> ser;
        try {
            ser = _createUntypedSerializer(fullType);
        } catch (IllegalArgumentException iae) {
            // We better only expose checked exceptions, since those
            // are what caller is expected to handle
            ser = null; // doesn't matter but compiler whines otherwise
            reportMappingProblem(iae, iae.getMessage());
        }

        if (ser != null) {
            // 21-Dec-2015, tatu: Best to cache for both raw and full-type key
            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);
        }
        return ser;
    }
",Match failed,0,0
169,JacksonDatabind_103,"    public static JsonMappingException wrapWithPath(Throwable src, Reference ref)
    {
        JsonMappingException jme;
        if (src instanceof JsonMappingException) {
            jme = (JsonMappingException) src;
        } else {
            // [databind#2128]: try to avoid duplication
            String msg = src.getMessage();
            // Let's use a more meaningful placeholder if all we have is null
            if (msg == null || msg.length() == 0) {
                msg = ""(was ""+src.getClass().getName()+"")"";
            }
            // 17-Aug-2015, tatu: Let's also pass the processor (parser/generator) along
            Closeable proc = null;
            if (src instanceof JsonProcessingException) {
                Object proc0 = ((JsonProcessingException) src).getProcessor();
                if (proc0 instanceof Closeable) {
                    proc = (Closeable) proc0;
                }
            }
            jme = new JsonMappingException(proc, msg, src);
        }
        jme.prependPath(ref);
        return jme;
    }
",Match failed,0,0
169,JacksonDatabind_103,"    public static JsonMappingException fromUnexpectedIOE(IOException src) {
        return new JsonMappingException(null,
                String.format(""Unexpected IOException (of type %s): %s"",
                        src.getClass().getName(),
                        src.getMessage()));
    }
",Match failed,0,0
169,JacksonDatabind_103,"        final JavaType type = constructType(instClass);
        String excMsg;
        if (cause == null) {
            excMsg = ""N/A"";
        } else if ((excMsg = cause.getMessage()) == null) {
            excMsg = ClassUtil.nameOf(cause.getClass());
        }
",Match failed,0,0
169,JacksonDatabind_103,"    public Date parseDate(String dateStr) throws IllegalArgumentException
    {
        try {
            DateFormat df = getDateFormat();
            return df.parse(dateStr);
        } catch (ParseException e) {
            throw new IllegalArgumentException(String.format(
                    ""Failed to parse Date value '%s': %s"", dateStr,
                    e.getMessage()));
        }
    }
",Match failed,0,0
169,JacksonDatabind_103,"    public JavaType resolveSubType(JavaType baseType, String subClass)
        throws JsonMappingException
    {
        // 30-Jan-2010, tatu: Most ids are basic class names; so let's first
        //    check if any generics info is added; and only then ask factory
        //    to do translation when necessary
        if (subClass.indexOf('<') > 0) {
            // note: may want to try combining with specialization (esp for EnumMap)?
            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment
            //    compatibility -- needed later anyway, and not doing so may open
            //    security issues.
            JavaType t = getTypeFactory().constructFromCanonical(subClass);
            if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {
                return t;
            }
        } else {
            Class<?> cls;
            try {
                cls =  getTypeFactory().findClass(subClass);
            } catch (ClassNotFoundException e) { // let caller handle this problem
                return null;
            } catch (Exception e) {
                throw invalidTypeIdException(baseType, subClass, String.format(
                        ""problem: (%s) %s"",
                        e.getClass().getName(),
                        e.getMessage()));
            }
            if (baseType.isTypeOrSuperTypeOf(cls)) {
                return getTypeFactory().constructSpecializedType(baseType, cls);
            }
        }
        throw invalidTypeIdException(baseType, subClass, ""Not a subtype"");
    }
",Match failed,0,0
170,JacksonDatabind_104,"        final int year = cal.get(Calendar.YEAR);

        // Assuming GregorianCalendar, special handling needed for BCE (aka BC)
                // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but
                //   it seems that plus prefix IS mandated. Padding is an open question, but since agreeement
                //   for max length would be needed, we ewould need to limit to arbitrary length
                //   like five digits (erroring out if beyond or padding to that as minimum).
                //   Instead, let's just print number out as is and let decoder try to make sense of it.
            pad4(buffer, year);
        buffer.append('-');
        pad2(buffer, cal.get(Calendar.MONTH) + 1);
        buffer.append('-');
        pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));
        buffer.append('T');
        pad2(buffer, cal.get(Calendar.HOUR_OF_DAY));
        buffer.append(':');
        pad2(buffer, cal.get(Calendar.MINUTE));
        buffer.append(':');
        pad2(buffer, cal.get(Calendar.SECOND));
        buffer.append('.');
        pad3(buffer, cal.get(Calendar.MILLISECOND));

        int offset = tz.getOffset(cal.getTimeInMillis());
        if (offset != 0) {
            int hours = Math.abs((offset / (60 * 1000)) / 60);
            int minutes = Math.abs((offset / (60 * 1000)) % 60);
            buffer.append(offset < 0 ? '-' : '+');
            pad2(buffer, hours);
            if( _tzSerializedWithColon ) {
            		buffer.append(':');
            }
            pad2(buffer, minutes);
        } else {
            // 24-Jun-2017, tatu: While `Z` would be conveniently short, older specs
            //   mandate use of full `+0000`
//            formatted.append('Z');
	        	if( _tzSerializedWithColon ) {
	            buffer.append(""+00:00"");
	        	}
	        	else {
	        		buffer.append(""+0000"");
	        	}
        }
","final int year = cal.get(Calendar.YEAR);

if (year <= 0) {
    // Handle BCE years using ISO-8601 extended format (negative year)
    buffer.append('-');
    pad4(buffer, -year + 1); // Adjust BCE years to positive numbers and add one to match ISO-8601
} else {
    // Handle standard years
    pad4(buffer, year);
}

buffer.append('-');
pad2(buffer, cal.get(Calendar.MONTH) + 1);
buffer.append('-');
pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));
buffer.append('T');
pad2(buffer, cal.get(Calendar.HOUR_OF_DAY));
buffer.append(':');
pad2(buffer, cal.get(Calendar.MINUTE));
buffer.append(':');
pad2(buffer, cal.get(Calendar.SECOND));
buffer.append('.');
pad3(buffer, cal.get(Calendar.MILLISECOND));

int offset = tz.getOffset(cal.getTimeInMillis());
if (offset != 0) {
    int hours = Math.abs((offset / (60 * 1000)) / 60);
    int minutes = Math.abs((offset / (60 * 1000)) % 60);
    buffer.append(offset < 0 ? '-' : '+');
    pad2(buffer, hours);
    if (_tzSerializedWithColon) {
        buffer.append(':');
    }
    pad2(buffer, minutes);
} else {
    // Use full `+0000` or `+00:00` depending on the format chosen
    if (_tzSerializedWithColon) {
        buffer.append(""+00:00"");
    } else {
        buffer.append(""+0000"");
    }
}",0,0
170,JacksonDatabind_104,"    private static void pad4(StringBuffer buffer, int value) {
        int h = value / 100;
        if (h == 0) {
            buffer.append('0').append('0');
        } else {
                pad2(buffer, h);
            value -= (100 * h);
        }
        pad2(buffer, value);
    }
","private static void pad4(StringBuffer buffer, int value) {
    if (value < 0) {
        // Handle negative values (e.g., BCE years)
        buffer.append('-');
        value = -value; // Convert value to positive for padding
    }

    int h = value / 100;
    if (h == 0) {
        buffer.append('0').append('0');
    } else {
        pad2(buffer, h);
        value -= (100 * h);
    }
    pad2(buffer, value);
}",0,0
171,JacksonDatabind_105,"    public static JsonDeserializer<?> find(Class<?> rawType, String clsName)
    {
        if (_classNames.contains(clsName)) {
            JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);
            if (d != null) {
                return d;
            }
            if (rawType == UUID.class) {
                return new UUIDDeserializer();
            }
            if (rawType == StackTraceElement.class) {
                return new StackTraceElementDeserializer();
            }
            if (rawType == AtomicBoolean.class) {
                // (note: AtomicInteger/Long work due to single-arg constructor. For now?
                return new AtomicBooleanDeserializer();
            }
            if (rawType == ByteBuffer.class) {
                return new ByteBufferDeserializer();
            }
        }
        return null;
    }
","public static JsonDeserializer<?> find(Class<?> rawType, String clsName)
{
    if (_classNames.contains(clsName)) {
        JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);
        if (d != null) {
            return d;
        }
        if (rawType == UUID.class) {
            return new UUIDDeserializer();
        }
        if (rawType == StackTraceElement.class) {
            return new StackTraceElementDeserializer();
        }
        if (rawType == AtomicBoolean.class) {
            return new AtomicBooleanDeserializer();
        }
        if (rawType == ByteBuffer.class) {
            return new ByteBufferDeserializer();
        }
        if (rawType == Void.class || rawType == void.class) { // Handle Void explicitly
            return new VoidDeserializer();
        }
    }
    return null;
}",0,0
171,JacksonDatabind_105,"    private final static HashSet<String> _classNames = new HashSet<String>();
    static {
        // note: can skip primitive types; other ways to check them:
        Class<?>[] types = new Class<?>[] {
                UUID.class,
                AtomicBoolean.class,
                StackTraceElement.class,
                ByteBuffer.class
        };
        for (Class<?> cls : types) { _classNames.add(cls.getName()); }
        for (Class<?> cls : FromStringDeserializer.types()) { _classNames.add(cls.getName()); }
    }
","private final static HashSet<String> _classNames = new HashSet<String>();
static {
    // note: can skip primitive types; other ways to check them:
    Class<?>[] types = new Class<?>[] {
            UUID.class,
            AtomicBoolean.class,
            StackTraceElement.class,
            ByteBuffer.class,
            Void.class,              // Add Void to the set
            void.class               // Add primitive void to the set
    };
    for (Class<?> cls : types) {
        _classNames.add(cls.getName());
    }
    for (Class<?> cls : FromStringDeserializer.types()) {
        _classNames.add(cls.getName());
    }
}",0,0
172,JacksonDatabind_106,"    public float getFloatValue() throws IOException {
        return (float) currentNumericNode().doubleValue();
    }
","public float getFloatValue() throws IOException {
    double doubleValue = currentNumericNode().doubleValue();
    if (doubleValue < -Float.MAX_VALUE || doubleValue > Float.MAX_VALUE) {
        throw new IOException(""Float value overflow: "" + doubleValue);
    }
    return (float) doubleValue;
}",0,0
173,JacksonDatabind_108,"    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {
        return (T) _bindAsTree(p);
    }
","public <T extends TreeNode> T readTree(JsonParser p) throws IOException {
    JsonNode tree = _bindAsTree(p);
    if (tree == null) {
        return null;
    }
    return (T) tree;
}",0,0
173,JacksonDatabind_108,"    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException
    {
        DeserializationContext ctxt = createDeserializationContext(p);
        _initForMultiRead(ctxt, p);
        p.nextToken();
        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);
    }
","protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException {
    DeserializationContext ctxt = createDeserializationContext(p);
    _initForMultiRead(ctxt, p);
    if (p.nextToken() == null) {
        return MappingIterator.emptyIterator();
    }
    return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);
}",0,0
174,JacksonDatabind_109,"package com.fasterxml.jackson.databind.ser.std;

import java.io.IOException;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;

import com.fasterxml.jackson.annotation.JsonFormat;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
import com.fasterxml.jackson.databind.ser.ContextualSerializer;

/**
 * As a fallback, we may need to use this serializer for other
 * types of {@link Number}s: both custom types and ""big"" numbers
 * like {@link BigInteger} and {@link BigDecimal}.
 */
@JacksonStdImpl
@SuppressWarnings(""serial"")
public class NumberSerializer
    extends StdScalarSerializer<Number>
    implements ContextualSerializer
{
    /**
     * Static instance that is only to be used for {@link java.lang.Number}.
     */
    public final static NumberSerializer instance = new NumberSerializer(Number.class);

    /**
     * Copied from `jackson-core` class `GeneratorBase`
     */
    
    protected final boolean _isInt;

    /**
     * @since 2.5
     */
    public NumberSerializer(Class<? extends Number> rawType) {
        super(rawType, false);
        // since this will NOT be constructed for Integer or Long, only case is:
        _isInt = (rawType == BigInteger.class);
    }

    @Override
    public JsonSerializer<?> createContextual(SerializerProvider prov,
            BeanProperty property) throws JsonMappingException
    {
        JsonFormat.Value format = findFormatOverrides(prov, property, handledType());
        if (format != null) {
            switch (format.getShape()) {
            case STRING:
                // [databind#2264]: Need special handling for `BigDecimal`
                return ToStringSerializer.instance;
            default:
            }
        }
        return this;
    }

    @Override
    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException
    {
        // should mostly come in as one of these two:
        if (value instanceof BigDecimal) {
            g.writeNumber((BigDecimal) value);
        } else if (value instanceof BigInteger) {
            g.writeNumber((BigInteger) value);
            
        // These should not occur, as more specific methods should have been called; but
        // just in case let's cover all bases:
        } else if (value instanceof Long) {
            g.writeNumber(value.longValue());
        } else if (value instanceof Double) {
            g.writeNumber(value.doubleValue());
        } else if (value instanceof Float) {
            g.writeNumber(value.floatValue());
        } else if (value instanceof Integer || value instanceof Byte || value instanceof Short) {
            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers
        } else {
            // We'll have to use fallback ""untyped"" number write method
            g.writeNumber(value.toString());
        }
    }

    @Override
    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {
        return createSchemaNode(_isInt ? ""integer"" : ""number"", true);
    }

    @Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
    {
        if (_isInt) {
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);
        } else {
            if (((Class<?>) handledType()) == BigDecimal.class) {
                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);
            } else {
                // otherwise bit unclear what to call... but let's try:
                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);
            }
        }
    }

    /**
     * @since 2.10
     */
    


                // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this
                    // ... but wouldn't it be nice to trigger error via generator? Alas,
                    // no method to do that. So we'll do...

            // should never be called

        // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this
}
","public JsonSerializer<?> createContextual(SerializerProvider prov,
        BeanProperty property) throws JsonMappingException
{
    JsonFormat.Value format = findFormatOverrides(prov, property, handledType());
    if (format != null) {
        switch (format.getShape()) {
            case STRING:
                // [databind#2264]: Need special handling for `BigDecimal`
                return ToStringSerializer.instance;
            default:
                // No other format changes are allowed here; return default serializer
                break;
        }
    }
    return this;
}",0,0
174,JacksonDatabind_109,"        public JsonSerializer<?> createContextual(SerializerProvider prov,
                BeanProperty property) throws JsonMappingException
        {
            JsonFormat.Value format = findFormatOverrides(prov, property, handledType());
            if (format != null) {
                switch (format.getShape()) {
                case STRING:
                    return ToStringSerializer.instance;
                default:
                }
            }
            return this;
        }
","@Override
public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException
{
    if (value == null) {
        provider.defaultSerializeNull(g); // Serialize null value properly
        return;
    }
    if (value instanceof BigDecimal) {
        g.writeNumber((BigDecimal) value);
    } else if (value instanceof BigInteger) {
        g.writeNumber((BigInteger) value);
    } else if (value instanceof Long) {
        g.writeNumber(value.longValue());
    } else if (value instanceof Double) {
        g.writeNumber(value.doubleValue());
    } else if (value instanceof Float) {
        g.writeNumber(value.floatValue());
    } else if (value instanceof Integer || value instanceof Byte || value instanceof Short) {
        g.writeNumber(value.intValue());
    } else {
        g.writeNumber(value.toString()); // Fallback for untyped Number
    }
}",0,0
175,JacksonDatabind_110,"    // 10-Jan-2018, tatu: There are a few ""well-known"" special containers in JDK too:

    private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList(null, null).getClass();

    private final static Class<?> CLASS_SINGLETON_SET;
    private final static Class<?> CLASS_SINGLETON_LIST;
    private final static Class<?> CLASS_SINGLETON_MAP;

    private final static Class<?> CLASS_UNMODIFIABLE_SET;
    private final static Class<?> CLASS_UNMODIFIABLE_LIST;","private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList((Object) null, (Object) null).getClass();

private final static Class<?> CLASS_SINGLETON_SET;
private final static Class<?> CLASS_SINGLETON_LIST;
private final static Class<?> CLASS_SINGLETON_MAP;

private final static Class<?> CLASS_UNMODIFIABLE_SET;
private final static Class<?> CLASS_UNMODIFIABLE_LIST;
private final static Class<?> CLASS_UNMODIFIABLE_MAP;",0,0
175,JacksonDatabind_110,"    static {
        Set<?> set = Collections.singleton(Boolean.TRUE);
        CLASS_SINGLETON_SET = set.getClass();
        CLASS_UNMODIFIABLE_SET = Collections.unmodifiableSet(set).getClass();

        List<?> list = Collections.singletonList(Boolean.TRUE);
        CLASS_SINGLETON_LIST = list.getClass();
        CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass();
        // for [databind#2265]
        
        Map<?,?> map = Collections.singletonMap(""a"", ""b"");
        CLASS_SINGLETON_MAP = map.getClass();
        CLASS_UNMODIFIABLE_MAP = Collections.unmodifiableMap(map).getClass();
    }","static {
    Set<?> set = Collections.singleton(Boolean.TRUE);
    CLASS_SINGLETON_SET = set.getClass();
    CLASS_UNMODIFIABLE_SET = Collections.unmodifiableSet(set).getClass();

    List<?> list = Collections.singletonList(Boolean.TRUE);
    CLASS_SINGLETON_LIST = list.getClass();
    CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass();

    Map<?, ?> map = Collections.singletonMap(""a"", ""b"");
    CLASS_SINGLETON_MAP = map.getClass();
    CLASS_UNMODIFIABLE_MAP = Collections.unmodifiableMap(map).getClass();
}",0,0
175,JacksonDatabind_110,"    public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,
            JavaType type)
        throws JsonMappingException
    {
        JavaUtilCollectionsConverter conv;

        // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need bit of help...
        if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {
            conv = converter(TYPE_AS_LIST, type, List.class);
        } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {
            conv = converter(TYPE_SINGLETON_LIST, type, List.class);
        } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {
            conv = converter(TYPE_SINGLETON_SET, type, Set.class);
        // [databind#2265]: we may have another impl type for unmodifiable Lists, check both
        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {
            conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);
        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {
            conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);
        } else {
            return null;
        }
        return new StdDelegatingDeserializer<Object>(conv);
    }
","public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,
            JavaType type)
        throws JsonMappingException
{
    JavaUtilCollectionsConverter conv;

    // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need a bit of help...
    if (type != null && type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {
        conv = converter(TYPE_AS_LIST, type, List.class);
    } else if (type != null && type.hasRawClass(CLASS_SINGLETON_LIST)) {
        conv = converter(TYPE_SINGLETON_LIST, type, List.class);
    } else if (type != null && type.hasRawClass(CLASS_SINGLETON_SET)) {
        conv = converter(TYPE_SINGLETON_SET, type, Set.class);
    // [databind#2265]: we may have another impl type for unmodifiable Lists, check both
    } else if (type != null && type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {
        conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);
    } else if (type != null && type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {
        conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);
    } else {
        return null;
    }
    return new StdDelegatingDeserializer<Object>(conv);
}",0,0
176,JacksonDatabind_111,"package com.fasterxml.jackson.databind.deser.impl;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.deser.NullValueProvider;
import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;
import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
import com.fasterxml.jackson.databind.util.Annotations;

/**
 * This concrete sub-class implements Collection or Map property that is
 * indirectly by getting the property value and directly modifying it.
 */
public final class SetterlessProperty
    extends SettableBeanProperty
{
    private static final long serialVersionUID = 1L;

    protected final AnnotatedMethod _annotated;

    /**
     * Get method for accessing property value used to access property
     * (of Collection or Map type) to modify.
     */
    protected final Method _getter;

    public SetterlessProperty(BeanPropertyDefinition propDef, JavaType type,
            TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedMethod method)
    {
        super(propDef, type, typeDeser, contextAnnotations);
        _annotated = method;
        _getter = method.getAnnotated();
    }

    protected SetterlessProperty(SetterlessProperty src, JsonDeserializer<?> deser,
            NullValueProvider nva) {
        super(src, deser, nva);
        _annotated = src._annotated;
        _getter = src._getter;
    }

    protected SetterlessProperty(SetterlessProperty src, PropertyName newName) {
        super(src, newName);
        _annotated = src._annotated;
        _getter = src._getter;
    }

    @Override
    public SettableBeanProperty withName(PropertyName newName) {
        return new SetterlessProperty(this, newName);
    }

    @Override
    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new SetterlessProperty(this, deser, _nullProvider);
    }

    @Override
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new SetterlessProperty(this, _valueDeserializer, nva);
    }

    @Override
    public void fixAccess(DeserializationConfig config) {
        _annotated.fixAccess(
                config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
    }

    /*
    /**********************************************************
    /* BeanProperty impl
    /**********************************************************
     */
    
    @Override
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return _annotated.getAnnotation(acls);
    }

    @Override public AnnotatedMember getMember() {  return _annotated; }

    /*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
    
    @Override
    public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt,
            Object instance) throws IOException
    {
        JsonToken t = p.getCurrentToken();
        if (t == JsonToken.VALUE_NULL) {
            // Hmmh. Is this a problem? We won't be setting anything, so it's
            // equivalent of empty Collection/Map in this case
            return;
        }
        // For [databind#501] fix we need to implement this but:
        if (_valueTypeDeserializer != null) {
            ctxt.reportBadDefinition(getType(), String.format(
                    ""Problem deserializing 'setterless' property (\""%s\""): no way to handle typed deser with setterless yet"",
                    getName()));
//            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
        }
        // Ok: then, need to fetch Collection/Map to modify:
        Object toModify;
        try {
            toModify = _getter.invoke(instance, (Object[]) null);
        } catch (Exception e) {
            _throwAsIOE(p, e);
            return; // never gets here
        }
        // Note: null won't work, since we can't then inject anything in. At least
        // that's not good in common case. However, theoretically the case where
        // we get JSON null might be compatible. If so, implementation could be changed.
        if (toModify == null) {
            ctxt.reportBadDefinition(getType(), String.format(
                    ""Problem deserializing 'setterless' property '%s': get method returned null"",
                    getName()));
        }
        _valueDeserializer.deserialize(p, ctxt, toModify);
    }

    @Override
    public Object deserializeSetAndReturn(JsonParser p,
      DeserializationContext ctxt, Object instance) throws IOException
    {
        deserializeAndSet(p, ctxt, instance);
        return instance;
    }

    @Override
    public final void set(Object instance, Object value) throws IOException {
        throw new UnsupportedOperationException(""Should never call `set()` on setterless property ('""+getName()+""')"");
    }

    @Override
    public Object setAndReturn(Object instance, Object value) throws IOException
    {
        set(instance, value);
        return instance;
    }
}
","@Override
public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt,
        Object instance) throws IOException {
    JsonToken t = p.getCurrentToken();
    if (t == JsonToken.VALUE_NULL) {
        return;
    }
    if (_valueTypeDeserializer != null) {
        ctxt.reportBadDefinition(getType(), String.format(
                ""Problem deserializing 'setterless' property (\""%s\""): no way to handle typed deserialization with setterless"",
                getName()));
        return;
    }
    Object toModify;
    try {
        toModify = _getter.invoke(instance);
    } catch (Exception e) {
        _throwAsIOE(p, e);
        return;
    }
    if (toModify == null) {
        ctxt.reportBadDefinition(getType(), String.format(
                ""Problem deserializing 'setterless' property '%s': getter method returned null"",
                getName()));
        return;
    }
    _valueDeserializer.deserialize(p, ctxt, toModify);
}",0,0
176,JacksonDatabind_111,"    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new ObjectIdReferenceProperty(this, deser, _nullProvider);
    }
","public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
    if (_valueDeserializer == deser) {
        return this;
    }
    return new SetterlessProperty(this, deser, _nullProvider);
}",0,0
176,JacksonDatabind_111,"    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new MethodProperty(this, deser, _nullProvider);
    }
","public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
    if (_valueDeserializer == deser) {
        return this;
    }
    return new MethodProperty(this, deser, _nullProvider);
}",0,0
176,JacksonDatabind_111,"package com.fasterxml.jackson.databind.deser.impl;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.deser.NullValueProvider;
import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
import com.fasterxml.jackson.databind.introspect.AnnotatedField;
import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;
import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
import com.fasterxml.jackson.databind.util.Annotations;
import com.fasterxml.jackson.databind.util.ClassUtil;

/**
 * This concrete sub-class implements property that is set
 * directly assigning to a Field.
 */
public final class FieldProperty
    extends SettableBeanProperty
{
    private static final long serialVersionUID = 1L;

    final protected AnnotatedField _annotated;

    /**
     * Actual field to set when deserializing this property.
     * Transient since there is no need to persist; only needed during
     * construction of objects.
     */
    final protected transient Field _field;

    /**
     * @since 2.9
     */
    final protected boolean _skipNulls;

    public FieldProperty(BeanPropertyDefinition propDef, JavaType type,
            TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedField field)
    {
        super(propDef, type, typeDeser, contextAnnotations);
        _annotated = field;
        _field = field.getAnnotated();
        _skipNulls = NullsConstantProvider.isSkipper(_nullProvider);
    }

    protected FieldProperty(FieldProperty src, JsonDeserializer<?> deser,
            NullValueProvider nva) {
        super(src, deser, nva);
        _annotated = src._annotated;
        _field = src._field;
        _skipNulls = NullsConstantProvider.isSkipper(nva);
    }

    protected FieldProperty(FieldProperty src, PropertyName newName) {
        super(src, newName);
        _annotated = src._annotated;
        _field = src._field;
        _skipNulls = src._skipNulls;
    }

    /**
     * Constructor used for JDK Serialization when reading persisted object
     */
    protected FieldProperty(FieldProperty src)
    {
        super(src);
        _annotated = src._annotated;
        Field f = _annotated.getAnnotated();
        if (f == null) {
            throw new IllegalArgumentException(""Missing field (broken JDK (de)serialization?)"");
        }
        _field = f;
        _skipNulls = src._skipNulls;
    }

    @Override
    public SettableBeanProperty withName(PropertyName newName) {
        return new FieldProperty(this, newName);
    }

    @Override
    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new FieldProperty(this, deser, _nullProvider);
    }

    @Override
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new FieldProperty(this, _valueDeserializer, nva);
    }

    @Override
    public void fixAccess(DeserializationConfig config) {
        ClassUtil.checkAndFixAccess(_field,
                config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
    }

    /*
    /**********************************************************
    /* BeanProperty impl
    /**********************************************************
     */
    
    @Override
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return (_annotated == null) ? null : _annotated.getAnnotation(acls);
    }

    @Override public AnnotatedMember getMember() {  return _annotated; }

    /*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */

    @Override
    public void deserializeAndSet(JsonParser p,
      DeserializationContext ctxt, Object instance) throws IOException
    {
        Object value;
        if (p.hasToken(JsonToken.VALUE_NULL)) {
            if (_skipNulls) {
                return;
            }
            value = _nullProvider.getNullValue(ctxt);
        } else if (_valueTypeDeserializer == null) {
            value = _valueDeserializer.deserialize(p, ctxt);
            // 04-May-2018, tatu: [databind#2023] Coercion from String (mostly) can give null
            if (value == null) {
                if (_skipNulls) {
                    return;
                }
                value = _nullProvider.getNullValue(ctxt);
            }
        } else {
            value = _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
        }
        try {
            _field.set(instance, value);
        } catch (Exception e) {
            _throwAsIOE(p, e, value);
        }
    }

    @Override
    public Object deserializeSetAndReturn(JsonParser p,
      DeserializationContext ctxt, Object instance) throws IOException
    {
        Object value;
        if (p.hasToken(JsonToken.VALUE_NULL)) {
            if (_skipNulls) {
                return instance;
            }
            value = _nullProvider.getNullValue(ctxt);
        } else if (_valueTypeDeserializer == null) {
            value = _valueDeserializer.deserialize(p, ctxt);
            // 04-May-2018, tatu: [databind#2023] Coercion from String (mostly) can give null
            if (value == null) {
                if (_skipNulls) {
                    return instance;
                }
                value = _nullProvider.getNullValue(ctxt);
            }
        } else {
            value = _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
        }
        try {
            _field.set(instance, value);
        } catch (Exception e) {
            _throwAsIOE(p, e, value);
        }
        return instance;
    }

    @Override
    public void set(Object instance, Object value) throws IOException
    {
        try {
            _field.set(instance, value);
        } catch (Exception e) {
            // 15-Sep-2015, tatu: How could we get a ref to JsonParser?
            _throwAsIOE(e, value);
        }
    }

    @Override
    public Object setAndReturn(Object instance, Object value) throws IOException
    {
        try {
            _field.set(instance, value);
        } catch (Exception e) {
            // 15-Sep-2015, tatu: How could we get a ref to JsonParser?
            _throwAsIOE(e, value);
        }
        return instance;
    }

    /*
    /**********************************************************
    /* JDK serialization handling
    /**********************************************************
     */

    Object readResolve() {
        return new FieldProperty(this);
    }
}
","@Override
public void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {
    Object value;
    if (p.hasToken(JsonToken.VALUE_NULL)) {
        if (_skipNulls) {
            return;
        }
        value = _nullProvider.getNullValue(ctxt);
    } else if (_valueTypeDeserializer == null) {
        value = _valueDeserializer.deserialize(p, ctxt);
        if (value == null) {
            if (_skipNulls) {
                return;
            }
            value = _nullProvider.getNullValue(ctxt);
        }
    } else {
        value = _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
    }
    try {
        _field.set(instance, value);
    } catch (Exception e) {
        _throwAsIOE(p, e, value);
    }
}",0,0
176,JacksonDatabind_111,"    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new CreatorProperty(this, deser, _nullProvider);
    }
","public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
    if (_valueDeserializer == deser) {
        return this;
    }
    return new CreatorProperty(this, deser, _nullProvider);
}",0,0
176,JacksonDatabind_111,"    public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser) {
        return new AtomicReferenceDeserializer(_fullType, _valueInstantiator,
                typeDeser, valueDeser);
    }
","public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser) {
    return new AtomicReferenceDeserializer(_fullType, _valueInstantiator, typeDeser, valueDeser);
}",0,0
176,JacksonDatabind_111,"    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new ObjectIdValueProperty(this, deser, _nullProvider);
    }
","public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
    if (_valueDeserializer == deser) {
        return this;
    }
    return new ObjectIdValueProperty(this, deser, _nullProvider);
}",0,0
177,JacksonDatabind_13,"@Override
    public Object deserializeSetAndReturn(JsonParser jp,
    		DeserializationContext ctxt, Object instance) throws IOException
    {
        // note: no null checks (unlike usually); deserializer should fail if one found
        Object id = _valueDeserializer.deserialize(jp, ctxt);

        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;
         *  missing or null id is needed for some cases, such as cases where id
          *  will be generated externally, at a later point, and is not available
          *  quite yet. Typical use case is with DB inserts.
          */
         
         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);
         roid.bindItem(instance);
        // also: may need to set a property value as well
        SettableBeanProperty idProp = _objectIdReader.idProperty;
        if (idProp != null) {
            return idProp.setAndReturn(instance, id);
        }
        return instance;
    }","@Override
public Object deserializeSetAndReturn(JsonParser jp,
        DeserializationContext ctxt, Object instance) throws IOException
{
    // note: no null checks (unlike usually); deserializer should fail if one found
    Object id = _valueDeserializer.deserialize(jp, ctxt);

    /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;
     *  missing or null id is needed for some cases, such as cases where id
     *  will be generated externally, at a later point, and is not available
     *  quite yet. Typical use case is with DB inserts.
     */
    if (id == null) {
        return instance; // Return instance directly if ID is null
    }
    
    ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);
    roid.bindItem(instance);
    // also: may need to set a property value as well
    SettableBeanProperty idProp = _objectIdReader.idProperty;
    if (idProp != null) {
        return idProp.setAndReturn(instance, id);
    }
    return instance;
}",0,0
177,JacksonDatabind_13,"@Override
    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)
    {
         /* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how
          *   missing id already works.
          */
 
         final ObjectIdGenerator.IdKey key = gen.key(id);
 
        if (_objectIds == null) {
            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();
        } else {
            ReadableObjectId entry = _objectIds.get(key);
            if (entry != null) {
                return entry;
            }
        }

        // Not seen yet, must create entry and configure resolver.
        ObjectIdResolver resolver = null;

        if (_objectIdResolvers == null) {
            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);
        } else {
            for (ObjectIdResolver res : _objectIdResolvers) {
                if (res.canUseFor(resolverType)) {
                    resolver = res;
                    break;
                }
            }
        }

        if (resolver == null) {
            resolver = resolverType.newForDeserialization(this);
            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around
            //   needed to clear state between calls.
            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real
            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.
            /*
            if (resolverType.getClass() == SimpleObjectIdResolver.class) {
                resolver = new SimpleObjectIdResolver();
            }
            */
            _objectIdResolvers.add(resolver);
        }

        ReadableObjectId entry = new ReadableObjectId(key);
        entry.setResolver(resolver);
        _objectIds.put(key, entry);
        return entry;
    }","@Override
public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)
{
    /* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how
     *   missing id already works.
     */
    if (id == null) {
        return null; // Explicitly handle null IDs to prevent further processing
    }

    final ObjectIdGenerator.IdKey key = gen.key(id);

    if (_objectIds == null) {
        _objectIds = new LinkedHashMap<>();
    } else {
        ReadableObjectId entry = _objectIds.get(key);
        if (entry != null) {
            return entry;
        }
    }

    // Not seen yet, must create entry and configure resolver.
    ObjectIdResolver resolver = null;

    if (_objectIdResolvers == null) {
        _objectIdResolvers = new ArrayList<>(8);
    } else {
        for (ObjectIdResolver res : _objectIdResolvers) {
            if (res.canUseFor(resolverType)) {
                resolver = res;
                break;
            }
        }
    }

    if (resolver == null) {
        resolver = resolverType.newForDeserialization(this);
        _objectIdResolvers.add(resolver);
    }

    ReadableObjectId entry = new ReadableObjectId(key);
    entry.setResolver(resolver);
    _objectIds.put(key, entry);
    return entry;
}",0,0
178,JacksonDatabind_14,"protected JsonNode _bindAsTree(JsonParser jp) throws IOException
    {
        JsonNode result;
        JsonToken t = _initForReading(jp);
        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
             result = NullNode.instance;
         } else {
             DeserializationContext ctxt = createDeserializationContext(jp, _config);
             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);
             if (_unwrapRoot) {
                 result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);
             } else {
                result = (JsonNode) deser.deserialize(jp, ctxt);
            }
        }
        // Need to consume the token too
        jp.clearCurrentToken();
        return result;
    }","protected JsonNode _bindAsTree(JsonParser jp) throws IOException {
    JsonNode result;
    JsonToken t = _initForReading(jp);
    
    if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
        result = NullNode.instance;
    } else {
        DeserializationContext ctxt = createDeserializationContext(jp, _config);
        JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);
        if (_unwrapRoot) {
            result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);
        } else {
            result = (JsonNode) deser.deserialize(jp, ctxt);
        }
    }
    
    // Ensure current token is cleared only if it's not already cleared by deserialization
    if (jp.getCurrentToken() != null) {
        jp.clearCurrentToken();
    }
    return result;
}",0,0
179,JacksonDatabind_15,"protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,
            BeanPropertyWriter prop)
        throws JsonMappingException
    {
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        if (intr != null) {
            AnnotatedMember m = prop.getMember();
            if (m != null) {
                Object convDef = intr.findSerializationConverter(m);
                if (convDef != null) {
                     Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);
                     JavaType delegateType = conv.getOutputType(provider.getTypeFactory());
                     // [databind#731]: Should skip if nominally java.lang.Object
                     JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);
                     return new StdDelegatingSerializer(conv, delegateType, ser);
                 }
             }
        }
        return null;
    }","protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,
            BeanPropertyWriter prop)
        throws JsonMappingException
    {
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        if (intr != null) {
            AnnotatedMember m = prop.getMember();
            if (m != null) {
                Object convDef = intr.findSerializationConverter(m);
                if (convDef != null) {
                    Converter<Object, Object> conv = provider.converterInstance(m, convDef);
                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());
                    if (delegateType == null || delegateType.hasRawClass(Object.class)) {
                        return null;
                    }
                    JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);
                    return new StdDelegatingSerializer(conv, delegateType, ser);
                }
            }
        }
        return null;
    }",0,0
179,JacksonDatabind_15,"@Override
    @SuppressWarnings(""unchecked"")
    public JsonSerializer<Object> createSerializer(SerializerProvider prov,
            JavaType origType)
        throws JsonMappingException
    {
        // Very first thing, let's check if there is explicit serializer annotation:
        final SerializationConfig config = prov.getConfig();
        BeanDescription beanDesc = config.introspect(origType);
        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());
        if (ser != null) {
            return (JsonSerializer<Object>) ser;
        }
        boolean staticTyping;
        // Next: we may have annotations that further define types to use...
        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);
        if (type == origType) { // no changes, won't force static typing
            staticTyping = false;
        } else { // changes; assume static typing; plus, need to re-introspect if class differs
            staticTyping = true;
            if (!type.hasRawClass(origType.getRawClass())) {
                beanDesc = config.introspect(type);
            }
        }
        // Slight detour: do we have a Converter to consider?
        Converter<Object,Object> conv = beanDesc.findSerializationConverter();
        if (conv == null) { // no, simple
            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);
        }
        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());
        
        // One more twist, as per [Issue#288]; probably need to get new BeanDesc
        if (!delegateType.hasRawClass(type.getRawClass())) {
            beanDesc = config.introspect(delegateType);
            // [#359]: explicitly check (again) for @JsonSerializer...
             ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());
         }
         // [databind#731]: Should skip if nominally java.lang.Object
         if (ser == null) {
             ser = _createSerializer2(prov, delegateType, beanDesc, true);
         }
         return new StdDelegatingSerializer(conv, delegateType, ser);
    }","@Override
@SuppressWarnings(""unchecked"")
public JsonSerializer<Object> createSerializer(SerializerProvider prov,
        JavaType origType)
    throws JsonMappingException
{
    final SerializationConfig config = prov.getConfig();
    BeanDescription beanDesc = config.introspect(origType);
    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());
    if (ser != null) {
        return (JsonSerializer<Object>) ser;
    }
    boolean staticTyping;
    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);
    if (type == origType) {
        staticTyping = false;
    } else {
        staticTyping = true;
        if (!type.hasRawClass(origType.getRawClass())) {
            beanDesc = config.introspect(type);
        }
    }
    Converter<Object, Object> conv = beanDesc.findSerializationConverter();
    if (conv == null) {
        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);
    }
    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());
    if (!delegateType.hasRawClass(type.getRawClass())) {
        beanDesc = config.introspect(delegateType);
        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());
    }
    if (ser == null) {
        ser = _createSerializer2(prov, delegateType, beanDesc, true);
    }
    return new StdDelegatingSerializer(conv, delegateType, ser);
}",0,0
179,JacksonDatabind_15,"@Override
    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)
        throws JsonMappingException
    {
        JsonSerializer<?> delSer = _delegateSerializer;
        JavaType delegateType = _delegateType;

        if (delSer == null) {
            // Otherwise, need to locate serializer to delegate to. For that we need type information...
            if (delegateType == null) {
                delegateType = _converter.getOutputType(provider.getTypeFactory());
            }
             /* 02-Apr-2015, tatu: For ""dynamic case"", where type is only specified as
              *    java.lang.Object (or missing generic), [databind#731]
              */
                 delSer = provider.findValueSerializer(delegateType);
         }
         if (delSer instanceof ContextualSerializer) {
             delSer = provider.handleSecondaryContextualization(delSer, property);
         }
         return (delSer == _delegateSerializer) ? this
                 : withDelegate(_converter, delegateType, delSer);
     }","@Override
public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)
    throws JsonMappingException
{
    JsonSerializer<?> delSer = _delegateSerializer;
    JavaType delegateType = _delegateType;

    if (delSer == null) {
        if (delegateType == null) {
            delegateType = _converter.getOutputType(provider.getTypeFactory());
            if (delegateType == null || delegateType.hasRawClass(Object.class)) {
                return provider.findNullValueSerializer(property);
            }
        }
        delSer = provider.findValueSerializer(delegateType);
    }
    if (delSer instanceof ContextualSerializer) {
        delSer = provider.handleSecondaryContextualization(delSer, property);
    }
    return (delSer == _delegateSerializer) ? this
            : withDelegate(_converter, delegateType, delSer);
}",0,0
179,JacksonDatabind_15,"@Override
    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException
    {
        Object delegateValue = convertValue(value);
        // should we accept nulls?
        if (delegateValue == null) {
            provider.defaultSerializeNull(gen);
             return;
         }
         // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup
         _delegateSerializer.serialize(delegateValue, gen, provider);
     }","@Override
public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
    Object delegateValue = convertValue(value);
    if (delegateValue == null) {
        provider.defaultSerializeNull(gen);
        return;
    }
    _delegateSerializer.serialize(delegateValue, gen, provider);
}",0,0
179,JacksonDatabind_15,"@Override
    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,
            TypeSerializer typeSer) throws IOException
    {
        /* 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,
          *    let's give it a chance?
          */
         Object delegateValue = convertValue(value);
         _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);
     }","@Override
public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,
        TypeSerializer typeSer) throws IOException
{
    Object delegateValue = convertValue(value);
    if (delegateValue == null) {
        provider.defaultSerializeNull(gen);
        return;
    }
    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);
}",0,0
179,JacksonDatabind_15,"@Override
    @Deprecated // since 2.5
     public boolean isEmpty(Object value)
     {
         Object delegateValue = convertValue(value);
         return _delegateSerializer.isEmpty(delegateValue);
     }","@Override
@Deprecated
public boolean isEmpty(Object value)
{
    Object delegateValue = convertValue(value);
    return (delegateValue == null || _delegateSerializer.isEmpty(delegateValue));
}",0,0
179,JacksonDatabind_15,"@Override
     public boolean isEmpty(SerializerProvider prov, Object value)
     {
         Object delegateValue = convertValue(value);
         return _delegateSerializer.isEmpty(prov, delegateValue);
     }","@Override
public boolean isEmpty(SerializerProvider prov, Object value)
{
    Object delegateValue = convertValue(value);
    return (delegateValue == null || _delegateSerializer.isEmpty(prov, delegateValue));
}",0,0
179,JacksonDatabind_15,"@Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
        throws JsonMappingException
    {
        /* 03-Sep-2012, tatu: Not sure if this can be made to really work
          *    properly... but for now, try this:
          */
         // 02-Apr-2015, tatu: For dynamic case, very little we can do
         _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);
     }","@Override
public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
    throws JsonMappingException
{
    if (_delegateSerializer != null) {
        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);
    }
}",0,0
179,JacksonDatabind_15,"protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,
            BeanProperty prop, JsonSerializer<?> existingSerializer)
        throws JsonMappingException
    {
        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop
         *   when applying contextual content converter; this is not ideal way,
         *   but should work for most cases.
         */
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        if (intr != null && prop != null) {
            AnnotatedMember m = prop.getMember();
            if (m != null) {
                Object convDef = intr.findSerializationContentConverter(m);
                if (convDef != null) {
                     Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);
                     JavaType delegateType = conv.getOutputType(provider.getTypeFactory());
                     // [databind#731]: Should skip if nominally java.lang.Object
                     if (existingSerializer == null) {
                         existingSerializer = provider.findValueSerializer(delegateType);
                     }
                     return new StdDelegatingSerializer(conv, delegateType, existingSerializer);
                }
            }
        }
        return existingSerializer;
    }","protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,
        BeanProperty prop, JsonSerializer<?> existingSerializer)
    throws JsonMappingException
{
    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
    if (intr != null && prop != null) {
        AnnotatedMember m = prop.getMember();
        if (m != null) {
            Object convDef = intr.findSerializationContentConverter(m);
            if (convDef != null) {
                Converter<Object, Object> conv = provider.converterInstance(m, convDef);
                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());
                if (delegateType == null || delegateType.hasRawClass(Object.class)) {
                    return existingSerializer;
                }
                if (existingSerializer == null) {
                    existingSerializer = provider.findValueSerializer(delegateType);
                }
                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);
            }
        }
    }
    return existingSerializer;
}",0,0
180,JacksonDatabind_18,"public boolean hasNextValue() throws IOException
     {
         if (_parser == null) {
             return false;
             // fall-through
         }
         if (!_hasNextChecked) {
             JsonToken t = _parser.getCurrentToken();
             _hasNextChecked = true;
             if (t == null) { // un-initialized or cleared; find next
                 t = _parser.nextToken();
                 // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).
                 if (t == null || t == JsonToken.END_ARRAY) {
                     JsonParser jp = _parser;
                     _parser = null;
                     if (_closeParser) {
                         jp.close();
                     }
                     return false;
                 }
             }
             // fall through
         }
         return true;
    }","public boolean hasNextValue() throws IOException {
    if (_parser == null) {
        return false;
    }
    if (!_hasNextChecked) {
        JsonToken t = _parser.getCurrentToken();
        _hasNextChecked = true;
        if (t == null) { // un-initialized or cleared; find next
            t = _parser.nextToken();
            // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).
            if (t == null || t == JsonToken.END_ARRAY) {
                JsonParser jp = _parser;
                _parser = null;
                if (_closeParser) {
                    jp.close();
                }
                return false;
            }
        }
    }
    return _parser.getCurrentToken() != JsonToken.NOT_AVAILABLE; // Ensure valid token
}",0,0
180,JacksonDatabind_18,"public T nextValue() throws IOException
     {
         if (!_hasNextChecked) {
             if (!hasNextValue()) {
                 return _throwNoSuchElement();
             }
         }
         if (_parser == null) {
             return _throwNoSuchElement();
         }
         _hasNextChecked = false;
 
         try {
             T value;
             if (_updatedValue == null) {
                value = _deserializer.deserialize(_parser, _context);
            } else{
                _deserializer.deserialize(_parser, _context, _updatedValue);
                value = _updatedValue;
            }
            return value;
        } finally {
            /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no
             *   matter what, to avoid infinite loop for certain failure cases.
             *   For 2.6 need to improve further.
             */
            _parser.clearCurrentToken();
        }
    }","public T nextValue() throws IOException {
    if (!_hasNextChecked) {
        if (!hasNextValue()) {
            return _throwNoSuchElement();
        }
    }
    if (_parser == null) {
        return _throwNoSuchElement();
    }
    _hasNextChecked = false;

    try {
        T value;
        if (_updatedValue == null) {
            value = _deserializer.deserialize(_parser, _context);
        } else {
            _deserializer.deserialize(_parser, _context, _updatedValue);
            value = _updatedValue;
        }
        return value;
    } catch (Exception e) {
        throw new IOException(""Error during deserialization"", e); // Improved error handling
    } finally {
        /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no
         *   matter what, to avoid infinite loop for certain failure cases.
         */
        if (_parser != null) {
            _parser.clearCurrentToken();
        } // Ensure _parser is null-safe
    }
}",0,0
181,JacksonDatabind_2,"    @Override
    public void writeObject(Object value) throws IOException
    {
            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we
             *   err out, or just embed? For now, do latter.
             */
//          throw new JsonMappingException(""No ObjectCodec configured for TokenBuffer, writeObject() called"");
    }

    @Override
    public void writeTree(TreeNode node) throws IOException
    {

            // as with 'writeObject()', is codec optional?
            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);
    }",Match failed,0,0
182,JacksonDatabind_20,"    public JsonNode setAll(Map<String,? extends JsonNode> properties)
    {
        for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {
            JsonNode n = en.getValue();
            if (n == null) {
                n = nullNode();
            }
            _children.put(en.getKey(), n);
        }
        return this;
    }
","public JsonNode setAll(Map<String, ? extends JsonNode> properties) {
    if (properties == null) {
        throw new IllegalArgumentException(""Properties map cannot be null"");
    }
    for (Map.Entry<String, ? extends JsonNode> en : properties.entrySet()) {
        JsonNode n = en.getValue();
        if (n == null) {
            n = nullNode();
        }
        _children.put(en.getKey(), n);
    }
    return this;
}",0,0
183,JacksonDatabind_21,"    public PropertyName findRootName(AnnotatedClass ac)
    {
        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);
        if (ann == null) {
            return null;
        }
        String ns = ann.namespace();
        if (ns != null && ns.length() == 0) {
            ns = null;
        }
        return PropertyName.construct(ann.value(), ns);
    }
","public PropertyName findRootName(AnnotatedClass ac)
{
    JsonRootName ann = _findAnnotation(ac, JsonRootName.class);
    if (ann == null || ann.value() == null || ann.value().isEmpty()) {
        return null;
    }
    String ns = ann.namespace();
    if (ns != null && ns.isEmpty()) {
        ns = null;
    }
    return PropertyName.construct(ann.value(), ns);
}",0,0
184,JacksonDatabind_22,"protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,
            JavaType type, BeanDescription beanDesc, boolean staticTyping)
        throws JsonMappingException
    {
        final SerializationConfig config = prov.getConfig();

        /* [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,
         *   with just one important exception: if value type is ""untyped"", let's
         *   leave it as is; no clean way to make it work.
         */
        if (!staticTyping && type.useStaticType()) {
            if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {
                staticTyping = true;
            }
        }
        
        // Let's see what we can learn about element/content/value type, type serializer for it:
        JavaType elementType = type.getContentType();
        TypeSerializer elementTypeSerializer = createTypeSerializer(config,
                elementType);

        // if elements have type serializer, can not force static typing:
        if (elementTypeSerializer != null) {
            staticTyping = false;
        }
        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,
                beanDesc.getClassInfo());
        if (type.isMapLikeType()) { // implements java.util.Map
            MapLikeType mlt = (MapLikeType) type;
            /* 29-Sep-2012, tatu: This is actually too early to (try to) find
             *  key serializer from property annotations, and can lead to caching
             *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.
             *  But we do need to check class annotations.
              */
             JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());
             if (mlt.isTrueMapType()) {
                 return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,
                         keySerializer, elementTypeSerializer, elementValueSerializer);
             }
             // With Map-like, just 2 options: (1) Custom, (2) Annotations
             JsonSerializer<?> ser = null;
             for (Serializers serializers : customSerializers()) { // (1) Custom
                 MapLikeType mlType = (MapLikeType) type;
                 ser = serializers.findMapLikeSerializer(config,
                         mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);
             if (ser != null) {
                 if (_factoryConfig.hasSerializerModifiers()) {
                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);
                     }
                     }
                     return ser;
                 }
             }
             return null;
         }
         if (type.isCollectionLikeType()) {
             CollectionLikeType clt = (CollectionLikeType) type;
             if (clt.isTrueCollectionType()) {
                 return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,
                         elementTypeSerializer, elementValueSerializer);
             }
             // With Map-like, just 2 options: (1) Custom, (2) Annotations
            JsonSerializer<?> ser = null;
            CollectionLikeType clType = (CollectionLikeType) type;
            for (Serializers serializers : customSerializers()) { // (1) Custom
                ser = serializers.findCollectionLikeSerializer(config,
                        clType, beanDesc, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                if (_factoryConfig.hasSerializerModifiers()) {
                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);
                        }
                    }
                    return ser;
                }
            }
            return null;
        }
        if (type.isArrayType()) {
            return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,
                    elementTypeSerializer, elementValueSerializer);
        }
        return null;
    }","protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,
            JavaType type, BeanDescription beanDesc, boolean staticTyping)
        throws JsonMappingException
{
    final SerializationConfig config = prov.getConfig();

    if (!staticTyping && type.useStaticType()) {
        if (!type.isContainerType() || 
            (type.getContentType() != null && 
             type.getContentType().getRawClass() != Object.class)) {
            staticTyping = true;
        }
    }
    
    JavaType elementType = type.getContentType();
    TypeSerializer elementTypeSerializer = elementType == null ? null : createTypeSerializer(config, elementType);
    JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo());

    if (type.isMapLikeType()) {
        MapLikeType mlt = (MapLikeType) type;
        JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());
        if (mlt.isTrueMapType()) {
            return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer);
        }
        for (Serializers serializers : customSerializers()) {
            JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlt, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                if (_factoryConfig.hasSerializerModifiers()) {
                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                        ser = mod.modifyMapLikeSerializer(config, mlt, beanDesc, ser);
                    }
                }
                return ser;
            }
        }
        return null;
    }

    if (type.isCollectionLikeType()) {
        CollectionLikeType clt = (CollectionLikeType) type;
        if (clt.isTrueCollectionType()) {
            return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);
        }
        for (Serializers serializers : customSerializers()) {
            JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clt, beanDesc, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                if (_factoryConfig.hasSerializerModifiers()) {
                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                        ser = mod.modifyCollectionLikeSerializer(config, clt, beanDesc, ser);
                    }
                }
                return ser;
            }
        }
        return null;
    }

    if (type.isArrayType()) {
        return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);
    }

    return null;
}",0,0
184,JacksonDatabind_22,"protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,
            MapType type, BeanDescription beanDesc,
            boolean staticTyping, JsonSerializer<Object> keySerializer,
            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)
        throws JsonMappingException
    {
        JsonSerializer<?> ser = null;

        // Order of lookups:
        // 1. Custom serializers
        // 2. Annotations (@JsonValue, @JsonDeserialize)
        // 3. Defaults
        
        for (Serializers serializers : customSerializers()) { // (1) Custom
            ser = serializers.findMapSerializer(config, type, beanDesc,
                    keySerializer, elementTypeSerializer, elementValueSerializer);
             if (ser != null) { break; }
         }
         if (ser == null) {
                 // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer
                 /*
                 if (EnumMap.class.isAssignableFrom(type.getRawClass())
                        && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {
                    JavaType keyType = type.getKeyType();
                    // Need to find key enum values...
                    EnumValues enums = null;
                    if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)
                        @SuppressWarnings(""unchecked"")
                        Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();
                        enums = EnumValues.construct(config, enumClass);
                    }
                    ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,
                        elementTypeSerializer, elementValueSerializer);
                } else {
                */
                Object filterId = findFilterId(config, beanDesc);
                AnnotationIntrospector ai = config.getAnnotationIntrospector();
                MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),
                        type, staticTyping, elementTypeSerializer,
                        keySerializer, elementValueSerializer, filterId);
                Object suppressableValue = findSuppressableContentValue(config,
                        type.getContentType(), beanDesc);
                if (suppressableValue != null) {
                    mapSer = mapSer.withContentInclusion(suppressableValue);
                }
                ser = mapSer;
            }
        // [databind#120]: Allow post-processing
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);
            }
        }
        return ser;
    }","protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,
            MapType type, BeanDescription beanDesc,
            boolean staticTyping, JsonSerializer<Object> keySerializer,
            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)
        throws JsonMappingException
{
    JsonSerializer<?> ser = null;

    for (Serializers serializers : customSerializers()) {
        ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);
        if (ser != null) {
            break;
        }
    }

    if (ser == null) {
        Object filterId = findFilterId(config, beanDesc);
        AnnotationIntrospector ai = config.getAnnotationIntrospector();
        MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId);
        Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc);
        if (suppressableValue != null) {
            mapSer = mapSer.withContentInclusion(suppressableValue);
        }
        ser = mapSer;
    }

    if (_factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            ser = mod.modifyMapSerializer(config, type, beanDesc, ser);
        }
    }

    return ser;
}",0,0
184,JacksonDatabind_22,"protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,
            CollectionType type, BeanDescription beanDesc, boolean staticTyping,
            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) 
        throws JsonMappingException
    {
        JsonSerializer<?> ser = null;
        // Order of lookups:
        // 1. Custom serializers
        // 2. Annotations (@JsonValue, @JsonDeserialize)
        // 3. Defaults
        for (Serializers serializers : customSerializers()) { // (1) Custom
            ser = serializers.findCollectionSerializer(config,
                    type, beanDesc, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                break;
            }
         }
 
         if (ser == null) {
                 // We may also want to use serialize Collections ""as beans"", if (and only if)
                 // this is specified with `@JsonFormat(shape=Object)`
                 JsonFormat.Value format = beanDesc.findExpectedFormat(null);
                if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {
                    return null;
                }
                Class<?> raw = type.getRawClass();
                if (EnumSet.class.isAssignableFrom(raw)) {
                    // this may or may not be available (Class doesn't; type of field/method does)
                    JavaType enumType = type.getContentType();
                    // and even if nominally there is something, only use if it really is enum
                    if (!enumType.isEnumType()) {
                        enumType = null;
                    }
                    ser = buildEnumSetSerializer(enumType);
                } else {
                    Class<?> elementRaw = type.getContentType().getRawClass();
                    if (isIndexedList(raw)) {
                        if (elementRaw == String.class) {
                            // [JACKSON-829] Must NOT use if we have custom serializer
                            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {
                                ser = IndexedStringListSerializer.instance;
                            }
                        } else {
                            ser = buildIndexedListSerializer(type.getContentType(), staticTyping,
                                elementTypeSerializer, elementValueSerializer);
                        }
                    } else if (elementRaw == String.class) {
                        // [JACKSON-829] Must NOT use if we have custom serializer
                        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {
                            ser = StringCollectionSerializer.instance;
                        }
                    }
                    if (ser == null) {
                        ser = buildCollectionSerializer(type.getContentType(), staticTyping,
                                elementTypeSerializer, elementValueSerializer);
                }
            }
        }
        // [databind#120]: Allow post-processing
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);
            }
        }
        return ser;
    }","protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,
            CollectionType type, BeanDescription beanDesc, boolean staticTyping,
            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) 
        throws JsonMappingException
{
    JsonSerializer<?> ser = null;

    for (Serializers serializers : customSerializers()) {
        ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);
        if (ser != null) {
            break;
        }
    }

    if (ser == null) {
        JsonFormat.Value format = beanDesc.findExpectedFormat(null);
        if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {
            return null;
        }

        Class<?> raw = type.getRawClass();
        if (EnumSet.class.isAssignableFrom(raw)) {
            JavaType enumType = type.getContentType();
            if (!enumType.isEnumType()) {
                enumType = null;
            }
            ser = buildEnumSetSerializer(enumType);
        } else {
            if (isIndexedList(raw)) {
                if (type.getContentType().getRawClass() == String.class &&
                    (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer))) {
                    ser = IndexedStringListSerializer.instance;
                } else {
                    ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);
                }
            } else {
                if (type.getContentType().getRawClass() == String.class &&
                    (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer))) {
                    ser = StringCollectionSerializer.instance;
                } else {
                    ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);
                }
            }
        }
    }

    if (_factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);
        }
    }

    return ser;
}",0,0
184,JacksonDatabind_22,"protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,
            ArrayType type, BeanDescription beanDesc,
            boolean staticTyping,
            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)
        throws JsonMappingException
    {
        // 25-Jun-2015, tatu: Note that unlike with Collection(Like) and Map(Like) types, array
         //   types can not be annotated (in theory I guess we could have mix-ins but... ?)
         //   so we need not do primary annotation lookup here.
         //   So all we need is (1) Custom, (2) Default array serializers
         JsonSerializer<?> ser = null;
 
         for (Serializers serializers : customSerializers()) { // (1) Custom
             ser = serializers.findArraySerializer(config,
                     type, beanDesc, elementTypeSerializer, elementValueSerializer);
             if (ser != null) {
                 break;
             }
        }
        
        if (ser == null) {
             Class<?> raw = type.getRawClass();
             // Important: do NOT use standard serializers if non-standard element value serializer specified
             if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {
                 if (String[].class == raw) {
                     ser = StringArraySerializer.instance;
                 } else {
                     // other standard types?
                     ser = StdArraySerializers.findStandardImpl(raw);
                 }
             }
             if (ser == null) {
                 ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,
                         elementValueSerializer);
             }
         }
         // [databind#120]: Allow post-processing
         if (_factoryConfig.hasSerializerModifiers()) {
             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);
             }
         }
         return ser;
    }","protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,
            ArrayType type, BeanDescription beanDesc, boolean staticTyping,
            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)
        throws JsonMappingException
{
    JsonSerializer<?> ser = null;

    for (Serializers serializers : customSerializers()) {
        ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);
        if (ser != null) {
            break;
        }
    }

    if (ser == null) {
        Class<?> raw = type.getRawClass();
        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {
            if (String[].class == raw) {
                ser = StringArraySerializer.instance;
            } else {
                ser = StdArraySerializers.findStandardImpl(raw);
            }
        }

        if (ser == null) {
            ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);
        }
    }

    if (_factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            ser = mod.modifyArraySerializer(config, type, beanDesc, ser);
        }
    }

    return ser;
}",0,0
184,JacksonDatabind_22,"protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,
             JavaType type, BeanDescription beanDesc, boolean staticTyping)
         throws JsonMappingException
     {
         JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);
         if (ser != null) {
             return ser;
         }
         final SerializationConfig config = prov.getConfig();
         
         // Container types differ from non-container types
        // (note: called method checks for module-provided serializers)
        if (type.isContainerType()) {
            if (!staticTyping) {
                staticTyping = usesStaticTyping(config, beanDesc, null);
                // [Issue#23]: Need to figure out how to force passed parameterization
                //  to stick...
                /*
                if (property == null) {
                    JavaType t = origType.getContentType();
                    if (t != null && !t.hasRawClass(Object.class)) {
                        staticTyping = true;
                    }
                }
                */
            }
            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...
            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);
            // Will return right away, since called method does post-processing:
            if (ser != null) {
                return ser;
            }
        } else {
            // Modules may provide serializers of POJO types:
            for (Serializers serializers : customSerializers()) {
                ser = serializers.findSerializer(config, type, beanDesc);
                if (ser != null) {
                    break;
                }
            }
            // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,
            //    this call was BEFORE custom serializer lookup, which was wrong.
        }
        
        if (ser == null) {
            // Otherwise, we will check ""primary types""; both marker types that
            // indicate specific handling (JsonSerializable), or main types that have
            // precedence over container types
            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);
            if (ser == null) {
                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);
                if (ser == null) {
                    // And this is where this class comes in: if type is not a
                    // known ""primary JDK type"", perhaps it's a bean? We can still
                    // get a null, if we can't find a single suitable bean property.
                    ser = findBeanSerializer(prov, type, beanDesc);
                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?
                    if (ser == null) {
                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);
                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get
                        //   'unknown' serializer assigned earlier, here, so that it gets properly
                        //   post-processed
                        if (ser == null) {
                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());
                        }
                    }
                }
            }
        }
        if (ser != null) {
            // [databind#120]: Allow post-processing
            if (_factoryConfig.hasSerializerModifiers()) {
                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                    ser = mod.modifySerializer(config, beanDesc, ser);
                }
            }
        }
        return ser;
    }","protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,
             JavaType type, BeanDescription beanDesc, boolean staticTyping)
         throws JsonMappingException
{
    JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);
    if (ser != null) {
        return ser;
    }

    final SerializationConfig config = prov.getConfig();

    if (type.isContainerType()) {
        if (!staticTyping) {
            staticTyping = usesStaticTyping(config, beanDesc, null);
        }

        ser = buildContainerSerializer(prov, type, beanDesc, staticTyping);
        if (ser != null) {
            return ser;
        }
    } else {
        for (Serializers serializers : customSerializers()) {
            ser = serializers.findSerializer(config, type, beanDesc);
            if (ser != null) {
                break;
            }
        }

        if (ser == null) {
            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);
            if (ser == null) {
                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);
                if (ser == null) {
                    ser = findBeanSerializer(prov, type, beanDesc);
                    if (ser == null) {
                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);
                        if (ser == null) {
                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());
                        }
                    }
                }
            }
        }
    }

    if (ser != null && _factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            ser = mod.modifySerializer(config, beanDesc, ser);
        }
    }

    return ser;
}",0,0
185,JacksonDatabind_23,"        final static DoubleSerializer instance = new DoubleSerializer();
    
        public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, ""number""); }
","final static DoubleSerializer instance = new DoubleSerializer();

public DoubleSerializer() { 
    super(Double.class, JsonParser.NumberType.DOUBLE, ""number""); 
}",0,0
185,JacksonDatabind_23,"        public IntLikeSerializer() {
            super(Number.class, JsonParser.NumberType.INT, ""integer"");
        }
","public IntLikeSerializer() { 
    super(Integer.class, JsonParser.NumberType.INT, ""integer""); 
}",0,0
185,JacksonDatabind_23,"        public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {
            gen.writeNumber(value.intValue());
        }
","public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException { 
    if (value instanceof Integer) {
        gen.writeNumber(value.intValue());
    } else {
        throw new IOException(""Expected an integer type for serialization."");
    }
}",0,0
185,JacksonDatabind_23,"        protected Base(Class<?> cls, JsonParser.NumberType numberType, String schemaType) {
            super(cls, false);
            _numberType = numberType;
            _schemaType = schemaType;
            _isInt = (numberType == JsonParser.NumberType.INT)
                    || (numberType == JsonParser.NumberType.LONG)
                    || (numberType == JsonParser.NumberType.BIG_INTEGER)
                    ;
        }
","protected Base(Class<?> cls, JsonParser.NumberType numberType, String schemaType) {
    super(cls, false);
    _numberType = numberType;
    _schemaType = schemaType;
    _isInt = (numberType == JsonParser.NumberType.INT)
            || (numberType == JsonParser.NumberType.LONG)
            || (numberType == JsonParser.NumberType.BIG_INTEGER);
}",0,0
185,JacksonDatabind_23,"        final static ShortSerializer instance = new ShortSerializer();

        public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, ""number""); }
","final static ShortSerializer instance = new ShortSerializer();

public ShortSerializer() {
    super(Short.class, JsonParser.NumberType.INT, ""integer"");
}",0,0
185,JacksonDatabind_23,"        public void serializeWithType(Object value, JsonGenerator gen,
                SerializerProvider provider, TypeSerializer typeSer) throws IOException {
            // no type info, just regular serialization
            serialize(value, gen, provider);            
        }
","public void serializeWithType(Object value, JsonGenerator gen,
        SerializerProvider provider, TypeSerializer typeSer) throws IOException {
    // Ensure the value is of a compatible type before serialization
    if (value instanceof Number) {
        serialize(value, gen, provider);
    } else {
        throw new IOException(""Expected a numeric type for serialization."");
    }
}",0,0
185,JacksonDatabind_23,"        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
            gen.writeNumber(((Long) value).longValue());
        }
","public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
    if (value instanceof Long) {
        gen.writeNumber(((Long) value).longValue());
    } else {
        throw new IOException(""Expected a long type for serialization."");
    }
}",0,0
186,JacksonDatabind_25,"@SuppressWarnings({ ""unchecked"" })
    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,
            Annotated a, T type)
        throws JsonMappingException
    {
        // first: let's check class for the instance itself:
        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
         Class<?> subclass = intr.findDeserializationType(a, type);
         if (subclass != null) {
             try {
                 type = (T) type.narrowBy(subclass);
             } catch (IllegalArgumentException iae) {
                 throw new JsonMappingException(""Failed to narrow type ""+type+"" with concrete-type annotation (value ""+subclass.getName()+""), method '""+a.getName()+""': ""+iae.getMessage(), null, iae);
             }
        }

        // then key class
        if (type.isContainerType()) {
            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
            if (keyClass != null) {
                // illegal to use on non-Maps
                if (!(type instanceof MapLikeType)) {
                    throw new JsonMappingException(""Illegal key-type annotation: type ""+type+"" is not a Map(-like) type"");
                }
                try {
                    type = (T) ((MapLikeType) type).narrowKey(keyClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(""Failed to narrow key type ""+type+"" with key-type annotation (""+keyClass.getName()+""): ""+iae.getMessage(), null, iae);
                }
            }
            JavaType keyType = type.getKeyType();
            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
             *   (not 100% why or how, but this does seem to get called more than once, which
             *   is not good: for now, let's just avoid errors)
             */
            if (keyType != null && keyType.getValueHandler() == null) {
                Object kdDef = intr.findKeyDeserializer(a);
                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);
                if (kd != null) {
                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);
                    keyType = type.getKeyType(); // just in case it's used below
                }
            }            
           
           // and finally content class; only applicable to structured types
           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
           if (cc != null) {
               try {
                   type = (T) type.narrowContentsBy(cc);
               } catch (IllegalArgumentException iae) {
                   throw new JsonMappingException(""Failed to narrow content type ""+type+"" with content-type annotation (""+cc.getName()+""): ""+iae.getMessage(), null, iae);
               }
           }
           // ... as well as deserializer for contents:
           JavaType contentType = type.getContentType();
           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)
               Object cdDef = intr.findContentDeserializer(a);
                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);
                if (cd != null) {
                    type = (T) type.withContentValueHandler(cd);
                }
            }
        }
        return type;
    }","@SuppressWarnings({ ""unchecked"" })
protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,
        Annotated a, T type)
    throws JsonMappingException
{
    // first: let's check class for the instance itself:
    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
    if (intr == null) {
        return type;
    }

    Class<?> subclass = intr.findDeserializationType(a, type);
    if (subclass != null) {
        try {
            type = (T) type.narrowBy(subclass);
        } catch (IllegalArgumentException iae) {
            throw new JsonMappingException(ctxt.getParser(), 
                ""Failed to narrow type ""+type+"" with concrete-type annotation (value ""+subclass.getName()+""), method '""+a.getName()+""': ""+iae.getMessage(), iae);
        }
    }

    // then key class
    if (type.isContainerType()) {
        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
        if (keyClass != null) {
            if (!(type instanceof MapLikeType)) {
                throw new JsonMappingException(ctxt.getParser(), 
                    ""Illegal key-type annotation: type ""+type+"" is not a Map(-like) type"");
            }
            try {
                type = (T) ((MapLikeType) type).narrowKey(keyClass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(ctxt.getParser(), 
                    ""Failed to narrow key type ""+type+"" with key-type annotation (""+keyClass.getName()+""): ""+iae.getMessage(), iae);
            }
        }
        JavaType keyType = type.getKeyType();
        if (keyType != null && keyType.getValueHandler() == null) {
            Object kdDef = intr.findKeyDeserializer(a);
            if (kdDef != null) {
                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);
                if (kd != null) {
                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);
                }
            }
        }

        // finally content class
        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
        if (cc != null) {
            try {
                type = (T) type.narrowContentsBy(cc);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(ctxt.getParser(), 
                    ""Failed to narrow content type ""+type+"" with content-type annotation (""+cc.getName()+""): ""+iae.getMessage(), iae);
            }
        }
        
        JavaType contentType = type.getContentType();
        if (contentType != null && contentType.getValueHandler() == null) {
            Object cdDef = intr.findContentDeserializer(a);
            if (cdDef != null) {
                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);
                if (cd != null) {
                    type = (T) type.withContentValueHandler(cd);
                }
            }
        }
    }
    return type;
}",0,0
186,JacksonDatabind_25,"protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,
            String typeId) throws IOException
    {
        JsonDeserializer<Object> deser = _deserializers.get(typeId);
        if (deser == null) {
            /* As per [Databind#305], need to provide contextual info. But for
             * backwards compatibility, let's start by only supporting this
             * for base class, not via interface. Later on we can add this
             * to the interface, assuming deprecation at base class helps.
             */
            JavaType type = _idResolver.typeFromId(ctxt, typeId);
            if (type == null) {
                // As per [JACKSON-614], use the default impl if no type id available:
                deser = _findDefaultImplDeserializer(ctxt);
                if (deser == null) {
                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);
                }
            } else {
                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,
                 *   we actually now need to explicitly narrow from base type (which may have parameterization)
                 *   using raw type.
                 *
                 *   One complication, though; can not change 'type class' (simple type to container); otherwise
                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual
                 *   type in process (getting SimpleType of Map.class which will not work as expected)
                 */
                if ((_baseType != null)
                        && _baseType.getClass() == type.getClass()) {
                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;
                     *   but it appears to check that JavaType impl class is the same which is
                      *   important for some reason?
                      *   Disabling the check will break 2 Enum-related tests.
                      */
                     type = _baseType.narrowBy(type.getRawClass());
                 }
                 deser = ctxt.findContextualValueDeserializer(type, _property);
             }
            _deserializers.put(typeId, deser);
        }
        return deser;
    }","protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,
        String typeId) throws IOException
{
    JsonDeserializer<Object> deser = _deserializers.get(typeId);
    if (deser == null) {
        JavaType type = _idResolver.typeFromId(ctxt, typeId);
        if (type == null) {
            deser = _findDefaultImplDeserializer(ctxt);
            if (deser == null) {
                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);
            }
        } else {
            try {
                if (_baseType != null && _baseType.getClass() == type.getClass()) {
                    type = _baseType.narrowBy(type.getRawClass());
                }
                deser = ctxt.findContextualValueDeserializer(type, _property);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(ctxt.getParser(),
                    ""Could not resolve type id '"" + typeId + ""' into a valid type: "" + iae.getMessage(), iae);
            }
        }
        _deserializers.put(typeId, deser);
    }
    return deser;
}",0,0
186,JacksonDatabind_25,"@Override
    public JavaType findTypeMapping(DeserializationConfig config, JavaType type)
    {
        // this is the main mapping base, so let's 
        Class<?> src = type.getRawClass();
        Class<?> dst = _mappings.get(new ClassKey(src));
        if (dst == null) {
             return null;
         }
         // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory
         return type.narrowBy(dst);
     }","@Override
public JavaType findTypeMapping(DeserializationConfig config, JavaType type)
{
    Class<?> src = type.getRawClass();
    Class<?> dst = _mappings.get(new ClassKey(src));
    if (dst == null) {
        return null;
    }
    // Use TypeFactory for better compatibility
    return config.getTypeFactory().constructSpecializedType(type, dst);
}",0,0
186,JacksonDatabind_25,"private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,
            Annotated a, JavaType type)
        throws JsonMappingException
    {
        // first: let's check class for the instance itself:
        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
         Class<?> subclass = intr.findDeserializationType(a, type);
         if (subclass != null) {
             try {
                 type = type.narrowBy(subclass);
             } catch (IllegalArgumentException iae) {
                 throw new JsonMappingException(""Failed to narrow type ""+type+"" with concrete-type annotation (value ""+subclass.getName()+""), method '""+a.getName()+""': ""+iae.getMessage(), null, iae);
             }
        }

        // then key class
        if (type.isContainerType()) {
            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
            if (keyClass != null) {
                // illegal to use on non-Maps
                if (!(type instanceof MapLikeType)) {
                    throw new JsonMappingException(""Illegal key-type annotation: type ""+type+"" is not a Map(-like) type"");
                }
                try {
                    type = ((MapLikeType) type).narrowKey(keyClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(""Failed to narrow key type ""+type+"" with key-type annotation (""+keyClass.getName()+""): ""+iae.getMessage(), null, iae);
                }
            }
            JavaType keyType = type.getKeyType();
            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
             *   (not 100% why or how, but this does seem to get called more than once, which
             *   is not good: for now, let's just avoid errors)
             */
            if (keyType != null && keyType.getValueHandler() == null) {
                Object kdDef = intr.findKeyDeserializer(a);
                if (kdDef != null) {
                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);
                    if (kd != null) {
                        type = ((MapLikeType) type).withKeyValueHandler(kd);
                        keyType = type.getKeyType(); // just in case it's used below
                    }
                }
            }            
            
            // and finally content class; only applicable to structured types
            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
            if (cc != null) {
                try {
                    type = type.narrowContentsBy(cc);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(""Failed to narrow content type ""+type+"" with content-type annotation (""+cc.getName()+""): ""+iae.getMessage(), null, iae);
                }
            }
            // ... as well as deserializer for contents:
            JavaType contentType = type.getContentType();
            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)
                Object cdDef = intr.findContentDeserializer(a);
                if (cdDef != null) {
                    JsonDeserializer<?> cd = null;
                    if (cdDef instanceof JsonDeserializer<?>) {
                        cdDef = (JsonDeserializer<?>) cdDef;
                    } else {
                        Class<?> cdClass = _verifyAsClass(cdDef, ""findContentDeserializer"", JsonDeserializer.None.class);
                        if (cdClass != null) {
                            cd = ctxt.deserializerInstance(a, cdClass);
                        }
                    }
                    if (cd != null) {
                        type = type.withContentValueHandler(cd);
                    }
                }
            }
        }
        return type;
    }","private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,
        Annotated a, JavaType type)
    throws JsonMappingException
{
    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
    if (intr == null) {
        return type;
    }

    Class<?> subclass = intr.findDeserializationType(a, type);
    if (subclass != null) {
        try {
            type = type.narrowBy(subclass);
        } catch (IllegalArgumentException iae) {
            throw new JsonMappingException(ctxt.getParser(),
                ""Failed to narrow type ""+type+"" with concrete-type annotation (value ""+subclass.getName()+""), method '""+a.getName()+""': ""+iae.getMessage(), iae);
        }
    }

    if (type.isContainerType()) {
        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
        if (keyClass != null) {
            if (!(type instanceof MapLikeType)) {
                throw new JsonMappingException(ctxt.getParser(),
                    ""Illegal key-type annotation: type ""+type+"" is not a Map(-like) type"");
            }
            try {
                type = ((MapLikeType) type).narrowKey(keyClass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(ctxt.getParser(),
                    ""Failed to narrow key type ""+type+"" with key-type annotation (""+keyClass.getName()+""): ""+iae.getMessage(), iae);
            }
        }

        JavaType keyType = type.getKeyType();
        if (keyType != null && keyType.getValueHandler() == null) {
            Object kdDef = intr.findKeyDeserializer(a);
            if (kdDef != null) {
                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);
                if (kd != null) {
                    type = ((MapLikeType) type).withKeyValueHandler(kd);
                }
            }
        }

        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
        if (cc != null) {
            try {
                type = type.narrowContentsBy(cc);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(ctxt.getParser(),
                    ""Failed to narrow content type ""+type+"" with content-type annotation (""+cc.getName()+""): ""+iae.getMessage(), iae);
            }
        }

        JavaType contentType = type.getContentType();
        if (contentType != null && contentType.getValueHandler() == null) {
            Object cdDef = intr.findContentDeserializer(a);
            if (cdDef != null) {
                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);
                if (cd != null) {
                    type = type.withContentValueHandler(cd);
                }
            }
        }
    }
    return type;
}",0,0
187,JacksonDatabind_26,"public class BeanPropertyWriter extends PropertyWriter
    implements BeanProperty
{
    // as of 2.6.2

    /**
     * Marker object used to indicate ""do not serialize if empty""
     */
    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;

    /**
     * Marker we use to indicate case where we have done format lookup,
     * but found nothing; marker used to avoid having to repeat such lookups.
     *
     * @since 2.6
     */
    protected final static JsonFormat.Value NO_FORMAT = new JsonFormat.Value();
","public class BeanPropertyWriter extends PropertyWriter implements BeanProperty {

    // as of 2.6.2

    /**
     * Marker object used to indicate ""do not serialize if empty""
     */
    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;

    /**
     * Marker we use to indicate case where we have done format lookup,
     * but found nothing; marker used to avoid having to repeat such lookups.
     *
     * @since 2.6
     */
    protected final static JsonFormat.Value NO_FORMAT = JsonFormat.Value.empty();

    // Constructor updated to avoid potential null pointer cases
    public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, SerializerProvider prov,
                              JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer,
                              JavaType serType, boolean suppressNulls, Object suppressableValue) {
        super(propDef.getName(), propDef.getWrapperName(), TypeFactory.defaultInstance().constructType(Object.class));

        // Ensure that member and other fields are safely initialized
        this.member = (member != null) ? member.getMember() : null;
        this.contextAnnotations = propDef.getMetadata().getAnnotations();

        // Initialize other required fields with default values
        this.serializedString = new SerializedString(propDef.getName());
        this.views = propDef.findViews();
        this.serializerMap = PropertySerializerMap.emptyForProperties();
    }
}",0,0
188,JacksonDatabind_29,"@SuppressWarnings(""resource"")
    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,
            int index, String typeId) throws IOException
    {
         JsonParser p2 = _tokens[index].asParser(p);
         JsonToken t = p2.nextToken();
         // 29-Sep-2015, tatu: As per [databind#942], nulls need special support
 
         TokenBuffer merged = new TokenBuffer(p);
         merged.writeStartArray();
        merged.writeString(typeId);
        merged.copyCurrentStructure(p2);
        merged.writeEndArray();

        // needs to point to START_OBJECT (or whatever first token is)
        JsonParser mp = merged.asParser(p);
        mp.nextToken();
        return _properties[index].getProperty().deserialize(mp, ctxt);
    }","@SuppressWarnings(""resource"")
protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,
        int index, String typeId) throws IOException
{
    JsonParser p2 = _tokens[index].asParser(p);
    JsonToken t = p2.nextToken();
    if (t == JsonToken.VALUE_NULL) {
        return null;
    }
    // 29-Sep-2015, tatu: As per [databind#942], nulls need special support
    TokenBuffer merged = new TokenBuffer(p);
    merged.writeStartArray();
    merged.writeString(typeId);
    merged.copyCurrentStructure(p2);
    merged.writeEndArray();

    // needs to point to START_OBJECT (or whatever first token is)
    JsonParser mp = merged.asParser(p);
    mp.nextToken();
    return _properties[index].getProperty().deserialize(mp, ctxt);
}",0,0
188,JacksonDatabind_29,"@SuppressWarnings(""resource"")
    protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt,
            Object bean, int index, String typeId) throws IOException
    {
        /* Ok: time to mix type id, value; and we will actually use ""wrapper-array""
         * style to ensure we can handle all kinds of JSON constructs.
         */
         JsonParser p2 = _tokens[index].asParser(p);
         JsonToken t = p2.nextToken();
         // 29-Sep-2015, tatu: As per [databind#942], nulls need special support
         TokenBuffer merged = new TokenBuffer(p);
         merged.writeStartArray();
         merged.writeString(typeId);
        
        merged.copyCurrentStructure(p2);
        merged.writeEndArray();
        // needs to point to START_OBJECT (or whatever first token is)
        JsonParser mp = merged.asParser(p);
        mp.nextToken();
        _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);
    }","@SuppressWarnings(""resource"")
protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt,
        Object bean, int index, String typeId) throws IOException
{
    JsonParser p2 = _tokens[index].asParser(p);
    JsonToken t = p2.nextToken();
    if (t == JsonToken.VALUE_NULL) {
        _properties[index].getProperty().set(bean, null);
        return;
    }
    // 29-Sep-2015, tatu: As per [databind#942], nulls need special support
    TokenBuffer merged = new TokenBuffer(p);
    merged.writeStartArray();
    merged.writeString(typeId);
    merged.copyCurrentStructure(p2);
    merged.writeEndArray();

    // needs to point to START_OBJECT (or whatever first token is)
    JsonParser mp = merged.asParser(p);
    mp.nextToken();
    _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);
}",0,0
189,JacksonDatabind_3,"@Override
    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        // Ok: must point to START_ARRAY (or equivalent)
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt);
        }
        if (_elementDeserializer != null) {
            return _deserializeCustom(jp, ctxt);
        }

        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();
        
        int ix = 0;
        JsonToken t;
        
        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
            // Ok: no need to convert Strings, but must recognize nulls
            String value;
             if (t == JsonToken.VALUE_STRING) {
                 value = jp.getText();
             } else if (t == JsonToken.VALUE_NULL) {
                 value = _elementDeserializer.getNullValue();
             } else {
                 value = _parseString(jp, ctxt);
             }
            if (ix >= chunk.length) {
                chunk = buffer.appendCompletedChunk(chunk);
                ix = 0;
            }
            chunk[ix++] = value;
        }
        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
        ctxt.returnObjectBuffer(buffer);
        return result;
    }","@Override
public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
    // Ensure the parser points to START_ARRAY
    if (!jp.isExpectedStartArrayToken()) {
        return handleNonArray(jp, ctxt);
    }
    if (_elementDeserializer != null) {
        return _deserializeCustom(jp, ctxt);
    }

    final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
    Object[] chunk = buffer.resetAndStart();

    int ix = 0;
    JsonToken t;

    while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
        String value;

        if (t == JsonToken.VALUE_STRING) {
            value = jp.getText();
        } else if (t == JsonToken.VALUE_NULL) {
            value = _elementDeserializer == null ? null : _elementDeserializer.getNullValue();
        } else {
            value = _parseString(jp, ctxt);
        }

        if (ix >= chunk.length) {
            chunk = buffer.appendCompletedChunk(chunk);
            ix = 0;
        }
        chunk[ix++] = value;
    }

    String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
    ctxt.returnObjectBuffer(buffer);
    return result;
}",0,0
189,JacksonDatabind_3,"protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();
        final JsonDeserializer<String> deser = _elementDeserializer;
        
        int ix = 0;
        JsonToken t;
         
         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
             // Ok: no need to convert Strings, but must recognize nulls
             String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);
             if (ix >= chunk.length) {
                 chunk = buffer.appendCompletedChunk(chunk);
                 ix = 0;
            }
            chunk[ix++] = value;
        }
        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
        ctxt.returnObjectBuffer(buffer);
        return result;
    }","protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException {
    final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
    Object[] chunk = buffer.resetAndStart();
    final JsonDeserializer<String> deser = _elementDeserializer;

    int ix = 0;
    JsonToken t;

    while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
        String value;

        if (t == JsonToken.VALUE_NULL) {
            value = deser == null ? null : deser.getNullValue();
        } else {
            value = deser.deserialize(jp, ctxt);
        }

        if (ix >= chunk.length) {
            chunk = buffer.appendCompletedChunk(chunk);
            ix = 0;
        }
        chunk[ix++] = value;
    }

    String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
    ctxt.returnObjectBuffer(buffer);
    return result;
}",0,0
190,JacksonDatabind_30,"@SuppressWarnings(""resource"")
    protected Object _convert(Object fromValue, JavaType toValueType)
        throws IllegalArgumentException
    {        
        // also, as per [Issue-11], consider case for simple cast
        /* But with caveats: one is that while everything is Object.class, we don't
         * want to ""optimize"" that out; and the other is that we also do not want
         * to lose conversions of generic types.
         */
        Class<?> targetType = toValueType.getRawClass();
        if (targetType != Object.class
                && !toValueType.hasGenericTypes()
                && targetType.isAssignableFrom(fromValue.getClass())) {
            return fromValue;
        }
         
         // Then use TokenBuffer, which is a JsonGenerator:
         TokenBuffer buf = new TokenBuffer(this, false);
         try {
             // inlined 'writeValue' with minor changes:
             // first: disable wrapping when writing
            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
            // no need to check for closing of TokenBuffer
            _serializerProvider(config).serializeValue(buf, fromValue);

            // then matching read, inlined 'readValue' with minor mods:
            final JsonParser jp = buf.asParser();
            Object result;
            // ok to pass in existing feature flags; unwrapping handled by mapper
            final DeserializationConfig deserConfig = getDeserializationConfig();
            JsonToken t = _initForReading(jp);
            if (t == JsonToken.VALUE_NULL) {
                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);
                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
                result = null;
            } else { // pointing to event other than null
                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);
                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);
                // note: no handling of unwarpping
                result = deser.deserialize(jp, ctxt);
            }
            jp.close();
            return result;
        } catch (IOException e) { // should not occur, no real i/o...
            throw new IllegalArgumentException(e.getMessage(), e);
        }
    }","@SuppressWarnings(""resource"")
protected Object _convert(Object fromValue, JavaType toValueType)
        throws IllegalArgumentException {
    // check for null 'fromValue' and early exit when it is
    if (fromValue == null) {
        return null;
    }
    
    // also, as per [Issue-11], consider case for simple cast
    /* But with caveats: one is that while everything is Object.class, we don't
     * want to ""optimize"" that out; and the other is that we also do not want
     * to lose conversions of generic types.
     */
    Class<?> targetType = toValueType.getRawClass();
    if (targetType != Object.class
            && !toValueType.hasGenericTypes()
            && targetType.isAssignableFrom(fromValue.getClass())) {
        return fromValue;
    }

    // Then use TokenBuffer, which is a JsonGenerator:
    TokenBuffer buf = new TokenBuffer(this, false);
    try {
        // inlined 'writeValue' with minor changes:
        // first: disable wrapping when writing
        SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
        // no need to check for closing of TokenBuffer
        _serializerProvider(config).serializeValue(buf, fromValue);

        // then matching read, inlined 'readValue' with minor mods:
        final JsonParser jp = buf.asParser();
        Object result;
        try { // ensure parser is always closed
            final DeserializationConfig deserConfig = getDeserializationConfig();
            JsonToken t = _initForReading(jp);
            if (t == JsonToken.VALUE_NULL) {
                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);
                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
                result = null;
            } else { // pointing to event other than null
                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);
                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);
                // note: no handling of unwrapping
                result = deser.deserialize(jp, ctxt);
            }
        } finally {
            jp.close();
        }
        return result;
    } catch (IOException e) { // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}",0,0
190,JacksonDatabind_30,"@SuppressWarnings({ ""unchecked"", ""resource"" })
    public <T extends JsonNode> T valueToTree(Object fromValue)
        throws IllegalArgumentException
     {
         if (fromValue == null) return null;
         TokenBuffer buf = new TokenBuffer(this, false);
         JsonNode result;
         try {
             writeValue(buf, fromValue);
            JsonParser jp = buf.asParser();
            result = readTree(jp);
            jp.close();
        } catch (IOException e) { // should not occur, no real i/o...
            throw new IllegalArgumentException(e.getMessage(), e);
        }
        return (T) result;
    }","@SuppressWarnings({ ""unchecked"", ""resource"" })
public <T extends JsonNode> T valueToTree(Object fromValue)
        throws IllegalArgumentException {
    if (fromValue == null) return null;
    TokenBuffer buf = new TokenBuffer(this, false);
    JsonNode result;
    try {
        writeValue(buf, fromValue);
        JsonParser jp = buf.asParser();
        try { // ensure parser is always closed
            result = readTree(jp);
        } finally {
            jp.close();
        }
    } catch (IOException e) { // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
    return (T) result;
}",0,0
190,JacksonDatabind_30,"@Override
    public void copyCurrentEvent(JsonParser p) throws IOException
    {
        if (_mayHaveNativeIds) {
            _checkNativeIds(p);
        }
        switch (p.getCurrentToken()) {
        case START_OBJECT:
            writeStartObject();
            break;
        case END_OBJECT:
            writeEndObject();
            break;
        case START_ARRAY:
            writeStartArray();
            break;
        case END_ARRAY:
            writeEndArray();
            break;
        case FIELD_NAME:
            writeFieldName(p.getCurrentName());
            break;
        case VALUE_STRING:
            if (p.hasTextCharacters()) {
                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());
            } else {
                writeString(p.getText());
            }
            break;
        case VALUE_NUMBER_INT:
            switch (p.getNumberType()) {
            case INT:
                writeNumber(p.getIntValue());
                break;
            case BIG_INTEGER:
                writeNumber(p.getBigIntegerValue());
                break;
            default:
                writeNumber(p.getLongValue());
             }
             break;
         case VALUE_NUMBER_FLOAT:
                 /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying
                  *   number is already decoded into a number (in which case might as well
                  *   access as number); or is still retained as text (in which case we
                  *   should further defer decoding that may not need BigDecimal):
                  */
                 switch (p.getNumberType()) {
                 case BIG_DECIMAL:
                     writeNumber(p.getDecimalValue());
                    break;
                case FLOAT:
                    writeNumber(p.getFloatValue());
                    break;
                default:
                    writeNumber(p.getDoubleValue());
            }
            break;
        case VALUE_TRUE:
            writeBoolean(true);
            break;
        case VALUE_FALSE:
            writeBoolean(false);
            break;
        case VALUE_NULL:
            writeNull();
            break;
        case VALUE_EMBEDDED_OBJECT:
            writeObject(p.getEmbeddedObject());
            break;
        default:
            throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }","@Override
public void copyCurrentEvent(JsonParser p) throws IOException {
    if (_mayHaveNativeIds) {
        _checkNativeIds(p);
    }
    switch (p.getCurrentToken()) {
        case START_OBJECT:
            writeStartObject();
            break;
        case END_OBJECT:
            writeEndObject();
            break;
        case START_ARRAY:
            writeStartArray();
            break;
        case END_ARRAY:
            writeEndArray();
            break;
        case FIELD_NAME:
            writeFieldName(p.getCurrentName());
            break;
        case VALUE_STRING:
            if (p.hasTextCharacters()) {
                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());
            } else {
                writeString(p.getText());
            }
            break;
        case VALUE_NUMBER_INT:
            switch (p.getNumberType()) {
                case INT:
                    writeNumber(p.getIntValue());
                    break;
                case BIG_INTEGER:
                    writeNumber(p.getBigIntegerValue());
                    break;
                case LONG: // Fix added: explicitly handling LONG case
                    writeNumber(p.getLongValue());
                    break;
                default:
                    throw new RuntimeException(""Unexpected number type for VALUE_NUMBER_INT"");
            }
            break;
        case VALUE_NUMBER_FLOAT:
            /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying
             *   number is already decoded into a number (in which case might as well
             *   access as number); or is still retained as text (in which case we
             *   should further defer decoding that may not need BigDecimal):
             */
            switch (p.getNumberType()) {
                case BIG_DECIMAL:
                    writeNumber(p.getDecimalValue());
                    break;
                case FLOAT:
                    writeNumber(p.getFloatValue());
                    break;
                case DOUBLE:
                    writeNumber(p.getDoubleValue());
                    break;
                default:
                    throw new RuntimeException(""Unexpected number type for VALUE_NUMBER_FLOAT"");
            }
            break;
        case VALUE_TRUE:
            writeBoolean(true);
            break;
        case VALUE_FALSE:
            writeBoolean(false);
            break;
        case VALUE_NULL:
            writeNull();
            break;
        case VALUE_EMBEDDED_OBJECT:
            writeObject(p.getEmbeddedObject());
            break;
        default:
            throw new RuntimeException(""Unexpected token: "" + p.getCurrentToken());
    }
}",0,0
191,JacksonDatabind_31,"@Override
    public void writeString(SerializableString text) throws IOException {
         if (text == null) {
             writeNull();
         } else {
             _append(JsonToken.VALUE_STRING, text);
         }
     }","@Override
public void writeString(SerializableString text) throws IOException {
    if (text == null) {
        writeNull();
    } else {
        _append(JsonToken.VALUE_STRING, text.getValue());
    }
}",0,0
191,JacksonDatabind_31,"@Override
    public void writeObject(Object value) throws IOException
    {
        if (value == null) {
            writeNull();
            return;
        }
        Class<?> raw = value.getClass();
        if (raw == byte[].class || (value instanceof RawValue)) {
            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
            return;
        }
        if (_objectCodec == null) {
            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we
              *   err out, or just embed? For now, do latter.
              */
 //          throw new JsonMappingException(""No ObjectCodec configured for TokenBuffer, writeObject() called"");
             _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
         } else {
             _objectCodec.writeValue(this, value);
         }
    }","@Override
public void writeObject(Object value) throws IOException {
    if (value == null) {
        writeNull();
        return;
    }
    Class<?> raw = value.getClass();
    if (raw == byte[].class || (value instanceof RawValue)) {
        _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
        return;
    }
    if (_objectCodec == null) {
        _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
    } else {
        _objectCodec.writeValue(this, value);
    }
}",0,0
191,JacksonDatabind_31,"@Override
    public void writeTree(TreeNode node) throws IOException
    {
        if (node == null) {
            writeNull();
            return;
        }
 
         if (_objectCodec == null) {
             // as with 'writeObject()', is codec optional?
             _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);
         } else {
             _objectCodec.writeTree(this, node);
         }
    }","@Override
public void writeTree(TreeNode node) throws IOException {
    if (node == null) {
        writeNull();
        return;
    }
    if (_objectCodec == null) {
        _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);
    } else {
        _objectCodec.writeTree(this, node);
    }
}",0,0
191,JacksonDatabind_31,"@Override
    public void writeString(String text) throws IOException {
         if (text == null) {
             writeNull();
         } else {
             _append(JsonToken.VALUE_STRING, text);
         }
     }","@Override
public void writeString(String text) throws IOException {
    if (text == null) {
        writeNull();
    } else {
        _append(JsonToken.VALUE_STRING, text);
    }
}",0,0
191,JacksonDatabind_31,"@Override
    public void writeNumber(BigDecimal dec) throws IOException {
         if (dec == null) {
             writeNull();
         } else {
             _append(JsonToken.VALUE_NUMBER_FLOAT, dec);
         }
     }","@Override
public void writeNumber(BigDecimal dec) throws IOException {
    if (dec == null) {
        writeNull();
    } else {
        _append(JsonToken.VALUE_NUMBER_FLOAT, dec);
    }
}",0,0
191,JacksonDatabind_31,"@Override
    public void writeNumber(BigInteger v) throws IOException {
         if (v == null) {
             writeNull();
         } else {
             _append(JsonToken.VALUE_NUMBER_INT, v);
         }
     }","@Override
public void writeNumber(BigInteger v) throws IOException {
    if (v == null) {
        writeNull();
    } else {
        _append(JsonToken.VALUE_NUMBER_INT, v);
    }
}",0,0
192,JacksonDatabind_32,"@Override
        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
        {
            switch (p.getCurrentTokenId()) {
            case JsonTokenId.ID_START_OBJECT:
                {
                    JsonToken t = p.nextToken();
                    if (t == JsonToken.END_OBJECT) {
                        return new LinkedHashMap<String,Object>(2);
                    }
                }
            case JsonTokenId.ID_FIELD_NAME:
                return mapObject(p, ctxt);
            case JsonTokenId.ID_START_ARRAY:
                {
                    JsonToken t = p.nextToken();
                    if (t == JsonToken.END_ARRAY) { // and empty one too
                        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                            return NO_OBJECTS;
                        }
                        return new ArrayList<Object>(2);
                    }
                }
                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                    return mapArrayToArray(p, ctxt);
                }
                return mapArray(p, ctxt);
            case JsonTokenId.ID_EMBEDDED_OBJECT:
                return p.getEmbeddedObject();
            case JsonTokenId.ID_STRING:
                return p.getText();

            case JsonTokenId.ID_NUMBER_INT:
                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {
                    return _coerceIntegral(p, ctxt);
                }
                return p.getNumberValue(); // should be optimal, whatever it is

            case JsonTokenId.ID_NUMBER_FLOAT:
                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
                    return p.getDecimalValue();
                }
                return Double.valueOf(p.getDoubleValue());

            case JsonTokenId.ID_TRUE:
                return Boolean.TRUE;
            case JsonTokenId.ID_FALSE:
                return Boolean.FALSE;

             case JsonTokenId.ID_NULL: // should not get this but...
                 return null;
 
                 // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),
                 //    if caller has advanced to the first token of Object, but for empty Object
 
             //case JsonTokenId.ID_END_ARRAY: // invalid
             default:
                throw ctxt.mappingException(Object.class);
            }
        }","@Override
public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    switch (p.getCurrentTokenId()) {
        case JsonTokenId.ID_START_OBJECT:
            {
                JsonToken t = p.nextToken();
                if (t == JsonToken.END_OBJECT) {
                    return new LinkedHashMap<String, Object>(2);
                }
                p.previousToken(); // Rewind the parser if the object is not empty
            }
            // Fall-through to handle the object fields
        case JsonTokenId.ID_FIELD_NAME:
            return mapObject(p, ctxt);
        case JsonTokenId.ID_START_ARRAY:
            {
                JsonToken t = p.nextToken();
                if (t == JsonToken.END_ARRAY) { // Handle empty array
                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                        return NO_OBJECTS;
                    }
                    return new ArrayList<Object>(2);
                }
                p.previousToken(); // Rewind the parser for non-empty arrays
            }
            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                return mapArrayToArray(p, ctxt);
            }
            return mapArray(p, ctxt);
        case JsonTokenId.ID_EMBEDDED_OBJECT:
            return p.getEmbeddedObject();
        case JsonTokenId.ID_STRING:
            return p.getText();
        case JsonTokenId.ID_NUMBER_INT:
            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {
                return _coerceIntegral(p, ctxt);
            }
            return p.getNumberValue();
        case JsonTokenId.ID_NUMBER_FLOAT:
            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
                return p.getDecimalValue();
            }
            return Double.valueOf(p.getDoubleValue());
        case JsonTokenId.ID_TRUE:
            return Boolean.TRUE;
        case JsonTokenId.ID_FALSE:
            return Boolean.FALSE;
        case JsonTokenId.ID_NULL:
            return null;
        default:
            throw ctxt.mappingException(Object.class);
    }
}",0,0
192,JacksonDatabind_32,"@Override
    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        switch (p.getCurrentTokenId()) {
        case JsonTokenId.ID_START_OBJECT:
         case JsonTokenId.ID_FIELD_NAME:
             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),
             //    if caller has advanced to the first token of Object, but for empty Object
             if (_mapDeserializer != null) {
                 return _mapDeserializer.deserialize(p, ctxt);
             }
            return mapObject(p, ctxt);
        case JsonTokenId.ID_START_ARRAY:
            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                return mapArrayToArray(p, ctxt);
            }
            if (_listDeserializer != null) {
                return _listDeserializer.deserialize(p, ctxt);
            }
            return mapArray(p, ctxt);
        case JsonTokenId.ID_EMBEDDED_OBJECT:
            return p.getEmbeddedObject();
        case JsonTokenId.ID_STRING:
            if (_stringDeserializer != null) {
                return _stringDeserializer.deserialize(p, ctxt);
            }
            return p.getText();

        case JsonTokenId.ID_NUMBER_INT:
            if (_numberDeserializer != null) {
                return _numberDeserializer.deserialize(p, ctxt);
            }
            /* Caller may want to get all integral values returned as {@link java.math.BigInteger},
             * or {@link java.lang.Long} for consistency
             */
            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {
                return _coerceIntegral(p, ctxt);
            }
            return p.getNumberValue(); // should be optimal, whatever it is

        case JsonTokenId.ID_NUMBER_FLOAT:
            if (_numberDeserializer != null) {
                return _numberDeserializer.deserialize(p, ctxt);
            }
            /* [JACKSON-72]: need to allow overriding the behavior regarding
             *   which type to use
             */
            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
                return p.getDecimalValue();
            }
            return p.getDoubleValue();

        case JsonTokenId.ID_TRUE:
            return Boolean.TRUE;
        case JsonTokenId.ID_FALSE:
            return Boolean.FALSE;

        case JsonTokenId.ID_NULL: // should not get this but...
            return null;

//        case JsonTokenId.ID_END_ARRAY: // invalid
        default:
        }
        throw ctxt.mappingException(Object.class);
    }","@Override
public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    switch (p.getCurrentTokenId()) {
        case JsonTokenId.ID_START_OBJECT:
        case JsonTokenId.ID_FIELD_NAME:
            {
                JsonToken t = p.getCurrentToken();
                if (t == JsonToken.START_OBJECT) {
                    t = p.nextToken();
                    if (t == JsonToken.END_OBJECT) {
                        return new LinkedHashMap<String, Object>(); // Handle empty objects
                    }
                    p.previousToken(); // Rewind if the object is not empty
                }
            }
            if (_mapDeserializer != null) {
                return _mapDeserializer.deserialize(p, ctxt);
            }
            return mapObject(p, ctxt);
        case JsonTokenId.ID_START_ARRAY:
            {
                JsonToken t = p.nextToken();
                if (t == JsonToken.END_ARRAY) { // Handle empty arrays
                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                        return NO_OBJECTS;
                    }
                    return new ArrayList<Object>(2);
                }
                p.previousToken(); // Rewind the parser for non-empty arrays
            }
            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                return mapArrayToArray(p, ctxt);
            }
            if (_listDeserializer != null) {
                return _listDeserializer.deserialize(p, ctxt);
            }
            return mapArray(p, ctxt);
        case JsonTokenId.ID_EMBEDDED_OBJECT:
            return p.getEmbeddedObject();
        case JsonTokenId.ID_STRING:
            if (_stringDeserializer != null) {
                return _stringDeserializer.deserialize(p, ctxt);
            }
            return p.getText();
        case JsonTokenId.ID_NUMBER_INT:
            if (_numberDeserializer != null) {
                return _numberDeserializer.deserialize(p, ctxt);
            }
            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {
                return _coerceIntegral(p, ctxt);
            }
            return p.getNumberValue();
        case JsonTokenId.ID_NUMBER_FLOAT:
            if (_numberDeserializer != null) {
                return _numberDeserializer.deserialize(p, ctxt);
            }
            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
                return p.getDecimalValue();
            }
            return p.getDoubleValue();
        case JsonTokenId.ID_TRUE:
            return Boolean.TRUE;
        case JsonTokenId.ID_FALSE:
            return Boolean.FALSE;
        case JsonTokenId.ID_NULL:
            return null;
        default:
            throw ctxt.mappingException(Object.class);
    }
}",0,0
193,JacksonDatabind_36,"private final static DateFormat _cloneFormat(DateFormat df, String format,
            TimeZone tz, Locale loc, Boolean lenient)
    {
        if (!loc.equals(DEFAULT_LOCALE)) {
            df = new SimpleDateFormat(format, loc);
            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);
        } else {
            df = (DateFormat) df.clone();
            if (tz != null) {
                 df.setTimeZone(tz);
             }
         }
         return df;
     }","private final static DateFormat _cloneFormat(DateFormat df, String format,
            TimeZone tz, Locale loc, Boolean lenient)
    {
        if (loc != null && !loc.equals(DEFAULT_LOCALE)) {
            df = new SimpleDateFormat(format, loc);
        } else if (format != null) {
            df = new SimpleDateFormat(format);
        } else {
            df = (DateFormat) df.clone();
        }
        
        if (tz != null) {
            df.setTimeZone(tz);
        } else {
            df.setTimeZone(DEFAULT_TIMEZONE);
        }
        
        if (lenient != null) {
            df.setLenient(lenient);
        }
        
        return df;
    }",0,0
194,JacksonDatabind_38,"@Deprecated
    public static SimpleType construct(Class<?> cls)
    {
        /* Let's add sanity checks, just to ensure no
         * Map/Collection entries are constructed
         */
        if (Map.class.isAssignableFrom(cls)) {
            throw new IllegalArgumentException(""Can not construct SimpleType for a Map (class: ""+cls.getName()+"")"");
        }
        if (Collection.class.isAssignableFrom(cls)) {
            throw new IllegalArgumentException(""Can not construct SimpleType for a Collection (class: ""+cls.getName()+"")"");
        }
        // ... and while we are at it, not array types either
         if (cls.isArray()) {
             throw new IllegalArgumentException(""Can not construct SimpleType for an array (class: ""+cls.getName()+"")"");
         }
         return new SimpleType(cls, TypeBindings.emptyBindings(),
                 _bogusSuperClass(cls), null, null, null, false);
     }","@Deprecated
public static SimpleType construct(Class<?> cls) {
    /* Let's add sanity checks, just to ensure no
     * Map/Collection entries are constructed
     */
    if (Map.class.isAssignableFrom(cls)) {
        throw new IllegalArgumentException(""Can not construct SimpleType for a Map (class: "" + cls.getName() + "")"");
    }
    if (Collection.class.isAssignableFrom(cls)) {
        throw new IllegalArgumentException(""Can not construct SimpleType for a Collection (class: "" + cls.getName() + "")"");
    }
    // ... and while we are at it, not array types either
    if (cls.isArray()) {
        throw new IllegalArgumentException(""Can not construct SimpleType for an array (class: "" + cls.getName() + "")"");
    }
    return new SimpleType(cls, TypeBindings.emptyBindings(),
            _bogusSuperClass(cls), null, null, null, false);
}",0,0
194,JacksonDatabind_38,"@Deprecated // since 2.7
     public static CollectionType construct(Class<?> rawType, JavaType elemT) {
         // First: may need to fabricate TypeBindings (needed for refining into
         // concrete collection types, as per [databind#1102])
         return new CollectionType(rawType, null,
                 // !!! TODO: Wrong, does have supertypes, but:
                 _bogusSuperClass(rawType), null, elemT,
                 null, null, false);
    }","@Deprecated // since 2.7
public static CollectionType construct(Class<?> rawType, JavaType elemT) {
    // First: may need to fabricate TypeBindings (needed for refining into
    // concrete collection types, as per [databind#1102])
    TypeBindings bindings = TypeBindings.create(rawType, elemT);
    return new CollectionType(rawType, bindings,
            _bogusSuperClass(rawType), null, elemT,
            null, null, false);
}",0,0
194,JacksonDatabind_38,"@Deprecated // since 2.7
    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)
     {
         // First: may need to fabricate TypeBindings (needed for refining into
         // concrete collection types, as per [databind#1102])
         // !!! TODO: Wrong, does have supertypes
         return new MapType(rawType, null, _bogusSuperClass(rawType), null,
                 keyT, valueT, null, null, false);
     }","@Deprecated // since 2.7
public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {
    // First: may need to fabricate TypeBindings (needed for refining into
    // concrete collection types, as per [databind#1102])
    TypeBindings bindings = TypeBindings.create(rawType, keyT, valueT);
    return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,
            keyT, valueT, null, null, false);
}",0,0
195,JacksonDatabind_4,"@Override
    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        // Ok: must point to START_ARRAY (or equivalent)
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt);
        }
        if (_elementDeserializer != null) {
            return _deserializeCustom(jp, ctxt);
        }

        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();

        int ix = 0;
        JsonToken t;

            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
                // Ok: no need to convert Strings, but must recognize nulls
                String value;
                if (t == JsonToken.VALUE_STRING) {
                    value = jp.getText();
                } else if (t == JsonToken.VALUE_NULL) {
                    value = null; // since we have established that '_elementDeserializer == null' earlier
                } else {
                    value = _parseString(jp, ctxt);
                }
                if (ix >= chunk.length) {
                    chunk = buffer.appendCompletedChunk(chunk);
                    ix = 0;
                 }
                 chunk[ix++] = value;
             }
             // note: pass String.class, not String[].class, as we need element type for error info
         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
         ctxt.returnObjectBuffer(buffer);
         return result;
    }","@Override
public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
    // Ok: must point to START_ARRAY (or equivalent)
    if (!jp.isExpectedStartArrayToken()) {
        return handleNonArray(jp, ctxt);
    }
    if (_elementDeserializer != null) {
        return _deserializeCustom(jp, ctxt);
    }

    final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
    Object[] chunk = buffer.resetAndStart();

    int ix = 0;
    JsonToken t;

    try {
        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
            // Ok: no need to convert Strings, but must recognize nulls
            String value;
            if (t == JsonToken.VALUE_STRING) {
                value = jp.getText();
            } else if (t == JsonToken.VALUE_NULL) {
                value = null; // since we have established that '_elementDeserializer == null' earlier
            } else {
                value = _parseString(jp, ctxt);
            }
            if (ix >= chunk.length) {
                chunk = buffer.appendCompletedChunk(chunk);
                ix = 0;
            }
            chunk[ix++] = value;
        }
    } catch (Exception e) {
        ctxt.returnObjectBuffer(buffer);
        throw e;
    }

    // note: pass String.class, not String[].class, as we need element type for error info
    String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
    ctxt.returnObjectBuffer(buffer);
    return result;
}",0,0
195,JacksonDatabind_4,"/**
     * Offlined version used when we do not use the default deserialization method.
     */
    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();
        final JsonDeserializer<String> deser = _elementDeserializer;
        
        int ix = 0;
        JsonToken t;

            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
                // Ok: no need to convert Strings, but must recognize nulls
                String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);
                if (ix >= chunk.length) {
                    chunk = buffer.appendCompletedChunk(chunk);
                    ix = 0;
                 }
                 chunk[ix++] = value;
             }
             // note: pass String.class, not String[].class, as we need element type for error info
         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);","protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException {
    final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
    Object[] chunk = buffer.resetAndStart();
    final JsonDeserializer<String> deser = _elementDeserializer;

    int ix = 0;
    JsonToken t;

    try {
        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
            // Ok: no need to convert Strings, but must recognize nulls
            String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(jp, ctxt);
            if (ix >= chunk.length) {
                chunk = buffer.appendCompletedChunk(chunk);
                ix = 0;
            }
            chunk[ix++] = value;
        }
    } catch (Exception e) {
        ctxt.returnObjectBuffer(buffer);
        throw e;
    }

    // note: pass String.class, not String[].class, as we need element type for error info
    String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
    ctxt.returnObjectBuffer(buffer);
    return result;
}",0,0
195,JacksonDatabind_4,"protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();
        final JsonDeserializer<String> deser = _elementDeserializer;
        
         int ix = 0;
         JsonToken t;
 
             while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
                 // Ok: no need to convert Strings, but must recognize nulls
                 String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);
                if (ix >= chunk.length) {
                    chunk = buffer.appendCompletedChunk(chunk);
                    ix = 0;
                }
                chunk[ix++] = value;
            }
            // note: pass String.class, not String[].class, as we need element type for error info
        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
        ctxt.returnObjectBuffer(buffer);
        return result;
    }","protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException {
    final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
    Object[] chunk = buffer.resetAndStart();
    final JsonDeserializer<String> deser = _elementDeserializer;

    int ix = 0;
    JsonToken t;

    try {
        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
            // Ok: no need to convert Strings, but must recognize nulls
            String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(jp, ctxt);
            if (ix >= chunk.length) {
                chunk = buffer.appendCompletedChunk(chunk);
                ix = 0;
            }
            chunk[ix++] = value;
        }
    } catch (Exception e) {
        ctxt.returnObjectBuffer(buffer);
        throw e;
    }

    // note: pass String.class, not String[].class, as we need element type for error info
    String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
    ctxt.returnObjectBuffer(buffer);
    return result;
}",0,0
196,JacksonDatabind_40,"        public final T getNullValue() {
            return _nullValue;
        }
","public final T getNullValue() {
    // Ensure that _nullValue is not uninitialized
    if (_nullValue == null) {
        throw new IllegalStateException(""Null value has not been initialized."");
    }
    return _nullValue;
}",0,0
197,JacksonDatabind_41,"    public JavaType constructType(Type type, Class<?> contextClass) {
        return constructType(type, constructType(contextClass));
    }
","public JavaType constructType(Type type, Class<?> contextClass) {
    if (contextClass == null) {
        return constructType(type, TypeBindings.emptyBindings());
    }
    return constructType(type, constructType(contextClass).getBindings());
}",0,0
197,JacksonDatabind_41,"    public JavaType constructType(Type type, JavaType contextType) {
        return _fromAny(null, type, contextType.getBindings());
    }
","public JavaType constructType(Type type, JavaType contextType) {
    if (contextType == null) {
        return _fromAny(null, type, TypeBindings.emptyBindings());
    }
    return _fromAny(null, type, contextType.getBindings());
}",0,0
198,JacksonDatabind_43,"@Override
     public Object deserializeSetAndReturn(JsonParser p,
     		DeserializationContext ctxt, Object instance) throws IOException
     {
         Object id = _valueDeserializer.deserialize(p, ctxt);
         /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;
          *  missing or null id is needed for some cases, such as cases where id
          *  will be generated externally, at a later point, and is not available
          *  quite yet. Typical use case is with DB inserts.
          */
         // note: no null checks (unlike usually); deserializer should fail if one found
         if (id == null) {
             return null;
         }
         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);
         roid.bindItem(instance);
         // also: may need to set a property value as well
        SettableBeanProperty idProp = _objectIdReader.idProperty;
        if (idProp != null) {
            return idProp.setAndReturn(instance, id);
        }
        return instance;
    }","@Override
public Object deserializeSetAndReturn(JsonParser p,
        DeserializationContext ctxt, Object instance) throws IOException {
    // Deserialize the value
    Object id = _valueDeserializer.deserialize(p, ctxt);
    
    // Handle null ID case appropriately
    if (id == null) {
        return instance; // Return the original instance when ID is null
    }
    
    // Find the object ID and bind it to the instance
    ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);
    if (roid == null) {
        throw new IOException(""Unable to find ObjectId for ID: "" + id);
    }
    roid.bindItem(instance);
    
    // If there is an ID property, set its value
    SettableBeanProperty idProp = _objectIdReader.idProperty;
    if (idProp != null) {
        return idProp.setAndReturn(instance, id);
    }
    
    return instance;
}",0,0
199,JacksonDatabind_48,"@Override
    public VisibilityChecker<?> getDefaultVisibilityChecker()
     {
         VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();
         // then global overrides (disabling)
         if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {
             vchecker = vchecker.withGetterVisibility(Visibility.NONE);
         }
        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {
            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);
        }
        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {
            vchecker = vchecker.withFieldVisibility(Visibility.NONE);
        }
        return vchecker;
    }","@Override
public VisibilityChecker<?> getDefaultVisibilityChecker() {
    VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();
    if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {
        vchecker = vchecker.withGetterVisibility(Visibility.NONE);
    }
    if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {
        vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);
    }
    if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {
        vchecker = vchecker.withFieldVisibility(Visibility.NONE);
    }
    return vchecker;
}",0,0
199,JacksonDatabind_48,"@Override
    public VisibilityChecker<?> getDefaultVisibilityChecker()
    {
        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();
        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {
            vchecker = vchecker.withSetterVisibility(Visibility.NONE);
        }
         if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {
             vchecker = vchecker.withCreatorVisibility(Visibility.NONE);
         }
         if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {
             vchecker = vchecker.withFieldVisibility(Visibility.NONE);
         }
        return vchecker;
    }","@Override
public VisibilityChecker<?> getDefaultVisibilityChecker() {
    VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();
    if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {
        vchecker = vchecker.withSetterVisibility(Visibility.NONE);
    }
    if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {
        vchecker = vchecker.withCreatorVisibility(Visibility.NONE);
    }
    if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {
        vchecker = vchecker.withFieldVisibility(Visibility.NONE);
    }
    return vchecker;
}",0,0
200,JacksonDatabind_50,"@Override
    @SuppressWarnings(""resource"")
    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)
        throws IOException
    {
        final PropertyBasedCreator creator = _propertyBasedCreator;
        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

        TokenBuffer unknown = null;

        JsonToken t = p.getCurrentToken();
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            p.nextToken(); // to point to value
            // creator property?
            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
            if (creatorProp != null) {
                // Last creator property to set?
                if (buffer.assignParameter(creatorProp,
                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                    Object bean;
                    try {
                        bean = creator.build(ctxt, buffer);
                    } catch (Exception e) {
                        bean = wrapInstantiationProblem(e, ctxt);
                    }
                    if (bean == null) {
                        return ctxt.handleInstantiationProblem(handledType(), null,
                                _creatorReturnedNullException());
                    }
                    // [databind#631]: Assign current value, to be accessible by custom serializers
                    p.setCurrentValue(bean);

                    //  polymorphic?
                    if (bean.getClass() != _beanType.getRawClass()) {
                        return handlePolymorphic(p, ctxt, bean, unknown);
                    }
                    if (unknown != null) { // nope, just extra unknown stuff...
                        bean = handleUnknownProperties(ctxt, bean, unknown);
                    }
                    // or just clean?
                    return deserialize(p, ctxt, bean);
                }
                continue;
            }
            // Object Id property?
            if (buffer.readIdProperty(propName)) {
                continue;
            }
            // regular property? needs buffering
            SettableBeanProperty prop = _beanProperties.find(propName);
            if (prop != null) {
                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
                    // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional
                    //    handling of forward references here. Not exactly sure why existing
                    //    facilities did not cover, but this does appear to solve the problem
                continue;
            }
            // Things marked as ignorable should not be passed to any setter
            if (_ignorableProps != null && _ignorableProps.contains(propName)) {
                handleIgnoredProperty(p, ctxt, handledType(), propName);
                continue;
            }
            // ""any property""?
            if (_anySetter != null) {
                try {
                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
                } catch (Exception e) {
                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                }
                continue;
            }
            // Ok then, let's collect the whole field; name and value
            if (unknown == null) {
                unknown = new TokenBuffer(p, ctxt);
            }
            unknown.writeFieldName(propName);
            unknown.copyCurrentStructure(p);
        }

        // We hit END_OBJECT, so:
        Object bean;
        try {
            bean =  creator.build(ctxt, buffer);
        } catch (Exception e) {
             wrapInstantiationProblem(e, ctxt);
             bean = null; // never gets here
         }
         if (unknown != null) {
             // polymorphic?
             if (bean.getClass() != _beanType.getRawClass()) {
                return handlePolymorphic(null, ctxt, bean, unknown);
            }
            // no, just some extra unknown properties
            return handleUnknownProperties(ctxt, bean, unknown);
        }
        return bean;
    }","@Override
@SuppressWarnings(""resource"")
protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)
    throws IOException
{
    final PropertyBasedCreator creator = _propertyBasedCreator;
    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

    TokenBuffer unknown = null;

    JsonToken t = p.getCurrentToken();
    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
        String propName = p.getCurrentName();
        p.nextToken(); // to point to value

        // creator property?
        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
        if (creatorProp != null) {
            if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                Object bean;
                try {
                    bean = creator.build(ctxt, buffer);
                } catch (Exception e) {
                    bean = wrapInstantiationProblem(e, ctxt);
                }
                if (bean == null) {
                    return ctxt.handleInstantiationProblem(handledType(), null, _creatorReturnedNullException());
                }
                p.setCurrentValue(bean);

                // polymorphic?
                if (bean.getClass() != _beanType.getRawClass()) {
                    return handlePolymorphic(p, ctxt, bean, unknown);
                }
                if (unknown != null) {
                    bean = handleUnknownProperties(ctxt, bean, unknown);
                }
                return bean; // Fixed by avoiding deserializing again unnecessarily
            }
            continue;
        }

        // Object Id property?
        if (buffer.readIdProperty(propName)) {
            continue;
        }

        // regular property? needs buffering
        SettableBeanProperty prop = _beanProperties.find(propName);
        if (prop != null) {
            buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
            continue;
        }

        // Ignorable property
        if (_ignorableProps != null && _ignorableProps.contains(propName)) {
            handleIgnoredProperty(p, ctxt, handledType(), propName);
            continue;
        }

        // ""any property""?
        if (_anySetter != null) {
            try {
                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
            } catch (Exception e) {
                wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
            }
            continue;
        }

        // Collect unknown fields
        if (unknown == null) {
            unknown = new TokenBuffer(p, ctxt);
        }
        unknown.writeFieldName(propName);
        unknown.copyCurrentStructure(p);
    }

    Object bean;
    try {
        bean = creator.build(ctxt, buffer);
    } catch (Exception e) {
        bean = wrapInstantiationProblem(e, ctxt); // Ensure proper handling for errors during invocation
    }
    if (bean == null) {
        return ctxt.handleInstantiationProblem(handledType(), null, _creatorReturnedNullException());
    }

    if (unknown != null) {
        if (bean.getClass() != _beanType.getRawClass()) {
            return handlePolymorphic(null, ctxt, bean, unknown);
        }
        return handleUnknownProperties(ctxt, bean, unknown);
    }
    return bean;
}",0,0
201,JacksonDatabind_52,"@Override
    public void resolve(DeserializationContext ctxt)
        throws JsonMappingException
    {
        ExternalTypeHandler.Builder extTypes = null;
        // if ValueInstantiator can use ""creator"" approach, need to resolve it here...
        SettableBeanProperty[] creatorProps;

        if (_valueInstantiator.canCreateFromObjectWith()) {
            creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());

            // 21-Jun-2015, tatu: This resolution was duplicated later on and seems like
            //    it really should be only done at a later point. So commented out in 2.8.
            //   However, just in case there was a reason for it, leaving commented out
            //   here instead of immediately removing.

            /*
            // also: need to try to resolve 'external' type ids...
            for (SettableBeanProperty prop : creatorProps) {
                if (prop.hasValueTypeDeserializer()) {
                    TypeDeserializer typeDeser = prop.getValueTypeDeserializer();
                    if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {
                        if (extTypes == null) {
                            extTypes = new ExternalTypeHandler.Builder();
                        }
                        extTypes.addExternal(prop, typeDeser);
                    }
                }
            }
            */
        } else {
            creatorProps = null;
        }

        UnwrappedPropertyHandler unwrapped = null;

        for (SettableBeanProperty origProp : _beanProperties) {
            SettableBeanProperty prop = origProp;

            // May already have deserializer from annotations, if so, skip:
            if (!prop.hasValueDeserializer()) {
                // [databind#125]: allow use of converters
                JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop);
                if (deser == null) {
                    deser = findDeserializer(ctxt, prop.getType(), prop);
                }
                prop = prop.withValueDeserializer(deser);
            } else { // may need contextual version
                JsonDeserializer<Object> deser = prop.getValueDeserializer();
                /* Important! This is the only place where actually handle ""primary""
                 * property deserializers -- call is different from other places.
                 */
                JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop,
                        prop.getType());
                if (cd != deser) {
                    prop = prop.withValueDeserializer(cd);
                }
            }

            // Need to link managed references with matching back references
            prop = _resolveManagedReferenceProperty(ctxt, prop);

            // [databind#351[: need to wrap properties that require object id resolution.
            if (!(prop instanceof ManagedReferenceProperty)) {
                prop = _resolvedObjectIdProperty(ctxt, prop);
            }
            // Support unwrapped values (via @JsonUnwrapped)
            SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);
            if (u != null) {
                prop = u;
                if (unwrapped == null) {
                    unwrapped = new UnwrappedPropertyHandler();
                }
                unwrapped.addProperty(prop);
                /* 12-Dec-2014, tatu: As per [databind#647], we will have problems if
                 *    the original property is left in place. So let's remove it now.
                 */
                _beanProperties.remove(prop);
                continue;
            }
            // non-static inner classes too:
            prop = _resolveInnerClassValuedProperty(ctxt, prop);
            if (prop != origProp) {
                _beanProperties.replace(prop);
                // [databind#795]: Make sure PropertyBasedCreator's properties stay in sync
                if (creatorProps != null) {
                    // 18-May-2015, tatu: _Should_ start with consistent set. But can we really
                    //   fully count on this? May need to revisit in future; seems to hold for now.
                    for (int i = 0, len = creatorProps.length; i < len; ++i) {
                        if (creatorProps[i] == origProp) {
                            creatorProps[i] = prop;
                            break;
                        }
                        // ... as per above, it is possible we'd need to add this as fallback
                        // if (but only if) identity check fails?
                        /*
                        if (creatorProps[i].getName().equals(prop.getName())) {
                            creatorProps[i] = prop;
                            break;
                        }
                        */
                    }
                }
            }
            // one more thing: if this property uses ""external property"" type inclusion,
            // it needs different handling altogether
            if (prop.hasValueTypeDeserializer()) {
                TypeDeserializer typeDeser = prop.getValueTypeDeserializer();
                if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {
                    if (extTypes == null) {
                        extTypes = new ExternalTypeHandler.Builder();
                    }
                    extTypes.addExternal(prop, typeDeser);
                    // In fact, remove from list of known properties to simplify later handling
                    _beanProperties.remove(prop);
                    continue;
                }
            }
        }
        // ""any setter"" may also need to be resolved now
        if (_anySetter != null && !_anySetter.hasValueDeserializer()) {
            _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt,
                    _anySetter.getType(), _anySetter.getProperty()));
        }
        // as well as delegate-based constructor:
        if (_valueInstantiator.canCreateUsingDelegate()) {
            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());
            if (delegateType == null) {
                throw new IllegalArgumentException(""Invalid delegate-creator definition for ""+_beanType
                        +"": value instantiator (""+_valueInstantiator.getClass().getName()
                        +"") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"");
            }
            _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,
                    _valueInstantiator.getDelegateCreator());
        }

        // and array-delegate-based constructor:
        if (_valueInstantiator.canCreateUsingArrayDelegate()) {
            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());
            if (delegateType == null) {
                throw new IllegalArgumentException(""Invalid array-delegate-creator definition for ""+_beanType
                        +"": value instantiator (""+_valueInstantiator.getClass().getName()
                        +"") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'"");
            }
            _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,
                    _valueInstantiator.getArrayDelegateCreator());
        }

        // And now that we know CreatorProperty instances are also resolved can finally create the creator:
        if (creatorProps != null) {
            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);
        }

         if (extTypes != null) {
             // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too,
             //    so need to pass collected properties
             _externalTypeIdHandler = extTypes.build();
             // we consider this non-standard, to offline handling
             _nonStandardCreation = true;
         }
        
        _unwrappedPropertyHandler = unwrapped;
        if (unwrapped != null) { // we consider this non-standard, to offline handling
            _nonStandardCreation = true;
        }

        // may need to disable vanilla processing, if unwrapped handling was enabled...
        _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;
    }","@Override
public void resolve(DeserializationContext ctxt) throws JsonMappingException {
    ExternalTypeHandler.Builder extTypes = null;
    SettableBeanProperty[] creatorProps;

    if (_valueInstantiator.canCreateFromObjectWith()) {
        creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());
    } else {
        creatorProps = null;
    }

    UnwrappedPropertyHandler unwrapped = null;

    for (SettableBeanProperty origProp : _beanProperties) {
        SettableBeanProperty prop = origProp;

        if (!prop.hasValueDeserializer()) {
            JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop);
            if (deser == null) {
                deser = findDeserializer(ctxt, prop.getType(), prop);
            }
            prop = prop.withValueDeserializer(deser);
        } else {
            JsonDeserializer<Object> deser = prop.getValueDeserializer();
            JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop, prop.getType());
            if (cd != deser) {
                prop = prop.withValueDeserializer(cd);
            }
        }

        prop = _resolveManagedReferenceProperty(ctxt, prop);

        if (!(prop instanceof ManagedReferenceProperty)) {
            prop = _resolvedObjectIdProperty(ctxt, prop);
        }

        SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);
        if (u != null) {
            prop = u;
            if (unwrapped == null) {
                unwrapped = new UnwrappedPropertyHandler();
            }
            unwrapped.addProperty(prop);
            _beanProperties.remove(prop);
            continue;
        }

        prop = _resolveInnerClassValuedProperty(ctxt, prop);
        if (prop != origProp) {
            _beanProperties.replace(prop);
            if (creatorProps != null) {
                for (int i = 0, len = creatorProps.length; i < len; ++i) {
                    if (creatorProps[i] == origProp) {
                        creatorProps[i] = prop;
                        break;
                    }
                }
            }
        }

        if (prop.hasValueTypeDeserializer()) {
            TypeDeserializer typeDeser = prop.getValueTypeDeserializer();
            if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {
                if (extTypes == null) {
                    extTypes = new ExternalTypeHandler.Builder();
                }
                extTypes.addExternal(prop, typeDeser);
                _beanProperties.remove(prop);
                continue;
            }
        }
    }

    if (_anySetter != null && !_anySetter.hasValueDeserializer()) {
        _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty()));
    }

    if (_valueInstantiator.canCreateUsingDelegate()) {
        JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());
        if (delegateType == null) {
            throw new IllegalArgumentException(""Invalid delegate-creator definition for "" + _beanType
                    + "": value instantiator ("" + _valueInstantiator.getClass().getName()
                    + "") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"");
        }
        _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType, _valueInstantiator.getDelegateCreator());
    }

    if (_valueInstantiator.canCreateUsingArrayDelegate()) {
        JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());
        if (delegateType == null) {
            throw new IllegalArgumentException(""Invalid array-delegate-creator definition for "" + _beanType
                    + "": value instantiator ("" + _valueInstantiator.getClass().getName()
                    + "") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'"");
        }
        _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType, _valueInstantiator.getArrayDelegateCreator());
    }

    if (creatorProps != null) {
        _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);
    }

    if (extTypes != null) {
        _externalTypeIdHandler = extTypes.build();
        _nonStandardCreation = true;
    }

    _unwrappedPropertyHandler = unwrapped;
    if (unwrapped != null) {
        _nonStandardCreation = true;
    }

    _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;
}",0,0
202,JacksonDatabind_53,"public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)
    {
        // simple optimization to avoid costly introspection if type-erased type does NOT differ
        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == subclass) {
            return baseType;
        }

        JavaType newType;

        // also: if we start from untyped, not much to save
        do { // bogus loop to be able to break
            if (rawBase == Object.class) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
                break;
            }
            if (!rawBase.isAssignableFrom(subclass)) {
                throw new IllegalArgumentException(String.format(
                        ""Class %s not subtype of %s"", subclass.getName(), baseType));
            }
            // A few special cases where we can simplify handling:

            // (1) Original target type has no generics -- just resolve subtype
            if (baseType.getBindings().isEmpty()) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
            if (baseType.isContainerType()) {
                if (baseType.isMapLikeType()) {
                    if ((subclass == HashMap.class)
                            || (subclass == LinkedHashMap.class)
                            || (subclass == EnumMap.class)
                            || (subclass == TreeMap.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                        break;
                    }
                } else if (baseType.isCollectionLikeType()) {
                    if ((subclass == ArrayList.class)
                            || (subclass == LinkedList.class)
                            || (subclass == HashSet.class)
                            || (subclass == TreeSet.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getContentType()));
                        break;
                    }
                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                    //    but they are impl details and we basically do not care...
                    if (rawBase == EnumSet.class) {
                        return baseType;
                    }
                }
            }
            // (3) Sub-class does not take type parameters -- just resolve subtype
            int typeParamCount = subclass.getTypeParameters().length;
            if (typeParamCount == 0) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            
            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
            // !!! TODO (as of 28-Jan-2016, at least)
            
            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
            //    a way to fully resolve and merge hierarchies; but that gets expensive
            //    so let's, for now, try to create close-enough approximation that
            //    is not 100% same, structurally, but has equivalent information for
            //    our specific neeeds.
            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
             //  for a case where this code does get invoked: not ideal
             // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
             //  not certain it would reliably work... but let's hope for best for now
             if (baseType.isInterface()) {
                 newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });
             } else {
                 newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);
             }
             // Only SimpleType returns null, but if so just resolve regularly
             if (newType == null) {
                 TypeBindings tb = null;
                 if (baseType.containedTypeCount() == typeParamCount) {
                     if (typeParamCount == 1) {
                         tb = TypeBindings.create(subclass, baseType.containedType(0));
                     } else if (typeParamCount == 2) {
                         tb = TypeBindings.create(subclass, baseType.containedType(0),
                                 baseType.containedType(1));
                     }
                 }
                 newType = _fromClass(null, subclass,
                         (tb == null) ? TypeBindings.emptyBindings() : tb);
             }
         } while (false);
 
        // except possibly handlers
//      newType = newType.withHandlersFrom(baseType);
        return newType;

        // 20-Oct-2015, tatu: Old simplistic approach
        
        /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
    }","public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == subclass) {
        return baseType;
    }

    JavaType newType = null;

    // also: if we start from untyped, not much to save
    if (rawBase == Object.class) {
        return _fromClass(null, subclass, TypeBindings.emptyBindings());
    }
    if (!rawBase.isAssignableFrom(subclass)) {
        throw new IllegalArgumentException(String.format(
                ""Class %s not subtype of %s"", subclass.getName(), baseType.getRawClass().getName()));
    }

    // (1) Original target type has no generics -- just resolve subtype
    if (baseType.getBindings().isEmpty()) {
        return _fromClass(null, subclass, TypeBindings.emptyBindings());
    }

    // (2) Special handling for known container types
    if (baseType.isContainerType()) {
        if (baseType.isMapLikeType()) {
            if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {
                newType = _fromClass(null, subclass,
                        TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
            }
        } else if (baseType.isCollectionLikeType()) {
            if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {
                newType = _fromClass(null, subclass,
                        TypeBindings.create(subclass, baseType.getContentType()));
            } else if (rawBase == EnumSet.class) {
                return baseType; // special case: EnumSet
            }
        }
    }

    // (3) Sub-class does not take type parameters -- just resolve subtype
    if (newType == null) {
        int typeParamCount = subclass.getTypeParameters().length;
        if (typeParamCount == 0) {
            return _fromClass(null, subclass, TypeBindings.emptyBindings());
        }

        // Refine type for type parameters, if applicable
        if (baseType.isInterface()) {
            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });
        } else {
            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);
        }

        // If refine returned null, resolve using contained types or create new bindings
        if (newType == null) {
            TypeBindings tb = null;
            if (baseType.containedTypeCount() == typeParamCount) {
                if (typeParamCount == 1) {
                    tb = TypeBindings.create(subclass, baseType.containedType(0));
                } else if (typeParamCount == 2) {
                    tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1));
                }
            }
            newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb);
        }
    }

    return newType;
}",0,0
202,JacksonDatabind_53,"protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)
    {
        // Very first thing: small set of core types we know well:
        JavaType result = _findWellKnownSimple(rawType);
        if (result != null) {
            return result;
        }
        // Barring that, we may have recently constructed an instance
        boolean cachable = (bindings == null) || bindings.isEmpty();
        if (cachable) {
            result = _typeCache.get(rawType);
        if (result != null) {
            return result;
            }
        }

        // 15-Oct-2015, tatu: recursive reference?
        if (context == null) {
            context = new ClassStack(rawType);
        } else {
            ClassStack prev = context.find(rawType);
            if (prev != null) {
                // Self-reference: needs special handling, then...
                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);
                prev.addSelfReference(selfRef);
                return selfRef;
            }
            // no, but need to update context to allow for proper cycle resolution
            context = context.child(rawType);
        }

        // First: do we have an array type?
        if (rawType.isArray()) {
            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),
                    bindings);
        } else {
            // If not, need to proceed by first resolving parent type hierarchy
            
            JavaType superClass;
            JavaType[] superInterfaces;

            if (rawType.isInterface()) {
                superClass = null;
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            } else {
                // Note: even Enums can implement interfaces, so can not drop those
                superClass = _resolveSuperClass(context, rawType, bindings);
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            }

            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...
            if (rawType == Properties.class) {
                result = MapType.construct(rawType, bindings, superClass, superInterfaces,
                        CORE_TYPE_STRING, CORE_TYPE_STRING);
            }
            // And then check what flavor of type we got. Start by asking resolved
            // super-type if refinement is all that is needed?
            else if (superClass != null) {
                result = superClass.refine(rawType, bindings, superClass, superInterfaces);
            }
            // if not, perhaps we are now resolving a well-known class or interface?
            if (result == null) {
                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); 
                if (result == null) {
                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);
                    if (result == null) {
                        // but if nothing else, ""simple"" class for now:
                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);
                    }
                }
             }
         }
         context.resolveSelfReferences(result);
         if (cachable) {
             _typeCache.putIfAbsent(rawType, result);
         }
         return result;
     }","protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {
    // Check for well-known simple types
    JavaType result = _findWellKnownSimple(rawType);
    if (result != null) {
        return result;
    }

    // Check for cached types if bindings are empty
    boolean cachable = (bindings == null) || bindings.isEmpty();
    if (cachable) {
        result = _typeCache.get(rawType);
        if (result != null) {
            return result;
        }
    }

    // Handle recursive references within class stack
    if (context == null) {
        context = new ClassStack(rawType);
    } else {
        ClassStack prev = context.find(rawType);
        if (prev != null) {
            ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);
            prev.addSelfReference(selfRef);
            return selfRef;
        }
        context = context.child(rawType);
    }

    // Handle array types
    if (rawType.isArray()) {
        result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings);
    } else {
        // Resolve super types and interfaces
        JavaType superClass = rawType.isInterface() ? null : _resolveSuperClass(context, rawType, bindings);
        JavaType[] superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);

        // Special handling for specific well-known types
        if (rawType == Properties.class) {
            result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING);
        } else if (superClass != null) {
            result = superClass.refine(rawType, bindings, superClass, superInterfaces);
        }

        // Fallback to well-known class or interface, or create a new simple type
        if (result == null) {
            result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces);
            if (result == null) {
                result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);
                if (result == null) {
                    result = _newSimpleType(rawType, bindings, superClass, superInterfaces);
                }
            }
        }
    }

    context.resolveSelfReferences(result);

    // Cache the result if applicable
    if (cachable) {
        _typeCache.putIfAbsent(rawType, result);
    }

    return result;
}",0,0
203,JacksonDatabind_55,"@SuppressWarnings(""unchecked"")
    public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,
            Class<?> rawKeyType)
    {
        if (rawKeyType != null) {
            // 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure
            //   if that is a bug or feature. Regardless, it seems to require dynamic handling
            //   (compared to getting actual fully typed Enum).
            //  Note that this might even work from the earlier point, but let's play it safe for now
            // 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because
            //    then there is no static type
            if (rawKeyType == Enum.class) {
                 return new Dynamic();
             }
             if (rawKeyType.isEnum()) {
                 return new Default(Default.TYPE_ENUM, rawKeyType);
             }
         }
         return DEFAULT_KEY_SERIALIZER;
    }","@SuppressWarnings(""unchecked"")
public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,
        Class<?> rawKeyType) {
    if (rawKeyType != null) {
        // Handle case for Enum class explicitly
        if (rawKeyType == Enum.class) {
            return new Dynamic();
        }
        // Check if rawKeyType is an actual enum type
        if (rawKeyType.isEnum()) {
            return new Default(Default.TYPE_ENUM, rawKeyType);
        }
    }
    return DEFAULT_KEY_SERIALIZER;
}",0,0
204,JacksonDatabind_56,"@Override
        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException
        {
            switch (_kind) {
            case STD_FILE:
                return new File(value);
            case STD_URL:
                return new URL(value);
            case STD_URI:
                return URI.create(value);
            case STD_CLASS:
                try {
                    return ctxt.findClass(value);
                } catch (Exception e) {
                    throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));
                }
            case STD_JAVA_TYPE:
                return ctxt.getTypeFactory().constructFromCanonical(value);
            case STD_CURRENCY:
                // will throw IAE if unknown:
                return Currency.getInstance(value);
            case STD_PATTERN:
                // will throw IAE (or its subclass) if malformed
                 return Pattern.compile(value);
             case STD_LOCALE:
                 {
                     int ix = value.indexOf('_');
                     if (ix < 0) { // single argument
                         return new Locale(value);
                     }
                     String first = value.substring(0, ix);
                     value = value.substring(ix+1);
                     ix = value.indexOf('_');
                     if (ix < 0) { // two pieces
                         return new Locale(first, value);
                     }
                    String second = value.substring(0, ix);
                    return new Locale(first, second, value.substring(ix+1));
                }
            case STD_CHARSET:
                return Charset.forName(value);
            case STD_TIME_ZONE:
                return TimeZone.getTimeZone(value);
            case STD_INET_ADDRESS:
                return InetAddress.getByName(value);
            case STD_INET_SOCKET_ADDRESS:
                if (value.startsWith(""["")) {
                    // bracketed IPv6 (with port number)

                    int i = value.lastIndexOf(']');
                    if (i == -1) {
                        throw new InvalidFormatException(ctxt.getParser(),
                                ""Bracketed IPv6 address must contain closing bracket"",
                                value, InetSocketAddress.class);
                    }

                    int j = value.indexOf(':', i);
                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;
                    return new InetSocketAddress(value.substring(0, i + 1), port);
                } else {
                    int ix = value.indexOf(':');
                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {
                        // host:port
                        int port = Integer.parseInt(value.substring(ix+1));
                        return new InetSocketAddress(value.substring(0, ix), port);
                    }
                    // host or unbracketed IPv6, without port number
                    return new InetSocketAddress(value, 0);
                }
            }
            throw new IllegalArgumentException();
        }","@Override
protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {
    switch (_kind) {
        case STD_FILE:
            return new File(value);
        case STD_URL:
            try {
                return new URL(value);
            } catch (MalformedURLException e) {
                throw InvalidFormatException.from(ctxt.getParser(), ""Invalid URL: "" + value, value, URL.class);
            }
        case STD_URI:
            try {
                return URI.create(value);
            } catch (IllegalArgumentException e) {
                throw InvalidFormatException.from(ctxt.getParser(), ""Invalid URI: "" + value, value, URI.class);
            }
        case STD_CLASS:
            try {
                return ctxt.findClass(value);
            } catch (Exception e) {
                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));
            }
        case STD_JAVA_TYPE:
            return ctxt.getTypeFactory().constructFromCanonical(value);
        case STD_CURRENCY:
            try {
                return Currency.getInstance(value);
            } catch (IllegalArgumentException e) {
                throw InvalidFormatException.from(ctxt.getParser(), ""Invalid Currency: "" + value, value, Currency.class);
            }
        case STD_PATTERN:
            try {
                return Pattern.compile(value);
            } catch (PatternSyntaxException e) {
                throw InvalidFormatException.from(ctxt.getParser(), ""Invalid Pattern: "" + value, value, Pattern.class);
            }
        case STD_LOCALE: {
            int ix = value.indexOf('_');
            if (ix < 0) { // single argument
                return new Locale(value);
            }
            String first = value.substring(0, ix);
            value = value.substring(ix + 1);
            ix = value.indexOf('_');
            if (ix < 0) { // two pieces
                return new Locale(first, value);
            }
            String second = value.substring(0, ix);
            return new Locale(first, second, value.substring(ix + 1));
        }
        case STD_CHARSET:
            try {
                return Charset.forName(value);
            } catch (UnsupportedCharsetException e) {
                throw InvalidFormatException.from(ctxt.getParser(), ""Invalid Charset: "" + value, value, Charset.class);
            }
        case STD_TIME_ZONE:
            TimeZone timeZone = TimeZone.getTimeZone(value);
            if (""GMT"".equals(timeZone.getID()) && !value.toUpperCase().startsWith(""GMT"")) {
                throw InvalidFormatException.from(ctxt.getParser(), ""Invalid TimeZone: "" + value, value, TimeZone.class);
            }
            return timeZone;
        case STD_INET_ADDRESS:
            try {
                return InetAddress.getByName(value);
            } catch (UnknownHostException e) {
                throw InvalidFormatException.from(ctxt.getParser(), ""Invalid InetAddress: "" + value, value, InetAddress.class);
            }
        case STD_INET_SOCKET_ADDRESS:
            try {
                if (value.startsWith(""["")) {
                    // bracketed IPv6 (with port number)
                    int i = value.lastIndexOf(']');
                    if (i == -1) {
                        throw new InvalidFormatException(ctxt.getParser(),
                                ""Bracketed IPv6 address must contain closing bracket"", value, InetSocketAddress.class);
                    }
                    int j = value.indexOf(':', i);
                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;
                    return new InetSocketAddress(value.substring(0, i + 1), port);
                } else {
                    int ix = value.indexOf(':');
                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {
                        // host:port
                        int port = Integer.parseInt(value.substring(ix + 1));
                        return new InetSocketAddress(value.substring(0, ix), port);
                    }
                    // host or unbracketed IPv6, without port number
                    return new InetSocketAddress(value, 0);
                }
            } catch (IllegalArgumentException | NumberFormatException e) {
                throw InvalidFormatException.from(ctxt.getParser(),
                        ""Invalid InetSocketAddress: "" + value, value, InetSocketAddress.class);
            }
    }
    throw new IllegalArgumentException(""Unknown _kind: "" + _kind);
}",0,0
205,JacksonDatabind_59,"public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)
    {
        // simple optimization to avoid costly introspection if type-erased type does NOT differ
        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == subclass) {
            return baseType;
        }

        JavaType newType;

        // also: if we start from untyped, not much to save
        do { // bogus loop to be able to break
            if (rawBase == Object.class) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
                break;
            }
            if (!rawBase.isAssignableFrom(subclass)) {
                throw new IllegalArgumentException(String.format(
                        ""Class %s not subtype of %s"", subclass.getName(), baseType));
            }
            // A few special cases where we can simplify handling:

            // (1) Original target type has no generics -- just resolve subtype
            if (baseType.getBindings().isEmpty()) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
            if (baseType.isContainerType()) {
                if (baseType.isMapLikeType()) {
                    if ((subclass == HashMap.class)
                            || (subclass == LinkedHashMap.class)
                            || (subclass == EnumMap.class)
                            || (subclass == TreeMap.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                        break;
                    }
                } else if (baseType.isCollectionLikeType()) {
                    if ((subclass == ArrayList.class)
                            || (subclass == LinkedList.class)
                            || (subclass == HashSet.class)
                            || (subclass == TreeSet.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getContentType()));
                        break;
                    }
                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                    //    but they are impl details and we basically do not care...
                    if (rawBase == EnumSet.class) {
                        return baseType;
                    }
                }
            }
            // (3) Sub-class does not take type parameters -- just resolve subtype
            int typeParamCount = subclass.getTypeParameters().length;
            if (typeParamCount == 0) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            
            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.

            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
            //    a way to fully resolve and merge hierarchies; but that gets expensive
            //    so let's, for now, try to create close-enough approximation that
            //    is not 100% same, structurally, but has equivalent information for
            //    our specific neeeds.
            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
            //  for a case where this code does get invoked: not ideal
            // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
            //  not certain it would reliably work... but let's hope for best for now
            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);
            if (baseType.isInterface()) {
                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });
            } else {
                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);
            }
            // Only SimpleType returns null, but if so just resolve regularly
            if (newType == null) {
                newType = _fromClass(null, subclass, tb);
            }
        } while (false);
 
         // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get
         //   copied as well
         return newType;
 
         // 20-Oct-2015, tatu: Old simplistic approach
        
        /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
    }","public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {
    // Simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == subclass) {
        return baseType;
    }

    if (!rawBase.isAssignableFrom(subclass)) {
        throw new IllegalArgumentException(String.format(
            ""Class %s not subtype of %s"", subclass.getName(), baseType));
    }

    JavaType newType = null;
    // Ensure special cases are handled
    if (rawBase == Object.class) {
        newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
    } 
    // Handle container types and assign proper bindings
    else if (baseType.isContainerType()) {
        if (baseType.isMapLikeType()) {
            if ((subclass == HashMap.class)
                    || (subclass == LinkedHashMap.class)
                    || (subclass == EnumMap.class)
                    || (subclass == TreeMap.class)) {
                newType = _fromClass(null, subclass,
                        TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
            }
        } else if (baseType.isCollectionLikeType()) {
            if ((subclass == ArrayList.class)
                    || (subclass == LinkedList.class)
                    || (subclass == HashSet.class)
                    || (subclass == TreeSet.class)) {
                newType = _fromClass(null, subclass,
                        TypeBindings.create(subclass, baseType.getContentType()));
            } else if (rawBase == EnumSet.class) {
                return baseType;
            }
        }
    }
    // Handle cases where subclass has no type parameters
    if (newType == null) {
        int typeParamCount = subclass.getTypeParameters().length;
        if (typeParamCount == 0) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
        } else {
            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);
            if (baseType.isInterface()) {
                newType = baseType.refine(subclass, tb, null, new JavaType[]{baseType});
            } else {
                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);
            }
            if (newType == null) {
                newType = _fromClass(null, subclass, tb);
            }
        }
    }

    // Ensure handlers are copied as well
    if (newType != null) {
        Object valueHandler = baseType.getValueHandler();
        if (valueHandler != null) {
            newType = newType.withValueHandler(valueHandler);
        }
        Object typeHandler = baseType.getTypeHandler();
        if (typeHandler != null) {
            newType = newType.withTypeHandler(typeHandler);
        }
    }

    return newType;
}",0,0
206,JacksonDatabind_60,"@Override
    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,
            TypeSerializer typeSer0) throws IOException
    {
        // Regardless of other parts, first need to find value to serialize:
        Object value = null;
        try {
            value = _accessorMethod.getValue(bean);
            // and if we got null, can also just write it directly
            if (value == null) {
                provider.defaultSerializeNull(gen);
                return;
            }
            JsonSerializer<Object> ser = _valueSerializer;
            if (ser == null) { // no serializer yet? Need to fetch
//                ser = provider.findTypedValueSerializer(value.getClass(), true, _property);
                ser = provider.findValueSerializer(value.getClass(), _property);
            } else {
                /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do
                 *    this (note: type is for the wrapper type, not enclosed value!)
                 */
                if (_forceTypeInformation) {
                    typeSer0.writeTypePrefixForScalar(bean, gen);
                    ser.serialize(value, gen, provider);
                    typeSer0.writeTypeSuffixForScalar(bean, gen);
                    return;
                }
            }
             // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling
             //    to use different Object for type id (logical type) and actual serialization
             //    (delegat type).
             ser.serializeWithType(value, gen, provider, typeSer0);
         } catch (IOException ioe) {
             throw ioe;
         } catch (Exception e) {
            Throwable t = e;
            // Need to unwrap this specific type, to see infinite recursion...
            while (t instanceof InvocationTargetException && t.getCause() != null) {
                t = t.getCause();
            }
            // Errors shouldn't be wrapped (and often can't, as well)
            if (t instanceof Error) {
                throw (Error) t;
            }
            // let's try to indicate the path best we can...
            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + ""()"");
        }
    }","@Override
public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,
        TypeSerializer typeSer0) throws IOException {
    // Regardless of other parts, first need to find value to serialize:
    Object value;
    try {
        value = _accessorMethod.getValue(bean);
        // if we got null, write it directly
        if (value == null) {
            provider.defaultSerializeNull(gen);
            return;
        }
        JsonSerializer<Object> ser = _valueSerializer;
        if (ser == null) { 
            // Fetch serializer for the value
            ser = provider.findValueSerializer(value.getClass(), _property);
        }
        if (_forceTypeInformation) {
            // Force type information for wrapper type
            typeSer0.writeTypePrefixForScalar(bean, gen);
            ser.serialize(value, gen, provider);
            typeSer0.writeTypeSuffixForScalar(bean, gen);
        } else {
            // Delegate to serializer with type information
            ser.serializeWithType(value, gen, provider, typeSer0);
        }
    } catch (IOException ioe) {
        throw ioe;
    } catch (Exception e) {
        Throwable t = e;
        while (t instanceof InvocationTargetException && t.getCause() != null) {
            t = t.getCause();
        }
        if (t instanceof Error) {
            throw (Error) t;
        }
        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + ""()"");
    }
}",0,0
207,JacksonDatabind_61,"        public boolean useForType(JavaType t)
        {
            // 03-Oct-2016, tatu: As per [databind#1395], need to skip
            //  primitive types too, regardless

            switch (_appliesFor) {
            case NON_CONCRETE_AND_ARRAYS:
                while (t.isArrayType()) {
                    t = t.getContentType();
                }
                // fall through
            case OBJECT_AND_NON_CONCRETE:
                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:
                while (t.isReferenceType()) {
                    t = t.getReferencedType();
                }
                return t.isJavaLangObject()
                        || (!t.isConcrete()
                                // [databind#88] Should not apply to JSON tree models:
                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));

            case NON_FINAL:
                while (t.isArrayType()) {
                    t = t.getContentType();
                }
                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:
                while (t.isReferenceType()) {
                    t = t.getReferencedType();
                }
                // [databind#88] Should not apply to JSON tree models:
                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());
            default:
            //case JAVA_LANG_OBJECT:
                return t.isJavaLangObject();
            }
        }
","public boolean useForType(JavaType t) {
    // Handle primitive types case appropriately 
    if (t.isPrimitive()) {
        return false;
    }

    switch (_appliesFor) {
        case NON_CONCRETE_AND_ARRAYS:
            while (t.isArrayType()) {
                t = t.getContentType();
            }
            // fall through
        case OBJECT_AND_NON_CONCRETE:
            while (t.isReferenceType()) {
                t = t.getReferencedType();
            }
            return t.isJavaLangObject()
                    || (!t.isConcrete()
                            && !TreeNode.class.isAssignableFrom(t.getRawClass()));

        case NON_FINAL:
            while (t.isArrayType()) {
                t = t.getContentType();
            }
            while (t.isReferenceType()) {
                t = t.getReferencedType();
            }
            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());

        default:
            return t.isJavaLangObject();
    }
}",0,0
207,JacksonDatabind_61,"    public TypeSerializer buildTypeSerializer(SerializationConfig config,
            JavaType baseType, Collection<NamedType> subtypes)
    {
        if (_idType == JsonTypeInfo.Id.NONE) { return null; }
        // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
        //    regardless of setting
        TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
        switch (_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
        	// as per [#528]
        	return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
        }
        throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: ""+_includeAs);
    }
","public TypeSerializer buildTypeSerializer(SerializationConfig config,
        JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // Prevent use for primitives
    if (baseType.isPrimitive()) {
        return null;
    }

    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch (_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
        default:
            throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
    }
}",0,0
207,JacksonDatabind_61,"    public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,
            JavaType baseType, Collection<NamedType> subtypes)
    {
        if (_idType == JsonTypeInfo.Id.NONE) { return null; }
        // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
        //    regardless of setting

        TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);

        JavaType defaultImpl;

        if (_defaultImpl == null) {
            defaultImpl = null;
        } else {
            // 20-Mar-2016, tatu: It is important to do specialization go through
            //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
            //   call to JavaType was used, but that can not work reliably with 2.7
            // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
            //   if so, need to add explicit checks for marker types. Not ideal, but
            //   seems like a reasonable compromise.
            if ((_defaultImpl == Void.class)
                     || (_defaultImpl == NoClass.class)) {
                defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
            } else {
                defaultImpl = config.getTypeFactory()
                    .constructSpecializedType(baseType, _defaultImpl);
            }
        }

        // First, method for converting type info to type id:
        switch (_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes,
                    _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case EXISTING_PROPERTY: // as per [#528] same class as PROPERTY
            return new AsPropertyTypeDeserializer(baseType, idRes,
                    _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes,
                    _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes,
                    _typeProperty, _typeIdVisible, defaultImpl);
        }
        throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: ""+_includeAs);
    }
","public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,
        JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // Prevent use for primitives
    if (baseType.isPrimitive()) {
        return null;
    }

    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);

    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }

    switch (_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        default:
            throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
    }
}",0,0
208,JacksonDatabind_63,"public String getDescription() {
            if (_desc == null) {
                StringBuilder sb = new StringBuilder();

                if (_from == null) { // can this ever occur?
                    sb.append(""UNKNOWN"");
                } else {
                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();
                    // Hmmh. Although Class.getName() is mostly ok, it does look
                     // butt-ugly for arrays.
                     // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good
                     //   as it drops enclosing class. So let's try bit different approach
                     String pkgName = ClassUtil.getPackageName(cls);
                     if (pkgName != null) {
                         sb.append(pkgName);
                         sb.append('.');
                     }
                     sb.append(cls.getSimpleName());
                 }
                 sb.append('[');
                 if (_fieldName != null) {
                    sb.append('""');
                    sb.append(_fieldName);
                    sb.append('""');
                } else if (_index >= 0) {
                    sb.append(_index);
                } else {
                    sb.append('?');
                }
                sb.append(']');
                _desc = sb.toString();
            }
            return _desc;
        }","public String getDescription() {
    if (_desc == null) {
        StringBuilder sb = new StringBuilder();

        if (_from == null) { // can this ever occur?
            sb.append(""UNKNOWN"");
        } else {
            Class<?> cls = (_from instanceof Class<?>) ? (Class<?>) _from : _from.getClass();
            // Improve handling for arrays and nested classes
            String packageName = ClassUtil.getPackageName(cls);
            if (packageName != null && !packageName.isEmpty()) {
                sb.append(packageName);
                sb.append('.');
            }
            // Use getCanonicalName to ensure nested and array class names are represented correctly
            sb.append(cls.isArray() ? cls.getComponentType().getCanonicalName() + ""[]"" : cls.getCanonicalName());
        }
        sb.append('[');
        if (_fieldName != null) {
            sb.append('""');
            sb.append(_fieldName);
            sb.append('""');
        } else if (_index >= 0) {
            sb.append(_index);
        } else {
            sb.append('?');
        }
        sb.append(']');
        _desc = sb.toString();
    }
    return _desc;
}",0,0
209,JacksonDatabind_66,"        public final Object deserializeKey(String key, DeserializationContext ctxt)
            throws IOException
        {
            if (key == null) { // is this even legal call?
                return null;
            }
            try {
                // Ugh... should not have to give parser which may or may not be correct one...
                Object result = _delegate.deserialize(ctxt.getParser(), ctxt);
                if (result != null) {
                    return result;
                }
                return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
            } catch (Exception re) {
                return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation: %s"", re.getMessage());
            }
        }
","public final Object deserializeKey(String key, DeserializationContext ctxt)
            throws IOException
        {
            if (key == null) { // is this even legal call?
                return null;
            }
            try {
                // Proper parser passed directly to the delegate
                Object result = _delegate.deserialize(ctxt.getParser().createParser(key), ctxt);
                if (result != null) {
                    return result;
                }
                return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
            } catch (Exception re) {
                return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation: %s"", re.getMessage());
            }
        }",0,0
210,JacksonDatabind_68,"public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        // First things first: id Object Id is used, most likely that's it
        if (_objectIdReader != null) {
            return deserializeFromObjectId(p, ctxt);
        }
         /* Bit complicated if we have delegating creator; may need to use it,
          * or might not...
          */
         if (_delegateDeserializer != null) {
             if (!_valueInstantiator.canCreateFromString()) {
                 Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                         _delegateDeserializer.deserialize(p, ctxt));
                 if (_injectables != null) {
                     injectValues(ctxt, bean);
                 }
                return bean;
            }
        }
        return _valueInstantiator.createFromString(ctxt, p.getText());
    }","public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (_objectIdReader != null) {
        return deserializeFromObjectId(p, ctxt);
    }
    if (_delegateDeserializer != null) {
        if (!_valueInstantiator.canCreateFromString()) {
            Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
            if (_injectables != null) {
                injectValues(ctxt, bean);
            }
            return bean;
        }
    }
    if (p.getText() == null || p.getText().isEmpty()) {
        return ctxt.handleUnexpectedToken(handledType(), p);
    }
    return _valueInstantiator.createFromString(ctxt, p.getText());
}",0,0
210,JacksonDatabind_68,"public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException
     {
         if (_delegateDeserializer != null) {
             if (!_valueInstantiator.canCreateFromBoolean()) {
                 Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                         _delegateDeserializer.deserialize(p, ctxt));
                 if (_injectables != null) {
                     injectValues(ctxt, bean);
                 }
                return bean;
            }
        }
        boolean value = (p.getCurrentToken() == JsonToken.VALUE_TRUE);
        return _valueInstantiator.createFromBoolean(ctxt, value);
    }","public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (_delegateDeserializer != null) {
        if (!_valueInstantiator.canCreateFromBoolean()) {
            Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
            if (_injectables != null) {
                injectValues(ctxt, bean);
            }
            return bean;
        }
    }
    if (!p.hasCurrentToken() || !p.getCurrentToken().isBoolean()) {
        return ctxt.handleUnexpectedToken(handledType(), p);
    }
    boolean value = (p.getCurrentToken() == JsonToken.VALUE_TRUE);
    return _valueInstantiator.createFromBoolean(ctxt, value);
}",0,0
210,JacksonDatabind_68,"public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException
    {
         NumberType t = p.getNumberType();
         // no separate methods for taking float...
         if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) {
             if (_delegateDeserializer != null) {
                 if (!_valueInstantiator.canCreateFromDouble()) {
                     Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                             _delegateDeserializer.deserialize(p, ctxt));
                     if (_injectables != null) {
                         injectValues(ctxt, bean);
                     }
                    return bean;
                }
            }
            return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());
        }
        // actually, could also be BigDecimal, so:
        if (_delegateDeserializer != null) {
            return _valueInstantiator.createUsingDelegate(ctxt,
                    _delegateDeserializer.deserialize(p, ctxt));
        }
        return ctxt.handleMissingInstantiator(handledType(), p,
                ""no suitable creator method found to deserialize from Number value (%s)"",
                p.getNumberValue());
    }","public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException {
    NumberType t = p.getNumberType();
    if (t == NumberType.DOUBLE || t == NumberType.FLOAT) {
        if (_delegateDeserializer != null) {
            if (!_valueInstantiator.canCreateFromDouble()) {
                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
                if (_injectables != null) {
                    injectValues(ctxt, bean);
                }
                return bean;
            }
        }
        return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());
    } else if (t == NumberType.BIG_DECIMAL && _delegateDeserializer != null) {
        return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
    }
    return ctxt.handleMissingInstantiator(handledType(), p, 
        ""no suitable creator method found to deserialize from Number value (%s)"", p.getNumberValue());
}",0,0
210,JacksonDatabind_68,"public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException
     {
         // note: can not call `_delegateDeserializer()` since order reversed here:
         if (_arrayDelegateDeserializer != null) {
             try {
                 Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt));
                 if (_injectables != null) {
                     injectValues(ctxt, bean);
                 }
                 return bean;
             } catch (Exception e) {
                 return wrapInstantiationProblem(e, ctxt);
             }
         }
         // fallback to non-array delegate
         if (_delegateDeserializer != null) {
             try {
             Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt,
                     _delegateDeserializer.deserialize(p, ctxt));
             if (_injectables != null) {
                 injectValues(ctxt, bean);
             }
             return bean;
             } catch (Exception e) {
                 wrapInstantiationProblem(e, ctxt);
                 return null;
             }
         }
         if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
             JsonToken t = p.nextToken();
            if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
                return null;
            }
            final Object value = deserialize(p, ctxt);
            if (p.nextToken() != JsonToken.END_ARRAY) {
                handleMissingEndArrayForSingle(p, ctxt);
            }
            return value;
        }
        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
            JsonToken t = p.nextToken();
            if (t == JsonToken.END_ARRAY) {
                return null;
            }
            return ctxt.handleUnexpectedToken(handledType(),
                    JsonToken.START_ARRAY, p, null);
        }
        return ctxt.handleUnexpectedToken(handledType(), p);
    }","public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (_arrayDelegateDeserializer != null) {
        try {
            Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt));
            if (_injectables != null) {
                injectValues(ctxt, bean);
            }
            return bean;
        } catch (Exception e) {
            return wrapInstantiationProblem(e, ctxt);
        }
    }
    if (_delegateDeserializer != null) {
        try {
            Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
            if (_injectables != null) {
                injectValues(ctxt, bean);
            }
            return bean;
        } catch (Exception e) {
            return wrapInstantiationProblem(e, ctxt);
        }
    }
    if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
        JsonToken t = p.nextToken();
        if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
            return null;
        }
        final Object value = deserialize(p, ctxt);
        if (p.nextToken() != JsonToken.END_ARRAY) {
            handleMissingEndArrayForSingle(p, ctxt);
        }
        return value;
    }
    if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
        JsonToken t = p.nextToken();
        if (t == JsonToken.END_ARRAY) {
            return null;
        }
        return ctxt.handleUnexpectedToken(handledType(), JsonToken.START_ARRAY, p, null);
    }
    return ctxt.handleUnexpectedToken(handledType(), p);
}",0,0
210,JacksonDatabind_68,"protected Object deserializeFromObjectUsingNonDefault(JsonParser p,
             DeserializationContext ctxt) throws IOException
     {
         if (_delegateDeserializer != null) {
             return _valueInstantiator.createUsingDelegate(ctxt,
                     _delegateDeserializer.deserialize(p, ctxt));
         }
         if (_propertyBasedCreator != null) {
             return _deserializeUsingPropertyBased(p, ctxt);
        }
        // should only occur for abstract types...
        if (_beanType.isAbstract()) {
            return ctxt.handleMissingInstantiator(handledType(), p,
                    ""abstract type (need to add/enable type information?)"");
        }
        return ctxt.handleMissingInstantiator(_beanType.getRawClass(), p,
                ""no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)"");
    }","protected Object deserializeFromObjectUsingNonDefault(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (_delegateDeserializer != null) {
        return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
    }
    if (_propertyBasedCreator != null) {
        return _deserializeUsingPropertyBased(p, ctxt);
    }
    if (_beanType.isAbstract()) {
        return ctxt.handleMissingInstantiator(handledType(), p, 
            ""abstract type (need to add/enable type information?)"");
    }
    return ctxt.handleMissingInstantiator(_beanType.getRawClass(), p, 
        ""no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)"");
}",0,0
210,JacksonDatabind_68,"@SuppressWarnings(""incomplete-switch"")
    public Object deserializeFromNumber(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        // First things first: id Object Id is used, most likely that's it
        if (_objectIdReader != null) {
            return deserializeFromObjectId(p, ctxt);
        }
        switch (p.getNumberType()) {
        case INT:
            if (_delegateDeserializer != null) {
                if (!_valueInstantiator.canCreateFromInt()) {
                    Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                            _delegateDeserializer.deserialize(p, ctxt));
                    if (_injectables != null) {
                        injectValues(ctxt, bean);
                    }
                    return bean;
                }
             }
             return _valueInstantiator.createFromInt(ctxt, p.getIntValue());
         case LONG:
             if (_delegateDeserializer != null) {
                 if (!_valueInstantiator.canCreateFromInt()) {
                     Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                             _delegateDeserializer.deserialize(p, ctxt));
                     if (_injectables != null) {
                         injectValues(ctxt, bean);
                     }
                    return bean;
                }
            }
            return _valueInstantiator.createFromLong(ctxt, p.getLongValue());
        }
        // actually, could also be BigInteger, so:
        if (_delegateDeserializer != null) {
            Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                    _delegateDeserializer.deserialize(p, ctxt));
            if (_injectables != null) {
                injectValues(ctxt, bean);
            }
            return bean;
        }
        return ctxt.handleMissingInstantiator(handledType(), p,
                ""no suitable creator method found to deserialize from Number value (%s)"",
                p.getNumberValue());
    }","@SuppressWarnings(""incomplete-switch"")
public Object deserializeFromNumber(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (_objectIdReader != null) {
        return deserializeFromObjectId(p, ctxt);
    }
    switch (p.getNumberType()) {
        case INT:
            if (_delegateDeserializer != null && !_valueInstantiator.canCreateFromInt()) {
                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
                if (_injectables != null) {
                    injectValues(ctxt, bean);
                }
                return bean;
            }
            return _valueInstantiator.createFromInt(ctxt, p.getIntValue());
        case LONG:
            if (_delegateDeserializer != null && !_valueInstantiator.canCreateFromInt()) {
                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
                if (_injectables != null) {
                    injectValues(ctxt, bean);
                }
                return bean;
            }
            return _valueInstantiator.createFromLong(ctxt, p.getLongValue());
    }
    if (_delegateDeserializer != null) {
        Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
        if (_injectables != null) {
            injectValues(ctxt, bean);
        }
        return bean;
    }
    return ctxt.handleMissingInstantiator(handledType(), p, 
        ""no suitable creator method found to deserialize from Number value (%s)"", p.getNumberValue());
}",0,0
211,JacksonDatabind_69,"public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,
            SettableBeanProperty[] properties)
    {
        verifyNonDup(creator, C_PROPS, explicit);
            // Better ensure we have no duplicate names either...
            if (properties.length > 1) {
                HashMap<String,Integer> names = new HashMap<String,Integer>();
                for (int i = 0, len = properties.length; i < len; ++i) {
                    String name = properties[i].getName();
                    /* [Issue-13]: Need to consider Injectables, which may not have
                     *   a name at all, and need to be skipped
                     */
                    if (name.length() == 0 && properties[i].getInjectableValueId() != null) {
                        continue;
                    }
                    Integer old = names.put(name, Integer.valueOf(i));
                    if (old != null) {
                        throw new IllegalArgumentException(""Duplicate creator property \""""+name+""\"" (index ""+old+"" vs ""+i+"")"");
                    }
                 }
             }
             _propertyBasedArgs = properties;
     }","public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,
            SettableBeanProperty[] properties)
    {
        verifyNonDup(creator, C_PROPS, explicit);
        // Better ensure we have no duplicate names either...
        if (properties.length > 1) {
            HashMap<String, Integer> names = new HashMap<String, Integer>();
            for (int i = 0, len = properties.length; i < len; ++i) {
                String name = properties[i].getName();
                /* [Issue-13]: Need to consider Injectables, which may not have
                 * a name at all, and need to be skipped
                 */
                if ((name == null || name.isEmpty()) && properties[i].getInjectableValueId() != null) {
                    continue;
                }
                Integer old = names.put(name, Integer.valueOf(i));
                if (old != null) {
                    throw new IllegalArgumentException(""Duplicate creator property \"""" + name + ""\"" (index "" + old + "" vs "" + i + "")"");
                }
            }
        }
        _propertyBasedArgs = properties;
    }",0,0
211,JacksonDatabind_69,"protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
    {
        final int mask = (1 << typeIndex);
        _hasNonDefaultCreator = true;
        AnnotatedWithParams oldOne = _creators[typeIndex];
        // already had an explicitly marked one?
        if (oldOne != null) {
            boolean verify;
             if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is
                 // but skip, if new one not annotated
                 if (!explicit) {
                     return;
                 }
                 // both explicit: verify
                 verify = true;
            } else {
                // otherwise only verify if neither explicitly annotated.
                verify = !explicit;
            }

            // one more thing: ok to override in sub-class
            if (verify && (oldOne.getClass() == newOne.getClass())) {
                // [databind#667]: avoid one particular class of bogus problems
                Class<?> oldType = oldOne.getRawParameterType(0);
                Class<?> newType = newOne.getRawParameterType(0);

                if (oldType == newType) {
                    throw new IllegalArgumentException(""Conflicting ""+TYPE_DESCS[typeIndex]
                            +"" creators: already had explicitly marked ""+oldOne+"", encountered ""+newOne);
                }
                // otherwise, which one to choose?
                if (newType.isAssignableFrom(oldType)) {
                    // new type more generic, use old
                    return;
                }
                // new type more specific, use it
            }
        }
        if (explicit) {
            _explicitCreators |= mask;
        }
        _creators[typeIndex] = _fixAccess(newOne);
    }","protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
    {
        final int mask = (1 << typeIndex);
        _hasNonDefaultCreator = true;
        AnnotatedWithParams oldOne = _creators[typeIndex];
        // already had an explicitly marked one?
        if (oldOne != null) {
            boolean verify;
            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is
                // but skip, if new one not annotated
                if (!explicit) {
                    return;
                }
                // both explicit: verify
                verify = true;
            } else {
                // otherwise only verify if neither explicitly annotated.
                verify = !explicit;
            }

            // one more thing: ok to override in sub-class
            if (verify && (oldOne.getClass() == newOne.getClass())) {
                // [databind#667]: avoid one particular class of bogus problems
                Class<?> oldType = oldOne.getRawParameterType(0);
                Class<?> newType = newOne.getRawParameterType(0);

                if (oldType.equals(newType)) {
                    throw new IllegalArgumentException(""Conflicting "" + TYPE_DESCS[typeIndex]
                            + "" creators: already had explicitly marked "" + oldOne + "", encountered "" + newOne);
                }
                // otherwise, which one to choose?
                if (newType.isAssignableFrom(oldType)) {
                    // new type more generic, use old
                    return;
                }
                // new type more specific, use it
            }
        }
        if (explicit) {
            _explicitCreators |= mask;
        }
        _creators[typeIndex] = _fixAccess(newOne);
    }",0,0
212,JacksonDatabind_72,"package com.fasterxml.jackson.databind.deser.impl;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;

import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
import com.fasterxml.jackson.databind.introspect.*;
import com.fasterxml.jackson.databind.util.ClassUtil;

/**
 * This sub-class is used to handle special case of value being a
 * non-static inner class. If so, we will have to use a special
 * alternative for default constructor; but otherwise can delegate
 * to regular implementation.
 */
public final class InnerClassProperty
    extends SettableBeanProperty
{
    private static final long serialVersionUID = 1L;

    /**
     * Actual property that we use after value construction.
     */
    protected final SettableBeanProperty _delegate;

    /**
     * Constructor used when deserializing this property.
     * Transient since there is no need to persist; only needed during
     * construction of objects.
     */
    final protected transient Constructor<?> _creator;
    
    /**
     * Serializable version of single-arg constructor we use for value instantiation.
     */
    protected AnnotatedConstructor _annotated;

    public InnerClassProperty(SettableBeanProperty delegate,
            Constructor<?> ctor)
    {
        super(delegate);
        _delegate = delegate;
        _creator = ctor;
    }

    /**
     * Constructor used with JDK Serialization; needed to handle transient
     * Constructor, wrap/unwrap in/out-of Annotated variant.
     */
    protected InnerClassProperty(InnerClassProperty src, AnnotatedConstructor ann)
    {
        super(src);
        _delegate = src._delegate;
        _annotated = ann;
        _creator = (_annotated == null) ? null : _annotated.getAnnotated();
        if (_creator == null) {
            throw new IllegalArgumentException(""Missing constructor (broken JDK (de)serialization?)"");
        }
    }
    
    protected InnerClassProperty(InnerClassProperty src, JsonDeserializer<?> deser)
    {
        super(src, deser);
        _delegate = src._delegate.withValueDeserializer(deser);
        _creator = src._creator;
    }

    protected InnerClassProperty(InnerClassProperty src, PropertyName newName) {
        super(src, newName);
        _delegate = src._delegate.withName(newName);
        _creator = src._creator;
    }

    @Override
    public InnerClassProperty withName(PropertyName newName) {
        return new InnerClassProperty(this, newName);
    }

    @Override
    public InnerClassProperty withValueDeserializer(JsonDeserializer<?> deser) {
        return new InnerClassProperty(this, deser);
    }

    @Override
    public void assignIndex(int index) { _delegate.assignIndex(index); }

    @Override
    public int getPropertyIndex() { return _delegate.getPropertyIndex(); }

    
    // // // BeanProperty impl
    
    @Override
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return _delegate.getAnnotation(acls);
    }

    @Override public AnnotatedMember getMember() {  return _delegate.getMember(); }

    /*
    /**********************************************************
    /* Deserialization methods
    /**********************************************************
     */

    @Override
    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean)
        throws IOException
    {
        JsonToken t = jp.getCurrentToken();
        Object value;
        if (t == JsonToken.VALUE_NULL) {
            value = _valueDeserializer.getNullValue(ctxt);
        } else if (_valueTypeDeserializer != null) {
            value = _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);
        } else  { // the usual case
            try {
                value = _creator.newInstance(bean);
            } catch (Exception e) {
                ClassUtil.unwrapAndThrowAsIAE(e, ""Failed to instantiate class ""+_creator.getDeclaringClass().getName()+"", problem: ""+e.getMessage());
                value = null;
            }
            _valueDeserializer.deserialize(jp, ctxt, value);
        }
        set(bean, value);
    }

    @Override
    public Object deserializeSetAndReturn(JsonParser jp,
      DeserializationContext ctxt, Object instance)
        throws IOException
    {
        return setAndReturn(instance, deserialize(jp, ctxt));
    }
    
    @Override
    public final void set(Object instance, Object value) throws IOException {
        _delegate.set(instance, value);
    }

    @Override
    public Object setAndReturn(Object instance, Object value) throws IOException {
        return _delegate.setAndReturn(instance, value);
    }

    /*
    /**********************************************************
    /* JDK serialization handling
    /**********************************************************
     */

    // When reading things back, 
    Object readResolve() {
        return new InnerClassProperty(this, _annotated);
    }

    Object writeReplace() {
        // need to construct a fake instance to support serialization
        if (_annotated != null) {
            return this;
        }
        return new InnerClassProperty(this, new AnnotatedConstructor(null, _creator, null, null));
    }
}
",Match failed,0,0
213,JacksonDatabind_73,"    protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props)
    {
        final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);
        Iterator<POJOPropertyBuilder> it = props.values().iterator();

        while (it.hasNext()) {
            POJOPropertyBuilder prop = it.next();
            // 26-Jan-2017, tatu: [databind#935]: need to denote removal of
            prop.removeNonVisible(inferMutators);
        }
    }","protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props) {
    final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);
    Iterator<POJOPropertyBuilder> it = props.values().iterator();

    while (it.hasNext()) {
        POJOPropertyBuilder prop = it.next();
        if (prop != null) {
            prop.removeNonVisible(inferMutators);
        }
    }
}",0,0
213,JacksonDatabind_73,"    public void removeNonVisible(boolean inferMutators)
    {
        /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition
         *  of explicit access type for property; if not ""AUTO"", it will
         *  dictate how visibility checks are applied.
         */
        JsonProperty.Access acc = findAccess();
        if (acc == null) {
            acc = JsonProperty.Access.AUTO;
        }
        switch (acc) {
        case READ_ONLY:
            // Remove setters, creators for sure, but fields too if deserializing
            _setters = null;
            _ctorParameters = null;
            if (!_forSerialization) {
                _fields = null;
            }
            break;
        case READ_WRITE:
            // no trimming whatsoever?
            break;
        case WRITE_ONLY:
            // remove getters, definitely, but also fields if serializing
            _getters = null;
            if (_forSerialization) {
                _fields = null;
            }
            break;
        default:
        case AUTO: // the default case: base it on visibility
            _getters = _removeNonVisible(_getters);
            _ctorParameters = _removeNonVisible(_ctorParameters);
    
            if (!inferMutators || (_getters == null)) {
                _fields = _removeNonVisible(_fields);
                _setters = _removeNonVisible(_setters);
            }
        }
    }","public void removeNonVisible(boolean inferMutators) {
    JsonProperty.Access acc = findAccess();
    if (acc == null) {
        acc = JsonProperty.Access.AUTO;
    }
    switch (acc) {
        case READ_ONLY:
            _setters = null;
            _ctorParameters = null;
            if (!_forSerialization) {
                _fields = null;
            }
            break;
        case READ_WRITE:
            // No changes needed
            break;
        case WRITE_ONLY:
            _getters = null;
            if (_forSerialization) {
                _fields = null;
            }
            break;
        default:
        case AUTO: 
            _getters = _removeNonVisible(_getters);
            _ctorParameters = _removeNonVisible(_ctorParameters);

            if (!inferMutators || (_getters == null)) {
                _fields = _removeNonVisible(_fields);
                _setters = _removeNonVisible(_setters);
            }
            break;
    }
}",0,0
214,JacksonDatabind_75,"@Override
    public JsonSerializer<?> createContextual(SerializerProvider serializers,
            BeanProperty property) throws JsonMappingException
    {
        if (property != null) {
            JsonFormat.Value format = findFormatOverrides(serializers,
                     property, handledType());
             if (format != null) {
                 Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(),
                         format, false);
                 if (serializeAsIndex != _serializeAsIndex) {
                     return new EnumSerializer(_values, serializeAsIndex);
                 }
            }
        }
        return this;
    }","@Override
public JsonSerializer<?> createContextual(SerializerProvider serializers,
        BeanProperty property) throws JsonMappingException {
    if (property != null) {
        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());
        if (format != null) {
            Boolean serializeAsIndex = _isShapeWrittenUsingIndex(
                    property.getType() != null ? property.getType().getRawClass() : null, 
                    format, 
                    false
            );
            if (!serializeAsIndex.equals(_serializeAsIndex)) {
                return new EnumSerializer(_values, serializeAsIndex);
            }
        }
    }
    return this;
}",0,0
214,JacksonDatabind_75,"@SuppressWarnings(""unchecked"")
    public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,
            BeanDescription beanDesc, JsonFormat.Value format)
    {
        /* 08-Apr-2015, tatu: As per [databind#749], we can not statically determine
         *   between name() and toString(), need to construct `EnumValues` with names,
          *   handle toString() case dynamically (for example)
          */
         EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass);
         Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);
         return new EnumSerializer(v, serializeAsIndex);
     }","@SuppressWarnings(""unchecked"")
public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,
        BeanDescription beanDesc, JsonFormat.Value format) {
    /* 08-Apr-2015, tatu: As per [databind#749], we can not statically determine
     *   between name() and toString(), need to construct `EnumValues` with names,
      *   handle toString() case dynamically (for example)
      */
    EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass);
    Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);
    return new EnumSerializer(v, serializeAsIndex != null ? serializeAsIndex : false);
}",0,0
215,JacksonDatabind_77,"@Override
    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        // We may also have custom overrides:
        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);
        if (custom != null) {
            return custom;
        }
        /* One more thing to check: do we have an exception type
         * (Throwable or its sub-classes)? If so, need slightly
         * different handling.
         */
        if (type.isThrowable()) {
            return buildThrowableDeserializer(ctxt, type, beanDesc);
        }
        /* Or, for abstract types, may have alternate means for resolution
         * (defaulting, materialization)
         */
        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are
        //    not something we could materialize anything for
        if (type.isAbstract() && !type.isPrimitive()) {
            // Let's make it possible to materialize abstract types.
            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);
            if (concreteType != null) {
                /* important: introspect actual implementation (abstract class or
                 * interface doesn't have constructors, for one)
                 */
                beanDesc = config.introspect(concreteType);
                return buildBeanDeserializer(ctxt, concreteType, beanDesc);
            }
        }

        // Otherwise, may want to check handlers for standard types, from superclass:
        @SuppressWarnings(""unchecked"")
        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);
        if (deser != null) {
            return deser;
        }

        // Otherwise: could the class be a Bean class? If not, bail out
        if (!isPotentialBeanType(type.getRawClass())) {
             return null;
         }
         // For checks like [databind#1599]
         // Use generic bean introspection to build deserializer
         return buildBeanDeserializer(ctxt, type, beanDesc);
     }","@Override
public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,
        JavaType type, BeanDescription beanDesc)
    throws JsonMappingException
{
    final DeserializationConfig config = ctxt.getConfig();
    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);
    if (custom != null) {
        return custom;
    }

    if (type.isThrowable()) {
        return buildThrowableDeserializer(ctxt, type, beanDesc);
    }

    if (type.isAbstract() && !type.isPrimitive()) {
        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);
        if (concreteType != null) {
            beanDesc = config.introspect(concreteType);
            return buildBeanDeserializer(ctxt, concreteType, beanDesc);
        }
    }

    @SuppressWarnings(""unchecked"")
    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);
    if (deser != null) {
        return deser;
    }
    
    Class<?> rawClass = type.getRawClass();
    if (rawClass == null || !isPotentialBeanType(rawClass)) {
        return null;
    }

    return buildBeanDeserializer(ctxt, type, beanDesc);
}",0,0
216,JacksonDatabind_78,"    protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc,
            Class<?> type, Map<Class<?>,Boolean> ignoredTypes)
    {
        Boolean status = ignoredTypes.get(type);
        if (status != null) {
            return status.booleanValue();
        }
        // 21-Apr-2016, tatu: For 2.8, can specify config overrides
        ConfigOverride override = config.findConfigOverride(type);
        if (override != null) {
            status = override.getIsIgnoredType();
        }
        if (status == null) {
            BeanDescription desc = config.introspectClassAnnotations(type);
            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());
            // We default to 'false', i.e. not ignorable
            if (status == null) {
                status = Boolean.FALSE;
            }
        }
        ignoredTypes.put(type, status);
        return status.booleanValue();
    }
","protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc,
            Class<?> type, Map<Class<?>,Boolean> ignoredTypes)
    {
        // First check if the type is cached in ignoredTypes
        Boolean status = ignoredTypes.get(type);
        if (status != null) {
            return status.booleanValue();
        }

        // Check for configuration overrides
        ConfigOverride override = config.findConfigOverride(type);
        if (override != null) {
            status = override.getIsIgnoredType();
        }

        // If not determined, introspect class annotations
        if (status == null) {
            BeanDescription desc = config.introspectClassAnnotations(type);
            AnnotationIntrospector ai = config.getAnnotationIntrospector();
            status = (ai == null) ? null : ai.isIgnorableType(desc.getClassInfo());
        }

        // Default to false if still undetermined
        if (status == null) {
            status = Boolean.FALSE;
        }

        ignoredTypes.put(type, status);
        return status.booleanValue();
    }",0,0
216,JacksonDatabind_78,"    public JsonDeserializer<Object> createBuilderBasedDeserializer(
    		DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,
    		Class<?> builderClass)
        throws JsonMappingException
    {
        // First: need a BeanDescription for builder class
        JavaType builderType = ctxt.constructType(builderClass);
        BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);
        return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);
    }
","public JsonDeserializer<Object> createBuilderBasedDeserializer(
        DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,
        Class<?> builderClass)
        throws JsonMappingException
    {
        // Validate that builderClass is not null
        if (builderClass == null) {
            throw new IllegalArgumentException(""Builder class cannot be null"");
        }

        // Construct JavaType for builder class
        JavaType builderType = ctxt.constructType(builderClass);

        // Fetch BeanDescription for the builder
        DeserializationConfig config = ctxt.getConfig();
        BeanDescription builderDesc = config.introspectForBuilder(builderType);

        // Delegate deserialization to downstream builder handler
        return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);
    }",0,0
216,JacksonDatabind_78,"    public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(
            new DeserializerFactoryConfig());

    public BeanDeserializerFactory(DeserializerFactoryConfig config) {
        super(config);
    }
","public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(
            new DeserializerFactoryConfig());

public BeanDeserializerFactory(DeserializerFactoryConfig config) {
    super(config);

    // Validate configuration to ensure it is not null
    if (config == null) {
        throw new IllegalArgumentException(""DeserializerFactoryConfig cannot be null"");
    }
}",0,0
217,JacksonDatabind_79,"@SuppressWarnings(""incomplete-switch"")
    @Override
    public JsonSerializer<?> createContextual(SerializerProvider provider,
            BeanProperty property)
        throws JsonMappingException
    {
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        final AnnotatedMember accessor = (property == null || intr == null)
                ? null : property.getMember();
        final SerializationConfig config = provider.getConfig();
        
        // Let's start with one big transmutation: Enums that are annotated
        // to serialize as Objects may want to revert
        JsonFormat.Shape shape = null;
        if (accessor != null) {
            JsonFormat.Value format = intr.findFormat((Annotated) accessor);

            if (format != null) {
                shape = format.getShape();
                // or, alternatively, asked to revert ""back to"" other representations...
                if (shape != _serializationShape) {
                    if (_handledType.isEnum()) {
                        switch (shape) {
                        case STRING:
                        case NUMBER:
                        case NUMBER_INT:
                            // 12-Oct-2014, tatu: May need to introspect full annotations... but
                            //   for now, just do class ones
                            BeanDescription desc = config.introspectClassAnnotations(_handledType);
                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType,
                                    provider.getConfig(), desc, format);
                            return provider.handlePrimaryContextualization(ser, property);
                        }
                    }
                }
            }
        }

        ObjectIdWriter oiw = _objectIdWriter;
        String[] ignorals = null;
        Object newFilterId = null;
        
        // Then we may have an override for Object Id
        if (accessor != null) {
            ignorals = intr.findPropertiesToIgnore(accessor, true);
            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);
             if (objectIdInfo == null) {
                 // no ObjectId override, but maybe ObjectIdRef?
                 if (oiw != null) {
                     objectIdInfo = intr.findObjectReferenceInfo(accessor,
                             new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));
                         oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());
                 }
             } else {
                 // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it
                // to be able to move to SerializerProvider (where it really belongs)
                
                // 2.1: allow modifications by ""id ref"" annotations as well:
                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);
                ObjectIdGenerator<?> gen;
                Class<?> implClass = objectIdInfo.getGeneratorType();
                JavaType type = provider.constructType(implClass);
                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];
                // Property-based generator is trickier
                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work
                    String propName = objectIdInfo.getPropertyName().getSimpleName();
                    BeanPropertyWriter idProp = null;

                    for (int i = 0, len = _props.length ;; ++i) {
                        if (i == len) {
                            throw new IllegalArgumentException(""Invalid Object Id definition for ""+_handledType.getName()
                                    +"": can not find property with name '""+propName+""'"");
                        }
                        BeanPropertyWriter prop = _props[i];
                        if (propName.equals(prop.getName())) {
                            idProp = prop;
                            /* Let's force it to be the first property to output
                             * (although it may still get rearranged etc)
                             */
                            if (i > 0) { // note: must shuffle both regular properties and filtered
                                System.arraycopy(_props, 0, _props, 1, i);
                                _props[0] = idProp;
                                if (_filteredProps != null) {
                                    BeanPropertyWriter fp = _filteredProps[i];
                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);
                                    _filteredProps[0] = fp;
                                }
                            }
                            break;
                        }
                    }
                    idType = idProp.getType();
                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);
                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());
                } else { // other types need to be simpler
                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);
                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,
                            objectIdInfo.getAlwaysAsId());
                }
            }
            
            // Or change Filter Id in use?
            Object filterId = intr.findFilterId(accessor);
            if (filterId != null) {
                // but only consider case of adding a new filter id (no removal via annotation)
                if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {
                    newFilterId = filterId;
                }
            }
        }
        // either way, need to resolve serializer:
        BeanSerializerBase contextual = this;
        if (oiw != null) {
            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);
            oiw = oiw.withSerializer(ser);
            if (oiw != _objectIdWriter) {
                contextual = contextual.withObjectIdWriter(oiw);
            }
        }
        // And possibly add more properties to ignore
        if (ignorals != null && ignorals.length != 0) {
            contextual = contextual.withIgnorals(ignorals);
        }
        if (newFilterId != null) {
            contextual = contextual.withFilterId(newFilterId);
        }
        if (shape == null) {
            shape = _serializationShape;
        }
        if (shape == JsonFormat.Shape.ARRAY) {
            return contextual.asArraySerializer();
        }
        return contextual;
    }","@SuppressWarnings(""incomplete-switch"")
@Override
public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)
        throws JsonMappingException {
    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();
    final SerializationConfig config = provider.getConfig();

    JsonFormat.Shape shape = null;
    if (accessor != null) {
        JsonFormat.Value format = intr.findFormat(accessor);
        if (format != null) {
            shape = format.getShape();
            if (shape != _serializationShape && _handledType.isEnum()) {
                switch (shape) {
                case STRING:
                case NUMBER:
                case NUMBER_INT:
                    BeanDescription desc = config.introspectClassAnnotations(_handledType);
                    JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);
                    return provider.handlePrimaryContextualization(ser, property);
                default:
                    break;
                }
            }
        }
    }

    ObjectIdWriter oiw = _objectIdWriter;
    String[] ignorals = null;
    Object newFilterId = null;

    if (accessor != null) {
        ignorals = intr.findPropertiesToIgnore(accessor, true);
        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);

        if (objectIdInfo == null && oiw != null) {
            objectIdInfo = intr.findObjectReferenceInfo(accessor,
                    new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));
            oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());
        } else if (objectIdInfo != null) {
            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);
            Class<?> implClass = objectIdInfo.getGeneratorType();
            JavaType idType = provider.constructType(implClass)
                    .findTypeParameters(implClass, ObjectIdGenerator.class)[0];

            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {
                String propName = objectIdInfo.getPropertyName().getSimpleName();
                BeanPropertyWriter idProp = null;

                for (BeanPropertyWriter prop : _props) {
                    if (propName.equals(prop.getName())) {
                        idProp = prop;
                        break;
                    }
                }

                if (idProp == null) {
                    throw new IllegalArgumentException(""Invalid Object Id definition for "" + _handledType.getName()
                            + "": can not find property with name '"" + propName + ""'"");
                }

                idType = idProp.getType();
                oiw = ObjectIdWriter.construct(
                        idType, (PropertyName) null, new PropertyBasedObjectIdGenerator(objectIdInfo, idProp),
                        objectIdInfo.getAlwaysAsId());
            } else {
                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(),
                        provider.objectIdGeneratorInstance(accessor, objectIdInfo),
                        objectIdInfo.getAlwaysAsId());
            }
        }

        Object filterId = intr.findFilterId(accessor);
        if (filterId != null && (newFilterId == null || !filterId.equals(_propertyFilterId))) {
            newFilterId = filterId;
        }
    }

    BeanSerializerBase contextual = this;
    if (oiw != null) {
        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);
        oiw = oiw.withSerializer(ser);

        if (oiw != _objectIdWriter) {
            contextual = contextual.withObjectIdWriter(oiw);
        }
    }

    if (ignorals != null && ignorals.length > 0) {
        contextual = contextual.withIgnorals(ignorals);
    }
    if (newFilterId != null) {
        contextual = contextual.withFilterId(newFilterId);
    }
    if (shape == null) {
        shape = _serializationShape;
    }
    if (shape == JsonFormat.Shape.ARRAY) {
        return contextual.asArraySerializer();
    }
    return contextual;
}",0,0
217,JacksonDatabind_79,"@Override
     public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {
         JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);
         if (ref != null) {
             objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());
         }
         return objectIdInfo;
     }","@Override
public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {
    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);
    if (ref != null) {
        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());
    }
    return objectIdInfo != null ? objectIdInfo : new ObjectIdInfo(null, null, null, false);
}",0,0
218,JacksonDatabind_80,"        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
        // for backwards compatibility, must allow null here:
        Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();
        
        HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();
        // start with registered subtypes (which have precedence)
        if (_registeredSubtypes != null) {
            for (NamedType subtype : _registeredSubtypes) {
                // is it a subtype of root type?
                if (rawBase.isAssignableFrom(subtype.getType())) { // yes
                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,
                            subtype.getType());
                    _collectAndResolve(curr, subtype, config, ai, collected);
                }
            }
        }
","final AnnotationIntrospector ai = config.getAnnotationIntrospector();
// for backwards compatibility, must allow null here:
Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();

HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();
// start with registered subtypes (which have precedence)
if (_registeredSubtypes != null) {
    for (NamedType subtype : _registeredSubtypes) {
        // is it a subtype of root type?
        if (rawBase != null && rawBase.isAssignableFrom(subtype.getType())) { // yes
            AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,
                    subtype.getType());
            _collectAndResolve(curr, subtype, config, ai, collected);
        }
    }
}",0,0
218,JacksonDatabind_80,"        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
        Class<?> rawBase = baseType.getRawClass();

        // Need to keep track of classes that have been handled already 
        Set<Class<?>> typesHandled = new HashSet<Class<?>>();
        Map<String,NamedType> byName = new LinkedHashMap<String,NamedType>();

        // start with lowest-precedence, which is from type hierarchy
        NamedType rootType = new NamedType(rawBase, null);
        AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,
                rawBase);
        _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);
        
        // then with definitions from property
            Collection<NamedType> st = ai.findSubtypes(property);
            if (st != null) {
                for (NamedType nt : st) {
                    ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());
                    _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);
                }            
        }
","final AnnotationIntrospector ai = config.getAnnotationIntrospector();
Class<?> rawBase = (baseType != null) ? baseType.getRawClass() : property.getRawType();

if (rawBase != null) {
    // Need to keep track of classes that have been handled already 
    Set<Class<?>> typesHandled = new HashSet<Class<?>>();
    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();

    // start with lowest-precedence, which is from type hierarchy
    NamedType rootType = new NamedType(rawBase, null);
    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,
            rawBase);
    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);

    // then with definitions from property
    Collection<NamedType> st = ai.findSubtypes(property);
    if (st != null) {
        for (NamedType nt : st) {
            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());
            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);
        }
    }
}",0,0
219,JacksonDatabind_81,"        final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());
        if (serClass != null) {
            if (type.hasRawClass(serClass)) {
                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of
                //    static typing this way
                type = type.withStaticTyping();
            } else {
                Class<?> currRaw = type.getRawClass();
                try {
                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,
                    //   may be needed here too in future?
                    if (serClass.isAssignableFrom(currRaw)) { // common case
                        type = tf.constructGeneralizedType(type, serClass);
                    } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well
                        type = tf.constructSpecializedType(type, serClass);
                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements
                    } else {
                        throw new JsonMappingException(null,
                                String.format(""Can not refine serialization type %s into %s; types not related"",
                                        type, serClass.getName()));
                    }
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(null,
                            String.format(""Failed to widen type %s with annotation (value %s), from '%s': %s"",
                                    type, serClass.getName(), a.getName(), iae.getMessage()),
                                    iae);
                }
            }
        }
","final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());
if (serClass != null && !type.hasRawClass(Void.class)) { // Ensure Void.class case is handled
    if (type.hasRawClass(serClass)) {
        // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of static typing this way
        type = type.withStaticTyping();
    } else {
        Class<?> currRaw = type.getRawClass();
        try {
            if (serClass.isAssignableFrom(currRaw)) { // common case
                type = tf.constructGeneralizedType(type, serClass);
            } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well
                type = tf.constructSpecializedType(type, serClass);
            } else {
                throw new JsonMappingException(null, String.format(
                        ""Can not refine serialization type %s into %s; types not related"", type, serClass.getName()));
            }
        } catch (IllegalArgumentException iae) {
            throw new JsonMappingException(null, String.format(
                    ""Failed to widen type %s with annotation (value %s), from '%s': %s"",
                    type, serClass.getName(), a.getName(), iae.getMessage()), iae);
        }
    }
}",0,0
219,JacksonDatabind_81,"            final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());
            if (keyClass != null) {
                try {
                    keyType = tf.constructSpecializedType(keyType, keyClass);
                    type = ((MapLikeType) type).withKeyType(keyType);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(null,
                            String.format(""Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s"",
                                    type, keyClass.getName(), a.getName(), iae.getMessage()),
                                    iae);
                }
            }
","final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());
if (keyClass != null && !type.isMapLikeType()) { // Ensure Map-like type is being processed
    try {
        keyType = tf.constructSpecializedType(keyType, keyClass);
        type = ((MapLikeType) type).withKeyType(keyType);
    } catch (IllegalArgumentException iae) {
        throw new JsonMappingException(null, String.format(
                ""Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s"",
                type, keyClass.getName(), a.getName(), iae.getMessage()), iae);
    }
}",0,0
219,JacksonDatabind_81,"            final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());
            if (keyClass != null) {
                if (keyType.hasRawClass(keyClass)) {
                    keyType = keyType.withStaticTyping();
                } else {
                    Class<?> currRaw = keyType.getRawClass();
                    try {
                        // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually
                        //   specialize (narrow) type sometimes, even if more commonly opposite
                        //   is needed.
                        if (keyClass.isAssignableFrom(currRaw)) { // common case
                            keyType = tf.constructGeneralizedType(keyType, keyClass);
                        } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well
                            keyType = tf.constructSpecializedType(keyType, keyClass);
                            // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements
                        } else {
                            throw new JsonMappingException(null,
                                    String.format(""Can not refine serialization key type %s into %s; types not related"",
                                            keyType, keyClass.getName()));
                        }
                    } catch (IllegalArgumentException iae) {
                        throw new JsonMappingException(null,
                                String.format(""Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s"",
                                        type, keyClass.getName(), a.getName(), iae.getMessage()),
                                        iae);
                    }
                }
                type = ((MapLikeType) type).withKeyType(keyType);
            }
","final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());
if (keyClass != null) {
    if (keyType.hasRawClass(keyClass)) {
        keyType = keyType.withStaticTyping();
    } else {
        Class<?> currRaw = keyType.getRawClass();
        try {
            if (keyClass.isAssignableFrom(currRaw)) { // common case
                keyType = tf.constructGeneralizedType(keyType, keyClass);
            } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well
                keyType = tf.constructSpecializedType(keyType, keyClass);
            } else {
                throw new JsonMappingException(null, String.format(
                        ""Can not refine serialization key type %s into %s; types not related"",
                        keyType, keyClass.getName()));
            }
        } catch (IllegalArgumentException iae) {
            throw new JsonMappingException(null, String.format(
                    ""Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s"",
                    type, keyClass.getName(), a.getName(), iae.getMessage()), iae);
        }
    }
    if (type.isMapLikeType()) { // Ensure type is Map-like before modification
        type = ((MapLikeType) type).withKeyType(keyType);
    }
}",0,0
219,JacksonDatabind_81,"    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {
        return StdTypeResolverBuilder.noTypeInfoBuilder();
    }
","protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {
    // Ensure the builder is always returned in a valid state
    return StdTypeResolverBuilder.noTypeInfoBuilder();
}",0,0
219,JacksonDatabind_81,"        final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);
        
        // Ok: start by refining the main type itself; common to all types
        final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());
        if ((valueClass != null) && !type.hasRawClass(valueClass)) {
            try {
                type = tf.constructSpecializedType(type, valueClass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(null,
                        String.format(""Failed to narrow type %s with annotation (value %s), from '%s': %s"",
                                type, valueClass.getName(), a.getName(), iae.getMessage()),
                                iae);
            }
        }
","final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);
final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());
if (valueClass != null && !type.hasRawClass(Void.class) && !type.hasRawClass(valueClass)) {
    try {
        type = tf.constructSpecializedType(type, valueClass);
    } catch (IllegalArgumentException iae) {
        throw new JsonMappingException(null, String.format(
                ""Failed to narrow type %s with annotation (value %s), from '%s': %s"",
                type, valueClass.getName(), a.getName(), iae.getMessage()), iae);
    }
}",0,0
219,JacksonDatabind_81,"        final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());
        if ((valueClass != null) && !type.hasRawClass(valueClass)) {
            try {
                type = tf.constructSpecializedType(type, valueClass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(null,
                        String.format(""Failed to narrow type %s with annotation (value %s), from '%s': %s"",
                                type, valueClass.getName(), a.getName(), iae.getMessage()),
                                iae);
            }
        }
","final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());
if (valueClass != null && !type.hasRawClass(Void.class) && !type.hasRawClass(valueClass)) {
    try {
        type = tf.constructSpecializedType(type, valueClass);
    } catch (IllegalArgumentException iae) {
        throw new JsonMappingException(null, String.format(
                ""Failed to narrow type %s with annotation (value %s), from '%s': %s"",
                type, valueClass.getName(), a.getName(), iae.getMessage()), iae);
    }
}",0,0
219,JacksonDatabind_81,"           final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());
           if (contentClass != null) {
               if (contentType.hasRawClass(contentClass)) {
                   contentType = contentType.withStaticTyping();
               } else {
                   // 03-Apr-2016, tatu: As per [databind#1178], may need to actually
                   //   specialize (narrow) type sometimes, even if more commonly opposite
                   //   is needed.
                   Class<?> currRaw = contentType.getRawClass();
                   try {
                       if (contentClass.isAssignableFrom(currRaw)) { // common case
                           contentType = tf.constructGeneralizedType(contentType, contentClass);
                       } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well
                           contentType = tf.constructSpecializedType(contentType, contentClass);
                           // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements
                       } else {
                           throw new JsonMappingException(null,
                                   String.format(""Can not refine serialization content type %s into %s; types not related"",
                                           contentType, contentClass.getName()));
                       }
                   } catch (IllegalArgumentException iae) { // shouldn't really happen
                       throw new JsonMappingException(null,
                               String.format(""Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s"",
                                       type, contentClass.getName(), a.getName(), iae.getMessage()),
                                       iae);
                   }
               }
               type = type.withContentType(contentType);
           }
","final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());
if (contentClass != null) {
    if (contentType.hasRawClass(contentClass)) {
        contentType = contentType.withStaticTyping();
    } else {
        Class<?> currRaw = contentType.getRawClass();
        try {
            if (contentClass.isAssignableFrom(currRaw)) { // common case
                contentType = tf.constructGeneralizedType(contentType, contentClass);
            } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well
                contentType = tf.constructSpecializedType(contentType, contentClass);
            } else {
                throw new JsonMappingException(null, String.format(
                        ""Can not refine serialization content type %s into %s; types not related"",
                        contentType, contentClass.getName()));
            }
        } catch (IllegalArgumentException iae) {
            throw new JsonMappingException(null, String.format(
                    ""Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s"",
                    type, contentClass.getName(), a.getName(), iae.getMessage()), iae);
        }
    }
    type = type.withContentType(contentType);
}",0,0
220,JacksonDatabind_84,"    public void setReference(JavaType ref)
    {
        // sanity check; should not be called multiple times
        if (_referencedType != null) {
            throw new IllegalStateException(""Trying to re-set self reference; old value = ""+_referencedType+"", new = ""+ref);
        }
        _referencedType = ref;
    }
","public void setReference(JavaType ref) {
    // sanity check; should not be called multiple times
    if (_referencedType != null && !_referencedType.equals(ref)) {
        throw new IllegalStateException(""Trying to re-set self reference; old value = "" + _referencedType + "", new = "" + ref);
    }
    _referencedType = ref;
}",0,0
221,JacksonDatabind_86,"    public void setReference(JavaType ref)
    {
        // sanity check; should not be called multiple times
        if (_referencedType != null) {
            throw new IllegalStateException(""Trying to re-set self reference; old value = ""+_referencedType+"", new = ""+ref);
        }
        _referencedType = ref;
    }
","public void setReference(JavaType ref) {
    // sanity check; should not be called multiple times
    if (_referencedType != null && !_referencedType.equals(ref)) {
        throw new IllegalStateException(""Trying to re-set self reference; old value = "" + _referencedType + "", new = "" + ref);
    }
    _referencedType = ref;
}",0,0
222,JacksonDatabind_87,"package com.fasterxml.jackson.databind.util;

import java.text.DateFormat;
import java.text.FieldPosition;
import java.text.ParseException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.*;

import com.fasterxml.jackson.core.io.NumberInput;

/**
 * Default {@link DateFormat} implementation used by standard Date
 * serializers and deserializers. For serialization defaults to using
 * an ISO-8601 compliant format (format String ""yyyy-MM-dd'T'HH:mm:ss.SSSZ"")
 * and for deserialization, both ISO-8601 and RFC-1123.
 */
@SuppressWarnings(""serial"")
public class StdDateFormat
    extends DateFormat
{
    /* TODO !!! 24-Nov-2009, tatu: Should rewrite this class:
     * JDK date parsing is awfully brittle, and ISO-8601 is quite
     * permissive. The two don't mix, need to write a better one.
     */
    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still
    //   not really robust. But still in use.

    /**
     * Defines a commonly used date format that conforms
     * to ISO-8601 date formatting standard, when it includes basic undecorated
     * timezone definition
     */
    public final static String DATE_FORMAT_STR_ISO8601 = ""yyyy-MM-dd'T'HH:mm:ss.SSSZ"";

    /**
     * Same as 'regular' 8601, but handles 'Z' as an alias for ""+0000""
     * (or ""UTC"")
     */
    protected final static String DATE_FORMAT_STR_ISO8601_Z = ""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"";

    /**
     * Same as 'regular' 8601 except misses timezone altogether
     *
     * @since 2.8.10
     */

    /**
     * ISO-8601 with just the Date part, no time
     */
    protected final static String DATE_FORMAT_STR_PLAIN = ""yyyy-MM-dd"";

    /**
     * This constant defines the date format specified by
     * RFC 1123 / RFC 822.
     */
    protected final static String DATE_FORMAT_STR_RFC1123 = ""EEE, dd MMM yyyy HH:mm:ss zzz"";

    /**
     * For error messages we'll also need a list of all formats.
     */
    protected final static String[] ALL_FORMATS = new String[] {
        DATE_FORMAT_STR_ISO8601,
        DATE_FORMAT_STR_ISO8601_Z,
        DATE_FORMAT_STR_RFC1123,
        DATE_FORMAT_STR_PLAIN
    };

    /**
     * By default we use UTC for everything, with Jackson 2.7 and later
     * (2.6 and earlier relied on GMT)
     */
    private final static TimeZone DEFAULT_TIMEZONE;
    static {
        DEFAULT_TIMEZONE = TimeZone.getTimeZone(""UTC""); // since 2.7
    }

    private final static Locale DEFAULT_LOCALE = Locale.US;

    protected final static DateFormat DATE_FORMAT_RFC1123;

    protected final static DateFormat DATE_FORMAT_ISO8601;
    protected final static DateFormat DATE_FORMAT_ISO8601_Z;

    protected final static DateFormat DATE_FORMAT_PLAIN;

    /* Let's construct ""blueprint"" date format instances: can not be used
     * as is, due to thread-safety issues, but can be used for constructing
     * actual instances more cheaply (avoids re-parsing).
     */
    static {
        /* Another important thing: let's force use of default timezone for
         * baseline DataFormat objects
         */

        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);
        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);
        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);
        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);
        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);
        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);
        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);
        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);
    }
    
    /**
     * A singleton instance can be used for cloning purposes, as a blueprint of sorts.
     */
    public final static StdDateFormat instance = new StdDateFormat();
    
    /**
     * Caller may want to explicitly override timezone to use; if so,
     * we will have non-null value here.
     */
    protected transient TimeZone _timezone;

    protected final Locale _locale;

    /**
     * Explicit override for leniency, if specified.
     *<p>
     * Can not be `final` because {@link #setLenient(boolean)} returns
     * `void`.
     *
     * @since 2.7
     */
    protected Boolean _lenient;
    
    protected transient DateFormat _formatRFC1123;
    protected transient DateFormat _formatISO8601;
    protected transient DateFormat _formatISO8601_z;
    protected transient DateFormat _formatPlain;

    /*
    /**********************************************************
    /* Life cycle, accessing singleton ""standard"" formats
    /**********************************************************
     */

    public StdDateFormat() {
        _locale = DEFAULT_LOCALE;
    }

    @Deprecated // since 2.7
    public StdDateFormat(TimeZone tz, Locale loc) {
        _timezone = tz;
        _locale = loc;
    }

    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {
        _timezone = tz;
        _locale = loc;
        _lenient = lenient;
    }
    
    public static TimeZone getDefaultTimeZone() {
        return DEFAULT_TIMEZONE;
    }
    
    /**
     * Method used for creating a new instance with specified timezone;
     * if no timezone specified, defaults to the default timezone (UTC).
     */
    public StdDateFormat withTimeZone(TimeZone tz) {
        if (tz == null) {
            tz = DEFAULT_TIMEZONE;
        }
        if ((tz == _timezone) || tz.equals(_timezone)) {
            return this;
        }
        return new StdDateFormat(tz, _locale, _lenient);
    }

    public StdDateFormat withLocale(Locale loc) {
        if (loc.equals(_locale)) {
            return this;
        }
        return new StdDateFormat(_timezone, loc, _lenient);
    }
    
    @Override
    public StdDateFormat clone() {
        /* Although there is that much state to share, we do need to
         * orchestrate a bit, mostly since timezones may be changed
         */
        return new StdDateFormat(_timezone, _locale, _lenient);
    }

    /**
     * @deprecated Since 2.4; use variant that takes Locale
     */
    @Deprecated
    public static DateFormat getISO8601Format(TimeZone tz) {
        return getISO8601Format(tz, DEFAULT_LOCALE);
    }

    /**
     * Method for getting a non-shared DateFormat instance
     * that uses specified timezone and can handle simple ISO-8601
     * compliant date format.
     * 
     * @since 2.4
     */
    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {
        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);
    }

    /**
     * Method for getting a non-shared DateFormat instance
     * that uses specific timezone and can handle RFC-1123
     * compliant date format.
     * 
     * @since 2.4
     */
    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {
        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                tz, loc, null);
    }

    /**
     * @deprecated Since 2.4; use variant that takes Locale
     */
    @Deprecated
    public static DateFormat getRFC1123Format(TimeZone tz) {
        return getRFC1123Format(tz, DEFAULT_LOCALE);
    }

    /*
    /**********************************************************
    /* Public API, configuration
    /**********************************************************
     */

    @Override // since 2.6
    public TimeZone getTimeZone() {
        return _timezone;
    }

    @Override
    public void setTimeZone(TimeZone tz)
    {
        /* DateFormats are timezone-specific (via Calendar contained),
         * so need to reset instances if timezone changes:
         */
        if (!tz.equals(_timezone)) {
            _clearFormats();
            _timezone = tz;
        }
    }

    /**
     * Need to override since we need to keep track of leniency locally,
     * and not via underlying {@link Calendar} instance like base class
     * does.
     */
    @Override // since 2.7
    public void setLenient(boolean enabled) {
        Boolean newValue = enabled;
        if (_lenient != newValue) {
            _lenient = newValue;
            // and since leniency settings may have been used:
            _clearFormats();
        }
    }

    @Override // since 2.7
    public boolean isLenient() {
        if (_lenient == null) {
            // default is, I believe, true
            return true;
        }
        return _lenient.booleanValue();
    }

    /*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */

    @Override
    public Date parse(String dateStr) throws ParseException
    {
        dateStr = dateStr.trim();
        ParsePosition pos = new ParsePosition(0);

        Date dt;

        if (looksLikeISO8601(dateStr)) { // also includes ""plain""
            dt = parseAsISO8601(dateStr, pos, true);
        } else {
            // Also consider ""stringified"" simple time stamp
            int i = dateStr.length();
            while (--i >= 0) {
                char ch = dateStr.charAt(i);
                if (ch < '0' || ch > '9') {
                    // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                    if (i > 0 || ch != '-') {
                        break;
                    }
                }
            }
            if ((i < 0)
                // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
                dt = new Date(Long.parseLong(dateStr));
            } else {
                // Otherwise, fall back to using RFC 1123
                dt = parseAsRFC1123(dateStr, pos);
            }
        }
        if (dt != null) {
            return dt;
        }

        StringBuilder sb = new StringBuilder();
        for (String f : ALL_FORMATS) {
            if (sb.length() > 0) {
                sb.append(""\"", \"""");
            } else {
                sb.append('""');
            }
            sb.append(f);
        }
        sb.append('""');
        throw new ParseException
            (String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"",
                           dateStr, sb.toString()), pos.getErrorIndex());
    }

    @Override
    public Date parse(String dateStr, ParsePosition pos)
    {
        if (looksLikeISO8601(dateStr)) { // also includes ""plain""
            try {
                return parseAsISO8601(dateStr, pos, false);
            } catch (ParseException e) { // will NOT be thrown due to false but is declared...
                return null;
            }
        }
        // Also consider ""stringified"" simple time stamp
        int i = dateStr.length();
        while (--i >= 0) {
            char ch = dateStr.charAt(i);
            if (ch < '0' || ch > '9') {
                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                if (i > 0 || ch != '-') {
                    break;
                }
            }
        }
        if (i < 0) { // all digits
            // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {
                return new Date(Long.parseLong(dateStr));
            }
        }
        // Otherwise, fall back to using RFC 1123
        return parseAsRFC1123(dateStr, pos);
    }

    /*
    /**********************************************************
    /* Public API, writing
    /**********************************************************
     */
    
    @Override
    public StringBuffer format(Date date, StringBuffer toAppendTo,
            FieldPosition fieldPosition)
    {
        if (_formatISO8601 == null) {
            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,
                    _timezone, _locale, _lenient);
        }
        return _formatISO8601.format(date, toAppendTo, fieldPosition);
    }

    /*
    /**********************************************************
    /* Std overrides
    /**********************************************************
     */
    
    @Override
    public String toString() {
        String str = ""DateFormat ""+getClass().getName();
        TimeZone tz = _timezone;
        if (tz != null) {
            str += "" (timezone: ""+tz+"")"";
        }
        str += ""(locale: ""+_locale+"")"";
        return str;
    }

    @Override // since 2.7[.2], as per [databind#1130]
    public boolean equals(Object o) {
        return (o == this);
    }

    @Override // since 2.7[.2], as per [databind#1130]
    public int hashCode() {
        return System.identityHashCode(this);
    }

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    /**
     * Overridable helper method used to figure out which of supported
     * formats is the likeliest match.
     */
    protected boolean looksLikeISO8601(String dateStr)
    {
        if (dateStr.length() >= 5
            && Character.isDigit(dateStr.charAt(0))
            && Character.isDigit(dateStr.charAt(3))
            && dateStr.charAt(4) == '-'
            ) {
            return true;
        }
        return false;
    }

    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)
            throws ParseException
    {
        /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */

        /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
        int len = dateStr.length();
        char c = dateStr.charAt(len-1);
        DateFormat df;
        String formatStr;

        // Need to support ""plain"" date...
        if (len <= 10 && Character.isDigit(c)) {
            df = _formatPlain;
            formatStr = DATE_FORMAT_STR_PLAIN;
            if (df == null) {
                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,
                        _timezone, _locale, _lenient);
            }
        } else if (c == 'Z') {
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,
                        DEFAULT_TIMEZONE, _locale, _lenient);
            }
            // may be missing milliseconds... if so, add
            if (dateStr.charAt(len-4) == ':') {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len-1, "".000"");
                dateStr = sb.toString();
            }
        } else {
            // Let's see if we have timezone indicator or not...
            if (hasTimeZone(dateStr)) {
                c = dateStr.charAt(len-3);
                if (c == ':') { // remove optional colon
                    // remove colon
                    StringBuilder sb = new StringBuilder(dateStr);
                    sb.delete(len-3, len-2);
                    dateStr = sb.toString();
                } else if (c == '+' || c == '-') { // missing minutes
                    // let's just append '00'
                    dateStr += ""00"";
                }
                // Milliseconds partial or missing; and even seconds are optional
                len = dateStr.length();
                // remove 'T', '+'/'-' and 4-digit timezone-offset
                int timeLen = len - dateStr.lastIndexOf('T') - 6;
                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss
                    int offset = len - 5; // insertion offset, before tz-offset
                    StringBuilder sb = new StringBuilder(dateStr);
                    switch (timeLen) {
                    case 11:
                        sb.insert(offset, '0'); break;
                    case 10:
                        sb.insert(offset, ""00""); break;
                    case 9: // is this legal? (just second fraction marker)
                        sb.insert(offset, ""000""); break;
                    case 8:
                        sb.insert(offset, "".000""); break;
                    case 7: // not legal to have single-digit second
                        break;
                    case 6: // probably not legal, but let's allow
                        sb.insert(offset, ""00.000"");
                    case 5: // is legal to omit seconds
                        sb.insert(offset, "":00.000"");
                    }
                    dateStr = sb.toString();
                }
                df = _formatISO8601;
                formatStr = DATE_FORMAT_STR_ISO8601;
                if (_formatISO8601 == null) {
                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,
                            _timezone, _locale, _lenient);
                }
            } else {
                // If not, plain date, no timezone
                StringBuilder sb = new StringBuilder(dateStr);
                int timeLen = len - dateStr.lastIndexOf('T') - 1;
                // And possible also millisecond part if missing
                if (timeLen < 12) { // missing, or partial
                    switch (timeLen) {
                    case 11: sb.append('0');
                    case 10: sb.append('0');
                    case 9: sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                    }
                }
                sb.append('Z');
                dateStr = sb.toString();
                df = _formatISO8601_z;
                formatStr = DATE_FORMAT_STR_ISO8601_Z;
                if (df == null) {
                    // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                    //    must use UTC, not whatever is configured as default timezone
                    //    (because we know `Z` identifier is used)
                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,
                            DEFAULT_TIMEZONE, _locale, _lenient);
                }
            }
        }
        Date dt = df.parse(dateStr, pos);
        // 22-Dec-2015, tatu: With non-lenient, may get null
        if (dt == null) {
            throw new ParseException
            (String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"",
                           dateStr, formatStr, _lenient),
               pos.getErrorIndex());
        }
        return dt;
    }

    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)
    {
        if (_formatRFC1123 == null) {
            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                    _timezone, _locale, _lenient);
        }
        return _formatRFC1123.parse(dateStr, pos);
    }

    private final static boolean hasTimeZone(String str)
    {
        // Only accept ""+hh"", ""+hhmm"" and ""+hh:mm"" (and with minus), so
        int len = str.length();
        if (len >= 6) {
            char c = str.charAt(len-6);
            if (c == '+' || c == '-') return true;
            c = str.charAt(len-5);
            if (c == '+' || c == '-') return true;
            c = str.charAt(len-3);
            if (c == '+' || c == '-') return true;
        }
        return false;
    }

    private final static DateFormat _cloneFormat(DateFormat df, String format,
            TimeZone tz, Locale loc, Boolean lenient)
    {
        if (!loc.equals(DEFAULT_LOCALE)) {
            df = new SimpleDateFormat(format, loc);
            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);
        } else {
            df = (DateFormat) df.clone();
            if (tz != null) {
                df.setTimeZone(tz);
            }
        }
        if (lenient != null) {
            df.setLenient(lenient.booleanValue());
        }
        return df;
    }

    protected void _clearFormats() {
        _formatRFC1123 = null;
        _formatISO8601 = null;
        _formatISO8601_z = null;

        _formatPlain = null;
    }
}

",Match failed,0,0
223,JacksonDatabind_90,"    public boolean canInstantiate() {
        return canCreateUsingDefault()
                || canCreateUsingDelegate() 
                || canCreateFromObjectWith() || canCreateFromString()
                || canCreateFromInt() || canCreateFromLong()
                || canCreateFromDouble() || canCreateFromBoolean();
    }
","public boolean canInstantiate() {
    return canCreateUsingDefault()
            || canCreateUsingDelegate()
            || canCreateFromObjectWith()
            || canCreateFromString()
            || canCreateFromInt()
            || canCreateFromLong()
            || canCreateFromDouble()
            || canCreateFromBoolean();
}",0,0
223,JacksonDatabind_90,"    public boolean canCreateFromObjectWith() {
        return (_withArgsCreator != null);
    }
","public boolean canCreateFromObjectWith() {
    return (_withArgsCreator != null) && !_withArgsCreator.isEmpty();
}",0,0
224,JacksonDatabind_92,"    public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(
            new DeserializerFactoryConfig());

    public BeanDeserializerFactory(DeserializerFactoryConfig config) {
        super(config);
    }
","public final static BeanDeserializerFactory instance;

static {
    instance = new BeanDeserializerFactory(new DeserializerFactoryConfig());
}

public BeanDeserializerFactory(DeserializerFactoryConfig config) {
    super(config);
}",0,0
225,JacksonDatabind_94,"public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException
    {
        // There are certain nasty classes that could cause problems, mostly
        // via default typing -- catch them here.
        final Class<?> raw = type.getRawClass();
        String full = raw.getName();

        main_check:
        do {
            if (_cfgIllegalClassNames.contains(full)) {
                break;
            }

            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling
            //    for some Spring framework types
            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces
            if (raw.isInterface()) {
                ;
            } else if (full.startsWith(PREFIX_SPRING)) {
                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){
                    String name = cls.getSimpleName();
                    // looking for ""AbstractBeanFactoryPointcutAdvisor"" but no point to allow any is there?
                    if (""AbstractPointcutAdvisor"".equals(name)
                            // ditto  for ""FileSystemXmlApplicationContext"": block all ApplicationContexts
                             || ""AbstractApplicationContext"".equals(name)) {
                         break main_check;
                     }
                 // [databind#1737]; more 3rd party
                 // s.add(""com.mchange.v2.c3p0.JndiRefForwardingDataSource"");
                 // s.add(""com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"");
                 // [databind#1931]; more 3rd party
                 // com.mchange.v2.c3p0.ComboPooledDataSource
                 // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource 
                 }
             }
             return;
        } while (false);

        throw JsonMappingException.from(ctxt,
                String.format(""Illegal type (%s) to deserialize: prevented for security reasons"", full));
    }","public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException {
    // There are certain nasty classes that could cause problems, mostly
    // via default typing -- catch them here.
    final Class<?> raw = type.getRawClass();
    String full = raw.getName();

    // Early return if illegal class name is found
    if (_cfgIllegalClassNames.contains(full)) {
        throw JsonMappingException.from(ctxt,
                String.format(""Illegal type (%s) to deserialize: prevented for security reasons"", full));
    }

    // Perform checks for certain Spring framework types
    if (!raw.isInterface() && full.startsWith(PREFIX_SPRING)) {
        for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {
            String name = cls.getSimpleName();
            // Looking for specific class names
            if (""AbstractPointcutAdvisor"".equals(name)
                    || ""AbstractApplicationContext"".equals(name)) {
                throw JsonMappingException.from(ctxt,
                        String.format(""Illegal type (%s) to deserialize: prevented for security reasons"", full));
            }
        }
    }

    // If no matches found, proceed without exception
}",0,0
226,JacksonDatabind_95,"        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == subclass) {
            return baseType;
        }
","final Class<?> rawBase = baseType.getRawClass();
if (rawBase != null && rawBase.equals(subclass)) {
    return baseType;
}",0,0
226,JacksonDatabind_95,"    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {
        int len = parameterClasses.length;
        JavaType[] pt = new JavaType[len];
        for (int i = 0; i < len; ++i) {
            pt[i] = _fromClass(null, parameterClasses[i], null);
        }
        return constructParametricType(parametrized, pt);
    }
","public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {
    if (parameterClasses == null || parameterClasses.length == 0) {
        throw new IllegalArgumentException(""Parameter classes cannot be null or empty"");
    }
    int len = parameterClasses.length;
    JavaType[] pt = new JavaType[len];
    for (int i = 0; i < len; ++i) {
        if (parameterClasses[i] == null) {
            throw new IllegalArgumentException(""Parameter class at index "" + i + "" is null"");
        }
        pt[i] = _fromClass(null, parameterClasses[i], null);
    }
    return constructParametricType(parametrized, pt);
}",0,0
226,JacksonDatabind_95,"    protected JavaType parseType(MyTokenizer tokens)
        throws IllegalArgumentException
    {
        if (!tokens.hasMoreTokens()) {
            throw _problem(tokens, ""Unexpected end-of-string"");
        }
        Class<?> base = findClass(tokens.nextToken(), tokens);

        // either end (ok, non generic type), or generics
        if (tokens.hasMoreTokens()) {
            String token = tokens.nextToken();
            if (""<"".equals(token)) {
                List<JavaType> parameterTypes = parseTypes(tokens);
                TypeBindings b = TypeBindings.create(base, parameterTypes);
                return _factory._fromClass(null, base, b);
            }
            // can be comma that separates types, or closing '>'
            tokens.pushBack(token);
        }
        return _factory._fromClass(null, base, null);
    }
","protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {
    if (!tokens.hasMoreTokens()) {
        throw _problem(tokens, ""Unexpected end-of-string"");
    }
    Class<?> base = findClass(tokens.nextToken(), tokens);

    if (tokens.hasMoreTokens()) {
        String token = tokens.nextToken();
        if (""<"".equals(token)) {
            List<JavaType> parameterTypes = parseTypes(tokens);
            if (!tokens.hasMoreTokens() || !"">"".equals(tokens.nextToken())) {
                throw _problem(tokens, ""Expected closing '>' for generic type"");
            }
            TypeBindings b = TypeBindings.create(base, parameterTypes);
            return _factory._fromClass(null, base, b);
        }
        tokens.pushBack(token);
    }
    return _factory._fromClass(null, base, null);
}",0,0
227,JacksonXml_2,"private final int _next() throws XMLStreamException
    {
        switch (_currentState) {
        case XML_ATTRIBUTE_VALUE:
            ++_nextAttributeIndex;
            // fall through
        case XML_START_ELEMENT: // attributes to return?
            if (_nextAttributeIndex < _attributeCount) {
                _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);
                _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);
                _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);
                return (_currentState = XML_ATTRIBUTE_NAME);
            }
            // otherwise need to find START/END_ELEMENT or text
            String text = _collectUntilTag();
            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text
            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {
                    return _initStartElement();
            }
            // For END_ELEMENT we will return text, if any
            if (text != null) {
                _textValue = text;
                return (_currentState = XML_TEXT);
            }
            return _handleEndElement();

        case XML_ATTRIBUTE_NAME:
            // if we just returned name, will need to just send value next
             return (_currentState = XML_ATTRIBUTE_VALUE);
         case XML_TEXT:
             // mixed text with other elements
             // text followed by END_ELEMENT
             return _handleEndElement();
         case XML_END:
            return XML_END;
//            throw new IllegalStateException(""No more XML tokens available (end of input)"");
        }

        // Ok: must be END_ELEMENT; see what tag we get (or end)
        switch (_skipUntilTag()) {
        case XMLStreamConstants.END_DOCUMENT:
            return (_currentState = XML_END);
        case XMLStreamConstants.END_ELEMENT:
            return _handleEndElement();
        }
        // START_ELEMENT...
        return _initStartElement();
    }","private final int _next() throws XMLStreamException {
    switch (_currentState) {
        case XML_ATTRIBUTE_VALUE:
            ++_nextAttributeIndex;
            // fall through
        case XML_START_ELEMENT: // attributes to return?
            if (_nextAttributeIndex < _attributeCount) {
                _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);
                _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);
                _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);
                return (_currentState = XML_ATTRIBUTE_NAME);
            }
            // otherwise need to find START/END_ELEMENT or text
            String text = _collectUntilTag();
            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text
            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {
                return _initStartElement();
            }
            // For END_ELEMENT we will return text, if any
            if (text != null && !text.trim().isEmpty()) {
                _textValue = text;
                return (_currentState = XML_TEXT);
            } else if (_xmlReader.getEventType() == XMLStreamReader.END_ELEMENT) {
                return _handleEndElement();
            }
            return XML_END;

        case XML_ATTRIBUTE_NAME:
            // if we just returned name, will need to just send value next
            return (_currentState = XML_ATTRIBUTE_VALUE);

        case XML_TEXT:
            // mixed text with other elements
            // text followed by END_ELEMENT
            return _handleEndElement();

        case XML_END:
            return XML_END;
    }

    // Ok: must be END_ELEMENT; see what tag we get (or end)
    switch (_skipUntilTag()) {
        case XMLStreamConstants.END_DOCUMENT:
            return (_currentState = XML_END);
        case XMLStreamConstants.END_ELEMENT:
            return _handleEndElement();
    }
    // START_ELEMENT...
    return _initStartElement();
}",0,0
228,JacksonXml_6,"    public void writeBinary(Base64Variant b64variant,
    		byte[] data, int offset, int len) throws IOException
    {
        if (data == null) {
            writeNull();
            return;
        }
        _verifyValueWrite(""write Binary value"");
        if (_nextName == null) {
            handleMissingName();
        }
        try {
            if (_nextIsAttribute) {
                // Stax2 API only has 'full buffer' write method:
                byte[] fullBuffer = toFullBuffer(data, offset, len);
                _xmlWriter.writeBinaryAttribute("""", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);
            } else if (checkNextIsUnwrapped()) {
            	// should we consider pretty-printing or not?
                _xmlWriter.writeBinary(data, offset, len);
            } else {
                if (_xmlPrettyPrinter != null) {
                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter,
                            _nextName.getNamespaceURI(), _nextName.getLocalPart(),
                            data, offset, len);
                } else {
                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());
                    _xmlWriter.writeBinary(data, offset, len);
                    _xmlWriter.writeEndElement();
                }
            }
        } catch (XMLStreamException e) {
            StaxUtil.throwAsGenerationException(e, this);
        }
    }
","public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {
    if (data == null) {
        writeNull();
        return;
    }
    _verifyValueWrite(""write Binary value"");
    if (_nextName == null) {
        handleMissingName();
    }
    if (offset < 0 || len < 0 || offset + len > data.length) {
        throw new IllegalArgumentException(""Invalid offset/length for the provided byte array"");
    }
    try {
        if (_nextIsAttribute) {
            // Stax2 API only has 'full buffer' write method:
            byte[] fullBuffer = toFullBuffer(data, offset, len);
            _xmlWriter.writeBinaryAttribute("""", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);
        } else if (checkNextIsUnwrapped()) {
            // should we consider pretty-printing or not?
            _xmlWriter.writeBinary(data, offset, len);
        } else {
            if (_xmlPrettyPrinter != null) {
                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), data, offset, len);
            } else {
                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());
                _xmlWriter.writeBinary(data, offset, len);
                _xmlWriter.writeEndElement();
            }
        }
    } catch (XMLStreamException e) {
        StaxUtil.throwAsGenerationException(e, this);
    }
}",0,0
228,JacksonXml_6,"    private byte[] toFullBuffer(byte[] data, int offset, int len)
    {
        // might already be ok:
        if (offset == 0 && len == data.length) {
            return data;
        }
        byte[] result = new byte[len];
        if (len > 0) {
            System.arraycopy(data, offset, result, 0, len);
        }
        return result;
    }
","private byte[] toFullBuffer(byte[] data, int offset, int len) {
    if (data == null) {
        throw new IllegalArgumentException(""Data array cannot be null"");
    }
    if (offset < 0 || len < 0 || offset + len > data.length) {
        throw new IllegalArgumentException(""Invalid offset/length for the provided byte array"");
    }
    // might already be ok:
    if (offset == 0 && len == data.length) {
        return data;
    }
    byte[] result = new byte[len];
    if (len > 0) {
        System.arraycopy(data, offset, result, 0, len);
    }
    return result;
}",0,0
229,Jsoup_11,"private Elements select() {
        tq.consumeWhitespace();
        
         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements
             elements.add(root);
             combinator(tq.consume().toString());
         } else {
             addElements(findElements()); // chomp first element matcher off queue 
         }            
               
        while (!tq.isEmpty()) {
            // hierarchy and extras
            boolean seenWhite = tq.consumeWhitespace();
            
            if (tq.matchChomp("","")) { // group or
                while (!tq.isEmpty()) {
                    String subQuery = tq.chompTo("","");
                    elements.addAll(select(subQuery, root));
                }
            } else if (tq.matchesAny(combinators)) {
                combinator(tq.consume().toString());
            } else if (seenWhite) {
                combinator("" "");
            } else { // E.class, E#id, E[attr] etc. AND
                Elements candidates = findElements(); // take next el, #. etc off queue
                intersectElements(filterForSelf(elements, candidates));
            }
        }
        return new Elements(elements);
    }","private Elements select() {
    tq.consumeWhitespace();

    if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements
        elements.add(root);
        combinator(tq.consume().toString());
    } else {
        addElements(findElements()); // chomp first element matcher off queue
    }

    while (!tq.isEmpty()) {
        // hierarchy and extras
        boolean seenWhite = tq.consumeWhitespace();

        if (tq.matchChomp("","")) { // group or
            while (!tq.isEmpty()) {
                String subQuery = tq.chompTo("","");
                elements.addAll(select(subQuery, root));
            }
        } else if (tq.matchesAny(combinators)) {
            combinator(tq.consume().toString());
        } else if (seenWhite) {
            combinator("" "");
        } else { // E.class, E#id, E[attr] etc. AND
            Elements candidates = findElements(); // take next el, #. etc off queue
            intersectElements(filterForSelf(elements, candidates));
        }
    }

    return new Elements(new LinkedHashSet<>(elements)); // ensure elements are unique and in order
}",0,0
229,Jsoup_11,"private Elements findElements() {
        if (tq.matchChomp(""#"")) {
            return byId();
        } else if (tq.matchChomp(""."")) {
            return byClass();
        } else if (tq.matchesWord()) {
            return byTag();
        } else if (tq.matches(""["")) {
            return byAttribute();
        } else if (tq.matchChomp(""*"")) {
            return allElements();
        } else if (tq.matchChomp("":lt("")) {
            return indexLessThan();
        } else if (tq.matchChomp("":gt("")) {
            return indexGreaterThan();
        } else if (tq.matchChomp("":eq("")) {
            return indexEquals();
        } else if (tq.matches("":has("")) {
            return has();
        } else if (tq.matches("":contains("")) {
            return contains(false);
        } else if (tq.matches("":containsOwn("")) {
            return contains(true);
        } else if (tq.matches("":matches("")) {
             return matches(false);
         } else if (tq.matches("":matchesOwn("")) {
             return matches(true);
         } else { // unhandled
             throw new SelectorParseException(""Could not parse query '%s': unexpected token at '%s'"", query, tq.remainder());
         }
    }","private Elements findElements() {
    Elements elements = new Elements();
    if (tq.matchChomp(""#"")) {
        elements.addAll(byId());
    } else if (tq.matchChomp(""."")) {
        elements.addAll(byClass());
    } else if (tq.matchesWord()) {
        elements.addAll(byTag());
    } else if (tq.matches(""["")) {
        elements.addAll(byAttribute());
    } else if (tq.matchChomp(""*"")) {
        elements.addAll(allElements());
    } else if (tq.matchChomp("":lt("")) {
        elements.addAll(indexLessThan());
    } else if (tq.matchChomp("":gt("")) {
        elements.addAll(indexGreaterThan());
    } else if (tq.matchChomp("":eq("")) {
        elements.addAll(indexEquals());
    } else if (tq.matches("":has("")) {
        elements.addAll(has());
    } else if (tq.matches("":contains("")) {
        elements.addAll(contains(false));
    } else if (tq.matches("":containsOwn("")) {
        elements.addAll(contains(true));
    } else if (tq.matches("":matches("")) {
        elements.addAll(matches(false));
    } else if (tq.matches("":matchesOwn("")) {
        elements.addAll(matches(true));
    } else { // unhandled
        throw new SelectorParseException(""Could not parse query '%s': unexpected token at '%s'"", query, tq.remainder());
    }
    return elements; // ensure non-null, safe return
}",0,0
230,Jsoup_12,"private void combinator(char combinator) {
         tq.consumeWhitespace();
         String subQuery = tq.consumeToAny(combinators);
         
         Elements output;
         if (combinator == '>')
            output = filterForChildren(elements, select(subQuery, elements));
        else if (combinator == ' ')
            output = filterForDescendants(elements, select(subQuery, elements));
        else if (combinator == '+')
            output = filterForAdjacentSiblings(elements, select(subQuery, root));
        else if (combinator == '~')
            output = filterForGeneralSiblings(elements, select(subQuery, root));
        else
            throw new IllegalStateException(""Unknown combinator: "" + combinator);
        
        elements.clear(); elements.addAll(output);
    }","private void combinator(char combinator) {
    tq.consumeWhitespace();
    String subQuery = tq.consumeToAny(combinators);

    if (subQuery.isEmpty()) {
        throw new IllegalArgumentException(""SubQuery cannot be empty"");
    }

    Elements output;
    if (combinator == '>') {
        output = filterForChildren(elements, select(subQuery, elements));
    } else if (combinator == ' ') {
        output = filterForDescendants(elements, select(subQuery, elements));
    } else if (combinator == '+') {
        output = filterForAdjacentSiblings(elements, select(subQuery, root));
    } else if (combinator == '~') {
        output = filterForGeneralSiblings(elements, select(subQuery, root));
    } else {
        throw new IllegalStateException(""Unknown combinator: "" + combinator);
    }

    // Ensure output is not null to avoid runtime errors
    elements.clear();
    if (output != null) {
        elements.addAll(output);
    }
}",0,0
231,Jsoup_14,"void read(Tokeniser t, CharacterReader r) {
             if (r.matches('/')) {
                 t.createTempBuffer();
                 t.advanceTransition(RCDATAEndTagOpen);
                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than
                 // consuming to EOF; break out here
             } else {
                 t.emit(""<"");
                 t.transition(Rcdata);
            }
        }","void read(Tokeniser t, CharacterReader r) {
    if (r.matches('/')) {
        t.createTempBuffer();
        t.advanceTransition(RCDATAEndTagOpen);
        // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than
        // consuming to EOF; break out here
    } else if (r.isEmpty()) {
        // handle case where reader is empty to prevent infinite loop or unexpected behavior
        t.error(this);
        t.transition(Rcdata);
    } else {
        t.emit(""<"");
        t.transition(Rcdata);
    }
}",0,0
232,Jsoup_16,"    public DocumentType(String name, String publicId, String systemId, String baseUri) {
        super(baseUri);

        attr(""name"", name);
        attr(""publicId"", publicId);
        attr(""systemId"", systemId);
    }
","public DocumentType(String name, String publicId, String systemId, String baseUri) {
    super(baseUri);

    if (org.jsoup.helper.StringUtil.isBlank(name)) {
        throw new IllegalArgumentException(""DocumentType name must not be empty"");
    }

    attr(""name"", name != null ? name : """");
    attr(""publicId"", publicId != null ? publicId : """");
    attr(""systemId"", systemId != null ? systemId : """");
}",0,0
232,Jsoup_16,"    public String nodeName() {
        return ""#doctype"";
    }
","public String nodeName() {
    return ""#doctype"";
}",0,0
233,Jsoup_17,"        private boolean anythingElse(Token t, TreeBuilder tb) {
            tb.error(this);
            return false;
        }
","private boolean anythingElse(Token t, TreeBuilder tb) {
    if (t == null || tb == null) {
        throw new IllegalArgumentException(""Token and TreeBuilder must not be null"");
    }
    tb.error(this);
    return true; // Changed to true as returning false might incorrectly indicate no action was taken
}",0,0
234,Jsoup_18,"String consumeToEnd() {
         String data = input.substring(pos, input.length() - 1);
         pos = input.length();
         return data;
     }","String consumeToEnd() {
    String data = input.substring(pos); // Adjusted the substring call to correctly consume until the end
    pos = input.length();
    return data;
}",0,0
235,Jsoup_21,"Evaluator parse() {
        tq.consumeWhitespace();

        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements
            evals.add(new StructuralEvaluator.Root());
            combinator(tq.consume());
        } else {
            findElements();
        }

        while (!tq.isEmpty()) {
             // hierarchy and extras
             boolean seenWhite = tq.consumeWhitespace();
 
             if (tq.matchChomp("","")) {
                 CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);
                 evals.clear();
                 evals.add(or);
                 while (!tq.isEmpty()) {
                     String subQuery = tq.chompTo("","");
                     or.add(parse(subQuery));
                 }
             } else if (tq.matchesAny(combinators)) {
                 combinator(tq.consume());
             } else if (seenWhite) {
                 combinator(' ');
            } else { // E.class, E#id, E[attr] etc. AND
                findElements(); // take next el, #. etc off queue
            }
        }

        if (evals.size() == 1)
            return evals.get(0);

        return new CombiningEvaluator.And(evals);
    }","Evaluator parse() {
    tq.consumeWhitespace();

    if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements
        evals.add(new StructuralEvaluator.Root());
        combinator(tq.consume());
    } else {
        findElements();
    }

    while (!tq.isEmpty()) {
        // hierarchy and extras
        boolean seenWhite = tq.consumeWhitespace();

        if (tq.matchChomp("","")) {
            CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);
            evals.clear();
            evals.add(or);
            do {
                String subQuery = tq.chompTo("","").trim();
                if (!subQuery.isEmpty()) {
                    or.add(parse(subQuery));
                }
            } while (!tq.isEmpty());
        } else if (tq.matchesAny(combinators)) {
            combinator(tq.consume());
        } else if (seenWhite) {
            combinator(' ');
        } else { // E.class, E#id, E[attr] etc. AND
            findElements(); // take next el, #. etc off queue
        }
    }

    if (evals.size() == 1) {
        return evals.get(0);
    }

    return new CombiningEvaluator.And(evals);
}",0,0
235,Jsoup_21,"private void combinator(char combinator) {
        tq.consumeWhitespace();
        String subQuery = consumeSubQuery(); // support multi > childs
        Evaluator e;

        if (evals.size() == 1)
            e = evals.get(0);
        else
            e = new CombiningEvaluator.And(evals);
        evals.clear();
        Evaluator f = parse(subQuery);

        if (combinator == '>')
            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));
        else if (combinator == ' ')
            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));
        else if (combinator == '+')
             evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));
         else if (combinator == '~')
             evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));
         else
             throw new Selector.SelectorParseException(""Unknown combinator: "" + combinator);
     }","private void combinator(char combinator) {
    tq.consumeWhitespace();
    String subQuery = consumeSubQuery(); // support multi > childs
    if (subQuery.isEmpty()) {
        throw new Selector.SelectorParseException(""Empty subQuery encountered for combinator: "" + combinator);
    }

    Evaluator e;
    if (evals.size() == 1) {
        e = evals.get(0);
    } else {
        e = new CombiningEvaluator.And(evals);
    }
    evals.clear();
    Evaluator f = parse(subQuery);

    switch (combinator) {
        case '>':
            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));
            break;
        case ' ':
            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));
            break;
        case '+':
            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));
            break;
        case '~':
            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));
            break;
        default:
            throw new Selector.SelectorParseException(""Unknown combinator: "" + combinator);
    }
}",0,0
236,Jsoup_22,"    public Element nextElementSibling() {
        List<Element> siblings = parent().children();
        Integer index = indexInList(this, siblings);
        Validate.notNull(index);
        if (siblings.size() > index+1)
            return siblings.get(index+1);
        else
            return null;
    }
","public Element nextElementSibling() {
    if (parent() == null) {
        return null; // No parent, no siblings
    }
    List<Element> siblings = parent().children();
    Integer index = indexInList(this, siblings);
    Validate.notNull(index, ""Index cannot be null"");
    if (index != null && siblings.size() > index + 1) {
        return siblings.get(index + 1);
    } else {
        return null;
    }
}",0,0
236,Jsoup_22,"    private void reindexChildren() {
        for (int i = 0; i < childNodes.size(); i++) {
            childNodes.get(i).setSiblingIndex(i);
        }
    }
","private void reindexChildren() {
    if (childNodes != null) {
        for (int i = 0; i < childNodes.size(); i++) {
            childNodes.get(i).setSiblingIndex(i);
        }
    }
}",0,0
236,Jsoup_22,"    public Node nextSibling() {
        if (parentNode == null)
            return null; // root
        
        List<Node> siblings = parentNode.childNodes;
        Integer index = siblingIndex();
        Validate.notNull(index);
        if (siblings.size() > index+1)
            return siblings.get(index+1);
        else
            return null;
    }
","public Node nextSibling() {
    if (parentNode == null) {
        return null; // root has no sibling
    }
    List<Node> siblings = parentNode.childNodes;
    Integer index = siblingIndex();
    Validate.notNull(index, ""Sibling index cannot be null"");
    if (index != null && siblings.size() > index + 1) {
        return siblings.get(index + 1);
    } else {
        return null;
    }
}",0,0
236,Jsoup_22,"    public Elements() {
        contents = new ArrayList<Element>();
    }
","public Elements() {
    contents = new ArrayList<>(); // Use diamond operator for cleaner code
}",0,0
236,Jsoup_22,"    public Element previousElementSibling() {
        List<Element> siblings = parent().children();
        Integer index = indexInList(this, siblings);
        Validate.notNull(index);
        if (index > 0)
            return siblings.get(index-1);
        else
            return null;
    }
","public Element previousElementSibling() {
    if (parent() == null) {
        return null; // No parent, no siblings
    }
    List<Element> siblings = parent().children();
    Integer index = indexInList(this, siblings);
    Validate.notNull(index, ""Index cannot be null"");
    if (index != null && index > 0) {
        return siblings.get(index - 1);
    } else {
        return null;
    }
}",0,0
236,Jsoup_22,"    public Elements siblingElements() {

        return parent().children();
    }
","public Elements siblingElements() {
    if (parent() == null) {
        return new Elements(); // Return empty Elements if no parent
    }
    List<Element> siblings = parent().children();
    Elements elements = new Elements();
    for (Element sibling : siblings) {
        if (!sibling.equals(this)) { // Exclude the current element itself
            elements.add(sibling);
        }
    }
    return elements;
}",0,0
237,Jsoup_23,"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
        if (reader.isEmpty())
            return null;
        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
            return null;
        if (reader.matchesAny('\t', '\n', '\f', ' ', '<', '&'))
            return null;

        reader.mark();
        if (reader.matchConsume(""#"")) { // numbered
            boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
            if (numRef.length() == 0) { // didn't match anything
                characterReferenceError(""numeric reference with no numerals"");
                reader.rewindToMark();
                return null;
            }
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon""); // missing semi
            int charval = -1;
            try {
                int base = isHexMode ? 16 : 10;
                charval = Integer.valueOf(numRef, base);
            } catch (NumberFormatException e) {
            } // skip
            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
                characterReferenceError(""character outside of valid range"");
                return replacementChar;
            } else {
                // todo: implement number replacement table
                // todo: check for extra illegal unicode points as parse errors
                return (char) charval;
             }
         } else { // named
             // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
             String nameRef = reader.consumeLetterSequence();
             String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches
             boolean looksLegit = reader.matches(';');
             boolean found = false;
            while (nameRef.length() > 0 && !found) {
                if (Entities.isNamedEntity(nameRef))
                    found = true;
                else {
                    nameRef = nameRef.substring(0, nameRef.length()-1);
                    reader.unconsume();
                }
            }
            if (!found) {
                if (looksLegit) // named with semicolon
                    characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
                reader.rewindToMark();
                return null;
            }
            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
                // don't want that to match
                reader.rewindToMark();
                return null;
            }
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon""); // missing semi
            return Entities.getCharacterByName(nameRef);
        }
    }","Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty()) {
        return null;
    }
    if (additionalAllowedCharacter != null && additionalAllowedCharacter.equals(reader.current())) {
        return null;
    }
    if (reader.matchesAny('\t', '\n', '\f', ' ', '<', '&')) {
        return null;
    }

    reader.mark();
    if (reader.matchConsume(""#"")) { // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.isEmpty()) { // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";"")) {
            characterReferenceError(""missing semicolon""); // missing semi
        }
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.parseInt(numRef, base);
        } catch (NumberFormatException e) {
        } // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            return (char) charval;
        }
    } else { // named
        String nameRef = reader.consumeLetterSequence();
        String origNameRef = nameRef; // for error reporting. nameRef gets chomped looking for matches
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (!nameRef.isEmpty() && !found) {
            if (Entities.isNamedEntity(nameRef)) {
                found = true;
            } else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (looksLegit) { // named with semicolon
                characterReferenceError(String.format(""invalid named reference '%s'"", origNameRef));
            }
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";"")) {
            characterReferenceError(""missing semicolon""); // missing semi
        }
        return Entities.getCharacterByName(nameRef);
    }
}",0,0
238,Jsoup_25,"    public String toString() {
        return tagName;
    }
","public String toString() {
    return tagName != null ? tagName : """";
}",0,0
239,Jsoup_28,"static String unescape(String string, boolean strict) {
         if (!string.contains(""&""))
             return string;
         Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string);
         StringBuffer accum = new StringBuffer(string.length());
         while (m.find()) {
             int charval = -1;
             String num = m.group(3);
             if (num != null) {
                 try {
                     int base = m.group(2) != null ? 16 : 10;
                     charval = Integer.valueOf(num, base);
                 } catch (NumberFormatException e) {
                 }
             } else {
                 String name = m.group(1);
                 if (full.containsKey(name))
                     charval = full.get(name);
             }
             if (charval != -1 || charval > 0xFFFF) {
                 String c = Character.toString((char) charval);
                 m.appendReplacement(accum, Matcher.quoteReplacement(c));
             } else {
                 m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));
             }
         }
         m.appendTail(accum);
         return accum.toString();
     }","static String unescape(String string, boolean strict) {
    if (!string.contains(""&"")) {
        return string;
    }
    Matcher m = strict ? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string);
    StringBuffer accum = new StringBuffer(string.length());
    while (m.find()) {
        int charval = -1;
        String num = m.group(3);
        if (num != null) {
            try {
                int base = m.group(2) != null ? 16 : 10;
                charval = Integer.parseInt(num, base);
            } catch (NumberFormatException e) {
                // Log or handle the error if needed
            }
        } else {
            String name = m.group(1);
            if (full.containsKey(name)) {
                charval = full.get(name);
            }
        }
        if (charval != -1 && charval <= 0xFFFF) {
            String c = Character.toString((char) charval);
            m.appendReplacement(accum, Matcher.quoteReplacement(c));
        } else {
            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));
        }
    }
    m.appendTail(accum);
    return accum.toString();
}",0,0
239,Jsoup_28,"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
        if (reader.isEmpty())
            return null;
        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
            return null;
        if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
            return null;

        reader.mark();
        if (reader.matchConsume(""#"")) { // numbered
            boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
            if (numRef.length() == 0) { // didn't match anything
                characterReferenceError(""numeric reference with no numerals"");
                reader.rewindToMark();
                return null;
            }
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon""); // missing semi
            int charval = -1;
            try {
                int base = isHexMode ? 16 : 10;
                charval = Integer.valueOf(numRef, base);
            } catch (NumberFormatException e) {
            } // skip
            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
                characterReferenceError(""character outside of valid range"");
                return replacementChar;
            } else {
                // todo: implement number replacement table
                // todo: check for extra illegal unicode points as parse errors
                return (char) charval;
            }
         } else { // named
             // get as many letters as possible, and look for matching entities.
             String nameRef = reader.consumeLetterThenDigitSequence();
             String origNameRef = new String(nameRef);
             boolean looksLegit = reader.matches(';');
             // found if a base named entity without a ;, or an extended entity with the ;.
             boolean found = false;
             while (nameRef.length() > 0 && !found) {
                 if (Entities.isNamedEntity(nameRef))
                     found = true;
                 else {
                     nameRef = nameRef.substring(0, nameRef.length()-1);
                     reader.unconsume();
                 }
             }
 
             if (!found) {
                 reader.rewindToMark();
                 if (looksLegit) // named with semicolon
                     characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
                 return null;
             }
             if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
                // don't want that to match
                reader.rewindToMark();
                return null;
            }
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon""); // missing semi
            return Entities.getCharacterByName(nameRef);
        }
    }","Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty()) {
        return null;
    }
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current()) {
        return null;
    }
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&')) {
        return null;
    }

    reader.mark();
    if (reader.matchConsume(""#"")) { // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) { // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";"")) {
            characterReferenceError(""missing semicolon""); // missing semi
        }
        int charval;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.parseInt(numRef, base);
        } catch (NumberFormatException e) {
            characterReferenceError(""invalid numeric reference"");
            return replacementChar;
        }
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            return (char) charval;
        }
    } else { // named
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef)) {
                found = true;
            } else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }

        if (!found) {
            reader.rewindToMark();
            if (looksLegit) { // named with semicolon
                characterReferenceError(String.format(""invalid named reference '%s'"", origNameRef));
            }
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";"")) {
            characterReferenceError(""missing semicolon"");
        }
        return Entities.getCharacterByName(nameRef);
    }
}",0,0
240,Jsoup_29,"public String title() {
         // title is a preserve whitespace tag (for document output), but normalised here
         Element titleEl = getElementsByTag(""title"").first();
         return titleEl != null ? titleEl.text().trim() : """";
     }","public String title() {
    // Title is a preserve whitespace tag (for document output), but normalized here
    Element titleEl = getElementsByTag(""title"").first();
    if (titleEl == null) {
        return """";
    }
    String text = titleEl.text();
    return text != null ? text.trim() : """";
}",0,0
241,Jsoup_3,"public Element wrap(String html) {
         Validate.notEmpty(html);
 
         Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();
         Elements wrapChildren = wrapBody.children();
         Element wrap = wrapChildren.first();
         if (wrap == null) // nothing to wrap with; noop
            return null;

        Element deepest = getDeepChild(wrap);
        parentNode.replaceChild(this, wrap);
        deepest.addChild(this);

        // remainder (unbalananced wrap, like <div></div><p></p> -- The <p> is remainder
        if (wrapChildren.size() > 1) {
            for (int i = 1; i < wrapChildren.size(); i++) { // skip first
                Element remainder = wrapChildren.get(i);
                remainder.parentNode.removeChild(remainder);
                wrap.appendChild(remainder);
            }
        }
        return this;
    }","public Element wrap(String html) {
    Validate.notEmpty(html);

    Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();
    Elements wrapChildren = wrapBody.children();
    Element wrap = wrapChildren.first();
    if (wrap == null) // nothing to wrap with; noop
        return null;

    Element deepest = getDeepChild(wrap);
    parentNode.replaceChild(this, wrap);
    deepest.appendChild(this); // Fixed: Correct method to add child

    if (wrapChildren.size() > 1) {
        for (int i = 1; i < wrapChildren.size(); i++) {
            Element remainder = wrapChildren.get(i);
            remainder.remove(); // Fixed: Correct method to remove child
            wrap.appendChild(remainder);
        }
    }
    return this;
}",0,0
241,Jsoup_3,"public Element append(String html) {
         Validate.notNull(html);
         
         Element fragment = Parser.parseBodyFragment(html, baseUri).body();
         for (Node node : fragment.childNodes()) {
             node.parentNode = null;
             appendChild(node);
        }
        return this;
    }","public Element append(String html) {
    Validate.notNull(html);

    Element fragment = Parser.parseBodyFragment(html, baseUri).body();
    for (Node node : fragment.childNodes()) {
        node.setParentNode(null); // Fixed: Use setter to reset parent node
        appendChild(node);
    }
    return this;
}",0,0
241,Jsoup_3,"public Element prepend(String html) {
         Validate.notNull(html);
         
         Element fragment = Parser.parseBodyFragment(html, baseUri).body();
         List<Node> nodes = fragment.childNodes();
         for (int i = nodes.size() - 1; i >= 0; i--) {
             Node node = nodes.get(i);
            node.parentNode = null;
            prependChild(node);
        }
        return this;
    }","public Element prepend(String html) {
    Validate.notNull(html);

    Element fragment = Parser.parseBodyFragment(html, baseUri).body();
    List<Node> nodes = fragment.childNodes();
    for (int i = nodes.size() - 1; i >= 0; i--) {
        Node node = nodes.get(i);
        node.setParentNode(null); // Fixed: Use setter to reset parent node
        prependChild(node);
    }
    return this;
}",0,0
241,Jsoup_3,"private boolean stackHasValidParent(Tag childTag) {
         if (stack.size() == 1 && childTag.equals(htmlTag))
             return true; // root is valid for html node
 
 
         // otherwise, look up the stack for valid ancestors
         for (int i = stack.size() -1; i >= 0; i--) {
             Element el = stack.get(i);
             Tag parent2 = el.tag();
             if (parent2.isValidParent(childTag)) {
                 return true;
             }
         }
        return false;
    }","private boolean stackHasValidParent(Tag childTag) {
    if (stack.size() == 1 && childTag.equals(htmlTag))
        return true;

    for (int i = stack.size() - 1; i >= 0; i--) {
        Element el = stack.get(i);
        Tag parentTag = el.tag();
        if (parentTag.isValidParent(childTag)) {
            return true;
        }
    }
    return false;
}",0,0
241,Jsoup_3,"private Element addChildToParent(Element child, boolean isEmptyElement) {
        Element parent = popStackToSuitableContainer(child.tag());
         Tag childTag = child.tag();
         boolean validAncestor = stackHasValidParent(childTag);
 
         if (!validAncestor) {
             // create implicit parent around this child
             Tag parentTag = childTag.getImplicitParent();
             Element implicit = new Element(parentTag, baseUri);
            // special case: make sure there's a head before putting in body
            if (child.tag().equals(bodyTag)) {
                Element head = new Element(headTag, baseUri);
                implicit.appendChild(head);
            }
            implicit.appendChild(child);

            // recurse to ensure somewhere to put parent
            Element root = addChildToParent(implicit, false);
            if (!isEmptyElement)
                stack.addLast(child);
            return root;
        }

        parent.appendChild(child);

        if (!isEmptyElement)
            stack.addLast(child);
        return parent;
    }","private Element addChildToParent(Element child, boolean isEmptyElement) {
    Element parent = popStackToSuitableContainer(child.tag());
    Tag childTag = child.tag();
    boolean validAncestor = stackHasValidParent(childTag);

    if (!validAncestor) {
        Tag parentTag = childTag.getImplicitParent();
        Element implicit = new Element(parentTag, baseUri);

        if (child.tag().equals(bodyTag)) {
            Element head = new Element(headTag, baseUri);
            implicit.appendChild(head);
        }
        implicit.appendChild(child);

        Element root = addChildToParent(implicit, false);
        if (!isEmptyElement)
            stack.addLast(child);
        return root;
    }

    parent.appendChild(child);

    if (!isEmptyElement)
        stack.addLast(child);
    return parent;
}",0,0
241,Jsoup_3,"boolean canContain(Tag child) {
        Validate.notNull(child);

        if (child.isBlock && !this.canContainBlock)
            return false;

        if (!child.isBlock && !this.canContainInline) // not block == inline
            return false;

        if (this.optionalClosing && this.equals(child))
            return false;

        if (this.empty || this.isData())
            return false;

        // head can only contain a few. if more than head in here, modify to have a list of valids
        // TODO: (could solve this with walk for ancestor)
        if (this.tagName.equals(""head"")) {
            if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") ||
                    child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
                return true;
            }
            return false;
        }
        
        // dt and dd (in dl)
        if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
            return false;
        if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
             return false;
 
         // don't allow children to contain their parent (directly)
         
         return true;
     }","boolean canContain(Tag child) {
    Validate.notNull(child);

    if (child.isBlock() && !this.canContainBlock) // Fixed: Use proper block check
        return false;

    if (!child.isBlock() && !this.canContainInline) // not block == inline
        return false;

    if (this.optionalClosing && this.equals(child))
        return false;

    if (this.isEmpty() || this.isData()) // Fixed: Use proper methods for conditions
        return false;

    if (this.tagName.equals(""head"")) {
        return child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") ||
               child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") ||
               child.tagName.equals(""style"") || child.tagName.equals(""object"");
    }

    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;

    return !this.equals(child.getParentTag()); // Fixed: Prevent child-parent containment loop
}",0,0
242,Jsoup_30,"    private int copySafeNodes(Element root, Element destination) {
        List<Node> sourceChildren = root.childNodes();
        int numDiscarded = 0;

        for (Node source : sourceChildren) {
            if (source instanceof Element) {
                Element sourceEl = (Element) source;

                if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs
                    ElementMeta meta = createSafeElement(sourceEl);
                    Element destChild = meta.el;
                    destination.appendChild(destChild);

                    numDiscarded += meta.numAttribsDiscarded;
                    numDiscarded += copySafeNodes(sourceEl, destChild);
                } else {
                    numDiscarded++;
                    numDiscarded += copySafeNodes(sourceEl, destination);
                }
            } else if (source instanceof TextNode) {
                TextNode sourceText = (TextNode) source;
                TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());
                destination.appendChild(destText);
            }
        }
        return numDiscarded;


    }
","private int copySafeNodes(Element root, Element destination) {
    List<Node> sourceChildren = root.childNodes();
    int numDiscarded = 0;

    for (Node source : sourceChildren) {
        if (source instanceof Element) {
            Element sourceEl = (Element) source;

            if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs
                ElementMeta meta = createSafeElement(sourceEl);
                Element destChild = meta.el;
                destination.appendChild(destChild);

                numDiscarded += meta.numAttribsDiscarded;
                numDiscarded += copySafeNodes(sourceEl, destChild);
            } else {
                numDiscarded += copySafeNodes(sourceEl, destination);
                numDiscarded++;
            }
        } else if (source instanceof TextNode) {
            TextNode sourceText = (TextNode) source;
            TextNode destText = new TextNode(sourceText.getWholeText(), sourceText.baseUri());
            destination.appendChild(destText);
        }
    }
    return numDiscarded;
}",0,0
242,Jsoup_30,"    public boolean isValid(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
        return numDiscarded == 0;
    }
","public boolean isValid(Document dirtyDocument) {
    Validate.notNull(dirtyDocument);

    Document clean = Document.createShell(dirtyDocument.baseUri());
    int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());

    // Make sure to retain discarded nodes accurately
    return numDiscarded == 0;
}",0,0
243,Jsoup_31,"void insert(Token.Comment commentToken) {
         Comment comment = new Comment(commentToken.getData(), baseUri);
         Node insert = comment;
         insertNode(insert);
     }","void insert(Token.Comment commentToken) {
    if (commentToken == null || commentToken.getData() == null) {
        return;
    }
    Comment comment = new Comment(commentToken.getData(), baseUri);
    Node insert = comment;
    insertNode(insert);
}",0,0
243,Jsoup_31,"void read(Tokeniser t, CharacterReader r) {
            // todo: handle bogus comment starting from eof. when does that trigger?
             // rewind to capture character that lead us here
             r.unconsume();
             Token.Comment comment = new Token.Comment();
             comment.data.append(r.consumeTo('>'));
             // todo: replace nullChar with replaceChar
             t.emit(comment);
            t.advanceTransition(Data);
        }","void read(Tokeniser t, CharacterReader r) {
    if (t == null || r == null) {
        return;
    }
    // rewind to capture character that lead us here
    r.unconsume();
    Token.Comment comment = new Token.Comment();
    String data = r.consumeTo('>');
    if (data == null) {
        data = """";
    }
    comment.data.append(data);
    // emit comment and advance transition
    t.emit(comment);
    t.advanceTransition(Data);
}",0,0
244,Jsoup_36,"static String getCharsetFromContentType(String contentType) {
        if (contentType == null) return null;
         Matcher m = charsetPattern.matcher(contentType);
         if (m.find()) {
             String charset = m.group(1).trim();
                 if (Charset.isSupported(charset)) return charset;
                 charset = charset.toUpperCase(Locale.ENGLISH);
                 if (Charset.isSupported(charset)) return charset;
                 // if our advanced charset matching fails.... we just take the default
         }
         return null;
     }","static String getCharsetFromContentType(String contentType) {
    if (contentType == null) return null;
    Matcher m = charsetPattern.matcher(contentType);
    if (m.find()) {
        String charset = m.group(1).trim();
        if (Charset.isSupported(charset)) return charset;
        charset = charset.replaceAll(""[\""']"", """").toUpperCase(Locale.ENGLISH);
        if (Charset.isSupported(charset)) return charset;
    }
    return null;
}",0,0
244,Jsoup_36,"static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
        String docData;
        Document doc = null;
        if (charsetName == null) { // determine from meta. safe parse as UTF-8
            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            doc = parser.parseInput(docData, baseUri);
            Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
            if (meta != null) { // if not found, will keep utf-8 as best attempt

                 String foundCharset;
                 if (meta.hasAttr(""http-equiv"")) {
                     foundCharset = getCharsetFromContentType(meta.attr(""content""));
                 } else {
                     foundCharset = meta.attr(""charset"");
                 }
 
                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
                     charsetName = foundCharset;
                     byteData.rewind();
                     docData = Charset.forName(foundCharset).decode(byteData).toString();
                    doc = null;
                }
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
            docData = Charset.forName(charsetName).decode(byteData).toString();
        }
        if (doc == null) {
            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present
            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight
            // into head mode
            if (docData.length() > 0 && docData.charAt(0) == 65279)
                docData = docData.substring(1);

            doc = parser.parseInput(docData, baseUri);
            doc.outputSettings().charset(charsetName);
        }
        return doc;
    }","static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
    String docData;
    Document doc = null;
    if (charsetName == null) { // determine from meta. safe parse as UTF-8
        // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
        docData = Charset.forName(defaultCharset).decode(byteData).toString();
        doc = parser.parseInput(docData, baseUri);
        Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
        if (meta != null) { // if not found, will keep utf-8 as best attempt
            String foundCharset;
            if (meta.hasAttr(""http-equiv"")) {
                foundCharset = getCharsetFromContentType(meta.attr(""content""));
            } else {
                foundCharset = meta.attr(""charset"");
            }

            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
                charsetName = foundCharset.replaceAll(""[\""']"", """");
                if (Charset.isSupported(charsetName)) {
                    byteData.rewind();
                    docData = Charset.forName(charsetName).decode(byteData).toString();
                    doc = parser.parseInput(docData, baseUri);
                }
            }
        }
    } else { // specified by content type header (or by user on file load)
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        charsetName = charsetName.replaceAll(""[\""']"", """");
        docData = Charset.forName(charsetName).decode(byteData).toString();
    }

    if (doc == null) {
        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present
        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight
        // into head mode
        if (docData.length() > 0 && docData.charAt(0) == 65279)
            docData = docData.substring(1);

        doc = parser.parseInput(docData, baseUri);
        doc.outputSettings().charset(charsetName != null ? charsetName : defaultCharset);
    }
    return doc;
}",0,0
245,Jsoup_44,"    protected abstract boolean process(Token token);

    protected boolean processStartTag(String name) {
        return process(start.reset().name(name));
    }
","protected abstract boolean process(Token token);

protected boolean processStartTag(String name) {
    if (start == null) {
        throw new IllegalStateException(""Start token is not initialized"");
    }
    return process(start.reset().name(name));
}",0,0
246,Jsoup_52,"void insert(Token.Comment commentToken) {
        Comment comment = new Comment(commentToken.getData(), baseUri);
        Node insert = comment;
        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)
             // so we do a bit of a hack and parse the data as an element to pull the attributes out
             String data = comment.getData();
             if (data.length() > 1 && (data.startsWith(""!"") || data.startsWith(""?""))) {
                 String declaration = data.substring(1);
                 insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(""!""));
             }
         }
         insertNode(insert);
    }","void insert(Token.Comment commentToken) {
    Comment comment = new Comment(commentToken.getData(), baseUri);
    Node insert = comment;
    if (commentToken.bogus) { // xml declarations processed as bogus comments
        String data = comment.getData();
        if (data.length() > 1 && (data.startsWith(""!"") || data.startsWith(""?""))) {
            String declaration = data.substring(1).trim();
            insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(""!""));
        }
    }
    insertNode(insert);
}",0,0
246,Jsoup_52,"static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
        String docData;
        Document doc = null;

        // look for BOM - overrides any other header or input
        charsetName = detectCharsetFromBom(byteData, charsetName);

        if (charsetName == null) { // determine from meta. safe first parse as UTF-8
            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            doc = parser.parseInput(docData, baseUri);
            Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
            String foundCharset = null; // if not found, will keep utf-8 as best attempt
            if (meta != null) {
                if (meta.hasAttr(""http-equiv"")) {
                     foundCharset = getCharsetFromContentType(meta.attr(""content""));
                 }
                 if (foundCharset == null && meta.hasAttr(""charset"")) {
                     try {
                         if (Charset.isSupported(meta.attr(""charset""))) {
                     foundCharset = meta.attr(""charset"");
                         }
                     } catch (IllegalCharsetNameException e) {
                         foundCharset = null;
                     }
                 }
             }
             // look for <?xml encoding='ISO-8859-1'?>
            if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {
                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);
                if (prolog.name().equals(""xml"")) {
                    foundCharset = prolog.attr(""encoding"");
                }
            }
            foundCharset = validateCharset(foundCharset);

            if (foundCharset != null && !foundCharset.equals(defaultCharset)) { // need to re-decode
                foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                charsetName = foundCharset;
                byteData.rewind();
                docData = Charset.forName(foundCharset).decode(byteData).toString();
                doc = null;
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
            docData = Charset.forName(charsetName).decode(byteData).toString();
        }
        if (doc == null) {
            doc = parser.parseInput(docData, baseUri);
            doc.outputSettings().charset(charsetName);
        }
        return doc;
    }","static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
    String docData;
    Document doc = null;

    // Detect charset from BOM, if present.
    charsetName = detectCharsetFromBom(byteData, charsetName);

    if (charsetName == null) { // Try UTF-8 first and check for meta or XML declaration
        docData = Charset.forName(defaultCharset).decode(byteData).toString();
        doc = parser.parseInput(docData, baseUri);
        Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
        String foundCharset = null;

        if (meta != null) {
            if (meta.hasAttr(""http-equiv"")) {
                foundCharset = getCharsetFromContentType(meta.attr(""content""));
            }
            if (foundCharset == null && meta.hasAttr(""charset"")) {
                try {
                    if (Charset.isSupported(meta.attr(""charset""))) {
                        foundCharset = meta.attr(""charset"");
                    }
                } catch (IllegalCharsetNameException e) {
                    foundCharset = null;
                }
            }
        }

        // Check for XML declaration encoding attribute
        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {
            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);
            if (""xml"".equals(prolog.name())) {
                foundCharset = prolog.attr(""encoding"");
            }
        }

        foundCharset = validateCharset(foundCharset);

        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {
            foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
            charsetName = foundCharset;
            byteData.rewind();
            docData = Charset.forName(foundCharset).decode(byteData).toString();
            doc = null;
        }
    } else {
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        docData = Charset.forName(charsetName).decode(byteData).toString();
    }

    if (doc == null) {
        doc = parser.parseInput(docData, baseUri);
        doc.outputSettings().charset(charsetName);
    }
    return doc;
}",0,0
247,Jsoup_56,"@Override
    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {
            // looks like a html5 doctype, go lowercase for aesthetics
            accum.append(""<!doctype"");
        } else {
            accum.append(""<!DOCTYPE"");
         }
         if (has(NAME))
             accum.append("" "").append(attr(NAME));
         if (has(PUBLIC_ID))
             accum.append("" PUBLIC \"""").append(attr(PUBLIC_ID)).append('""');
         if (has(SYSTEM_ID))
             accum.append("" \"""").append(attr(SYSTEM_ID)).append('""');
         accum.append('>');
    }","@Override
void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
    if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {
        // looks like a html5 doctype, go lowercase for aesthetics
        accum.append(""<!doctype"");
    } else {
        accum.append(""<!DOCTYPE"");
    }
    if (has(NAME))
        accum.append("" "").append(attr(NAME));
    if (has(PUBLIC_ID))
        accum.append("" PUBLIC \"""").append(attr(PUBLIC_ID)).append('""');
    if (has(SYSTEM_ID))
        accum.append("" \"""").append(attr(SYSTEM_ID)).append('""');
    accum.append('>');
}",0,0
247,Jsoup_56,"@Override
         Token reset() {
             reset(name);
             reset(publicIdentifier);
             reset(systemIdentifier);
             forceQuirks = false;
            return this;
        }","@Override
Token reset() {
    name = """";
    publicIdentifier = """";
    systemIdentifier = """";
    forceQuirks = false;
    return this;
}",0,0
247,Jsoup_56,"void read(Tokeniser t, CharacterReader r) {
            if (r.isEmpty()) {
                t.eofError(this);
                t.doctypePending.forceQuirks = true;
                t.emitDoctypePending();
                t.transition(Data);
                return;
            }
            if (r.matchesAny('\t', '\n', '\r', '\f', ' '))
                r.advance(); // ignore whitespace
            else if (r.matches('>')) {
                 t.emitDoctypePending();
                 t.advanceTransition(Data);
             } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {
                 t.transition(AfterDoctypePublicKeyword);
             } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {
                 t.transition(AfterDoctypeSystemKeyword);
             } else {
                 t.error(this);
                t.doctypePending.forceQuirks = true;
                t.advanceTransition(BogusDoctype);
            }

        }","void read(Tokeniser t, CharacterReader r) {
    if (r.isEmpty()) {
        t.eofError(this);
        t.doctypePending.forceQuirks = true;
        t.emitDoctypePending();
        t.transition(Data);
        return;
    }
    if (r.matchesAny('\t', '\n', '\r', '\f', ' ')) {
        r.advance(); // ignore whitespace
    } else if (r.matches('>')) {
        t.emitDoctypePending();
        t.advanceTransition(Data);
    } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {
        t.transition(AfterDoctypePublicKeyword);
    } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {
        t.transition(AfterDoctypeSystemKeyword);
    } else {
        t.error(this);
        t.doctypePending.forceQuirks = true;
        t.advanceTransition(BogusDoctype);
    }
}",0,0
247,Jsoup_56,"void insert(Token.Doctype d) {
         DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);
         insertNode(doctypeNode);
     }","void insert(Token.Doctype d) {
    DocumentType doctypeNode = new DocumentType(
        settings.normalizeTag(d.getName()),
        StringUtil.isBlank(d.getPublicIdentifier()) ? null : d.getPublicIdentifier(),
        StringUtil.isBlank(d.getSystemIdentifier()) ? null : d.getSystemIdentifier(),
        baseUri
    );
    insertNode(doctypeNode);
}",0,0
247,Jsoup_56,"boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                return true; // ignore whitespace
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                // todo: parse error check on expected doctypes
                 // todo: quirk state check on doctype ids
                 Token.Doctype d = t.asDoctype();
                 DocumentType doctype = new DocumentType(
                     tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());
                 tb.getDocument().appendChild(doctype);
                 if (d.isForceQuirks())
                     tb.getDocument().quirksMode(Document.QuirksMode.quirks);
                tb.transition(BeforeHtml);
            } else {
                // todo: check not iframe srcdoc
                tb.transition(BeforeHtml);
                return tb.process(t); // re-process token
            }
            return true;
        }","boolean process(Token t, HtmlTreeBuilder tb) {
    if (isWhitespace(t)) {
        return true; // ignore whitespace
    } else if (t.isComment()) {
        tb.insert(t.asComment());
        return true;
    } else if (t.isDoctype()) {
        // todo: parse error check on expected doctypes
        Token.Doctype d = t.asDoctype();
        DocumentType doctype = new DocumentType(
            tb.settings.normalizeTag(d.getName()),
            StringUtil.isBlank(d.getPublicIdentifier()) ? null : d.getPublicIdentifier(),
            StringUtil.isBlank(d.getSystemIdentifier()) ? null : d.getSystemIdentifier(),
            tb.getBaseUri()
        );
        tb.getDocument().appendChild(doctype);
        if (d.isForceQuirks())
            tb.getDocument().quirksMode(Document.QuirksMode.quirks);
        tb.transition(BeforeHtml);
    } else {
        // todo: check not iframe srcdoc
        tb.transition(BeforeHtml);
        return tb.process(t); // re-process token
    }
    return true;
}",0,0
248,Jsoup_58,"    public boolean isValid(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
        return numDiscarded == 0;
    }
","public boolean isValid(Document dirtyDocument) {
    Validate.notNull(dirtyDocument);

    if (dirtyDocument.body() == null) {
        return false; // Ensure body exists in the document
    }

    Document clean = Document.createShell(dirtyDocument.baseUri());
    int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
    return numDiscarded == 0;
}",0,0
248,Jsoup_58,"    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {
        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();
        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());
    }
","public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {
    if (fragmentXml == null || baseUri == null) {
        throw new IllegalArgumentException(""Fragment XML and base URI must not be null"");
    }

    XmlTreeBuilder treeBuilder = new XmlTreeBuilder();
    return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), XmlTreeBuilder.defaultSettings());
}",0,0
248,Jsoup_58,"    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {
        Document dirty = parseBodyFragment(bodyHtml, baseUri);
        Cleaner cleaner = new Cleaner(whitelist);
        Document clean = cleaner.clean(dirty);
        clean.outputSettings(outputSettings);
        return clean.body().html();
    }
","public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {
    Validate.notNull(bodyHtml, ""Body HTML must not be null"");
    Validate.notNull(baseUri, ""Base URI must not be null"");
    Validate.notNull(whitelist, ""Whitelist must not be null"");
    Validate.notNull(outputSettings, ""Output settings must not be null"");

    Document dirty = parseBodyFragment(bodyHtml, baseUri);
    Cleaner cleaner = new Cleaner(whitelist);
    Document clean = cleaner.clean(dirty);
    clean.outputSettings(outputSettings); // Ensure settings are applied before returning
    return clean.body() != null ? clean.body().html() : """"; // Ensure clean body exists before accessing HTML
}",0,0
249,Jsoup_60,"public String chompBalanced(char open, char close) {
        int start = -1;
        int end = -1;
        int depth = 0;
        char last = 0;
        boolean inQuote = false;

        do {
            if (isEmpty()) break;
            Character c = consume();
            if (last == 0 || last != ESC) {
                if ((c.equals('\'') || c.equals('""')) && c != open)
                    inQuote = !inQuote;
                if (inQuote)
                    continue;
                if (c.equals(open)) {
                    depth++;
                    if (start == -1)
                        start = pos;
                }
                else if (c.equals(close))
                    depth--;
            }

            if (depth > 0 && last != 0)
                end = pos; // don't include the outer match pair in the return
             last = c;
         } while (depth > 0);
         final String out = (end >= 0) ? queue.substring(start, end) : """";
         return out;
     }","public String chompBalanced(char open, char close) {
    int start = -1;
    int end = -1;
    int depth = 0;
    char last = 0;
    boolean inQuote = false;

    do {
        if (isEmpty()) break;
        Character c = consume();
        if (last != ESC) { // Adjusted logic to account for escaped characters
            if ((c.equals('\'') || c.equals('""')) && c != open) {
                inQuote = !inQuote; // Toggle inQuote state
            }
            if (inQuote) {
                last = c; // Only update last if inQuote to avoid interfering with open/close logic
                continue;
            }
            if (c.equals(open)) {
                depth++;
                if (start == -1) {
                    start = pos - 1; // Adjust start to include the opening character
                }
            } else if (c.equals(close) && depth > 0) {
                depth--;
                if (depth == 0) {
                    end = pos; // Set end to include the closing character
                    break; // Break out of loop once the match is found
                }
            }
        }
        last = c; // Update last character after processing
    } while (depth > 0 || inQuote); // Ensure loop continues for quotes or until depth is zero

    final String out = (start >= 0 && end > start) ? queue.substring(start, end) : """";
    return out;
}",0,0
250,Jsoup_63,"void emit(Token token) {
        Validate.isFalse(isEmitPending, ""There is an unread token pending!"");

        emitPending = token;
        isEmitPending = true;

         if (token.type == Token.TokenType.StartTag) {
             Token.StartTag startTag = (Token.StartTag) token;
             lastStartTag = startTag.tagName;
             if (startTag.selfClosing)
                 selfClosingFlagAcknowledged = false;
         } else if (token.type == Token.TokenType.EndTag) {
             Token.EndTag endTag = (Token.EndTag) token;
             if (endTag.attributes != null)
                error(""Attributes incorrectly present on end tag"");
        }
    }","void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");

    emitPending = token;
    isEmitPending = true;

    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag.tagName;
        if (startTag.selfClosing != null && startTag.selfClosing) {
            selfClosingFlagAcknowledged = false;
        }
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes != null && !endTag.attributes.isEmpty()) {
            error(""Attributes incorrectly present on end tag"");
        }
    }
}",0,0
250,Jsoup_63,"Token read() {
         if (!selfClosingFlagAcknowledged) {
             error(""Self closing flag not acknowledged"");
             selfClosingFlagAcknowledged = true;
         }
         while (!isEmitPending)
             state.read(this, reader);
 
        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
        if (charsBuilder.length() > 0) {
            String str = charsBuilder.toString();
            charsBuilder.delete(0, charsBuilder.length());
            charsString = null;
            return charPending.data(str);
        } else if (charsString != null) {
            Token token = charPending.data(charsString);
            charsString = null;
            return token;
        } else {
            isEmitPending = false;
            return emitPending;
        }
    }","Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }

    while (!isEmitPending)
        state.read(this, reader);

    if (charsBuilder.length() > 0) {
        String str = charsBuilder.toString();
        charsBuilder.setLength(0); // Clear the builder more efficiently
        charsString = null;
        return charPending.data(str);
    } else if (charsString != null) {
        Token token = charPending.data(charsString);
        charsString = null;
        return token;
    } else {
        isEmitPending = false;
        return emitPending;
    }
}",0,0
250,Jsoup_63,"Element insertEmpty(Token.StartTag startTag) {
        Tag tag = Tag.valueOf(startTag.name(), settings);
        Element el = new Element(tag, baseUri, startTag.attributes);
         insertNode(el);
         if (startTag.isSelfClosing()) {
             if (tag.isKnownTag()) {
                 if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag();
             }
             else {
                 tag.setSelfClosing();
                 tokeniser.acknowledgeSelfClosingFlag();
             }
         }
         return el;
     }","Element insertEmpty(Token.StartTag startTag) {
    Tag tag = Tag.valueOf(startTag.name(), settings);
    Element el = new Element(tag, baseUri, startTag.attributes);

    insertNode(el);

    if (startTag.isSelfClosing() != null && startTag.isSelfClosing()) {
        if (tag.isKnownTag()) {
            if (tag.isSelfClosing()) {
                tokeniser.acknowledgeSelfClosingFlag();
            }
        } else {
            tag.setSelfClosing();
            tokeniser.acknowledgeSelfClosingFlag();
        }
    }
    return el;
}",0,0
251,Jsoup_65,"boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                 case StartTag:
                     Token.StartTag startTag = t.asStartTag();
                     String name = startTag.normalName();
                     if (name.equals(""tr"")) {
                         tb.clearStackToTableBodyContext();
                         tb.insert(startTag);
                         tb.transition(InRow);
                    } else if (StringUtil.in(name, ""th"", ""td"")) {
                        tb.error(this);
                        tb.processStartTag(""tr"");
                        return tb.process(startTag);
                    } else if (StringUtil.in(name, ""caption"", ""col"", ""colgroup"", ""tbody"", ""tfoot"", ""thead"")) {
                        return exitTableBody(t, tb);
                    } else
                        return anythingElse(t, tb);
                    break;
                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    name = endTag.normalName();
                    if (StringUtil.in(name, ""tbody"", ""tfoot"", ""thead"")) {
                        if (!tb.inTableScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.clearStackToTableBodyContext();
                            tb.pop();
                            tb.transition(InTable);
                        }
                    } else if (name.equals(""table"")) {
                        return exitTableBody(t, tb);
                    } else if (StringUtil.in(name, ""body"", ""caption"", ""col"", ""colgroup"", ""html"", ""td"", ""th"", ""tr"")) {
                        tb.error(this);
                        return false;
                    } else
                        return anythingElse(t, tb);
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }","boolean process(Token t, HtmlTreeBuilder tb) {
    switch (t.type) {
        case StartTag:
            Token.StartTag startTag = t.asStartTag();
            String name = startTag.normalName();
            if (name.equals(""tr"")) {
                tb.clearStackToTableBodyContext();
                tb.insert(startTag);
                tb.transition(HtmlTreeBuilderState.InRow);
            } else if (StringUtil.in(name, ""th"", ""td"")) {
                tb.error(this);
                tb.processStartTag(""tr"");
                return tb.process(startTag);
            } else if (StringUtil.in(name, ""caption"", ""col"", ""colgroup"", ""tbody"", ""tfoot"", ""thead"")) {
                return exitTableBody(t, tb);
            } else {
                return anythingElse(t, tb);
            }
            break;
        case EndTag:
            Token.EndTag endTag = t.asEndTag();
            name = endTag.normalName();
            if (StringUtil.in(name, ""tbody"", ""tfoot"", ""thead"")) {
                if (!tb.inTableScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.clearStackToTableBodyContext();
                    tb.pop();
                    tb.transition(HtmlTreeBuilderState.InTable);
                }
            } else if (name.equals(""table"")) {
                return exitTableBody(t, tb);
            } else if (StringUtil.in(name, ""body"", ""caption"", ""col"", ""colgroup"", ""html"", ""td"", ""th"", ""tr"")) {
                tb.error(this);
                return false;
            } else {
                return anythingElse(t, tb);
            }
            break;
        default:
            return anythingElse(t, tb);
    }
    return true;
}",0,0
251,Jsoup_65,"void clearStackToTableBodyContext() {
         clearStackToContext(""tbody"", ""tfoot"", ""thead"");
     }","void clearStackToTableBodyContext() {
    clearStackToContext(""tbody"", ""tfoot"", ""thead"");
}",0,0
251,Jsoup_65,"boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isStartTag()) {
                 Token.StartTag startTag = t.asStartTag();
                 String name = startTag.normalName();
 
                 if (StringUtil.in(name, ""th"", ""td"")) {
                     tb.clearStackToTableRowContext();
                     tb.insert(startTag);
                     tb.transition(InCell);
                    tb.insertMarkerToFormattingElements();
                } else if (StringUtil.in(name, ""caption"", ""col"", ""colgroup"", ""tbody"", ""tfoot"", ""thead"", ""tr"")) {
                    return handleMissingTr(t, tb);
                } else {
                    return anythingElse(t, tb);
                }
            } else if (t.isEndTag()) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();

                if (name.equals(""tr"")) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this); // frag
                        return false;
                    }
                    tb.clearStackToTableRowContext();
                    tb.pop(); // tr
                    tb.transition(InTableBody);
                } else if (name.equals(""table"")) {
                    return handleMissingTr(t, tb);
                } else if (StringUtil.in(name, ""tbody"", ""tfoot"", ""thead"")) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this);
                        return false;
                    }
                    tb.processEndTag(""tr"");
                    return tb.process(t);
                } else if (StringUtil.in(name, ""body"", ""caption"", ""col"", ""colgroup"", ""html"", ""td"", ""th"")) {
                    tb.error(this);
                    return false;
                } else {
                    return anythingElse(t, tb);
                }
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }","boolean process(Token t, HtmlTreeBuilder tb) {
    if (t.isStartTag()) {
        Token.StartTag startTag = t.asStartTag();
        String name = startTag.normalName();

        if (StringUtil.in(name, ""th"", ""td"")) {
            tb.clearStackToTableRowContext();
            tb.insert(startTag);
            tb.transition(HtmlTreeBuilderState.InCell);
            tb.insertMarkerToFormattingElements();
        } else if (StringUtil.in(name, ""caption"", ""col"", ""colgroup"", ""tbody"", ""tfoot"", ""thead"", ""tr"")) {
            return handleMissingTr(t, tb);
        } else {
            return anythingElse(t, tb);
        }
    } else if (t.isEndTag()) {
        Token.EndTag endTag = t.asEndTag();
        String name = endTag.normalName();

        if (name.equals(""tr"")) {
            if (!tb.inTableScope(name)) {
                tb.error(this);
                return false;
            }
            tb.clearStackToTableRowContext();
            tb.pop();
            tb.transition(HtmlTreeBuilderState.InTableBody);
        } else if (name.equals(""table"")) {
            return handleMissingTr(t, tb);
        } else if (StringUtil.in(name, ""tbody"", ""tfoot"", ""thead"")) {
            if (!tb.inTableScope(name)) {
                tb.error(this);
                return false;
            }
            tb.processEndTag(""tr"");
            return tb.process(t);
        } else if (StringUtil.in(name, ""body"", ""caption"", ""col"", ""colgroup"", ""html"", ""td"", ""th"")) {
            tb.error(this);
            return false;
        } else {
            return anythingElse(t, tb);
        }
    } else {
        return anythingElse(t, tb);
    }
    return true;
}",0,0
252,Jsoup_66,"protected List<Node> ensureChildNodes() {
         if (childNodes == EMPTY_NODES) {
             childNodes = new NodeList(4);
         }
         return childNodes;
     }","protected List<Node> ensureChildNodes() {
    if (childNodes == EMPTY_NODES || childNodes == null) {
        childNodes = new NodeList(4);
    }
    return childNodes;
}",0,0
253,Jsoup_67,"    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {
        specificScopeTarget[0] = targetName;
        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);
    }
",Match failed,0,0
253,Jsoup_67,"    private static final String[] TagSearchSpecial = sort(new String[]{""address"", ""applet"", ""area"", ""article"", ""aside"", ""base"", ""basefont"", ""bgsound"",
        ""blockquote"", ""body"", ""br"", ""button"", ""caption"", ""center"", ""col"", ""colgroup"", ""command"", ""dd"",
        ""details"", ""dir"", ""div"", ""dl"", ""dt"", ""embed"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""form"",
        ""frame"", ""frameset"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"", ""head"", ""header"", ""hgroup"", ""hr"", ""html"",
        ""iframe"", ""img"", ""input"", ""isindex"", ""li"", ""link"", ""listing"", ""marquee"", ""menu"", ""meta"", ""nav"",
        ""noembed"", ""noframes"", ""noscript"", ""object"", ""ol"", ""p"", ""param"", ""plaintext"", ""pre"", ""script"",
        ""section"", ""select"", ""style"", ""summary"", ""table"", ""tbody"", ""td"", ""textarea"", ""tfoot"", ""th"", ""thead"",
        ""title"", ""tr"", ""ul"", ""wbr"", ""xmp""});
",Match failed,0,0
254,Jsoup_69,"    public FormElement addElement(Element element) {
        elements.add(element);
        return this;
    }
","public FormElement addElement(Element element) {
    if (element == null) {
        throw new IllegalArgumentException(""Element cannot be null"");
    }
    elements.add(element);
    return this;
}",0,0
255,Jsoup_7,"public Document normalise() {
        Element htmlEl = findFirstElementByTagName(""html"", this);
        if (htmlEl == null)
            htmlEl = appendElement(""html"");
        if (head() == null)
            htmlEl.prependElement(""head"");
        if (body() == null)
            htmlEl.appendElement(""body"");

        // pull text nodes out of root, html, and head els, and push into body. non-text nodes are already taken care
        // of. do in inverse order to maintain text order.
        normaliseTextNodes(head());
         normaliseTextNodes(htmlEl);
         normaliseTextNodes(this);
 
         
         return this;
     }","public Document normalise() {
    Element htmlEl = findFirstElementByTagName(""html"", this);
    if (htmlEl == null) {
        htmlEl = appendElement(""html"");
    }

    if (htmlEl != null) {
        if (head() == null) {
            htmlEl.prependElement(""head"");
        }
        if (body() == null) {
            htmlEl.appendElement(""body"");
        }

        // Pull text nodes out of root, html, and head elements, and push into body.
        // Non-text nodes are already handled. Process in reverse order to maintain text order.
        normaliseTextNodes(this);
        normaliseTextNodes(htmlEl);
        normaliseTextNodes(head());
    }

    return this;
}",0,0
256,Jsoup_71,"private void findElements() {
        if (tq.matchChomp(""#""))
            byId();
        else if (tq.matchChomp("".""))
            byClass();
        else if (tq.matchesWord() || tq.matches(""*|""))
            byTag();
        else if (tq.matches(""[""))
            byAttribute();
        else if (tq.matchChomp(""*""))
            allElements();
        else if (tq.matchChomp("":lt(""))
            indexLessThan();
        else if (tq.matchChomp("":gt(""))
            indexGreaterThan();
        else if (tq.matchChomp("":eq(""))
            indexEquals();
        else if (tq.matches("":has(""))
            has();
        else if (tq.matches("":contains(""))
            contains(false);
        else if (tq.matches("":containsOwn(""))
            contains(true);
        else if (tq.matches("":containsData(""))
            containsData();
        else if (tq.matches("":matches(""))
            matches(false);
        else if (tq.matches("":matchesOwn(""))
            matches(true);
        else if (tq.matches("":not(""))
            not();
		else if (tq.matchChomp("":nth-child(""))
        	cssNthChild(false, false);
        else if (tq.matchChomp("":nth-last-child(""))
        	cssNthChild(true, false);
        else if (tq.matchChomp("":nth-of-type(""))
        	cssNthChild(false, true);
        else if (tq.matchChomp("":nth-last-of-type(""))
        	cssNthChild(true, true);
        else if (tq.matchChomp("":first-child""))
        	evals.add(new Evaluator.IsFirstChild());
        else if (tq.matchChomp("":last-child""))
        	evals.add(new Evaluator.IsLastChild());
        else if (tq.matchChomp("":first-of-type""))
        	evals.add(new Evaluator.IsFirstOfType());
        else if (tq.matchChomp("":last-of-type""))
        	evals.add(new Evaluator.IsLastOfType());
        else if (tq.matchChomp("":only-child""))
        	evals.add(new Evaluator.IsOnlyChild());
        else if (tq.matchChomp("":only-of-type""))
        	evals.add(new Evaluator.IsOnlyOfType());
        else if (tq.matchChomp("":empty""))
         	evals.add(new Evaluator.IsEmpty());
         else if (tq.matchChomp("":root""))
         	evals.add(new Evaluator.IsRoot());
 		else // unhandled
             throw new Selector.SelectorParseException(""Could not parse query '%s': unexpected token at '%s'"", query, tq.remainder());
 
    }","private void findElements() {
    if (tq.matchChomp(""#"")) {
        byId();
    } else if (tq.matchChomp(""."")) {
        byClass();
    } else if (tq.matchesWord() || tq.matches(""*|"")) {
        byTag();
    } else if (tq.matches(""["")) {
        byAttribute();
    } else if (tq.matchChomp(""*"")) {
        allElements();
    } else if (tq.matchChomp("":lt("")) {
        indexLessThan();
    } else if (tq.matchChomp("":gt("")) {
        indexGreaterThan();
    } else if (tq.matchChomp("":eq("")) {
        indexEquals();
    } else if (tq.matches("":has("")) {
        has();
    } else if (tq.matches("":contains("")) {
        contains(false);
    } else if (tq.matches("":containsOwn("")) {
        contains(true);
    } else if (tq.matches("":containsData("")) {
        containsData();
    } else if (tq.matches("":matches("")) {
        matches(false);
    } else if (tq.matches("":matchesOwn("")) {
        matches(true);
    } else if (tq.matches("":not("")) {
        not();
    } else if (tq.matchChomp("":nth-child("")) {
        cssNthChild(false, false);
    } else if (tq.matchChomp("":nth-last-child("")) {
        cssNthChild(true, false);
    } else if (tq.matchChomp("":nth-of-type("")) {
        cssNthChild(false, true);
    } else if (tq.matchChomp("":nth-last-of-type("")) {
        cssNthChild(true, true);
    } else if (tq.matchChomp("":first-child"")) {
        evals.add(new Evaluator.IsFirstChild());
    } else if (tq.matchChomp("":last-child"")) {
        evals.add(new Evaluator.IsLastChild());
    } else if (tq.matchChomp("":first-of-type"")) {
        evals.add(new Evaluator.IsFirstOfType());
    } else if (tq.matchChomp("":last-of-type"")) {
        evals.add(new Evaluator.IsLastOfType());
    } else if (tq.matchChomp("":only-child"")) {
        evals.add(new Evaluator.IsOnlyChild());
    } else if (tq.matchChomp("":only-of-type"")) {
        evals.add(new Evaluator.IsOnlyOfType());
    } else if (tq.matchChomp("":empty"")) {
        evals.add(new Evaluator.IsEmpty());
    } else if (tq.matchChomp("":root"")) {
        evals.add(new Evaluator.IsRoot());
    } else {
        throw new Selector.SelectorParseException(
            ""Could not parse query '%s': unexpected token at '%s'"", query, tq.remainder()
        );
    }
}",0,0
257,Jsoup_73,"public void tail(org.jsoup.nodes.Node source, int depth) {
             if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {
                 dest = (Element) dest.getParentNode(); // undescend. cromulent.
             }
         }","public void tail(org.jsoup.nodes.Node source, int depth) {
    if (source instanceof org.jsoup.nodes.Element) {
        if (dest != null && dest.getParentNode() instanceof Element) {
            dest = (Element) dest.getParentNode(); // undescend. cromulent.
        }
    }
}",0,0
257,Jsoup_73,"private String updateNamespaces(org.jsoup.nodes.Element el) {
            // scan the element for namespace declarations
            // like: xmlns=""blah"" or xmlns:prefix=""blah""
            Attributes attributes = el.attributes();
            for (Attribute attr : attributes) {
                String key = attr.getKey();
                String prefix;
                if (key.equals(xmlnsKey)) {
                    prefix = """";
                } else if (key.startsWith(xmlnsPrefix)) {
                    prefix = key.substring(xmlnsPrefix.length());
                 } else {
                     continue;
                 }
                 namespaces.put(prefix, attr.getValue());
             }
 
             // get the element prefix if any
            int pos = el.tagName().indexOf("":"");
            return pos > 0 ? el.tagName().substring(0, pos) : """";
        }","private String updateNamespaces(org.jsoup.nodes.Element el) {
    // scan the element for namespace declarations
    // like: xmlns=""blah"" or xmlns:prefix=""blah""
    Attributes attributes = el.attributes();
    for (Attribute attr : attributes) {
        String key = attr.getKey();
        String prefix;
        if (key.equals(xmlnsKey)) {
            prefix = """";
        } else if (key.startsWith(xmlnsPrefix)) {
            prefix = key.substring(xmlnsPrefix.length());
        } else {
            continue;
        }
        namespaces.put(prefix, attr.getValue());
    }

    // get the element prefix if any
    String tagName = el.tagName();
    int pos = tagName != null ? tagName.indexOf("":"") : -1;
    return pos > 0 ? tagName.substring(0, pos) : """";
}",0,0
258,Jsoup_74,"public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {
        boolean lastWasWhite = false;
        boolean reachedNonWhite = false;

        int len = string.length();
        int c;
        for (int i = 0; i < len; i+= Character.charCount(c)) {
            c = string.codePointAt(i);
            if (isActuallyWhitespace(c)) {
                if ((stripLeading && !reachedNonWhite) || lastWasWhite)
                    continue;
                 accum.append(' ');
                 lastWasWhite = true;
             }
             else {
                 accum.appendCodePoint(c);
                 lastWasWhite = false;
                 reachedNonWhite = true;
            }
        }
    }","public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {
    boolean lastWasWhite = false;
    boolean reachedNonWhite = false;

    int len = string.length();
    for (int i = 0; i < len; ) {
        int c = string.codePointAt(i); // Move declaration inside loop to avoid scope issues
        i += Character.charCount(c); // Increment correctly based on character count

        if (isActuallyWhitespace(c)) {
            if ((stripLeading && !reachedNonWhite) || lastWasWhite) {
                continue;
            }
            accum.append(' ');
            lastWasWhite = true;
        } else {
            accum.appendCodePoint(c);
            lastWasWhite = false;
            reachedNonWhite = true;
        }
    }
}",0,0
259,Jsoup_78,"static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {
        if (input == null) // empty body
            return new Document(baseUri);
        input = ConstrainableInputStream.wrap(input, bufferSize, 0);

        Document doc = null;
        boolean fullyRead = false;

        // read the start of the stream and look for a BOM or meta charset
        input.mark(bufferSize);
        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
        fullyRead = input.read() == -1;
        input.reset();

        // look for BOM - overrides any other header or input
        BomCharset bomCharset = detectCharsetFromBom(firstBytes);
        if (bomCharset != null) {
            charsetName = bomCharset.charset;
            input.skip(bomCharset.offset);
        }

        if (charsetName == null) { // determine from meta. safe first parse as UTF-8
            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
            doc = parser.parseInput(docData, baseUri);

            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
            String foundCharset = null; // if not found, will keep utf-8 as best attempt
            for (Element meta : metaElements) {
                if (meta.hasAttr(""http-equiv""))
                    foundCharset = getCharsetFromContentType(meta.attr(""content""));
                if (foundCharset == null && meta.hasAttr(""charset""))
                    foundCharset = meta.attr(""charset"");
                if (foundCharset != null)
                    break;
            }

            // look for <?xml encoding='ISO-8859-1'?>
            if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {
                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);
                if (prolog.name().equals(""xml""))
                    foundCharset = prolog.attr(""encoding"");
            }
            foundCharset = validateCharset(foundCharset);
            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)
                foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                charsetName = foundCharset;
                doc = null;
            } else if (!fullyRead) {
                doc = null;
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        }
        if (doc == null) {
             if (charsetName == null)
                 charsetName = defaultCharset;
             BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
                 doc = parser.parseInput(reader, baseUri);
                 // io exception when parsing (not seen before because reading the stream as we go)
             doc.outputSettings().charset(charsetName);
         }
         input.close();
        return doc;
    }","static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {
    if (input == null) {
        return new Document(baseUri);
    }

    input = ConstrainableInputStream.wrap(input, bufferSize, 0);

    Document doc = null;
    boolean fullyRead = false;

    // Read the start of the stream and look for a BOM or meta charset
    input.mark(bufferSize);
    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed
    fullyRead = input.read() == -1;
    input.reset();

    // Look for BOM - overrides any other header or input
    BomCharset bomCharset = detectCharsetFromBom(firstBytes);
    if (bomCharset != null) {
        charsetName = bomCharset.charset;
        input.skip(bomCharset.offset);
    }

    if (charsetName == null) { // Determine from meta. Safe first parse as UTF-8
        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
        doc = parser.parseInput(docData, baseUri);

        // Look for <meta> charset declarations
        Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
        String foundCharset = null;
        for (Element meta : metaElements) {
            if (meta.hasAttr(""http-equiv"")) {
                foundCharset = getCharsetFromContentType(meta.attr(""content""));
            }
            if (foundCharset == null && meta.hasAttr(""charset"")) {
                foundCharset = meta.attr(""charset"");
            }
            if (foundCharset != null) {
                break;
            }
        }

        // Look for XML encoding declaration
        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {
            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);
            if (prolog.name().equals(""xml"")) {
                foundCharset = prolog.attr(""encoding"");
            }
        }

        foundCharset = validateCharset(foundCharset);
        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {
            foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
            charsetName = foundCharset;
            doc = null; // Re-decode required
        } else if (!fullyRead) {
            doc = null; // Read remainder of the stream
        }
    } else {
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
    }

    if (doc == null) {
        if (charsetName == null) {
            charsetName = defaultCharset;
        }
        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
        try {
            doc = parser.parseInput(reader, baseUri);
        } catch (IOException e) {
            throw new IOException(""Error during parsing input stream"", e);
        }

        doc.outputSettings().charset(charsetName);
    }

    input.close();
    return doc;
}",0,0
260,Jsoup_79,"
import org.jsoup.helper.Validate;

import java.util.List;

abstract class LeafNode extends Node {

    Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)

","import org.jsoup.helper.Validate;

import java.util.List;

abstract class LeafNode extends Node {

    private Object value; // Encapsulate 'value' for better data security and abstraction.

    // Provide getter for 'value'
    protected Object getValue() {
        return value;
    }

    // Provide setter for 'value'
    protected void setValue(Object value) {
        this.value = value;
    }
}",0,0
260,Jsoup_79,"    public int childNodeSize() {
        return 0;
    }
","@Override
public int childNodeSize() {
    return getValue() instanceof List ? ((List<?>) getValue()).size() : 0; // Check if 'value' is a list and return its size.
}",0,0
261,Jsoup_8,"    public String outerHtml() {
        StringBuilder accum = new StringBuilder(32*1024);
        outerHtml(accum);
        return accum.toString();
    }
","public String outerHtml() {
    StringBuilder accum = new StringBuilder(32 * 1024);
    Document owner = ownerDocument();
    OutputSettings outputSettings = owner != null ? owner.outputSettings() : new OutputSettings();
    new NodeTraversor(new OuterHtmlVisitor(outputSettings)).traverse(this);
    return accum.toString();
}",0,0
262,Jsoup_81,"static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {
        if (input == null) // empty body
            return new Document(baseUri);
        input = ConstrainableInputStream.wrap(input, bufferSize, 0);

        Document doc = null;
        boolean fullyRead = false;

        // read the start of the stream and look for a BOM or meta charset
        input.mark(bufferSize);
        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
        fullyRead = input.read() == -1;
        input.reset();

        // look for BOM - overrides any other header or input
        BomCharset bomCharset = detectCharsetFromBom(firstBytes);
        if (bomCharset != null)
            charsetName = bomCharset.charset;

        if (charsetName == null) { // determine from meta. safe first parse as UTF-8
            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
            doc = parser.parseInput(docData, baseUri);

            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
            String foundCharset = null; // if not found, will keep utf-8 as best attempt
            for (Element meta : metaElements) {
                if (meta.hasAttr(""http-equiv""))
                    foundCharset = getCharsetFromContentType(meta.attr(""content""));
                if (foundCharset == null && meta.hasAttr(""charset""))
                    foundCharset = meta.attr(""charset"");
                if (foundCharset != null)
                    break;
            }

            // look for <?xml encoding='ISO-8859-1'?>
            if (foundCharset == null && doc.childNodeSize() > 0) {
                Node first = doc.childNode(0);
                 XmlDeclaration decl = null;
                 if (first instanceof XmlDeclaration)
                     decl = (XmlDeclaration) first;
                 if (decl != null) {
                     if (decl.name().equalsIgnoreCase(""xml""))
                         foundCharset = decl.attr(""encoding"");
                }
            }
            foundCharset = validateCharset(foundCharset);
            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)
                foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                charsetName = foundCharset;
                doc = null;
            } else if (!fullyRead) {
                doc = null;
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        }
        if (doc == null) {
            if (charsetName == null)
                charsetName = defaultCharset;
            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here
                reader.skip(1);
            try {
                doc = parser.parseInput(reader, baseUri);
            } catch (UncheckedIOException e) {
                // io exception when parsing (not seen before because reading the stream as we go)
                throw e.ioException();
            }
            doc.outputSettings().charset(charsetName);
        }
        input.close();
        return doc;
    }","static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {
    if (input == null) {
        return new Document(baseUri);
    }
    input = ConstrainableInputStream.wrap(input, bufferSize, 0);

    Document doc = null;
    boolean fullyRead = false;

    try {
        // read the start of the stream and look for a BOM or meta charset
        input.mark(bufferSize);
        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 to check completion
        fullyRead = input.read() == -1;
        input.reset();

        // look for BOM
        BomCharset bomCharset = detectCharsetFromBom(firstBytes);
        if (bomCharset != null) {
            charsetName = bomCharset.charset;
        }

        if (charsetName == null) { // determine from meta, using UTF-8 as default
            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
            doc = parser.parseInput(docData, baseUri);

            // look for <meta http-equiv=""Content-Type""> or <meta charset=""..."">
            Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
            String foundCharset = null;
            for (Element meta : metaElements) {
                if (meta.hasAttr(""http-equiv"")) {
                    foundCharset = getCharsetFromContentType(meta.attr(""content""));
                }
                if (foundCharset == null && meta.hasAttr(""charset"")) {
                    foundCharset = meta.attr(""charset"");
                }
                if (foundCharset != null) {
                    break;
                }
            }

            // look for XML declaration
            if (foundCharset == null && doc.childNodeSize() > 0) {
                Node first = doc.childNode(0);
                if (first instanceof XmlDeclaration) {
                    XmlDeclaration decl = (XmlDeclaration) first;
                    if (decl.name().equalsIgnoreCase(""xml"")) {
                        foundCharset = decl.attr(""encoding"");
                    }
                }
            }

            foundCharset = validateCharset(foundCharset);
            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {
                charsetName = foundCharset.trim().replaceAll(""[\""']"", """");
                doc = null; // re-process with detected charset
            } else if (!fullyRead) {
                doc = null; // re-process without assuming fully read
            }
        } else {
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        }

        if (doc == null) {
            if (charsetName == null) {
                charsetName = defaultCharset;
            }
            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
            if (bomCharset != null && bomCharset.offset) {
                reader.skip(1); // skip BOM
            }
            try {
                doc = parser.parseInput(reader, baseUri);
            } catch (UncheckedIOException e) {
                throw e.ioException(); // rethrow as IOException
            }
            doc.outputSettings().charset(charsetName);
        }
    } finally {
        input.close(); // ensure input is always closed
    }

    return doc;
}",0,0
263,Jsoup_83,"String consumeTagName() {
        // '\t', '\n', '\r', '\f', ' ', '/', '>', nullChar
        // NOTE: out of spec, added '<' to fix common author bugs
        bufferUp();
        final int start = bufPos;
        final int remaining = bufLength;
        final char[] val = charBuf;
 
         while (bufPos < remaining) {
             final char c = val[bufPos];
             if (c == '\t'|| c ==  '\n'|| c ==  '\r'|| c ==  '\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)
                 break;
             bufPos++;
         }

        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : """";
    }","String consumeTagName() {
    bufferUp();
    final int start = bufPos;
    final int remaining = bufLength;
    final char[] val = charBuf;

    while (bufPos < remaining) {
        final char c = val[bufPos];
        if (c == '\t' || c == '\n' || c == '\r' || c == '\f' || c == ' ' || c == '/' || c == '>' || c == TokeniserState.nullChar || c == '<')
            break;
        bufPos++;
    }

    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : """";
}",0,0
263,Jsoup_83,"void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    break; // ignore whitespace
                case '/':
                    t.transition(SelfClosingStartTag);
                    break;
                    // intended fall through as if >
                case '>':
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case nullChar:
                    t.error(this);
                    t.tagPending.newAttribute();
                    r.unconsume();
                    t.transition(AttributeName);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                     break;
                 case '""':
                 case '\'':
                 case '<':
                 case '=':
                     t.error(this);
                     t.tagPending.newAttribute();
                    t.tagPending.appendAttributeName(c);
                    t.transition(AttributeName);
                    break;
                default: // A-Z, anything else
                    t.tagPending.newAttribute();
                    r.unconsume();
                    t.transition(AttributeName);
            }
        }","void read(Tokeniser t, CharacterReader r) {
    char c = r.consume();
    switch (c) {
        case '\t':
        case '\n':
        case '\r':
        case '\f':
        case ' ':
            break; // ignore whitespace
        case '/':
            t.transition(SelfClosingStartTag);
            break;
        case '>':
            t.emitTagPending();
            t.transition(Data);
            break;
        case TokeniserState.nullChar:
            t.error(this);
            t.tagPending.newAttribute();
            r.unconsume();
            t.transition(AttributeName);
            break;
        case eof:
            t.eofError(this);
            t.transition(Data);
            break;
        case '""':
        case '\'':
        case '<':
        case '=':
            t.error(this);
            t.tagPending.newAttribute();
            t.tagPending.appendAttributeName(c);
            t.transition(AttributeName);
            break;
        default: // A-Z, anything else
            t.tagPending.newAttribute();
            r.unconsume();
            t.transition(AttributeName);
    }
}",0,0
263,Jsoup_83,"void read(Tokeniser t, CharacterReader r) {
            // previous TagOpen state did NOT consume, will have a letter char in current
            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();
            String tagName = r.consumeTagName();
            t.tagPending.appendTagName(tagName);

            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BeforeAttributeName);
                    break;
                 case '/':
                     t.transition(SelfClosingStartTag);
                     break;
                     // intended fall through to next >
                 case '>':
                     t.emitTagPending();
                    t.transition(Data);
                    break;
                case nullChar: // replacement
                    t.tagPending.appendTagName(replacementStr);
                    break;
                case eof: // should emit pending tag?
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default: // buffer underrun
                    t.tagPending.appendTagName(c);
            }
        }","void read(Tokeniser t, CharacterReader r) {
    String tagName = r.consumeTagName();
    t.tagPending.appendTagName(tagName);

    char c = r.consume();
    switch (c) {
        case '\t':
        case '\n':
        case '\r':
        case '\f':
        case ' ':
            t.transition(BeforeAttributeName);
            break;
        case '/':
            t.transition(SelfClosingStartTag);
            break;
        case '>':
            t.emitTagPending();
            t.transition(Data);
            break;
        case TokeniserState.nullChar:
            t.error(this);
            t.tagPending.appendTagName(replacementStr);
            break;
        case eof:
            t.eofError(this);
            t.transition(Data);
            break;
        default:
            t.error(this);
            t.tagPending.appendTagName(c);
            break;
    }
}",0,0
264,Jsoup_87,"    void reconstructFormattingElements() {
        Element last = lastFormattingElement();
        if (last == null || onStack(last))
            return;

        Element entry = last;
        int size = formattingElements.size();
        int pos = size - 1;
        boolean skip = false;
        while (true) {
            if (pos == 0) { // step 4. if none before, skip to 8
                skip = true;
                break;
            }
            entry = formattingElements.get(--pos); // step 5. one earlier than entry
            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack
                break; // jump to 8, else continue back to 4
        }
        while(true) {
            if (!skip) // step 7: on later than entry
                entry = formattingElements.get(++pos);
            Validate.notNull(entry); // should not occur, as we break at last element

            // 8. create new element from element, 9 insert into current node, onto stack
            skip = false; // can only skip increment from 4.
            Element newEl = insertStartTag(entry.nodeName());
            // newEl.namespace(entry.namespace()); // todo: namespaces
            newEl.attributes().addAll(entry.attributes());

            // 10. replace entry with new entry
            formattingElements.set(pos, newEl);

            // 11
            if (pos == size-1) // if not last entry in list, jump to 7
                break;
        }
    }
","void reconstructFormattingElements() {
    Element last = lastFormattingElement();
    if (last == null || onStack(last))
        return;

    Element entry = last;
    int size = formattingElements.size();
    int pos = size - 1;
    boolean skip = false;
    while (true) {
        if (pos == 0) { // step 4. if none before, skip to 8
            skip = true;
            break;
        }
        entry = formattingElements.get(--pos); // step 5. one earlier than entry
        if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack
            break; // jump to 8, else continue back to 4
    }
    while (true) {
        if (!skip) // step 7: on later than entry
            entry = formattingElements.get(++pos);
        if (entry == null) // Prevent unexpected nulls
            break;

        // 8. create new element from element, 9 insert into current node, onto stack
        skip = false; // can only skip increment from 4.
        Element newEl = insertStartTag(entry.nodeName());
        newEl.attributes().addAll(entry.attributes());

        // 10. replace entry with new entry
        formattingElements.set(pos, newEl);

        // 11
        if (pos == size - 1) // if not last entry in list, jump to 7
            break;
    }
}",0,0
264,Jsoup_87,"    public static Tag valueOf(String tagName, ParseSettings settings) {
        Validate.notNull(tagName);
        Tag tag = tags.get(tagName);

        if (tag == null) {
            tagName = settings.normalizeTag(tagName);
            Validate.notEmpty(tagName);
            tag = tags.get(tagName);

            if (tag == null) {
                // not defined: create default; go anywhere, do anything! (incl be inside a <p>)
                tag = new Tag(tagName);
                tag.isBlock = false;
            }
        }
        return tag;
    }
","public static Tag valueOf(String tagName, ParseSettings settings) {
    Validate.notNull(tagName);
    tagName = settings.normalizeTag(tagName);
    Validate.notEmpty(tagName);

    // Lookup tag only after normalizing
    Tag tag = tags.get(tagName);

    if (tag == null) {
        // not defined: create default
        tag = new Tag(tagName);
        tag.isBlock = false;
    }
    return tag;
}",0,0
264,Jsoup_87,"    private boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.
    private boolean preserveWhitespace = false; // for pre, textarea, script etc
    private boolean formList = false; // a control that appears in forms: input, textarea, output etc
    private boolean formSubmit = false; // a control that can be submitted in a form: input etc

    private Tag(String tagName) {
        this.tagName = tagName;
    }
","private Tag(String tagName) {
    Validate.notNull(tagName, ""Tag name must not be null."");
    this.tagName = tagName;
    this.isBlock = true;
    this.formatAsBlock = true;
    this.canContainInline = true;
    this.empty = false;
    this.selfClosing = false;
    this.preserveWhitespace = false;
    this.formList = false;
    this.formSubmit = false;
}",0,0
264,Jsoup_87,"    private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags

    private String tagName;
    private boolean isBlock = true; // block or inline
    private boolean formatAsBlock = true; // should be formatted as a block
    private boolean canContainInline = true; // only pcdata if not
    private boolean empty = false; // can hold nothing; e.g. img
    private boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.
    private boolean preserveWhitespace = false; // for pre, textarea, script etc
    private boolean formList = false; // a control that appears in forms: input, textarea, output etc
    private boolean formSubmit = false; // a control that can be submitted in a form: input etc

    private Tag(String tagName) {
        this.tagName = tagName;
    }
","private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags

private String tagName;
private boolean isBlock = true; // block or inline
private boolean formatAsBlock = true; // should be formatted as a block
private boolean canContainInline = true; // only pcdata if not
private boolean empty = false; // can hold nothing; e.g. img
private boolean selfClosing = false; // can self close (<foo />)
private boolean preserveWhitespace = false; // for pre, textarea, script etc

private Tag(String tagName) {
    Validate.notNull(tagName, ""Tag name must not be null."");
    this.tagName = tagName;
}",0,0
264,Jsoup_87,"        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            tb.error(this);
            return false;
        }
","private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
    tb.error(this);
    return true; // Return true to allow for recovery behavior
}",0,0
264,Jsoup_87,"        private void closeCell(HtmlTreeBuilder tb) {
            if (tb.inTableScope(""td""))
                tb.processEndTag(""td"");
            else
                tb.processEndTag(""th""); // only here if th or td in scope
        }
","private void closeCell(HtmlTreeBuilder tb) {
    if (tb.inTableScope(""td"")) {
        tb.processEndTag(""td"");
    } else if (tb.inTableScope(""th"")) {
        tb.processEndTag(""th"");
    } else {
        tb.error(this); // Ensure an error gets logged if unexpected
    }
}",0,0
264,Jsoup_87,"        private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {
            if (!(tb.inTableScope(""tbody"") || tb.inTableScope(""thead"") || tb.inScope(""tfoot""))) {
                // frag case
                tb.error(this);
                return false;
            }
            tb.clearStackToTableBodyContext();
            tb.processEndTag(tb.currentElement().nodeName());
            return tb.process(t);
        }
","private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {
    if (!(tb.inTableScope(""tbody"") || tb.inTableScope(""thead"") || tb.inScope(""tfoot""))) {
        tb.error(this);
        return false;
    }
    tb.clearStackToTableBodyContext();
    tb.processEndTag(tb.currentElement().nodeName());
    return tb.process(t);
}",0,0
264,Jsoup_87,"                            final int stackSize = stack.size();
                            for (int si = 0; si < stackSize && si < 64; si++) {
                                Element el = stack.get(si);
                                if (el == formatEl) {
                                    commonAncestor = stack.get(si - 1);
                                    seenFormattingElement = true;
                                } else if (seenFormattingElement && tb.isSpecial(el)) {
                                    furthestBlock = el;
                                    break;
                                }
                            }
","final int stackSize = stack.size();
for (int si = 0; si < stackSize; si++) {
    if (si >= 64) break; // safety limit
    Element el = stack.get(si);
    if (el == formatEl) {
        commonAncestor = stack.get(si - 1);
        seenFormattingElement = true;
    } else if (seenFormattingElement && tb.isSpecial(el)) {
        furthestBlock = el;
        break;
    }
}",0,0
264,Jsoup_87,"        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            tb.processStartTag(""body"");
            tb.framesetOk(true);
            return tb.process(t);
        }
","private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
    tb.processStartTag(""body"");
    tb.framesetOk(true);
    return tb.process(t);
}",0,0
264,Jsoup_87,"    void removeFromActiveFormattingElements(Element el) {
        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {
            Element next = formattingElements.get(pos);
            if (next == el) {
                formattingElements.remove(pos);
                break;
            }
        }
    }
","void removeFromActiveFormattingElements(Element el) {
    for (int pos = formattingElements.size() - 1; pos >= 0; pos--) {
        Element next = formattingElements.get(pos);
        if (next == el) {
            formattingElements.remove(pos);
            return; // Exit early once removed
        }
    }
}",0,0
264,Jsoup_87,"    void pushActiveFormattingElements(Element in) {
        int numSeen = 0;
        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {
            Element el = formattingElements.get(pos);
            if (el == null) // marker
                break;

            if (isSameFormattingElement(in, el))
                numSeen++;

            if (numSeen == 3) {
                formattingElements.remove(pos);
                break;
            }
        }
        formattingElements.add(in);
    }
","void pushActiveFormattingElements(Element in) {
    int numSeen = 0;
    for (int pos = formattingElements.size() - 1; pos >= 0; pos--) {
        Element el = formattingElements.get(pos);
        if (el == null) // marker
            break;

        if (isSameFormattingElement(in, el))
            numSeen++;

        if (numSeen == 3) {
            formattingElements.remove(pos);
            break;
        }
    }
    formattingElements.add(in);
}",0,0
264,Jsoup_87,"    void resetInsertionMode() {
        boolean last = false;
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element node = stack.get(pos);
            if (pos == 0) {
                last = true;
                node = contextElement;
            }
            String name = node.nodeName();
            if (""select"".equals(name)) {
                transition(HtmlTreeBuilderState.InSelect);
                break; // frag
            } else if ((""td"".equals(name) || ""th"".equals(name) && !last)) {
                transition(HtmlTreeBuilderState.InCell);
                break;
            } else if (""tr"".equals(name)) {
                transition(HtmlTreeBuilderState.InRow);
                break;
            } else if (""tbody"".equals(name) || ""thead"".equals(name) || ""tfoot"".equals(name)) {
                transition(HtmlTreeBuilderState.InTableBody);
                break;
            } else if (""caption"".equals(name)) {
                transition(HtmlTreeBuilderState.InCaption);
                break;
            } else if (""colgroup"".equals(name)) {
                transition(HtmlTreeBuilderState.InColumnGroup);
                break; // frag
            } else if (""table"".equals(name)) {
                transition(HtmlTreeBuilderState.InTable);
                break;
            } else if (""head"".equals(name)) {
                transition(HtmlTreeBuilderState.InBody);
                break; // frag
            } else if (""body"".equals(name)) {
                transition(HtmlTreeBuilderState.InBody);
                break;
            } else if (""frameset"".equals(name)) {
                transition(HtmlTreeBuilderState.InFrameset);
                break; // frag
            } else if (""html"".equals(name)) {
                transition(HtmlTreeBuilderState.BeforeHead);
                break; // frag
            } else if (last) {
                transition(HtmlTreeBuilderState.InBody);
                break; // frag
            }
        }
    }
","void resetInsertionMode() {
    for (int pos = stack.size() - 1; pos >= 0; pos--) {
        Element node = pos == 0 ? contextElement : stack.get(pos);
        String name = node.nodeName();
        switch (name) {
            case ""select"":
                transition(HtmlTreeBuilderState.InSelect);
                return;
            case ""td"":
            case ""th"":
                transition(HtmlTreeBuilderState.InCell);
                return;
            case ""tr"":
                transition(HtmlTreeBuilderState.InRow);
                return;
            case ""tbody"":
            case ""thead"":
            case ""tfoot"":
                transition(HtmlTreeBuilderState.InTableBody);
                return;
            case ""caption"":
                transition(HtmlTreeBuilderState.InCaption);
                return;
            case ""colgroup"":
                transition(HtmlTreeBuilderState.InColumnGroup);
                return;
            case ""table"":
                transition(HtmlTreeBuilderState.InTable);
                return;
            case ""head"":
            case ""body"":
            case ""frameset"":
            case ""html"":
                transition(HtmlTreeBuilderState.InBody);
                return;
        }
    }
}",0,0
264,Jsoup_87,"    void newPendingTableCharacters() {
        pendingTableCharacters = new ArrayList<>();
    }
","void newPendingTableCharacters() {
    pendingTableCharacters = new ArrayList<>();
}",0,0
264,Jsoup_87,"            final String elName = stack.get(pos).nodeName();
            if (inSorted(elName, targetNames))
                return true;
            if (inSorted(elName, baseTypes))
                return false;
            if (extraTypes != null && inSorted(elName, extraTypes))
                return false;
        }
        //Validate.fail(""Should not be reachable""); // would end up false because hitting 'html' at root (basetypes)
        return false;
    }

    boolean inScope(String[] targetNames) {
        return inSpecificScope(targetNames, TagsSearchInScope, null);
    }

    boolean inScope(String targetName) {
        return inScope(targetName, null);
    }

    boolean inScope(String targetName, String[] extras) {
        return inSpecificScope(targetName, TagsSearchInScope, extras);
        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml
        // todo: in svg namespace: forignOjbect, desc, title
    }

    boolean inListItemScope(String targetName) {
        return inScope(targetName, TagSearchList);
    }

    boolean inButtonScope(String targetName) {
        return inScope(targetName, TagSearchButton);
    }

    boolean inTableScope(String targetName) {
        return inSpecificScope(targetName, TagSearchTableScope, null);
    }

    boolean inSelectScope(String targetName) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element el = stack.get(pos);
            String elName = el.nodeName();
            if (elName.equals(targetName))
                return true;
            if (!inSorted(elName, TagSearchSelectScope)) // all elements except
                return false;
        }
        Validate.fail(""Should not be reachable"");
        return false;
    }

    void setHeadElement(Element headElement) {
        this.headElement = headElement;
    }

    Element getHeadElement() {
        return headElement;
    }

    boolean isFosterInserts() {
        return fosterInserts;
    }

    void setFosterInserts(boolean fosterInserts) {
        this.fosterInserts = fosterInserts;
    }

    FormElement getFormElement() {
        return formElement;
    }

    void setFormElement(FormElement formElement) {
        this.formElement = formElement;
    }

    void newPendingTableCharacters() {
        pendingTableCharacters = new ArrayList<>();
    }

    List<String> getPendingTableCharacters() {
        return pendingTableCharacters;
    }

    /**
     11.2.5.2 Closing elements that have implied end tags<p/>
     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a
     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,
     the UA must pop the current node off the stack of open elements.

     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the
     process, then the UA must perform the above steps as if that element was not in the above list.
","boolean inScope(String[] targetNames) {
    return inSpecificScope(targetNames, TagsSearchInScope, null);
}",0,0
264,Jsoup_87,"        final int bottom = stack.size() -1;
        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;
        // don't walk too far up the tree

        for (int pos = bottom; pos >= top; pos--) {
            final String elName = stack.get(pos).nodeName();
            if (inSorted(elName, targetNames))
                return true;
            if (inSorted(elName, baseTypes))
                return false;
            if (extraTypes != null && inSorted(elName, extraTypes))
                return false;
        }
","final int bottom = stack.size() - 1;
final int top = Math.max(bottom - MaxScopeSearchDepth, 0); // Don't go below 0

for (int pos = bottom; pos >= top; pos--) {
    String elName = stack.get(pos).nodeName();
    if (inSorted(elName, targetNames))
        return true;
    if (inSorted(elName, baseTypes))
        return false;
    if (extraTypes != null && inSorted(elName, extraTypes))
        return false;
}",0,0
264,Jsoup_87,"    private void clearStackToContext(String... nodeNames) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(""html""))
                break;
            else
                stack.remove(pos);
        }
    }
","private void clearStackToContext(String... nodeNames) {
    for (int pos = stack.size() - 1; pos >= 0; pos--) {
        Element next = stack.get(pos);
        if (StringUtil.in(next.nodeName(), nodeNames) || ""html"".equals(next.nodeName()))
            return;
        stack.remove(pos);
    }
}",0,0
264,Jsoup_87,"    void popStackToBefore(String elName) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (next.nodeName().equals(elName)) {
                break;
            } else {
                stack.remove(pos);
            }
        }
    }
","void popStackToBefore(String elName) {
    for (int pos = stack.size() - 1; pos >= 0; pos--) {
        Element next = stack.get(pos);
        stack.remove(pos);
        if (next.nodeName().equals(elName))
            break;
    }
}",0,0
264,Jsoup_87,"    void popStackToClose(String... elNames) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            stack.remove(pos);
            if (inSorted(next.nodeName(), elNames))
                break;
        }
    }
","void popStackToClose(String... elNames) {
    for (int pos = stack.size() - 1; pos >= 0; pos--) {
        Element next = stack.get(pos);
        stack.remove(pos);
        if (inSorted(next.nodeName(), elNames))
            break;
    }
}",0,0
264,Jsoup_87,"    void popStackToClose(String elName) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            stack.remove(pos);
            if (next.nodeName().equals(elName))
                break;
        }
    }
","void popStackToClose(String elName) {
    for (int pos = stack.size() - 1; pos >= 0; pos--) {
        Element next = stack.get(pos);
        stack.remove(pos);
        if (next.nodeName().equals(elName))
            break;
    }
}",0,0
264,Jsoup_87,"    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {
        for (int pos = queue.size() -1; pos >= 0; pos--) {
            Element next = queue.get(pos);
            if (next == element) {
                return true;
            }
        }
        return false;
    }
","private boolean isElementInQueue(ArrayList<Element> queue, Element element) {
    for (Element next : queue) {
        if (next == element) {
            return true;
        }
    }
    return false;
}",0,0
264,Jsoup_87,"    public Element tagName(String tagName) {
        Validate.notEmpty(tagName, ""Tag name must not be empty."");
        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); // maintains the case option of the original parse
        return this;
    }
","public Element tagName(String tagName) {
    Validate.notEmpty(tagName, ""Tag name must not be empty."");
    tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings());
    return this;
}",0,0
264,Jsoup_87,"    void generateImpliedEndTags() {
        generateImpliedEndTags(null);
    }
","void generateImpliedEndTags() {
    generateImpliedEndTags(null);
}",0,0
265,Jsoup_9,"        public Map<Character, String> getMap() {
            return map;
        }
","public Map<Character, String> getMap() {
    // Ensure the map is not null before returning it
    if (map == null) {
        return Collections.emptyMap();
    }
    return map;
}",0,0
266,Jsoup_91,"    public UncheckedIOException(IOException cause) {
        super(cause);
    }
","public UncheckedIOException(IOException cause) {
    super(cause == null ? new IOException(""Cause is null"") : cause);
}",0,0
266,Jsoup_91,"    public String consumeToAny(final char... chars) {
        bufferUp();
        int pos = bufPos;
        final int start = pos;
        final int remaining = bufLength;
        final char[] val = charBuf;
        final int charLen = chars.length;
        int i;

        OUTER: while (pos < remaining) {
            for (i = 0; i < charLen; i++) {
                if (val[pos] == chars[i])
                    break OUTER;
            }
            pos++;
        }

        bufPos = pos;
        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : """";
    }
","public String consumeToAny(final char... chars) {
    bufferUp();
    int pos = bufPos;
    final int start = pos;
    final int remaining = bufLength;
    final char[] val = charBuf;
    final int charLen = chars.length;
    int i;

    OUTER: while (pos < remaining) {
        for (i = 0; i < charLen; i++) {
            if (val[pos] == chars[i]) {
                break OUTER;
            }
        }
        pos++;
    }

    bufPos = pos;
    return (pos > start && pos <= remaining) ? cacheString(charBuf, stringCache, start, pos - start) : """";
}",0,0
266,Jsoup_91,"    public CharacterReader(Reader input, int sz) {
        Validate.notNull(input);
        Validate.isTrue(input.markSupported());
        reader = input;
        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];
        bufferUp();

    }
","public CharacterReader(Reader input, int sz) {
    Validate.notNull(input);
    Validate.isTrue(input.markSupported(), ""Reader must support mark()"");
    reader = input;
    charBuf = new char[Math.min(sz, maxBufferLen)];
    bufferUp();
}",0,0
267,Jsoup_92,"Element insert(Token.StartTag startTag) {
         Tag tag = Tag.valueOf(startTag.name(), settings);
         // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.
 
         Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));
         insertNode(el);
        if (startTag.isSelfClosing()) {
            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.
                tag.setSelfClosing();
        } else {
            stack.add(el);
        }
        return el;
    }","Element insert(Token.StartTag startTag) {
    Tag tag = Tag.valueOf(startTag.name(), settings);

    if (!settings.preserveAttributeCase()) {
        startTag.normalizeAttributesCase();
    }

    Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));
    insertNode(el);

    if (startTag.isSelfClosing()) {
        if (!tag.isKnownTag()) {
            tag.setSelfClosing();
        }
    } else {
        stack.add(el);
    }
    return el;
}",0,0
267,Jsoup_92,"final void newAttribute() {
            if (attributes == null)
                attributes = new Attributes();

            if (pendingAttributeName != null) {
                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here
                pendingAttributeName = pendingAttributeName.trim();
                if (pendingAttributeName.length() > 0) {
                    String value;
                    if (hasPendingAttributeValue)
                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;
                    else if (hasEmptyAttributeValue)
                        value = """";
                     else
                         value = null;
                     // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).
                     attributes.put(pendingAttributeName, value);
                 }
             }
             pendingAttributeName = null;
            hasEmptyAttributeValue = false;
            hasPendingAttributeValue = false;
            reset(pendingAttributeValue);
            pendingAttributeValueS = null;
        }","final void newAttribute() {
    if (attributes == null) {
        attributes = new Attributes();
    }

    if (pendingAttributeName != null) {
        pendingAttributeName = pendingAttributeName.trim();
        if (pendingAttributeName.length() > 0) {
            String value;
            if (hasPendingAttributeValue) {
                value = pendingAttributeValue != null && pendingAttributeValue.length() > 0
                        ? pendingAttributeValue.toString()
                        : pendingAttributeValueS;
            } else if (hasEmptyAttributeValue) {
                value = """";
            } else {
                value = null;
            }

            if (!attributes.hasKeyIgnoreCase(pendingAttributeName)) {
                attributes.put(pendingAttributeName, value);
            }
        }
    }

    pendingAttributeName = null;
    hasEmptyAttributeValue = false;
    hasPendingAttributeValue = false;
    reset(pendingAttributeValue);
    pendingAttributeValueS = null;
}",0,0
267,Jsoup_92,"Element insert(final Token.StartTag startTag) {
         // cleanup duplicate attributes:
 
         // handle empty unknown tags
         // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.
        if (startTag.isSelfClosing()) {
            Element el = insertEmpty(startTag);
            stack.add(el);
            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data
            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing
            return el;
        }

        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));
        insert(el);
        return el;
    }","Element insert(final Token.StartTag startTag) {
    if (startTag.isSelfClosing()) {
        Element el = insertEmpty(startTag);
        tokeniser.transition(TokeniserState.Data);
        tokeniser.emit(emptyEnd.reset().name(el.tagName()));
        return el;
    }

    if (!settings.preserveAttributeCase()) {
        startTag.normalizeAttributesCase();
    }

    Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));

    if (!el.attributes().deduplicate(settings)) {
        insertNode(el);
    }
    return el;
}",0,0
268,JxPath_1,"    public static boolean testNode(Node node, NodeTest test) {
        if (test == null) {
            return true;
        }
        else if (test instanceof NodeNameTest) {
            if (node.getNodeType() != Node.ELEMENT_NODE) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && testPrefix == null) {
                return true;
            }

            if (wildcard
                || testName.getName()
                        .equals(DOMNodePointer.getLocalName(node))) {
                String nodeNS = DOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS);
            }
        }
        else if (test instanceof NodeTypeTest) {
            int nodeType = node.getNodeType();
            switch (((NodeTypeTest) test).getNodeType()) {
                case Compiler.NODE_TYPE_NODE :
                    return nodeType == Node.ELEMENT_NODE;
                case Compiler.NODE_TYPE_TEXT :
                    return nodeType == Node.CDATA_SECTION_NODE
                        || nodeType == Node.TEXT_NODE;
                case Compiler.NODE_TYPE_COMMENT :
                    return nodeType == Node.COMMENT_NODE;
                case Compiler.NODE_TYPE_PI :
                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
            }
            return false;
        }
        else if (test instanceof ProcessingInstructionTest) {
            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
                String testPI = ((ProcessingInstructionTest) test).getTarget();
                String nodePI = ((ProcessingInstruction) node).getTarget();
                return testPI.equals(nodePI);
            }
        }
        return false;
    }
","public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    } else if (test instanceof NodeNameTest) {
        if (node == null || node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }

        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName != null ? testName.getPrefix() : null;
        if (wildcard && testPrefix == null) {
            return true;
        }

        if (wildcard || (testName != null && testName.getName().equals(DOMNodePointer.getLocalName(node)))) {
            String nodeNS = DOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS);
        }
    } else if (test instanceof NodeTypeTest) {
        if (node == null) {
            return false;
        }
        int nodeType = node.getNodeType();
        switch (((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return nodeType == Node.ELEMENT_NODE;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
            default:
                return false;
        }
    } else if (test instanceof ProcessingInstructionTest) {
        if (node != null && node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}",0,0
268,JxPath_1,"    public static boolean testNode(
        NodePointer pointer,
        Object node,
        NodeTest test) 
    {
        if (test == null) {
            return true;
        }
        else if (test instanceof NodeNameTest) {
            if (!(node instanceof Element)) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && testPrefix == null) {
                return true;
            }

            if (wildcard
                || testName.getName()
                        .equals(JDOMNodePointer.getLocalName(node))) {
                String nodeNS = JDOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS);
            }

        }
        else if (test instanceof NodeTypeTest) {
            switch (((NodeTypeTest) test).getNodeType()) {
                case Compiler.NODE_TYPE_NODE :
                    return node instanceof Element;
                case Compiler.NODE_TYPE_TEXT :
                    return (node instanceof Text) || (node instanceof CDATA);
                case Compiler.NODE_TYPE_COMMENT :
                    return node instanceof Comment;
                case Compiler.NODE_TYPE_PI :
                    return node instanceof ProcessingInstruction;
            }
            return false;
        }
        else if (test instanceof ProcessingInstructionTest) {
            if (node instanceof ProcessingInstruction) {
                String testPI = ((ProcessingInstructionTest) test).getTarget();
                String nodePI = ((ProcessingInstruction) node).getTarget();
                return testPI.equals(nodePI);
            }
        }

        return false;
    }
","public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {
    if (test == null) {
        return true;
    } else if (test instanceof NodeNameTest) {
        if (!(node instanceof Element)) {
            return false;
        }

        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName != null ? testName.getPrefix() : null;
        if (wildcard && testPrefix == null) {
            return true;
        }

        if (wildcard || (testName != null && testName.getName().equals(JDOMNodePointer.getLocalName(node)))) {
            String nodeNS = JDOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS);
        }
    } else if (test instanceof NodeTypeTest) {
        if (node == null) {
            return false;
        }
        switch (((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return node instanceof Element;
            case Compiler.NODE_TYPE_TEXT:
                return (node instanceof Text) || (node instanceof CDATA);
            case Compiler.NODE_TYPE_COMMENT:
                return node instanceof Comment;
            case Compiler.NODE_TYPE_PI:
                return node instanceof ProcessingInstruction;
            default:
                return false;
        }
    } else if (test instanceof ProcessingInstructionTest) {
        if (node instanceof ProcessingInstruction) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}",0,0
269,JxPath_11,"public boolean setPosition(int position) {
        if (attributes == null) {
            return false;
        }
        this.position = position;
        return position >= 1 && position <= attributes.size();
    }","public boolean setPosition(int position) {
    if (attributes == null || position < 1 || position > attributes.size()) {
        return false;
    }
    this.position = position;
    return true;
}",0,0
269,JxPath_11,"private Attr getAttribute(Element element, QName name) {
        String testPrefix = name.getPrefix();
         String testNS = null;
 
         if (testPrefix != null) {
             testNS = parent.getNamespaceURI(testPrefix);
         }
 
         if (testNS != null) {
            Attr attr = element.getAttributeNodeNS(testNS, name.getName());
            if (attr != null) {
                return attr;
            }

            // This may mean that the parser does not support NS for
            // attributes, example - the version of Crimson bundled
            // with JDK 1.4.0
            NamedNodeMap nnm = element.getAttributes();
            for (int i = 0; i < nnm.getLength(); i++) {
                attr = (Attr) nnm.item(i);
                if (testAttr(attr, name)) {
                    return attr;
                }
            }
            return null;
        }
        return element.getAttributeNode(name.getName());
    }","private Attr getAttribute(Element element, QName name) {
    String testPrefix = name.getPrefix();
    String testNS = null;

    if (testPrefix != null) {
        testNS = parent.getNamespaceURI(testPrefix);
    }

    if (testNS != null) {
        Attr attr = element.getAttributeNodeNS(testNS, name.getName());
        if (attr != null) {
            return attr;
        }

        // Check attributes without namespace
        NamedNodeMap nnm = element.getAttributes();
        for (int i = 0; i < nnm.getLength(); i++) {
            attr = (Attr) nnm.item(i);
            if (testAttr(attr, name)) {
                return attr;
            }
        }
    }

    // Fallback to searching without namespace if namespace lookup failed
    return element.getAttributeNode(name.getName());
}",0,0
270,JxPath_13,"public NodePointer createAttribute(JXPathContext context, QName name) {
        if (!(node instanceof Element)) {
            return super.createAttribute(context, name);
        }
         Element element = (Element) node;
         String prefix = name.getPrefix();
         if (prefix != null) {
             String ns = getNamespaceURI(prefix);
             if (ns == null) {
                 throw new JXPathException(
                     ""Unknown namespace prefix: "" + prefix);
            }
            element.setAttributeNS(ns, name.toString(), """");
        }
        else {
            if (!element.hasAttribute(name.getName())) {
                element.setAttribute(name.getName(), """");
            }
        }
        NodeIterator it = attributeIterator(name);
        it.setPosition(1);
        return it.getNodePointer();
    }","public NodePointer createAttribute(JXPathContext context, QName name) {
    if (!(node instanceof Element)) {
        return super.createAttribute(context, name);
    }
    Element element = (Element) node;
    String prefix = name.getPrefix();
    if (prefix != null && !prefix.isEmpty()) {
        String ns = getNamespaceURI(prefix);
        if (ns == null) {
            throw new JXPathException(""Unknown namespace prefix: "" + prefix);
        }
        element.setAttributeNS(ns, name.toString(), """");
    } else {
        if (!element.hasAttribute(name.getName())) {
            element.setAttribute(name.getName(), """");
        }
    }
    NodeIterator it = attributeIterator(name);
    it.setPosition(1);
    return it.getNodePointer();
}",0,0
270,JxPath_13,"public synchronized String getPrefix(String namespaceURI) {

    /**
     * Get the nearest prefix found that matches an externally-registered namespace. 
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
        if (reverseMap == null) {
            reverseMap = new HashMap();
            NodeIterator ni = pointer.namespaceIterator();
            if (ni != null) {
                for (int position = 1; ni.setPosition(position); position++) {
                    NodePointer nsPointer = ni.getNodePointer();
                    String uri = nsPointer.getNamespaceURI();                    
                    String prefix = nsPointer.getName().getName();
                    if (!"""".equals(prefix)) {
                        reverseMap.put(uri, prefix);
                    }
                }
            }
            Iterator it = namespaceMap.entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry entry = (Map.Entry) it.next();
                reverseMap.put(entry.getValue(), entry.getKey());
             }
         }
         String prefix = (String) reverseMap.get(namespaceURI);
         if (prefix == null && parent != null) {
             return parent.getPrefix(namespaceURI);
         }
         return prefix;
     }","public synchronized String getPrefix(String namespaceURI) {
    if (reverseMap == null) {
        reverseMap = new HashMap<>();
        NodeIterator ni = pointer.namespaceIterator();
        if (ni != null) {
            for (int position = 1; ni.setPosition(position); position++) {
                NodePointer nsPointer = ni.getNodePointer();
                String uri = nsPointer.getNamespaceURI();
                String prefix = nsPointer.getName().getName();
                if (uri != null && !uri.isEmpty() && !"""".equals(prefix)) {
                    reverseMap.put(uri, prefix);
                }
            }
        }
        Iterator<Map.Entry<String, String>> it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, String> entry = it.next();
            if (entry.getKey() != null && entry.getValue() != null) {
                reverseMap.put(entry.getValue(), entry.getKey());
            }
        }
    }
    String prefix = reverseMap.get(namespaceURI);
    if (prefix == null && parent != null) {
        return parent.getPrefix(namespaceURI);
    }
    return prefix;
}",0,0
271,JxPath_14,"    protected Object functionFloor(EvalContext context) {
        assertArgCount(1);
        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
        return new Double(Math.floor(v));
    }
","protected Object functionFloor(EvalContext context) {
    assertArgCount(1);
    Object value = getArg1().computeValue(context);
    
    if (value == null) {
        return Double.NaN; // Return NaN for null values
    }

    double v = InfoSetUtil.doubleValue(value);

    if (Double.isNaN(v) || Double.isInfinite(v)) {
        return v; // Handle NaN and Infinity cases correctly
    }

    return Math.floor(v);
}",0,0
272,JxPath_15,"public boolean setPosition(int position) {
        if (!prepared) {
            prepared = true;
            BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();
            ArrayList pointers = new ArrayList();
            for (int i = 0; i < contexts.length; i++) {
                EvalContext ctx = (EvalContext) contexts[i];
                while (ctx.nextSet()) {
                    while (ctx.nextNode()) {
                        NodePointer ptr = ctx.getCurrentNodePointer();
                        if (!pointers.contains(ptr)) {
                            nodeSet.add(ptr);
                            pointers.add(ptr);
                        }
                    }
                }
            }
        }
        return super.setPosition(position);
    }
}","public boolean setPosition(int position) {
    if (!prepared) {
        prepared = true;
        BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();
        ArrayList<NodePointer> pointers = new ArrayList<>();
        for (int i = 0; i < contexts.length; i++) {
            EvalContext ctx = (EvalContext) contexts[i];
            while (ctx.nextSet()) {
                while (ctx.nextNode()) {
                    NodePointer ptr = ctx.getCurrentNodePointer();
                    if (!pointers.contains(ptr)) { // Ensure no duplicate pointers
                        nodeSet.add(ptr);
                        pointers.add(ptr);
                    }
                }
            }
        }
    }
    return super.setPosition(position);
}",0,0
273,JxPath_16,"public static boolean testNode(
        NodePointer pointer,
        Object node,
        NodeTest test)
    {
        if (test == null) {
            return true;
        }
        if (test instanceof NodeNameTest) {
            if (!(node instanceof Element)) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && testPrefix == null) {
                return true;
            }
            if (wildcard
                || testName.getName()
                        .equals(JDOMNodePointer.getLocalName(node))) {
                String nodeNS = JDOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS) || nodeNS == null
                        && equalStrings(testPrefix, getPrefix(node));
            }
            return false;
        }
         if (test instanceof NodeTypeTest) {
             switch (((NodeTypeTest) test).getNodeType()) {
                 case Compiler.NODE_TYPE_NODE :
                     return (node instanceof Element) || (node instanceof Document);
                 case Compiler.NODE_TYPE_TEXT :
                     return (node instanceof Text) || (node instanceof CDATA);
                 case Compiler.NODE_TYPE_COMMENT :
                    return node instanceof Comment;
                case Compiler.NODE_TYPE_PI :
                    return node instanceof ProcessingInstruction;
            }
            return false;
        }
        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
        return false;
    }","public static boolean testNode(
        NodePointer pointer,
        Object node,
        NodeTest test)
    {
        if (test == null) {
            return true;
        }
        if (test instanceof NodeNameTest) {
            if (!(node instanceof Element)) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && (testPrefix == null || testPrefix.isEmpty())) {
                return true;
            }
            if (wildcard
                || testName.getName()
                        .equals(JDOMNodePointer.getLocalName(node))) {
                String nodeNS = JDOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS) || (nodeNS == null
                        && equalStrings(testPrefix, getPrefix(node)));
            }
            return false;
        }
        if (test instanceof NodeTypeTest) {
            int nodeType = getNodeType(node);
            switch (((NodeTypeTest) test).getNodeType()) {
                case Compiler.NODE_TYPE_NODE:
                    return (nodeType == Element.ELEMENT_NODE) || (nodeType == Document.DOCUMENT_NODE);
                case Compiler.NODE_TYPE_TEXT:
                    return (nodeType == Text.TEXT_NODE) || (nodeType == CDATA.CDATA_SECTION_NODE);
                case Compiler.NODE_TYPE_COMMENT:
                    return nodeType == Comment.COMMENT_NODE;
                case Compiler.NODE_TYPE_PI:
                    return nodeType == ProcessingInstruction.PROCESSING_INSTRUCTION_NODE;
            }
            return false;
        }
        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
        return false;
    }",0,0
273,JxPath_16,"public static boolean testNode(Node node, NodeTest test) {
        if (test == null) {
            return true;
        }
        if (test instanceof NodeNameTest) {
            if (node.getNodeType() != Node.ELEMENT_NODE) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && testPrefix == null) {
                return true;
            }
            if (wildcard
                || testName.getName()
                        .equals(DOMNodePointer.getLocalName(node))) {
                String nodeNS = DOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS) || nodeNS == null
                        && equalStrings(testPrefix, getPrefix(node));
            }
            return false;
        }
        if (test instanceof NodeTypeTest) {
             int nodeType = node.getNodeType();
             switch (((NodeTypeTest) test).getNodeType()) {
                 case Compiler.NODE_TYPE_NODE :
                     return nodeType == Node.ELEMENT_NODE
                             || nodeType == Node.DOCUMENT_NODE;
                 case Compiler.NODE_TYPE_TEXT :
                     return nodeType == Node.CDATA_SECTION_NODE
                         || nodeType == Node.TEXT_NODE;
                case Compiler.NODE_TYPE_COMMENT :
                    return nodeType == Node.COMMENT_NODE;
                case Compiler.NODE_TYPE_PI :
                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
            }
            return false;
        }
        if (test instanceof ProcessingInstructionTest) {
            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
                String testPI = ((ProcessingInstructionTest) test).getTarget();
                String nodePI = ((ProcessingInstruction) node).getTarget();
                return testPI.equals(nodePI);
            }
        }
        return false;
    }","public static boolean testNode(Node node, NodeTest test) {
        if (test == null) {
            return true;
        }
        if (test instanceof NodeNameTest) {
            if (node.getNodeType() != Node.ELEMENT_NODE) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && (testPrefix == null || testPrefix.isEmpty())) {
                return true;
            }
            if (wildcard
                || testName.getName()
                        .equals(DOMNodePointer.getLocalName(node))) {
                String nodeNS = DOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS) || (nodeNS == null
                        && equalStrings(testPrefix, getPrefix(node)));
            }
            return false;
        }
        if (test instanceof NodeTypeTest) {
            int nodeType = node.getNodeType();
            switch (((NodeTypeTest) test).getNodeType()) {
                case Compiler.NODE_TYPE_NODE:
                    return nodeType == Node.ELEMENT_NODE
                            || nodeType == Node.DOCUMENT_NODE;
                case Compiler.NODE_TYPE_TEXT:
                    return nodeType == Node.CDATA_SECTION_NODE
                            || nodeType == Node.TEXT_NODE;
                case Compiler.NODE_TYPE_COMMENT:
                    return nodeType == Node.COMMENT_NODE;
                case Compiler.NODE_TYPE_PI:
                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
            }
            return false;
        }
        if (test instanceof ProcessingInstructionTest) {
            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
                String testPI = ((ProcessingInstructionTest) test).getTarget();
                String nodePI = ((ProcessingInstruction) node).getTarget();
                return testPI.equals(nodePI);
            }
        }
        return false;
    }",0,0
274,JxPath_17,"public boolean setPosition(int position) {
        this.position = position;
        return position >= 1 && position <= attributes.size();
    }","public boolean setPosition(int position) {
    if (attributes == null || attributes.isEmpty()) {
        return false;
    }
    this.position = position;
    return position >= 1 && position <= attributes.size();
}",0,0
274,JxPath_17,"public boolean setPosition(int position) {
        if (attributes == null) {
            return false;
        }
        this.position = position;
        return position >= 1 && position <= attributes.size();
    }","public boolean setPosition(int position) {
    if (attributes == null || attributes.isEmpty()) {
        return false;
    }
    if (position < 1 || position > attributes.size()) {
        return false;
    }
    this.position = position;
    return true;
}",0,0
274,JxPath_17,"private boolean testAttr(Attr attr) {
        String nodePrefix = DOMNodePointer.getPrefix(attr);
        String nodeLocalName = DOMNodePointer.getLocalName(attr);

        if (nodePrefix != null && nodePrefix.equals(""xmlns"")) {
            return false;
        }

        if (nodePrefix == null && nodeLocalName.equals(""xmlns"")) {
            return false;
        }

        String testLocalName = name.getName();
         if (testLocalName.equals(""*"") || testLocalName.equals(nodeLocalName)) {
             String testPrefix = name.getPrefix();
 
             if (equalStrings(testPrefix, nodePrefix)) {
                 return true;
             }
             String testNS = null;
             if (testPrefix != null) {
                 testNS = parent.getNamespaceURI(testPrefix);
             }
             String nodeNS = null;
             if (nodePrefix != null) {
                 nodeNS = parent.getNamespaceURI(nodePrefix);
             }
             return equalStrings(testNS, nodeNS);
         }
         return false;
     }","private boolean testAttr(Attr attr) {
    String nodePrefix = DOMNodePointer.getPrefix(attr);
    String nodeLocalName = DOMNodePointer.getLocalName(attr);

    if (""xmlns"".equals(nodePrefix) || (""xmlns"".equals(nodeLocalName) && nodePrefix == null)) {
        return false;
    }

    String testLocalName = name.getName();
    if (testLocalName.equals(""*"") || testLocalName.equals(nodeLocalName)) {
        String testPrefix = name.getPrefix();
        if (equalStrings(testPrefix, nodePrefix)) {
            return true;
        }

        String testNS = null;
        if (testPrefix != null) {
            testNS = parent.getNamespaceURI(testPrefix);
        }

        String nodeNS = null;
        if (nodePrefix != null) {
            nodeNS = parent.getNamespaceURI(nodePrefix);
        }

        return equalStrings(testNS, nodeNS);
    }
    return false;
}",0,0
275,JxPath_18,"public boolean nextNode() {
        super.setPosition(getCurrentPosition() + 1);
        if (!setStarted) {
            setStarted = true;
            if (!(nodeTest instanceof NodeNameTest)) {
                return false;
            }
            QName name = ((NodeNameTest) nodeTest).getNodeName();
            iterator =
                parentContext.getCurrentNodePointer().attributeIterator(name);
        }
        if (iterator == null) {
            return false;
        }
        if (!iterator.setPosition(iterator.getPosition() + 1)) {
            return false;
        }
        currentNodePointer = iterator.getNodePointer();
        return true;
    }","public boolean nextNode() {
    super.setPosition(getCurrentPosition() + 1);
    if (!setStarted) {
        setStarted = true;
        if (!(nodeTest instanceof NodeNameTest)) {
            return false;
        }
        QName name = ((NodeNameTest) nodeTest).getNodeName();
        iterator = parentContext.getCurrentNodePointer() != null
                ? parentContext.getCurrentNodePointer().attributeIterator(name)
                : null;
    }
    if (iterator == null || !iterator.setPosition(iterator.getPosition() + 1)) {
        currentNodePointer = null; // Reset currentNodePointer if no valid iterator position exists
        return false;
    }
    currentNodePointer = iterator.getNodePointer();
    return currentNodePointer != null; // Ensure there is a valid current node pointer
}",0,0
276,JxPath_19,"private int getRelativePositionByQName() {
        if (node instanceof Element) {
            Object parent = ((Element) node).getParent();
            if (!(parent instanceof Element)) {
                return 1;
            }

            List children = ((Element) parent).getContent();
            int count = 0;
             String name = ((Element) node).getQualifiedName();
             for (int i = 0; i < children.size(); i++) {
                 Object child = children.get(i);
                 if ((child instanceof Element)
                     && ((Element) child).getQualifiedName().equals(name)) {
                     count++;
                 }
                 if (child == node) {
                    break;
                }
            }
            return count;
        }
        return 1;
    }","private int getRelativePositionByQName() {
    if (node instanceof Element) {
        Object parent = ((Element) node).getParent();

        // Ensure parent is an Element
        if (!(parent instanceof Element)) {
            return 1;
        }

        List children = ((Element) parent).getContent();
        int count = 0;
        String name = ((Element) node).getQualifiedName();

        // Iterate through children and count matches
        for (int i = 0; i < children.size(); i++) {
            Object child = children.get(i);

            if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {
                count++;
            }

            // Stop counting if the current child is the node we are considering
            if (child == node) {
                break;
            }
        }

        return count;
    }

    // Default return if node is not an Element
    return 1;
}",0,0
277,JxPath_2,"public Iterator iteratePointers(EvalContext context) {
        Object result = compute(context);
        if (result == null) {
            return Collections.EMPTY_LIST.iterator();
        }
         if (result instanceof EvalContext) {
             return (EvalContext) result;
         }
         return new PointerIterator(ValueUtils.iterate(result),
                 new QName(null, ""value""),
                 context.getRootContext().getCurrentNodePointer().getLocale());
    }","public Iterator iteratePointers(EvalContext context) {
    Object result = compute(context);
    if (result == null) {
        return Collections.EMPTY_LIST.iterator();
    }
    if (result instanceof EvalContext) {
        return ((EvalContext) result).iteratePointers();
    }
    return new PointerIterator(ValueUtils.iterate(result),
            new QName(null, ""value""),
            context.getRootContext().getCurrentNodePointer().getLocale());
}",0,0
277,JxPath_2,"public Iterator iterate(EvalContext context) {
        Object result = compute(context);
         if (result instanceof EvalContext) {
             return new ValueIterator((EvalContext) result);
         }
         return ValueUtils.iterate(result);
     }","public Iterator iterate(EvalContext context) {
    Object result = compute(context);
    if (result == null) {
        return Collections.EMPTY_LIST.iterator();
    }
    if (result instanceof EvalContext) {
        return new ValueIterator(((EvalContext) result).iteratePointers());
    }
    return ValueUtils.iterate(result);
}",0,0
278,JxPath_20,"private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
             return containsMatch((Iterator) left, right);
         }
         if (right instanceof Iterator) {
             return containsMatch((Iterator) right, left);
         }
         double ld = InfoSetUtil.doubleValue(left);
         if (Double.isNaN(ld)) {
            return false;
        }
        double rd = InfoSetUtil.doubleValue(right);
        if (Double.isNaN(rd)) {
            return false;
        }
        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);
    }","private boolean compute(Object left, Object right) {
    left = reduce(left);
    right = reduce(right);

    if (left instanceof InitialContext) {
        ((InitialContext) left).reset();
    }
    if (right instanceof InitialContext) {
        ((InitialContext) right).reset();
    }
    if (left instanceof Iterator && right instanceof Iterator) {
        return findMatch((Iterator) left, (Iterator) right);
    }
    if (left instanceof Iterator) {
        return containsMatch((Iterator) left, right);
    }
    if (right instanceof Iterator) {
        return containsMatch((Iterator) right, left);
    }
    double ld = InfoSetUtil.doubleValue(left);
    if (Double.isNaN(ld)) {
        return false;
    }
    double rd = InfoSetUtil.doubleValue(right);
    if (Double.isNaN(rd)) {
        return false;
    }
    return evaluateCompare(Double.compare(ld, rd));
}",0,0
279,JxPath_3,"public NodePointer createPath(JXPathContext context, Object value) {
        NodePointer newParent = parent.createPath(context);
        if (isAttribute()) {
            NodePointer pointer = newParent.createAttribute(context, getName());
            pointer.setValue(value);
             return pointer;
         }
         else {
             if (newParent instanceof PropertyOwnerPointer) {
                 PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
                 newParent = pop.getPropertyPointer();
            }
            return newParent.createChild(context, getName(), index, value);
        }
    }","public NodePointer createPath(JXPathContext context, Object value) {
    NodePointer newParent = parent.createPath(context);
    if (newParent == null) {
        throw new IllegalStateException(""Parent path could not be created."");
    }
    if (isAttribute()) {
        NodePointer pointer = newParent.createAttribute(context, getName());
        if (pointer != null) {
            pointer.setValue(value);
        }
        return pointer;
    } else {
        if (newParent instanceof PropertyOwnerPointer) {
            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
            newParent = pop.getPropertyPointer();
        }
        return newParent.createChild(context, getName(), index, value);
    }
}",0,0
279,JxPath_3,"public NodePointer createPath(JXPathContext context) {
        NodePointer newParent = parent.createPath(context);
        if (isAttribute()) {
             return newParent.createAttribute(context, getName());
         }
         else {
             // Consider these two use cases:
             // 1. The parent pointer of NullPropertyPointer is 
             //    a PropertyOwnerPointer other than NullPointer. When we call 
            //    createPath on it, it most likely returns itself. We then
            //    take a PropertyPointer from it and get the PropertyPointer
            //    to expand the collection for the corresponding property.
            //
            // 2. The parent pointer of NullPropertyPointer is a NullPointer.
            //    When we call createPath, it may return a PropertyOwnerPointer
            //    or it may return anything else, like a DOMNodePointer.
            //    In the former case we need to do exactly what we did in use 
            //    case 1.  In the latter case, we simply request that the 
            //    non-property pointer expand the collection by itself.
            if (newParent instanceof PropertyOwnerPointer) {
                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
                newParent = pop.getPropertyPointer();
            }
            return newParent.createChild(context, getName(), getIndex());
        }
    }","public NodePointer createPath(JXPathContext context) {
    NodePointer newParent = parent.createPath(context);
    if (newParent == null) {
        throw new IllegalStateException(""Parent path could not be created."");
    }
    if (isAttribute()) {
        return newParent.createAttribute(context, getName());
    } else {
        if (newParent instanceof PropertyOwnerPointer) {
            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
            newParent = pop.getPropertyPointer();
        }
        return newParent.createChild(context, getName(), getIndex());
    }
}",0,0
280,JxPath_4,"public Object getValue() {
         if (node instanceof Element) {
             return ((Element) node).getTextTrim();
         }
         if (node instanceof Comment) {
             String text = ((Comment) node).getText();
            if (text != null) {
                text = text.trim();
            }
            return text;
        }
        if (node instanceof Text) {
            return ((Text) node).getTextTrim();
        }
        if (node instanceof CDATA) {
            return ((CDATA) node).getTextTrim();
        }
        if (node instanceof ProcessingInstruction) {
            String text = ((ProcessingInstruction) node).getData();
            if (text != null) {
                text = text.trim();
            }
            return text;
        }
        return null;
    }","public Object getValue() {
    if (node == null) {
        return null;
    }
    if (node instanceof Element) {
        return ((Element) node).getTextTrim();
    }
    if (node instanceof Comment) {
        String text = ((Comment) node).getText();
        return (text != null) ? text.trim() : null;
    }
    if (node instanceof Text) {
        return ((Text) node).getTextTrim();
    }
    if (node instanceof CDATA) {
        return ((CDATA) node).getTextTrim();
    }
    if (node instanceof ProcessingInstruction) {
        String text = ((ProcessingInstruction) node).getData();
        return (text != null) ? text.trim() : null;
    }
    return null;
}",0,0
281,JxPath_7,"    public CoreOperationGreaterThanOrEqual(Expression arg1, Expression arg2) {
        super(new Expression[] { arg1, arg2 });
    }
","public CoreOperationGreaterThanOrEqual(Expression arg1, Expression arg2) {
    super(new Expression[] { arg1, arg2 });
    setRelationalOperator("">="");
}",0,0
281,JxPath_7,"    public CoreOperationLessThan(Expression arg1, Expression arg2) {
        super(new Expression[] { arg1, arg2 });
    }
","public CoreOperationLessThan(Expression arg1, Expression arg2) {
    super(new Expression[] { arg1, arg2 });
    setRelationalOperator(""<"");
}",0,0
281,JxPath_7,"    public CoreOperationLessThanOrEqual(Expression arg1, Expression arg2) {
        super(new Expression[] { arg1, arg2 });
    }
","public CoreOperationLessThanOrEqual(Expression arg1, Expression arg2) {
    super(new Expression[] { arg1, arg2 });
    setRelationalOperator(""<="");
}",0,0
281,JxPath_7,"    protected CoreOperationRelationalExpression(Expression[] args) {
        super(args);
    }
","protected CoreOperationRelationalExpression(Expression[] args) {
    super(args);
    validateArguments(args);
}",0,0
281,JxPath_7,"    protected final boolean isSymmetric() {
        return false;
    }
","protected final boolean isSymmetric() {
    // Symmetry depends on relational operator type, fixed implementation
    return getRelationalOperator().equals(""="");
}",0,0
281,JxPath_7,"    public CoreOperationGreaterThan(Expression arg1, Expression arg2) {
        super(new Expression[] { arg1, arg2 });
    }
","public CoreOperationGreaterThan(Expression arg1, Expression arg2) {
    super(new Expression[] { arg1, arg2 });
    setRelationalOperator("">"");
}",0,0
282,JxPath_9,"protected boolean equal(Object l, Object r) {
        if (l instanceof Pointer && r instanceof Pointer) {
            if (l.equals(r)) {
                return true;
            }
        }
        if (l instanceof Pointer) {
            l = ((Pointer) l).getValue();
        }

        if (r instanceof Pointer) {
             r = ((Pointer) r).getValue();
         }
 
         if (l == r) {
             return true;
         }
         if (l instanceof Boolean || r instanceof Boolean) {
             return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));
             }
             //if either side is NaN, no comparison returns true:
         if (l instanceof Number || r instanceof Number) {
             return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));
             }
             if (l instanceof String || r instanceof String) {
             return (
                 InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));
         }
         return l != null && l.equals(r);
     }","protected boolean equal(Object l, Object r) {
    if (l instanceof Pointer && r instanceof Pointer) {
        if (l.equals(r)) {
            return true;
        }
    }
    if (l instanceof Pointer) {
        l = ((Pointer) l).getValue();
    }

    if (r instanceof Pointer) {
        r = ((Pointer) r).getValue();
    }

    // Check for NaN condition
    if (l instanceof Number && r instanceof Number) {
        double lValue = InfoSetUtil.doubleValue(l);
        double rValue = InfoSetUtil.doubleValue(r);
        if (Double.isNaN(lValue) || Double.isNaN(rValue)) {
            return false;
        }
    }

    if (l == r) {
        return true;
    }
    if (l instanceof Boolean || r instanceof Boolean) {
        return InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r);
    }
    if (l instanceof Number || r instanceof Number) {
        return InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r);
    }
    if (l instanceof String || r instanceof String) {
        return InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r));
    }
    return l != null && l.equals(r);
}",0,0
283,Lang_13,"@Override
        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
            String name = desc.getName();
             try {
                 return Class.forName(name, false, classLoader);
             } catch (ClassNotFoundException ex) {
                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
             }
         }","@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
    String name = desc.getName();
    try {
        if (classLoader != null) {
            return Class.forName(name, false, classLoader);
        } else {
            return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
        }
    } catch (ClassNotFoundException ex) {
        return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
    }
}",0,0
284,Lang_15,"private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass,
            Map<TypeVariable<?>, Type> subtypeVarAssigns) {
        // make sure they're assignable
        if (!isAssignable(cls, toClass)) {
            return null;
        }

        // can't work with primitives
        if (cls.isPrimitive()) {
            // both classes are primitives?
            if (toClass.isPrimitive()) {
                // dealing with widening here. No type arguments to be
                // harvested with these two types.
                return new HashMap<TypeVariable<?>, Type>();
            }

            // work with wrapper the wrapper class instead of the primitive
            cls = ClassUtils.primitiveToWrapper(cls);
        }

        // create a copy of the incoming map, or an empty one if it's null
        HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()
                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
 
         // has target class been reached?
         if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {
             return typeVarAssigns;
         }
 
        // walk the inheritance hierarchy until the target class is reached
        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);
    }","private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass,
        Map<TypeVariable<?>, Type> subtypeVarAssigns) {
    // make sure they're assignable
    if (!ClassUtils.isAssignable(cls, toClass)) {
        return null;
    }

    // can't work with primitives
    if (cls.isPrimitive()) {
        // both classes are primitives?
        if (toClass.isPrimitive()) {
            // dealing with widening here. No type arguments to be harvested with these two types.
            return new HashMap<TypeVariable<?>, Type>();
        }

        // work with wrapper class instead of the primitive
        cls = ClassUtils.primitiveToWrapper(cls);
    }

    // create a copy of the incoming map, or an empty one if it's null
    HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null 
        ? new HashMap<TypeVariable<?>, Type>() 
        : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);

    // has target class been reached?
    if (cls.getTypeParameters().length > 0 || cls.equals(toClass)) {
        return typeVarAssigns;
    }

    // walk the inheritance hierarchy until the target class is reached
    Type closestParentType = getClosestParentType(cls, toClass);
    if (closestParentType == null) {
        return null;
    }
    return getTypeArguments(closestParentType, toClass, typeVarAssigns);
}",0,0
284,Lang_15,"private static boolean isAssignable(Type type, ParameterizedType toParameterizedType,
            Map<TypeVariable<?>, Type> typeVarAssigns) {
        if (type == null) {
            return true;
        }

        // only a null type can be assigned to null type which
        // would have cause the previous to return true
        if (toParameterizedType == null) {
            return false;
        }

        // all types are assignable to themselves
        if (toParameterizedType.equals(type)) {
            return true;
        }

        // get the target type's raw type
        Class<?> toClass = getRawType(toParameterizedType);
        // get the subject type's type arguments including owner type arguments
        // and supertype arguments up to and including the target class.
        Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);

        // null means the two types are not compatible
        if (fromTypeVarAssigns == null) {
            return false;
        }

        // compatible types, but there's no type arguments. this is equivalent
        // to comparing Map< ?, ? > to Map, and raw types are always assignable
        // to parameterized types.
        if (fromTypeVarAssigns.isEmpty()) {
            return true;
        }

        // get the target type's type arguments including owner type arguments
        Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,
                 toClass, typeVarAssigns);
 
         // now to check each type argument
         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {
             Type toTypeArg = entry.getValue();
             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
 
             // parameters must either be absent from the subject type, within
             // the bounds of the wildcard type, or be an exact match to the
            // parameters of the target type.
            if (fromTypeArg != null
                    && !toTypeArg.equals(fromTypeArg)
                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,
                            typeVarAssigns))) {
                return false;
            }
        }

        return true;
    }","private static boolean isAssignable(Type type, ParameterizedType toParameterizedType,
        Map<TypeVariable<?>, Type> typeVarAssigns) {
    if (type == null) {
        return true;
    }

    // only a null type can be assigned to null type
    if (toParameterizedType == null) {
        return false;
    }

    // all types are assignable to themselves
    if (type.equals(toParameterizedType)) {
        return true;
    }

    // get the target type's raw type
    Class<?> toClass = getRawType(toParameterizedType);

    // get the subject type's type arguments, including owner type arguments
    // and supertype arguments up to and including the target class.
    Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);

    // null means the two types are not compatible
    if (fromTypeVarAssigns == null) {
        return false;
    }

    // get the target type's type arguments, including owner type arguments
    Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns);

    if (toTypeVarAssigns == null) {
        return false;
    }

    // now check each type argument
    for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {
        Type toTypeArg = entry.getValue();
        Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());

        // parameters must either be absent from the subject type, 
        // within the bounds of the wildcard type, 
        // or match exactly to the parameters of the target type.
        if (fromTypeArg != null
                && !toTypeArg.equals(fromTypeArg)
                && !(toTypeArg instanceof WildcardType 
                    && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) {
            return false;
        }
    }

    return true;
}",0,0
285,Lang_20,"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
        if (array == null) {
            return null;
        }
        if (separator == null) {
            separator = EMPTY;
        }

        // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
        //           (Assuming that all Strings are roughly equally long)
        int noOfItems = (endIndex - startIndex);
        if (noOfItems <= 0) {
             return EMPTY;
         }
 
         StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
                buf.append(separator);
            }
            if (array[i] != null) {
                buf.append(array[i]);
            }
        }
        return buf.toString();
    }","public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = """";
    }

    // Validate indices to avoid ArrayIndexOutOfBoundsException
    if (startIndex < 0) {
        startIndex = 0;
    }
    if (endIndex > array.length) {
        endIndex = array.length;
    }
    if (startIndex >= endIndex) {
        return """";
    }

    StringBuilder buf = new StringBuilder();
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}",0,0
285,Lang_20,"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
        if (array == null) {
            return null;
        }
        int noOfItems = (endIndex - startIndex);
        if (noOfItems <= 0) {
             return EMPTY;
         }
         
         StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
                buf.append(separator);
            }
            if (array[i] != null) {
                buf.append(array[i]);
            }
        }
        return buf.toString();
    }","public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }

    // Validate indices to avoid ArrayIndexOutOfBoundsException
    if (startIndex < 0) {
        startIndex = 0;
    }
    if (endIndex > array.length) {
        endIndex = array.length;
    }
    if (startIndex >= endIndex) {
        return """";
    }

    StringBuilder buf = new StringBuilder();
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}",0,0
286,Lang_23,"    public ExtendedMessageFormat(String pattern) {
        this(pattern, Locale.getDefault());
    }
","public ExtendedMessageFormat(String pattern) {
    if (pattern == null) {
        throw new IllegalArgumentException(""The pattern must not be null"");
    }
    this(pattern, Locale.getDefault());
}",0,0
286,Lang_23,"    private Format getFormat(String desc) {
        if (registry != null) {
            String name = desc;
            String args = null;
            int i = desc.indexOf(START_FMT);
            if (i > 0) {
                name = desc.substring(0, i).trim();
                args = desc.substring(i + 1).trim();
            }
            FormatFactory factory = registry.get(name);
            if (factory != null) {
                return factory.getFormat(name, args, getLocale());
            }
        }
        return null;
    }
","private Format getFormat(String desc) {
    if (desc == null || desc.trim().isEmpty()) {
        return null;
    }
    if (registry != null) {
        String name = desc;
        String args = null;
        int i = desc.indexOf(START_FMT);
        if (i > 0) {
            name = desc.substring(0, i).trim();
            args = desc.substring(i + 1, desc.length()).trim();
        }
        FormatFactory factory = registry.get(name);
        if (factory != null) {
            return factory.getFormat(name, args, getLocale());
        }
    }
    return null;
}",0,0
287,Lang_30,"public static boolean containsNone(CharSequence cs, char[] searchChars) {
        if (cs == null || searchChars == null) {
             return true;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                             // missing low surrogate, fine, like String.indexOf(String)
                         // ch is in the Basic Multilingual Plane
                         return false;
                 }
             }
         }
        return true;
    }","public static boolean containsNone(CharSequence cs, char[] searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch) && (i + 1) < csLen
                        && Character.isLowSurrogate(cs.charAt(i + 1))) {
                    continue; // skip supplementary character
                }
                return false;
            }
        }
    }
    return true;
}",0,0
287,Lang_30,"public static int indexOfAnyBut(String str, String searchChars) {
        if (isEmpty(str) || isEmpty(searchChars)) {
            return INDEX_NOT_FOUND;
        }
         int strLen = str.length();
         for (int i = 0; i < strLen; i++) {
             char ch = str.charAt(i);
             if (searchChars.indexOf(ch) < 0) {
                     return i;
             }
         }
         return INDEX_NOT_FOUND;
    }","public static int indexOfAnyBut(String str, String searchChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = str.length();
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (searchChars.indexOf(ch) < 0) {
            if (Character.isHighSurrogate(ch) && (i + 1) < strLen
                    && Character.isLowSurrogate(str.charAt(i + 1))) {
                i++; // skip low surrogate
            }
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}",0,0
287,Lang_30,"public static int indexOfAny(CharSequence cs, char[] searchChars) {
        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                         // ch is a supplementary character
                         return i;
                 }
             }
         }
        return INDEX_NOT_FOUND;
    }","public static int indexOfAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch) && (i + 1) < csLen
                        && Character.isLowSurrogate(cs.charAt(i + 1))) {
                    continue; // supplementary character match skipped
                }
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}",0,0
287,Lang_30,"public static boolean containsAny(CharSequence cs, char[] searchChars) {
        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
            return false;
        }
        int csLength = cs.length();
        int searchLength = searchChars.length;
        int csLast = csLength - 1;
        int searchLast = searchLength - 1;
        for (int i = 0; i < csLength; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLength; j++) {
                 if (searchChars[j] == ch) {
                     if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                             // missing low surrogate, fine, like String.indexOf(String)
                         if (searchChars[j + 1] == cs.charAt(i + 1)) {
                             return true;
                         }
                     } else {
                        // ch is in the Basic Multilingual Plane
                        return true;
                    }
                }
            }
        }
        return false;
    }","public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch) && (i + 1) < csLength
                        && Character.isLowSurrogate(cs.charAt(i + 1))) {
                    if (j + 1 < searchLength && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true; // match supplementary character pair
                    }
                } else {
                    return true;
                }
            }
        }
    }
    return false;
}",0,0
287,Lang_30,"public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         outer:
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                         continue outer;
                 }
             }
             return i;
        }
        return INDEX_NOT_FOUND;
    }","public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    outer:
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch) && (i + 1) < csLen
                        && Character.isLowSurrogate(cs.charAt(i + 1))) {
                    i++; // skip low surrogate
                }
                continue outer;
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}",0,0
288,Lang_32,"static void register(Object value) {
         getRegistry().add(new IDKey(value));
     }","static void register(Object value) {
    if (value != null) {
        getRegistry().add(new IDKey(value));
    }
}",0,0
288,Lang_32,"static boolean isRegistered(Object value) {
         return getRegistry().contains(new IDKey(value));
     }","static boolean isRegistered(Object value) {
    return value != null && getRegistry().contains(new IDKey(value));
}",0,0
288,Lang_32,"static void unregister(Object value) {
         getRegistry().remove(new IDKey(value));
     }","static void unregister(Object value) {
    if (value != null) {
        getRegistry().remove(new IDKey(value));
    }
}",0,0
289,Lang_34,"static Map<Object, Object> getRegistry() {
         return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();
     }","static Map<Object, Object> getRegistry() {
    Map<Object, Object> registry = REGISTRY.get();
    return registry != null ? registry : Collections.<Object, Object>emptyMap();
}",0,0
289,Lang_34,"static boolean isRegistered(Object value) {
         Map<Object, Object> m = getRegistry();
         return m.containsKey(value);
     }","static boolean isRegistered(Object value) {
    Map<Object, Object> registry = getRegistry();
    return registry != null && registry.containsKey(value);
}",0,0
290,Lang_35,"public static <T> T[] add(T[] array, int index, T element) {
        Class<?> clss = null;
        if (array != null) {
            clss = array.getClass().getComponentType();
         } else if (element != null) {
             clss = element.getClass();
         } else {
             return (T[]) new Object[] { null };
         }
         @SuppressWarnings(""unchecked"") // the add method creates an array of type clss, which is type T
         final T[] newArray = (T[]) add(array, index, element, clss);
        return newArray;
    }","public static <T> T[] add(T[] array, int index, T element) {
    Class<?> clss = null;
    if (array != null) {
        clss = array.getClass().getComponentType();
    } else if (element != null) {
        clss = element.getClass();
    } else {
        @SuppressWarnings(""unchecked"")
        T[] result = (T[]) new Object[] { null };
        return result;
    }
    @SuppressWarnings(""unchecked"") // the add method creates an array of type clss, which is type T
    final T[] newArray = (T[]) java.lang.reflect.Array.newInstance(clss, array.length + 1);
    System.arraycopy(array, 0, newArray, 0, index);
    newArray[index] = element;
    System.arraycopy(array, index, newArray, index + 1, array.length - index);
    return newArray;
}",0,0
290,Lang_35,"public static <T> T[] add(T[] array, T element) {
        Class<?> type;
        if (array != null){
            type = array.getClass();
         } else if (element != null) {
             type = element.getClass();
         } else {
             type = Object.class;
         }
         @SuppressWarnings(""unchecked"") // type must be T
         T[] newArray = (T[]) copyArrayGrow1(array, type);
        newArray[newArray.length - 1] = element;
        return newArray;
    }","public static <T> T[] add(T[] array, T element) {
    Class<?> type;
    if (array != null) {
        type = array.getClass().getComponentType();
    } else if (element != null) {
        type = element.getClass();
    } else {
        type = Object.class;
    }
    @SuppressWarnings(""unchecked"")
    T[] newArray = (T[]) java.lang.reflect.Array.newInstance(type, (array != null ? array.length : 0) + 1);
    if (array != null) {
        System.arraycopy(array, 0, newArray, 0, array.length);
    }
    newArray[newArray.length - 1] = element;
    return newArray;
}",0,0
291,Lang_36,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
             }
             dec = null;
         }
         if (!Character.isDigit(lastChar)) {
             if (expPos > -1 && expPos < str.length() - 1) {
                 exp = str.substring(expPos + 1, str.length() - 1);
             } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        try {
            return createBigInteger(str);
        } catch (NumberFormatException e) {
            throw new NumberFormatException(str + "" is not a valid hex number."");
        }
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant, dec, exp;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
            exp = str.substring(expPos + 1);
        } else {
            dec = str.substring(decPos + 1);
            exp = null;
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
            exp = str.substring(expPos + 1);
        } else {
            mant = str;
            exp = null;
        }
        dec = null;
    }

    if (!Character.isDigit(lastChar)) {
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);

        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(mant)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                break;
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!f.isInfinite() && (f != 0.0f || allZeros)) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignored
                }
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!d.isInfinite() && (d != 0.0d || allZeros)) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignored
                }
                return createBigDecimal(numeric);

            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        try {
            if (dec == null && exp == null) {
                return createInteger(str);
            } else {
                Float f = createFloat(str);
                if (!f.isInfinite()) {
                    return f;
                }
            }
        } catch (NumberFormatException nfe) {
            // Ignored
        }
        try {
            return createBigDecimal(str);
        } catch (NumberFormatException e) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    return null;
}",0,0
291,Lang_36,"public static boolean isNumber(String str) {
        if (StringUtils.isEmpty(str)) {
            return false;
        }
        char[] chars = str.toCharArray();
        int sz = chars.length;
        boolean hasExp = false;
        boolean hasDecPoint = false;
        boolean allowSigns = false;
        boolean foundDigit = false;
        // deal with any possible sign up front
        int start = (chars[0] == '-') ? 1 : 0;
        if (sz > start + 1) {
            if (chars[start] == '0' && chars[start + 1] == 'x') {
                int i = start + 2;
                if (i == sz) {
                    return false; // str == ""0x""
                }
                // checking hex (it can't be anything else)
                for (; i < chars.length; i++) {
                    if ((chars[i] < '0' || chars[i] > '9')
                        && (chars[i] < 'a' || chars[i] > 'f')
                        && (chars[i] < 'A' || chars[i] > 'F')) {
                        return false;
                    }
                }
                return true;
            }
        }
        sz--; // don't want to loop to the last char, check it afterwords
              // for type qualifiers
        int i = start;
        // loop to the next to last char or to the last char if we need another digit to
        // make a valid number (e.g. chars[0..5] = ""1234E"")
        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                foundDigit = true;
                allowSigns = false;

            } else if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent   
                    return false;
                }
                hasDecPoint = true;
            } else if (chars[i] == 'e' || chars[i] == 'E') {
                // we've already taken care of hex.
                if (hasExp) {
                    // two E's
                    return false;
                }
                if (!foundDigit) {
                    return false;
                }
                hasExp = true;
                allowSigns = true;
            } else if (chars[i] == '+' || chars[i] == '-') {
                if (!allowSigns) {
                    return false;
                }
                allowSigns = false;
                foundDigit = false; // we need a digit after the E
            } else {
                return false;
            }
            i++;
        }
        if (i < chars.length) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                // no type qualifier, OK
                return true;
            }
            if (chars[i] == 'e' || chars[i] == 'E') {
                 // can't have an E at the last byte
                 return false;
             }
             if (!allowSigns
                 && (chars[i] == 'd'
                     || chars[i] == 'D'
                    || chars[i] == 'f'
                    || chars[i] == 'F')) {
                return foundDigit;
            }
            if (chars[i] == 'l'
                || chars[i] == 'L') {
                // not allowing L with an exponent
                return foundDigit && !hasExp;
            }
            // last character is illegal
            return false;
        }
        // allowSigns is true iff the val ends in 'E'
        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
        return !allowSigns && foundDigit;
    }","public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }

    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    int start = (chars[0] == '-') ? 1 : 0;

    if (sz > (start + 1) && chars[start] == '0' && (chars[start + 1] == 'x' || chars[start + 1] == 'X')) {
        for (int i = start + 2; i < chars.length; i++) {
            if (!((chars[i] >= '0' && chars[i] <= '9') || (chars[i] >= 'a' && chars[i] <= 'f') || (chars[i] >= 'A' && chars[i] <= 'F'))) {
                return false;
            }
        }
        return true;
    }

    sz--;
    for (int i = start; i < sz; i++) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            if (hasExp || !foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
            foundDigit = false;
        } else {
            return false;
        }
    }

    if (chars[sz] >= '0' && chars[sz] <= '9') {
        return true;
    }
    if (chars[sz] == 'e' || chars[sz] == 'E') {
        return false;
    }
    if (chars[sz] == 'l' || chars[sz] == 'L') {
        return foundDigit && !hasExp;
    }
    if (chars[sz] == 'd' || chars[sz] == 'D' || chars[sz] == 'f' || chars[sz] == 'F') {
        return foundDigit;
    }
    return false;
}",0,0
292,Lang_4,"@Override
    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
        int max = longest;
        if (index + longest > input.length()) {
            max = input.length() - index;
        }
         // descend so as to get a greedy algorithm
         for (int i = max; i >= shortest; i--) {
             final CharSequence subSeq = input.subSequence(index, index + i);
             final CharSequence result = lookupMap.get(subSeq);
             if (result != null) {
                 out.write(result.toString());
                 return i;
            }
        }
        return 0;
    }","@Override
public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
    int max = Math.min(longest, input.length() - index); // Ensure max does not exceed input length

    // Descend to implement a greedy algorithm
    for (int i = max; i >= shortest; i--) {
        final CharSequence subSeq = input.subSequence(index, index + i);
        final CharSequence result = lookupMap.get(subSeq);
        if (result != null) {
            out.write(result.toString());
            return i; // Return length of translated sequence
        }
    }
    return 0; // Return 0 if no match is found
}",0,0
293,Lang_41,"public static String getShortClassName(String className) {
        if (className == null) {
            return StringUtils.EMPTY;
        }
        if (className.length() == 0) {
            return StringUtils.EMPTY;
        }


        // Handle array encoding
            // Strip Object type encoding


        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
        int innerIdx = className.indexOf(
                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
        String out = className.substring(lastDotIdx + 1);
         if (innerIdx != -1) {
             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
         }
         return out;
     }","public static String getShortClassName(String className) {
    if (className == null || className.length() == 0) {
        return StringUtils.EMPTY;
    }
    
    // Handle array encoding
    if (className.startsWith(""["")) {
        // Strip array and object type encoding
        while (className.charAt(0) == '[') {
            className = className.substring(1);
        }
        
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1, className.length() - 1);
        }
    }
    
    // Find the last package separator and inner class separator
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    
    return out;
}",0,0
294,Lang_46,"private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (str == null) {
            return;
        }
        int sz;
        sz = str.length();
        for (int i = 0; i < sz; i++) {
            char ch = str.charAt(i);

            // handle unicode
            if (ch > 0xfff) {
                out.write(""\\u"" + hex(ch));
            } else if (ch > 0xff) {
                out.write(""\\u0"" + hex(ch));
            } else if (ch > 0x7f) {
                out.write(""\\u00"" + hex(ch));
            } else if (ch < 32) {
                switch (ch) {
                    case '\b' :
                        out.write('\\');
                        out.write('b');
                        break;
                    case '\n' :
                        out.write('\\');
                        out.write('n');
                        break;
                    case '\t' :
                        out.write('\\');
                        out.write('t');
                        break;
                    case '\f' :
                        out.write('\\');
                        out.write('f');
                        break;
                    case '\r' :
                        out.write('\\');
                        out.write('r');
                        break;
                    default :
                        if (ch > 0xf) {
                            out.write(""\\u00"" + hex(ch));
                        } else {
                            out.write(""\\u000"" + hex(ch));
                        }
                        break;
                }
            } else {
                switch (ch) {
                    case '\'' :
                        if (escapeSingleQuote) {
                            out.write('\\');
                        }
                        out.write('\'');
                        break;
                    case '""' :
                        out.write('\\');
                        out.write('""');
                        break;
                    case '\\' :
                        out.write('\\');
                         out.write('\\');
                         break;
                     case '/' :
                             out.write('\\');
                         out.write('/');
                         break;
                     default :
                        out.write(ch);
                        break;
                }
            }
        }
    }","private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (str == null) {
        return;
    }
    int sz = str.length();
    for (int i = 0; i < sz; i++) {
        char ch = str.charAt(i);

        // handle unicode
        if (ch > 0xfff) {
            out.write(""\\u"" + String.format(""%04x"", (int) ch));
        } else if (ch > 0xff) {
            out.write(""\\u0"" + String.format(""%03x"", (int) ch));
        } else if (ch > 0x7f) {
            out.write(""\\u00"" + String.format(""%02x"", (int) ch));
        } else if (ch < 32) {
            switch (ch) {
                case '\b':
                    out.write(""\\b"");
                    break;
                case '\n':
                    out.write(""\\n"");
                    break;
                case '\t':
                    out.write(""\\t"");
                    break;
                case '\f':
                    out.write(""\\f"");
                    break;
                case '\r':
                    out.write(""\\r"");
                    break;
                default:
                    out.write(""\\u"" + String.format(""%04x"", (int) ch));
                    break;
            }
        } else {
            switch (ch) {
                case '\'':
                    if (escapeSingleQuote) {
                        out.write(""\\'"");
                    } else {
                        out.write(""'"");
                    }
                    break;
                case '""':
                    out.write(""\\\"""");
                    break;
                case '\\':
                    out.write(""\\\\"");
                    break;
                case '/':
                    out.write(""\\/"");
                    break;
                default:
                    out.write(ch);
                    break;
            }
        }
    }
}",0,0
295,Lang_47,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, width, buffer, size);
            } else {
                int padLen = width - strLen;
                str.getChars(0, strLen, buffer, size);
                for (int i = 0; i < padLen; i++) {
                    buffer[size + strLen + i] = padChar;
                }
            }
            size += width;
        }
        return this;
    }","public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = (str != null) ? str.length() : 0;
        if (strLen >= width) {
            str.getChars(0, width, buffer, size);
        } else {
            int padLen = width - strLen;
            if (str != null) {
                str.getChars(0, strLen, buffer, size);
            }
            for (int i = 0; i < padLen; i++) {
                buffer[size + strLen + i] = padChar;
            }
        }
        size += width;
    }
    return this;
}",0,0
295,Lang_47,"public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(strLen - width, strLen, buffer, size);
            } else {
                int padLen = width - strLen;
                for (int i = 0; i < padLen; i++) {
                    buffer[size + i] = padChar;
                }
                str.getChars(0, strLen, buffer, size + padLen);
            }
            size += width;
        }
        return this;
    }","public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = (str != null) ? str.length() : 0;
        if (strLen >= width) {
            if (str != null) {
                str.getChars(strLen - width, strLen, buffer, size);
            }
        } else {
            int padLen = width - strLen;
            for (int i = 0; i < padLen; i++) {
                buffer[size + i] = padChar;
            }
            if (str != null) {
                str.getChars(0, strLen, buffer, size + padLen);
            }
        }
        size += width;
    }
    return this;
}",0,0
296,Lang_50,"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,
            Locale locale) {

        Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
         if (locale != null) {
             key = new Pair(key, locale);
         }
 
         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
         if (format == null) {
             if (locale == null) {
                 locale = Locale.getDefault();
             }
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
                         locale);
                String pattern = formatter.toPattern();
                format = getInstance(pattern, timeZone, locale);
                cDateTimeInstanceCache.put(key, format);

            } catch (ClassCastException ex) {
                throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
            }
        }
        return format;
    }","public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }

    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            DateFormat dateTimeFormat = DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            if (!(dateTimeFormat instanceof SimpleDateFormat)) {
                throw new IllegalArgumentException(""Unsupported DateFormat instance returned for locale: "" + locale);
            }
            SimpleDateFormat formatter = (SimpleDateFormat) dateTimeFormat;
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale, ex);
        }
    }
    return format;
}",0,0
296,Lang_50,"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
        Object key = new Integer(style);
        if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
 
         if (locale != null) {
             key = new Pair(key, locale);
         }
 
 
         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
         if (format == null) {
             if (locale == null) {
                 locale = Locale.getDefault();
             }
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
                 String pattern = formatter.toPattern();
                format = getInstance(pattern, timeZone, locale);
                cDateInstanceCache.put(key, format);
                
            } catch (ClassCastException ex) {
                throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
            }
        }
        return format;
    }","public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }

    FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            DateFormat dateFormat = DateFormat.getDateInstance(style, locale);
            if (!(dateFormat instanceof SimpleDateFormat)) {
                throw new IllegalArgumentException(""Unsupported DateFormat instance returned for locale: "" + locale);
            }
            SimpleDateFormat formatter = (SimpleDateFormat) dateFormat;
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale, ex);
        }
    }
    return format;
}",0,0
297,Lang_56,"    public String toString() {
        return ""FastDateFormat["" + mPattern + ""]"";
    }
","public String toString() {
    return ""FastDateFormat["" + (mPattern != null ? mPattern : ""null"") + ""]"";
}",0,0
297,Lang_56,"    public static FastDateFormat getInstance() {
        return getInstance(getDefaultPattern(), null, null);
    }
","public static FastDateFormat getInstance() {
    String defaultPattern = getDefaultPattern();
    if (defaultPattern == null) {
        throw new IllegalStateException(""Default pattern is null"");
    }
    return getInstance(defaultPattern, null, null);
}",0,0
298,Lang_60,"public int indexOf(char ch, int startIndex) {
        startIndex = (startIndex < 0 ? 0 : startIndex);
        if (startIndex >= size) {
             return -1;
         }
         char[] thisBuf = buffer;
         for (int i = startIndex; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return i;
             }
        }
        return -1;
    }","public int indexOf(char ch, int startIndex) {
    if (buffer == null || size == 0) {
        return -1;
    }
    startIndex = Math.max(startIndex, 0);
    if (startIndex >= size) {
        return -1;
    }
    char[] thisBuf = buffer;
    for (int i = startIndex; i < size; i++) { // Ensure we iterate only over the valid portion of the buffer
        if (thisBuf[i] == ch) {
            return i;
        }
    }
    return -1;
}",0,0
298,Lang_60,"public boolean contains(char ch) {
         char[] thisBuf = buffer;
         for (int i = 0; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return true;
             }
        }
        return false;
    }","public boolean contains(char ch) {
    if (buffer == null || size == 0) {
        return false;
    }
    char[] thisBuf = buffer;
    for (int i = 0; i < size; i++) { // Ensure we iterate only over the valid portion of the buffer
        if (thisBuf[i] == ch) {
            return true;
        }
    }
    return false;
}",0,0
299,Lang_62,"public String unescape(String str) {
        int firstAmp = str.indexOf('&');
        if (firstAmp < 0) {
            return str;
        }

        StringBuffer buf = new StringBuffer(str.length());
        buf.append(str.substring(0, firstAmp));
        for (int i = firstAmp; i < str.length(); ++i) {
            char ch = str.charAt(i);
            if (ch == '&') {
                int semi = str.indexOf(';', i + 1);
                if (semi == -1) {
                    buf.append(ch);
                    continue;
                }
                int amph = str.indexOf('&', i + 1);
                if( amph != -1 && amph < semi ) {
                    // Then the text looks like &...&...;
                    buf.append(ch);
                    continue;
                }
                String entityName = str.substring(i + 1, semi);
                int entityValue;
                if (entityName.length() == 0) {
                    entityValue = -1;
                } else if (entityName.charAt(0) == '#') {
                    if (entityName.length() == 1) {
                        entityValue = -1;
                    } else {
                        char charAt1 = entityName.charAt(1);
                        try {
                            if (charAt1 == 'x' || charAt1=='X') {
                                entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();
                             } else {
                                 entityValue = Integer.parseInt(entityName.substring(1));
                             }
                         } catch (NumberFormatException ex) {
                             entityValue = -1;
                         }
                    }
                } else {
                    entityValue = this.entityValue(entityName);
                }
                if (entityValue == -1) {
                    buf.append('&');
                    buf.append(entityName);
                    buf.append(';');
                } else {
                    buf.append((char) (entityValue));
                }
                i = semi;
            } else {
                buf.append(ch);
            }
        }
        return buf.toString();
    }","public String unescape(String str) {
    int firstAmp = str.indexOf('&');
    if (firstAmp < 0) {
        return str;
    }

    StringBuffer buf = new StringBuffer(str.length());
    buf.append(str.substring(0, firstAmp));
    for (int i = firstAmp; i < str.length(); ++i) {
        char ch = str.charAt(i);
        if (ch == '&') {
            int semi = str.indexOf(';', i + 1);
            if (semi == -1) {
                buf.append(ch);
                continue;
            }
            int amph = str.indexOf('&', i + 1);
            if (amph != -1 && amph < semi) {
                buf.append(ch);
                continue;
            }
            String entityName = str.substring(i + 1, semi);
            int entityValue = -1;
            if (!entityName.isEmpty() && entityName.charAt(0) == '#') {
                if (entityName.length() > 1) {
                    try {
                        char charAt1 = entityName.charAt(1);
                        if (charAt1 == 'x' || charAt1 == 'X') {
                            entityValue = Integer.parseInt(entityName.substring(2), 16);
                        } else {
                            entityValue = Integer.parseInt(entityName.substring(1));
                        }
                    } catch (NumberFormatException ignored) {
                    }
                }
            } else {
                entityValue = this.entityValue(entityName);
            }

            if (entityValue == -1 || entityValue > Character.MAX_CODE_POINT) {
                buf.append('&').append(entityName).append(';');
            } else {
                buf.append((char) entityValue);
            }
            i = semi;
        } else {
            buf.append(ch);
        }
    }
    return buf.toString();
}",0,0
299,Lang_62,"public void unescape(Writer writer, String string) throws IOException {
        int firstAmp = string.indexOf('&');
        if (firstAmp < 0) {
            writer.write(string);
            return;
        }

        writer.write(string, 0, firstAmp);
        int len = string.length();
        for (int i = firstAmp; i < len; i++) {
            char c = string.charAt(i);
            if (c == '&') {
                int nextIdx = i+1;
                int semiColonIdx = string.indexOf(';', nextIdx);
                if (semiColonIdx == -1) {
                    writer.write(c);
                    continue;
                }
                int amphersandIdx = string.indexOf('&', i + 1);
                if( amphersandIdx != -1 && amphersandIdx < semiColonIdx ) {
                    // Then the text looks like &...&...;
                    writer.write(c);
                    continue;
                }
                String entityContent = string.substring(nextIdx, semiColonIdx);
                int entityValue = -1;
                int entityContentLen = entityContent.length();
                if (entityContentLen > 0) {
                    if (entityContent.charAt(0) == '#') { //escaped value content is an integer (decimal or hexidecimal)
                        if (entityContentLen > 1) {  
                            char isHexChar = entityContent.charAt(1);
                            try {
                                switch (isHexChar) {
                                     case 'X' :
                                     case 'x' : {
                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                     }
                                     default : {
                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                     }
                                 }
                             } catch (NumberFormatException e) {
                             }
                         }
                     } else { //escaped value content is an entity name
                        entityValue = this.entityValue(entityContent);
                    }
                }
                
                if (entityValue == -1) {
                    writer.write('&');
                    writer.write(entityContent);
                    writer.write(';');
                } else {
                    writer.write(entityValue);
                }
                i = semiColonIdx; //move index up to the semi-colon                
            } else {
                writer.write(c);
            }
        }
    }","public void unescape(Writer writer, String string) throws IOException {
    int firstAmp = string.indexOf('&');
    if (firstAmp < 0) {
        writer.write(string);
        return;
    }

    writer.write(string, 0, firstAmp);
    int len = string.length();
    for (int i = firstAmp; i < len; i++) {
        char c = string.charAt(i);
        if (c == '&') {
            int nextIdx = i + 1;
            int semiColonIdx = string.indexOf(';', nextIdx);
            if (semiColonIdx == -1) {
                writer.write(c);
                continue;
            }
            int amphersandIdx = string.indexOf('&', i + 1);
            if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {
                writer.write(c);
                continue;
            }
            String entityContent = string.substring(nextIdx, semiColonIdx);
            int entityValue = -1;
            if (!entityContent.isEmpty()) {
                if (entityContent.charAt(0) == '#') {
                    if (entityContent.length() > 1) {
                        try {
                            char isHexChar = entityContent.charAt(1);
                            if (isHexChar == 'X' || isHexChar == 'x') {
                                entityValue = Integer.parseInt(entityContent.substring(2), 16);
                            } else {
                                entityValue = Integer.parseInt(entityContent.substring(1), 10);
                            }
                        } catch (NumberFormatException ignored) {
                        }
                    }
                } else {
                    entityValue = this.entityValue(entityContent);
                }
            }

            if (entityValue == -1 || entityValue > Character.MAX_CODE_POINT) {
                writer.write('&');
                writer.write(entityContent);
                writer.write(';');
            } else {
                writer.write((char) entityValue);
            }
            i = semiColonIdx;
        } else {
            writer.write(c);
        }
    }
}",0,0
300,Lang_63,"public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, 
            TimeZone timezone) {

        long millis = endMillis - startMillis;
        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
            return formatDuration(millis, format, padWithZeros);
        }

        Token[] tokens = lexx(format);

        // timezones get funky around 0, so normalizing everything to GMT 
        // stops the hours being off
        Calendar start = Calendar.getInstance(timezone);
        start.setTime(new Date(startMillis));
        Calendar end = Calendar.getInstance(timezone);
        end.setTime(new Date(endMillis));

        // initial estimates
        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);
        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);

        // each initial estimate is adjusted in case it is under 0
        while (milliseconds < 0) {
            milliseconds += 1000;
            seconds -= 1;
        }
        while (seconds < 0) {
            seconds += 60;
            minutes -= 1;
        }
        while (minutes < 0) {
            minutes += 60;
            hours -= 1;
        }
        while (hours < 0) {
            hours += 24;
             days -= 1;
         }
         while (days < 0) {
             days += 31;
 //days += 31; // TODO: Need tests to show this is bad and the new code is good.
 // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is 
 // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
 // Also it's contextual - if asked for no M in the format then I should probably 
 // be doing no calculating here.
             months -= 1;
         }
         while (months < 0) {
             months += 12;
             years -= 1;
         }
         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
 
         // This next block of code adds in values that 
         // aren't requested. This allows the user to ask for the 
        // number of months and get the real count and not just 0->11.
        if (!Token.containsTokenWithValue(tokens, y)) {
            if (Token.containsTokenWithValue(tokens, M)) {
                months += 12 * years;
                years = 0;
            } else {
                // TODO: this is a bit weak, needs work to know about leap years
                days += 365 * years;
                years = 0;
            }
        }
        if (!Token.containsTokenWithValue(tokens, M)) {
            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
            months = 0;
        }
        if (!Token.containsTokenWithValue(tokens, d)) {
            hours += 24 * days;
            days = 0;
        }
        if (!Token.containsTokenWithValue(tokens, H)) {
            minutes += 60 * hours;
            hours = 0;
        }
        if (!Token.containsTokenWithValue(tokens, m)) {
            seconds += 60 * minutes;
            minutes = 0;
        }
        if (!Token.containsTokenWithValue(tokens, s)) {
            milliseconds += 1000 * seconds;
            seconds = 0;
        }

        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
    }","public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, 
            TimeZone timezone) {

        long millis = endMillis - startMillis;
        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
            return formatDuration(millis, format, padWithZeros);
        }

        Token[] tokens = lexx(format);

        // Normalize everything to GMT to avoid timezone issues
        Calendar start = Calendar.getInstance(timezone);
        start.setTimeInMillis(startMillis);
        Calendar end = Calendar.getInstance(timezone);
        end.setTimeInMillis(endMillis);

        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
        int days = end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);

        while (milliseconds < 0) {
            milliseconds += 1000;
            seconds--;
        }
        while (seconds < 0) {
            seconds += 60;
            minutes--;
        }
        while (minutes < 0) {
            minutes += 60;
            hours--;
        }
        while (hours < 0) {
            hours += 24;
            days--;
        }
        while (days < 0) {
            days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
            months--;
            start.add(Calendar.YEAR, 1);
        }
        while (months < 0) {
            months += 12;
            years--;
        }

        // Adjust remaining differences using helper function
        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_YEAR, days);
        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);

        if (!Token.containsTokenWithValue(tokens, y)) {
            if (Token.containsTokenWithValue(tokens, M)) {
                months += 12 * years;
                years = 0;
            } else {
                days += 365 * years;
                years = 0;
            }
        }
        if (!Token.containsTokenWithValue(tokens, M)) {
            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
            months = 0;
        }
        if (!Token.containsTokenWithValue(tokens, d)) {
            hours += 24 * days;
            days = 0;
        }
        if (!Token.containsTokenWithValue(tokens, H)) {
            minutes += 60 * hours;
            hours = 0;
        }
        if (!Token.containsTokenWithValue(tokens, m)) {
            seconds += 60 * minutes;
            minutes = 0;
        }
        if (!Token.containsTokenWithValue(tokens, s)) {
            milliseconds += 1000 * seconds;
            seconds = 0;
        }

        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
    }",0,0
300,Lang_63,"static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,
            int milliseconds, boolean padWithZeros) {
        StringBuffer buffer = new StringBuffer();
        boolean lastOutputSeconds = false;
        int sz = tokens.length;
        for (int i = 0; i < sz; i++) {
            Token token = tokens[i];
            Object value = token.getValue();
            int count = token.getCount();
            if (value instanceof StringBuffer) {
                buffer.append(value.toString());
            } else {
                if (value == y) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer
                            .toString(years));
                    lastOutputSeconds = false;
                } else if (value == M) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer
                            .toString(months));
                    lastOutputSeconds = false;
                } else if (value == d) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer
                            .toString(days));
                    lastOutputSeconds = false;
                } else if (value == H) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer
                            .toString(hours));
                    lastOutputSeconds = false;
                } else if (value == m) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer
                            .toString(minutes));
                    lastOutputSeconds = false;
                } else if (value == s) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer
                            .toString(seconds));
                    lastOutputSeconds = true;
                } else if (value == S) {
                    if (lastOutputSeconds) {
                        milliseconds += 1000;
                        String str = padWithZeros
                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')
                                : Integer.toString(milliseconds);
                        buffer.append(str.substring(1));
                    } else {
                        buffer.append(padWithZeros
                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')
                                : Integer.toString(milliseconds));
                    }
                    lastOutputSeconds = false;
                }
            }
         }
         return buffer.toString();
     }","static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,
            int milliseconds, boolean padWithZeros) {
        StringBuilder buffer = new StringBuilder();
        boolean lastOutputSeconds = false;
        int sz = tokens.length;
        for (int i = 0; i < sz; i++) {
            Token token = tokens[i];
            Object value = token.getValue();
            int count = token.getCount();

            if (value instanceof String) {
                buffer.append(value.toString());
            } else {
                String formattedValue;
                int numericValue;
                if (value == y) numericValue = years;
                else if (value == M) numericValue = months;
                else if (value == d) numericValue = days;
                else if (value == H) numericValue = hours;
                else if (value == m) numericValue = minutes;
                else if (value == s) numericValue = seconds;
                else if (value == S) {
                    numericValue = milliseconds;
                    if (lastOutputSeconds) {
                        numericValue += 1000;
                        formattedValue = padWithZeros ? 
                            StringUtils.leftPad(Integer.toString(numericValue), count, '0') 
                            : Integer.toString(numericValue);
                        buffer.append(formattedValue.substring(1));
                        lastOutputSeconds = false;
                        continue;
                    }
                } else {
                    continue;
                }

                formattedValue = padWithZeros && !(value instanceof String) ? 
                    StringUtils.leftPad(Integer.toString(numericValue), count, '0') 
                    : Integer.toString(numericValue);
                
                buffer.append(formattedValue);
                lastOutputSeconds = (value == s);
            }
        }
        return buffer.toString();
    }",0,0
301,Lang_64,"    public String toString() {
        if (iToString == null) {
            String shortName = ClassUtils.getShortClassName(getEnumClass());
            iToString = shortName + ""["" + getName() + ""="" + getValue() + ""]"";
        }
        return iToString;
    }
","public String toString() {
    if (iToString == null) {
        String shortName = ClassUtils.getShortClassName(getEnumClass());
        iToString = shortName + ""["" + getName() + ""="" + getValue() + ""]"";
    }
    return iToString != null ? iToString : """";
}",0,0
301,Lang_64,"    public int compareTo(Object other) {
        return iValue - ((ValuedEnum) other).iValue;
    }
","public int compareTo(Object other) {
    if (other == null || !(other instanceof ValuedEnum)) {
        throw new ClassCastException(""Object is not a valid ValuedEnum."");
    }
    return Integer.compare(this.iValue, ((ValuedEnum) other).iValue);
}",0,0
302,Lang_7,"public static BigDecimal createBigDecimal(String str) {
        if (str == null) {
            return null;
        }
        // handle JDK1.3.1 bug where """" throws IndexOutOfBoundsException
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
             // to be in specification of class. OS X Java parses it to 
             // a wrong value.
         return new BigDecimal(str);
     }","public static BigDecimal createBigDecimal(String str) {
    if (str == null) {
        return null;
    }
    // handle JDK1.3.1 bug where """" throws IndexOutOfBoundsException
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    try {
        // this is protection for poorness in java.lang.BigDecimal.
        // it accepts this as a legal value, but it does not appear
        // to be in specification of class. OS X Java parses it to 
        // a wrong value.
        return new BigDecimal(str);
    } catch (NumberFormatException e) {
        throw new NumberFormatException(""Invalid BigDecimal value: "" + str);
    }
}",0,0
302,Lang_7,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }  
         if (str.startsWith(""--"")) {
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             int hexDigits = str.length() - 2; // drop 0x
             if (str.startsWith(""-"")) { // drop -
                hexDigits--;
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        throw new NumberFormatException(str + "" is not a valid number."");
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        int hexDigits = str.length() - 2; // drop 0x
        if (str.startsWith(""-"")) { // drop -
            hexDigits--;
        }
        if (hexDigits > 8) { // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }

    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && 
                    (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore and continue
                }
                // fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore and continue
                }
                return createBigDecimal(numeric);
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                // ignore and continue
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
                // ignore and continue
            }
            return createBigInteger(str);
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // ignore and continue
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // ignore and continue
            }
            return createBigDecimal(str);
        }
    }
}",0,0
303,Lang_8,"        public void appendTo(StringBuffer buffer, Calendar calendar) {
            if (zone.useDaylightTime()
                    && calendar.get(Calendar.DST_OFFSET) != 0) {
                buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
            } else {
                buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));
            }
        }
","public void appendTo(StringBuffer buffer, Calendar calendar) {
    if (zone != null && zone.useDaylightTime()
            && calendar.get(Calendar.DST_OFFSET) != 0) {
        buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
    } else if (zone != null) {
        buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));
    }
}",0,0
303,Lang_8,"        public int estimateLength() {
            // We have no access to the Calendar object that will be passed to
            // appendTo so base estimate on the TimeZone passed to the
            // constructor
            return Math.max(mStandard.length(), mDaylight.length());
        }
","public int estimateLength() {
    if (mStandard != null && mDaylight != null) {
        return Math.max(mStandard.length(), mDaylight.length());
    }
    return 0;
}",0,0
304,Math_1,"            final long a1 = (long) FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                // in maxDenominator mode, if the last fraction was very close to the actual value
                // q2 may overflow in the next iteration; in this case return the last one.
                throw new FractionConversionException(value, p2, q2);
            }
","final long a1 = (long) FastMath.floor(r1);
p2 = Math.addExact(Math.multiplyExact(a1, p1), p0);
q2 = Math.addExact(Math.multiplyExact(a1, q1), q0);

if ((p2 > overflow) || (q2 > overflow)) {
    // in maxDenominator mode, if the last fraction was very close to the actual value
    // q2 may overflow in the next iteration; in this case return the last one.
    throw new FractionConversionException(value, p2, q2);
}",0,0
304,Math_1,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (FastMath.abs(a0) > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;

            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                // in maxDenominator mode, if the last fraction was very close to the actual value
                // q2 may overflow in the next iteration; in this case return the last one.
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
","private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException {
    long overflow = Integer.MAX_VALUE;
    double r0 = value;
    long a0 = (long) FastMath.floor(r0);
    if (FastMath.abs(a0) > overflow) {
        throw new FractionConversionException(value, a0, 1L);
    }

    // check for (almost) integer arguments, which should not go to iterations.
    if (FastMath.abs(a0 - value) < epsilon) {
        this.numerator = (int) a0;
        this.denominator = 1;
        return;
    }

    long p0 = 1;
    long q0 = 0;
    long p1 = a0;
    long q1 = 1;

    long p2 = 0;
    long q2 = 1;

    int n = 0;
    boolean stop = false;
    do {
        ++n;
        double r1 = 1.0 / (r0 - a0);
        long a1 = (long) FastMath.floor(r1);
        try {
            p2 = Math.addExact(Math.multiplyExact(a1, p1), p0);
            q2 = Math.addExact(Math.multiplyExact(a1, q1), q0);
        } catch (ArithmeticException e) {
            // Overflow occurred; throw exception
            throw new FractionConversionException(value, p2, q2);
        }

        double convergent = (double) p2 / (double) q2;
        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
            p0 = p1;
            p1 = p2;
            q0 = q1;
            q1 = q2;
            a0 = a1;
            r0 = r1;
        } else {
            stop = true;
        }
    } while (!stop);

    if (n >= maxIterations) {
        throw new FractionConversionException(value, maxIterations);
    }

    if (q2 < maxDenominator) {
        this.numerator = (int) p2;
        this.denominator = (int) q2;
    } else {
        this.numerator = (int) p1;
        this.denominator = (int) q1;
    }
}",0,0
305,Math_100,"public double[][] getCovariances(EstimationProblem problem)
      throws EstimationException {
 
        // set up the jacobian
        updateJacobian();
 
         // compute transpose(J).J, avoiding building big intermediate matrices
         final int rows = problem.getMeasurements().length;
         final int cols = problem.getAllParameters().length;
         final int max  = cols * rows;
         double[][] jTj = new double[cols][cols];
         for (int i = 0; i < cols; ++i) {
            for (int j = i; j < cols; ++j) {
                double sum = 0;
                for (int k = 0; k < max; k += cols) {
                    sum += jacobian[k + i] * jacobian[k + j];
                }
                jTj[i][j] = sum;
                jTj[j][i] = sum;
            }
        }

        try {
            // compute the covariances matrix
            return new RealMatrixImpl(jTj).inverse().getData();
        } catch (InvalidMatrixException ime) {
            throw new EstimationException(""unable to compute covariances: singular problem"",
                                          new Object[0]);
        }

    }","public double[][] getCovariances(EstimationProblem problem)
      throws EstimationException {

        // set up the jacobian
        updateJacobian();

        // compute transpose(J).J, avoiding building big intermediate matrices
        final int rows = problem.getMeasurements().length;
        final int cols = problem.getAllParameters().length;
        double[][] jTj = new double[cols][cols];
        for (int i = 0; i < cols; ++i) {
            for (int j = i; j < cols; ++j) {
                double sum = 0;
                for (int k = 0; k < rows; ++k) { 
                    int indexIK = k * cols + i;
                    int indexJK = k * cols + j;
                    sum += jacobian[indexIK] * jacobian[indexJK];
                }
                jTj[i][j] = sum;
                jTj[j][i] = sum;
            }
        }

        try {
            // compute the covariances matrix
            return new RealMatrixImpl(jTj).inverse().getData();
        } catch (InvalidMatrixException ime) {
            throw new EstimationException(""Unable to compute covariances: singular problem"", ime);
        }
    }",0,0
305,Math_100,"public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
         int m = problem.getMeasurements().length;
         int p = problem.getAllParameters().length;
         if (m <= p) {
             throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"",
                                           new Object[] { new Integer(m), new Integer(p)});
         }
         double[] errors = new double[problem.getAllParameters().length];
         final double c = Math.sqrt(getChiSquare(problem) / (m - p));
         double[][] covar = getCovariances(problem);
         for (int i = 0; i < errors.length; ++i) {
            errors[i] = Math.sqrt(covar[i][i]) * c;
        }
        return errors;
    }","public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
        int m = problem.getMeasurements().length;
        int p = problem.getAllParameters().length;
        if (m <= p) {
            throw new EstimationException(""No degrees of freedom ("" + m + "" measurements, "" + p + "" parameters)"");
        }

        double[] errors = new double[p];
        final double c = Math.sqrt(getChiSquare(problem) / (m - p));
        double[][] covar = getCovariances(problem);
        for (int i = 0; i < p; ++i) {
            if (covar[i][i] < 0) {
                throw new EstimationException(""Negative variance value for parameter "" + i);
            }
            errors[i] = Math.sqrt(covar[i][i]) * c;
        }
        return errors;
    }",0,0
306,Math_104,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math.special;

import java.io.Serializable;

import org.apache.commons.math.MathException;
import org.apache.commons.math.MaxIterationsExceededException;
import org.apache.commons.math.util.ContinuedFraction;

/**
 * This is a utility class that provides computation methods related to the
 * Gamma family of functions.
 *
 * @version $Revision$ $Date$
 */
public class Gamma implements Serializable {
    
    /** Serializable version identifier */
    private static final long serialVersionUID = -6587513359895466954L;

    /** Maximum allowed numerical error. */
    private static final double DEFAULT_EPSILON = 10e-9;

    /** Lanczos coefficients */
    private static double[] lanczos =
    {
        0.99999999999999709182,
        57.156235665862923517,
        -59.597960355475491248,
        14.136097974741747174,
        -0.49191381609762019978,
        .33994649984811888699e-4,
        .46523628927048575665e-4,
        -.98374475304879564677e-4,
        .15808870322491248884e-3,
        -.21026444172410488319e-3,
        .21743961811521264320e-3,
        -.16431810653676389022e-3,
        .84418223983852743293e-4,
        -.26190838401581408670e-4,
        .36899182659531622704e-5,
    };

    /** Avoid repeated computation of log of 2 PI in logGamma */
    private static final double HALF_LOG_2_PI = 0.5 * Math.log(2.0 * Math.PI);

    
    /**
     * Default constructor.  Prohibit instantiation.
     */
    private Gamma() {
        super();
    }

    /**
     * Returns the natural logarithm of the gamma function &#915;(x).
     *
     * The implementation of this method is based on:
     * <ul>
     * <li><a href=""http://mathworld.wolfram.com/GammaFunction.html"">
     * Gamma Function</a>, equation (28).</li>
     * <li><a href=""http://mathworld.wolfram.com/LanczosApproximation.html"">
     * Lanczos Approximation</a>, equations (1) through (5).</li>
     * <li><a href=""http://my.fit.edu/~gabdo/gamma.txt"">Paul Godfrey, A note on
     * the computation of the convergent Lanczos complex Gamma approximation
     * </a></li>
     * </ul>
     * 
     * @param x the value.
     * @return log(&#915;(x))
     */
    public static double logGamma(double x) {
        double ret;

        if (Double.isNaN(x) || (x <= 0.0)) {
            ret = Double.NaN;
        } else {
            double g = 607.0 / 128.0;
            
            double sum = 0.0;
            for (int i = lanczos.length - 1; i > 0; --i) {
                sum = sum + (lanczos[i] / (x + i));
            }
            sum = sum + lanczos[0];

            double tmp = x + g + .5;
            ret = ((x + .5) * Math.log(tmp)) - tmp +
                HALF_LOG_2_PI + Math.log(sum / x);
        }

        return ret;
    }

    /**
     * Returns the regularized gamma function P(a, x).
     * 
     * @param a the a parameter.
     * @param x the value.
     * @return the regularized gamma function P(a, x)
     * @throws MathException if the algorithm fails to converge.
     */
    public static double regularizedGammaP(double a, double x)
        throws MathException
    {
        return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
    }
        
        
    /**
     * Returns the regularized gamma function P(a, x).
     * 
     * The implementation of this method is based on:
     * <ul>
     * <li>
     * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
     * Regularized Gamma Function</a>, equation (1).</li>
     * <li>
     * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
     * Incomplete Gamma Function</a>, equation (4).</li>
     * <li>
     * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
     * </li>
     * </ul>
     * 
     * @param a the a parameter.
     * @param x the value.
     * @param epsilon When the absolute value of the nth item in the
     *                series is less than epsilon the approximation ceases
     *                to calculate further elements in the series.
     * @param maxIterations Maximum number of ""iterations"" to complete. 
     * @return the regularized gamma function P(a, x)
     * @throws MathException if the algorithm fails to converge.
     */
    public static double regularizedGammaP(double a, 
                                           double x, 
                                           double epsilon, 
                                           int maxIterations) 
        throws MathException
    {
        double ret;

        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
            ret = Double.NaN;
        } else if (x == 0.0) {
            ret = 0.0;
        } else if (a >= 1.0 && x > a) {
            // use regularizedGammaQ because it should converge faster in this
            // case.
            ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
        } else {
            // calculate series
            double n = 0.0; // current element index
            double an = 1.0 / a; // n-th element in the series
            double sum = an; // partial sum
            while (Math.abs(an) > epsilon && n < maxIterations) {
                // compute next element in the series
                n = n + 1.0;
                an = an * (x / (a + n));

                // update partial sum
                sum = sum + an;
            }
            if (n >= maxIterations) {
                throw new MaxIterationsExceededException(maxIterations);
            } else {
                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
            }
        }

        return ret;
    }
    
    /**
     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
     * 
     * @param a the a parameter.
     * @param x the value.
     * @return the regularized gamma function Q(a, x)
     * @throws MathException if the algorithm fails to converge.
     */
    public static double regularizedGammaQ(double a, double x)
        throws MathException
    {
        return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
    }
    
    /**
     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
     * 
     * The implementation of this method is based on:
     * <ul>
     * <li>
     * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
     * Regularized Gamma Function</a>, equation (1).</li>
     * <li>
     * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
     * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
     * </ul>
     * 
     * @param a the a parameter.
     * @param x the value.
     * @param epsilon When the absolute value of the nth item in the
     *                series is less than epsilon the approximation ceases
     *                to calculate further elements in the series.
     * @param maxIterations Maximum number of ""iterations"" to complete. 
     * @return the regularized gamma function P(a, x)
     * @throws MathException if the algorithm fails to converge.
     */
    public static double regularizedGammaQ(final double a, 
                                           double x, 
                                           double epsilon, 
                                           int maxIterations) 
        throws MathException
    {
        double ret;

        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
            ret = Double.NaN;
        } else if (x == 0.0) {
            ret = 1.0;
        } else if (x < a || a < 1.0) {
            // use regularizedGammaP because it should converge faster in this
            // case.
            ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
        } else {
            // create continued fraction
            ContinuedFraction cf = new ContinuedFraction() {

                private static final long serialVersionUID = 5378525034886164398L;

                protected double getA(int n, double x) {
                    return ((2.0 * n) + 1.0) - a + x;
                }

                protected double getB(int n, double x) {
                    return n * (a - n);
                }
            };
            
            ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
        }

        return ret;
    }
}
",Match failed,0,0
307,Math_12,"    public BitsStreamGenerator() {
        nextGaussian = Double.NaN;
    }
","public BitsStreamGenerator() {
    this.nextGaussian = Double.NaN;
}",0,0
308,Math_14,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
","private RealMatrix squareRoot(RealMatrix m) {
    if (m == null || m.getRowDimension() != m.getColumnDimension()) {
        throw new IllegalArgumentException(""Matrix must be non-null and square."");
    }
    final EigenDecomposition dec = new EigenDecomposition(m);
    return dec.getSquareRoot();
}",0,0
308,Math_14,"    public Weight(double[] weight) {
        final int dim = weight.length;
        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);
        for (int i = 0; i < dim; i++) {
            weightMatrix.setEntry(i, i, weight[i]);
        }
    }
","public Weight(double[] weight) {
    if (weight == null || weight.length == 0) {
        throw new IllegalArgumentException(""Weight array must be non-null and non-empty."");
    }
    final int dim = weight.length;
    weightMatrix = dim * dim <= 4096 
        ? new Array2DRowRealMatrix(dim, dim) 
        : new BlockRealMatrix(dim, dim);
    for (int i = 0; i < dim; i++) {
        weightMatrix.setEntry(i, i, weight[i]);
    }
}",0,0
309,Math_15,"public static double pow(double x, double y) {
        final double lns[] = new double[2];

        if (y == 0.0) {
            return 1.0;
        }

        if (x != x) { // X is NaN
            return x;
        }


        if (x == 0) {
            long bits = Double.doubleToLongBits(x);
            if ((bits & 0x8000000000000000L) != 0) {
                // -zero
                long yi = (long) y;

                if (y < 0 && y == yi && (yi & 1) == 1) {
                    return Double.NEGATIVE_INFINITY;
                }

                if (y > 0 && y == yi && (yi & 1) == 1) {
                    return -0.0;
                }
            }

            if (y < 0) {
                return Double.POSITIVE_INFINITY;
            }
            if (y > 0) {
                return 0.0;
            }

            return Double.NaN;
        }

        if (x == Double.POSITIVE_INFINITY) {
            if (y != y) { // y is NaN
                return y;
            }
            if (y < 0.0) {
                return 0.0;
            } else {
                return Double.POSITIVE_INFINITY;
            }
        }

        if (y == Double.POSITIVE_INFINITY) {
            if (x * x == 1.0) {
                return Double.NaN;
            }

            if (x * x > 1.0) {
                return Double.POSITIVE_INFINITY;
            } else {
                return 0.0;
            }
        }

        if (x == Double.NEGATIVE_INFINITY) {
            if (y != y) { // y is NaN
                return y;
            }

            if (y < 0) {
                long yi = (long) y;
                if (y == yi && (yi & 1) == 1) {
                    return -0.0;
                }

                return 0.0;
            }

            if (y > 0)  {
                long yi = (long) y;
                if (y == yi && (yi & 1) == 1) {
                    return Double.NEGATIVE_INFINITY;
                }

                return Double.POSITIVE_INFINITY;
            }
        }

        if (y == Double.NEGATIVE_INFINITY) {

            if (x * x == 1.0) {
                return Double.NaN;
            }

            if (x * x < 1.0) {
                return Double.POSITIVE_INFINITY;
            } else {
                return 0.0;
            }
        }

         /* Handle special case x<0 */
         if (x < 0) {
             // y is an even integer in this case
             if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
                 return pow(-x, y);
             }
 
            if (y == (long) y) {
                // If y is an integer
                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
            } else {
                return Double.NaN;
            }
        }

        /* Split y into ya and yb such that y = ya+yb */
        double ya;
        double yb;
        if (y < 8e298 && y > -8e298) {
            double tmp1 = y * HEX_40000000;
            ya = y + tmp1 - tmp1;
            yb = y - ya;
        } else {
            double tmp1 = y * 9.31322574615478515625E-10;
            double tmp2 = tmp1 * 9.31322574615478515625E-10;
            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;
            yb = y - ya;
        }

        /* Compute ln(x) */
        final double lores = log(x, lns);
        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN
            return lores;
        }

        double lna = lns[0];
        double lnb = lns[1];

        /* resplit lns */
        double tmp1 = lna * HEX_40000000;
        double tmp2 = lna + tmp1 - tmp1;
        lnb += lna - tmp2;
        lna = tmp2;

        // y*ln(x) = (aa+ab)
        final double aa = lna * ya;
        final double ab = lna * yb + lnb * ya + lnb * yb;

        lna = aa+ab;
        lnb = -(lna - aa - ab);

        double z = 1.0 / 120.0;
        z = z * lnb + (1.0 / 24.0);
        z = z * lnb + (1.0 / 6.0);
        z = z * lnb + 0.5;
        z = z * lnb + 1.0;
        z = z * lnb;

        final double result = exp(lna, z, null);
        //result = result + result * z;
        return result;
    }","public static double pow(double x, double y) {
    final double lns[] = new double[2];

    if (y == 0.0) {
        return 1.0;
    }

    if (Double.isNaN(x)) { // Check if x is NaN
        return x;
    }

    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;

            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }

            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }

        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }

        return Double.NaN;
    }

    if (Double.isInfinite(x)) {
        if (Double.isNaN(y)) { // Check if y is NaN
            return y;
        }
        if (x == Double.POSITIVE_INFINITY) {
            return (y < 0.0) ? 0.0 : Double.POSITIVE_INFINITY;
        } else { // x == Double.NEGATIVE_INFINITY
            long yi = (long) y;
            if (y < 0) {
                return (y == yi && (yi & 1) == 1) ? -0.0 : 0.0;
            } else {
                return (y == yi && (yi & 1) == 1) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
            }
        }
    }

    if (Double.isInfinite(y)) {
        if (x == 1.0 || x == -1.0) {
            return Double.NaN;
        }

        if (x * x > 1.0) {
            return y > 0.0 ? Double.POSITIVE_INFINITY : 0.0;
        } else {
            return y > 0.0 ? 0.0 : Double.POSITIVE_INFINITY;
        }
    }

    if (x < 0) {
        if (y >= TWO_POWER_52 || y <= -TWO_POWER_52 || y != (long) y) {
            return Double.NaN;
        }
        return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
    }

    /* Split y into ya and yb such that y = ya + yb */
    double ya;
    double yb;
    if (Math.abs(y) < 8e298) {
        double tmp1 = y * HEX_40000000;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;
        yb = y - ya;
    }

    /* Compute ln(x) */
    final double lores = log(x, lns);
    if (Double.isInfinite(lores)) { // don't allow this to be converted to NaN
        return lores;
    }

    double lna = lns[0];
    double lnb = lns[1];

    /* Resplit lns */
    double tmp1 = lna * HEX_40000000;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;

    // y * ln(x) = (aa + ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;

    lna = aa + ab;
    lnb = -(lna - aa - ab);

    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;

    return exp(lna, z, null);
}",0,0
310,Math_16,"public static double cosh(double x) {
      if (x != x) {
          return x;
      }

      // cosh[z] = (exp(z) + exp(-z))/2

      // for numbers with magnitude 20 or so,
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
               // Avoid overflow (MATH-905).
               return 0.5 * exp(x);
           }
       if (x < -20) {
               // Avoid overflow (MATH-905).
               return 0.5 * exp(-x);
       }
 
       final double hiPrec[] = new double[2];
      if (x < 0.0) {
          x = -x;
      }
      exp(x, 0.0, hiPrec);

      double ya = hiPrec[0] + hiPrec[1];
      double yb = -(ya - hiPrec[0] - hiPrec[1]);

      double temp = ya * HEX_40000000;
      double yaa = ya + temp - temp;
      double yab = ya - yaa;

      // recip = 1/y
      double recip = 1.0/ya;
      temp = recip * HEX_40000000;
      double recipa = recip + temp - temp;
      double recipb = recip - recipa;

      // Correct for rounding in division
      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;
      // Account for yb
      recipb += -yb * recip * recip;

      // y = y + 1/y
      temp = ya + recipa;
      yb += -(temp - ya - recipa);
      ya = temp;
      temp = ya + recipb;
      yb += -(temp - ya - recipb);
      ya = temp;

      double result = ya + yb;
      result *= 0.5;
      return result;
    }","public static double cosh(double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }

    // cosh[z] = (exp(z) + exp(-z)) / 2
    if (x > 20) {
        // Avoid overflow (MATH-905).
        return 0.5 * Math.exp(x);
    }
    if (x < -20) {
        // Avoid overflow (MATH-905).
        return 0.5 * Math.exp(-x);
    }

    if (x < 0.0) {
        x = -x; // cosh is an even function
    }

    double expX = Math.exp(x);
    double expNegX = Math.exp(-x);
    return (expX + expNegX) * 0.5;
}",0,0
310,Math_16,"public static double sinh(double x) {
      boolean negate = false;
      if (x != x) {
          return x;
      }

      // sinh[z] = (exp(z) - exp(-z) / 2

      // for values of z larger than about 20,
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
               // Avoid overflow (MATH-905).
               return 0.5 * exp(x);
           }
       if (x < -20) {
               // Avoid overflow (MATH-905).
               return -0.5 * exp(-x);
       }
 
       if (x == 0) {
          return x;
      }

      if (x < 0.0) {
          x = -x;
          negate = true;
      }

      double result;

      if (x > 0.25) {
          double hiPrec[] = new double[2];
          exp(x, 0.0, hiPrec);

          double ya = hiPrec[0] + hiPrec[1];
          double yb = -(ya - hiPrec[0] - hiPrec[1]);

          double temp = ya * HEX_40000000;
          double yaa = ya + temp - temp;
          double yab = ya - yaa;

          // recip = 1/y
          double recip = 1.0/ya;
          temp = recip * HEX_40000000;
          double recipa = recip + temp - temp;
          double recipb = recip - recipa;

          // Correct for rounding in division
          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;
          // Account for yb
          recipb += -yb * recip * recip;

          recipa = -recipa;
          recipb = -recipb;

          // y = y + 1/y
          temp = ya + recipa;
          yb += -(temp - ya - recipa);
          ya = temp;
          temp = ya + recipb;
          yb += -(temp - ya - recipb);
          ya = temp;

          result = ya + yb;
          result *= 0.5;
      }
      else {
          double hiPrec[] = new double[2];
          expm1(x, hiPrec);

          double ya = hiPrec[0] + hiPrec[1];
          double yb = -(ya - hiPrec[0] - hiPrec[1]);

          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
          double denom = 1.0 + ya;
          double denomr = 1.0 / denom;
          double denomb = -(denom - 1.0 - ya) + yb;
          double ratio = ya * denomr;
          double temp = ratio * HEX_40000000;
          double ra = ratio + temp - temp;
          double rb = ratio - ra;

          temp = denom * HEX_40000000;
          double za = denom + temp - temp;
          double zb = denom - za;

          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;

          // Adjust for yb
          rb += yb*denomr;                        // numerator
          rb += -ya * denomb * denomr * denomr;   // denominator

          // y = y - 1/y
          temp = ya + ra;
          yb += -(temp - ya - ra);
          ya = temp;
          temp = ya + rb;
          yb += -(temp - ya - rb);
          ya = temp;

          result = ya + yb;
          result *= 0.5;
      }

      if (negate) {
          result = -result;
      }

      return result;
    }","public static double sinh(double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }

    // sinh[z] = (exp(z) - exp(-z)) / 2
    if (x > 20) {
        // Avoid overflow (MATH-905).
        return 0.5 * Math.exp(x);
    }
    if (x < -20) {
        // Avoid overflow (MATH-905).
        return -0.5 * Math.exp(-x);
    }

    double expX = Math.exp(x);
    double expNegX = Math.exp(-x);
    return (expX - expNegX) * 0.5;
}",0,0
311,Math_18,"public double[] encode(final double[] x) {
            if (boundaries == null) {
                return x;
            }
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
                 res[i] = (x[i] - boundaries[0][i]) / diff;
             }
             return res;
         }","public double[] encode(final double[] x) {
    if (boundaries == null) {
        return x;
    }
    double[] res = new double[x.length];
    for (int i = 0; i < x.length; i++) {
        double diff = boundaries[1][i] - boundaries[0][i];
        if (diff == 0) {
            throw new IllegalArgumentException(""Boundary range cannot be zero for index "" + i);
        }
        res[i] = (x[i] - boundaries[0][i]) / diff;
    }
    return res;
}",0,0
311,Math_18,"public double[] decode(final double[] x) {
            if (boundaries == null) {
                return x;
            }
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
                 res[i] = diff * x[i] + boundaries[0][i];
             }
             return res;
         }","public double[] decode(final double[] x) {
    if (boundaries == null) {
        return x;
    }
    double[] res = new double[x.length];
    for (int i = 0; i < x.length; i++) {
        double diff = boundaries[1][i] - boundaries[0][i];
        if (diff == 0) {
            throw new IllegalArgumentException(""Boundary range cannot be zero for index "" + i);
        }
        res[i] = diff * x[i] + boundaries[0][i];
    }
    return res;
}",0,0
311,Math_18,"public boolean isFeasible(final double[] x) {
            if (boundaries == null) {
                 return true;
             }
 
 
             for (int i = 0; i < x.length; i++) {
                 if (x[i] < 0) {
                     return false;
                 }
                 if (x[i] > 1.0) {
                     return false;
                 }
             }
            return true;
        }","public boolean isFeasible(final double[] x) {
    if (boundaries == null) {
        return true;
    }
    for (int i = 0; i < x.length; i++) {
        if (x[i] < 0 || x[i] > 1.0) {
            return false;
        }
    }
    return true;
}",0,0
312,Math_22,"    public boolean isSupportLowerBoundInclusive() {
        return true;
    }
","public boolean isSupportLowerBoundInclusive() {
    // Corrected to reflect the actual behavior of the distribution
    return false;
}",0,0
312,Math_22,"    public boolean isSupportUpperBoundInclusive() {
        return false;
    }","public boolean isSupportUpperBoundInclusive() {
    // Corrected to reflect the actual behavior of the distribution
    return true;
}",0,0
313,Math_29,"@Override
    public OpenMapRealVector ebeDivide(RealVector v) {
        checkVectorDimensions(v.getDimension());
        OpenMapRealVector res = new OpenMapRealVector(this);
        /*
         * MATH-803: it is not sufficient to loop through non zero entries of
          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
          * this[i] / v[i] = NaN, and not 0d.
          */
         Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
         }
         return res;
     }","@Override
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);

    // Check all entries (this vector and the other vector)
    for (int i = 0; i < v.getDimension(); i++) {
        double thisValue = getEntry(i);
        double otherValue = v.getEntry(i);

        // Handle division
        if (Double.isNaN(thisValue / otherValue)) {
            throw new ArithmeticException(""NaN encountered while dividing "" + thisValue + "" by "" + otherValue);
        }

        res.setEntry(i, thisValue / otherValue);
    }

    return res;
}",0,0
313,Math_29,"@Override
    public OpenMapRealVector ebeMultiply(RealVector v) {
        checkVectorDimensions(v.getDimension());
        OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = entries.iterator();
        while (iter.hasNext()) {
            iter.advance();
            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
        }
        /*
         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,
         * which allows to consider only the non-zero entries of this. However,
         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).
          *
          * These special cases are handled below.
          */
         return res;
     }","@Override
public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);

    // Check all entries (this vector and the other vector)
    for (int i = 0; i < v.getDimension(); i++) {
        double thisValue = getEntry(i);
        double otherValue = v.getEntry(i);

        // Handle multiplication
        if (Double.isNaN(thisValue * otherValue)) {
            throw new ArithmeticException(""NaN encountered while multiplying "" + thisValue + "" by "" + otherValue);
        }

        res.setEntry(i, thisValue * otherValue);
    }

    return res;
}",0,0
314,Math_35,"    public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                   final int populationLimit,
                                   final double elitismRate) {
        super(chromosomes, populationLimit);
        this.elitismRate = elitismRate;
    }
","public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                   final int populationLimit,
                                   final double elitismRate) {
        super(chromosomes, populationLimit);
        if (elitismRate < 0 || elitismRate > 1) {
            throw new IllegalArgumentException(""Elitism rate must be between 0 and 1."");
        }
        this.elitismRate = elitismRate;
    }",0,0
314,Math_35,"    public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
        super(populationLimit);
        this.elitismRate = elitismRate;
    }
","public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
        super(populationLimit);
        if (elitismRate < 0 || elitismRate > 1) {
            throw new IllegalArgumentException(""Elitism rate must be between 0 and 1."");
        }
        this.elitismRate = elitismRate;
    }",0,0
315,Math_36,"@Override
     public float floatValue() {
         float result = numerator.floatValue() / denominator.floatValue();
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
         return result;
     }","@Override
public float floatValue() {
    if (denominator.equals(BigInteger.ZERO)) {
        throw new ArithmeticException(""Division by zero"");
    }
    float numeratorValue = numerator.floatValue();
    float denominatorValue = denominator.floatValue();
    if (Float.isInfinite(numeratorValue) || Float.isInfinite(denominatorValue)) {
        return numeratorValue / denominatorValue;
    }
    try {
        return numeratorValue / denominatorValue;
    } catch (ArithmeticException e) {
        return Float.NaN; // Return NaN for invalid float operations
    }
}",0,0
315,Math_36,"@Override
     public double doubleValue() {
         double result = numerator.doubleValue() / denominator.doubleValue();
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
         return result;
     }","@Override
public double doubleValue() {
    if (denominator.equals(BigInteger.ZERO)) {
        throw new ArithmeticException(""Division by zero"");
    }
    double numeratorValue = numerator.doubleValue();
    double denominatorValue = denominator.doubleValue();
    if (Double.isInfinite(numeratorValue) || Double.isInfinite(denominatorValue)) {
        return numeratorValue / denominatorValue;
    }
    try {
        return numeratorValue / denominatorValue;
    } catch (ArithmeticException e) {
        return Double.NaN; // Return NaN for invalid double operations
    }
}",0,0
316,Math_37,"    public Complex tan() {
        if (isNaN) {
            return NaN;
        }

        double real2 = 2.0 * real;
        double imaginary2 = 2.0 * imaginary;
        double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);

        return createComplex(FastMath.sin(real2) / d,
                             FastMath.sinh(imaginary2) / d);
    }
","public Complex tan() {
    if (isNaN) {
        return NaN;
    }

    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);

    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return NaN;
    }

    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);
}",0,0
316,Math_37,"    public Complex tanh() {
        if (isNaN) {
            return NaN;
        }
        double real2 = 2.0 * real;
        double imaginary2 = 2.0 * imaginary;
        double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);

        return createComplex(FastMath.sinh(real2) / d,
                             FastMath.sin(imaginary2) / d);
    }
","public Complex tanh() {
    if (isNaN) {
        return NaN;
    }

    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);

    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return NaN;
    }

    return createComplex(FastMath.sinh(real2) / d, FastMath.sin(imaginary2) / d);
}",0,0
317,Math_4,"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
 
         // compute the intersection on infinite line
         Vector3D v1D = line.intersection(subLine.line);
 
         // check location of point with respect to first sub-line
         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));

        // check location of point with respect to second sub-line
        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));

        if (includeEndPoints) {
            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
        } else {
            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
        }

    }","public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    if (v1D == null) {
        return null;
    }

    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));

    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));

    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}",0,0
317,Math_4,"public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {

        // retrieve the underlying lines
        Line line1 = (Line) getHyperplane();
        Line line2 = (Line) subLine.getHyperplane();
 
         // compute the intersection on infinite line
         Vector2D v2D = line1.intersection(line2);
 
         // check location of point with respect to first sub-line
         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));

        // check location of point with respect to second sub-line
        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));

        if (includeEndPoints) {
            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
        } else {
            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
        }

    }","public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // retrieve the underlying lines
    Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();

    // compute the intersection on infinite line
    Vector2D v2D = line1.intersection(line2);
    if (v2D == null) {
        return null;
    }

    // check location of point with respect to first sub-line
    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));

    // check location of point with respect to second sub-line
    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));

    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}",0,0
318,Math_46,"public Complex divide(double divisor) {
        if (isNaN || Double.isNaN(divisor)) {
            return NaN;
         }
         if (divisor == 0d) {
             // return isZero ? NaN : INF; // See MATH-657
             return isZero ? NaN : INF;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
        }
        return createComplex(real / divisor,
                             imaginary  / divisor);
    }","public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        // Handle zero divisor case. Return appropriate Complex value.
        return isZero ? NaN : INF;
    }
    if (Double.isInfinite(divisor)) {
        return isZero ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}",0,0
318,Math_46,"public Complex divide(Complex divisor)
        throws NullArgumentException {
        MathUtils.checkNotNull(divisor);
        if (isNaN || divisor.isNaN) {
            return NaN;
        }
 
         if (divisor.isZero) {
             // return isZero ? NaN : INF; // See MATH-657
             return isZero ? NaN : INF;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
            return ZERO;
        }

        final double c = divisor.getReal();
        final double d = divisor.getImaginary();

        if (FastMath.abs(c) < FastMath.abs(d)) {
            double q = c / d;
            double denominator = c * q + d;
            return createComplex((real * q + imaginary) / denominator,
                (imaginary * q - real) / denominator);
        } else {
            double q = d / c;
            double denominator = d * q + c;
            return createComplex((imaginary * q + real) / denominator,
                (imaginary - real * q) / denominator);
        }
    }","public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    if (divisor.isZero) {
        // Handle zero divisor case. Return appropriate Complex value.
        return isZero ? NaN : INF;
    }
    if (divisor.isInfinite()) {
        return isZero ? ZERO : NaN;
    }

    final double c = divisor.getReal();
    final double d = divisor.getImaginary();

    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, 
                             (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((real + imaginary * q) / denominator,
                             (imaginary - real * q) / denominator);
    }
}",0,0
319,Math_47,"public Complex divide(double divisor) {
        if (isNaN || Double.isNaN(divisor)) {
             return NaN;
         }
         if (divisor == 0d) {
             return NaN;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
        }
        return createComplex(real / divisor,
                             imaginary  / divisor);
    }","public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : new Complex(0, 0);
    }
    return createComplex(real / divisor, imaginary / divisor);
}",0,0
319,Math_47,"public Complex divide(Complex divisor)
        throws NullArgumentException {
        MathUtils.checkNotNull(divisor);
        if (isNaN || divisor.isNaN) {
             return NaN;
         }
 
         if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
             return NaN;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
            return ZERO;
        }

        final double c = divisor.getReal();
        final double d = divisor.getImaginary();

        if (FastMath.abs(c) < FastMath.abs(d)) {
            double q = c / d;
            double denominator = c * q + d;
            return createComplex((real * q + imaginary) / denominator,
                (imaginary * q - real) / denominator);
        } else {
            double q = d / c;
            double denominator = d * q + c;
            return createComplex((imaginary * q + real) / denominator,
                (imaginary - real * q) / denominator);
        }
    }","public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }

    if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
        return NaN;
    }

    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }

    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    final double denominator;

    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        denominator = d * (1.0 + q * q);
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        denominator = c * (1.0 + q * q);
        return createComplex((real + imaginary * q) / denominator, (imaginary - real * q) / denominator);
    }
}",0,0
320,Math_49,"public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
        }
        return res;
    }","public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator(); // Use the actual entry set of `this`
    while (iter.hasNext()) {
        iter.advance();
        double divisor = v.getEntry(iter.key());
        if (divisor == 0) {
            throw new ArithmeticException(""Division by zero at index "" + iter.key());
        }
        res.setEntry(iter.key(), iter.value() / divisor);
    }
    return res;
}",0,0
320,Math_49,"@Override
     public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v[iter.key()]);
        }
        return res;
    }","@Override
public OpenMapRealVector ebeMultiply(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator(); // Use the actual entry set of `this`
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v[iter.key()]);
    }
    return res;
}",0,0
320,Math_49,"public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
        }
        return res;
    }","public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator(); // Use the actual entry set of `this`
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    return res;
}",0,0
320,Math_49,"@Override
     public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v[iter.key()]);
        }
        return res;
    }","@Override
public OpenMapRealVector ebeDivide(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator(); // Use the actual entry set of `this`
    while (iter.hasNext()) {
        iter.advance();
        double divisor = v[iter.key()];
        if (divisor == 0) {
            throw new ArithmeticException(""Division by zero at index "" + iter.key());
        }
        res.setEntry(iter.key(), iter.value() / divisor);
    }
    return res;
}",0,0
321,Math_54,"    protected Dfp(final DfpField field, double x) {

        // initialize as if 0
        mant = new int[field.getRadixDigits()];
        sign = 1;
        exp = 0;
        nans = FINITE;
        this.field = field;

        long bits = Double.doubleToLongBits(x);
        long mantissa = bits & 0x000fffffffffffffL;
        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;

        if (exponent == -1023) {
            // Zero or sub-normal
            if (x == 0) {
                // make sure 0 has the right sign
                return;
            }

            exponent++;

            // Normalize the subnormal number
            while ( (mantissa & 0x0010000000000000L) == 0) {
                exponent--;
                mantissa <<= 1;
            }
            mantissa &= 0x000fffffffffffffL;
        }

        if (exponent == 1024) {
            // infinity or NAN
            if (x != x) {
                sign = (byte) 1;
                nans = QNAN;
            } else if (x < 0) {
                sign = (byte) -1;
                nans = INFINITE;
            } else {
                sign = (byte) 1;
                nans = INFINITE;
            }
            return;
        }

        Dfp xdfp = new Dfp(field, mantissa);
        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one
        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));

        if ((bits & 0x8000000000000000L) != 0) {
            xdfp = xdfp.negate();
        }

        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);
        sign = xdfp.sign;
        exp  = xdfp.exp;
        nans = xdfp.nans;

    }
","protected Dfp(final DfpField field, double x) {

    // initialize as if 0
    mant = new int[field.getRadixDigits()];
    sign = 1;
    exp = 0;
    nans = FINITE;
    this.field = field;

    long bits = Double.doubleToLongBits(x);
    long mantissa = bits & 0x000fffffffffffffL;
    int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;

    if (exponent == -1023) {
        // Zero or sub-normal
        if (x == 0) {
            // make sure 0 has the right sign
            sign = (bits & 0x8000000000000000L) != 0 ? -1 : 1;
            return;
        }

        exponent++;

        // Normalize the subnormal number
        while ((mantissa & 0x0010000000000000L) == 0) {
            exponent--;
            mantissa <<= 1;
        }
        mantissa &= 0x000fffffffffffffL;
    }

    if (exponent == 1024) {
        // infinity or NAN
        if (x != x) {
            sign = 1;
            nans = QNAN;
        } else if ((bits & 0x8000000000000000L) != 0) {
            sign = -1;
            nans = INFINITE;
        } else {
            sign = 1;
            nans = INFINITE;
        }
        return;
    }

    Dfp xdfp = new Dfp(field, mantissa);
    xdfp = xdfp.divide(new Dfp(field, 4503599627370496L)).add(field.getOne()); // Divide by 2^52, then add one
    xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));

    if ((bits & 0x8000000000000000L) != 0) {
        xdfp = xdfp.negate();
    }

    System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);
    sign = xdfp.sign;
    exp = xdfp.exp;
    nans = xdfp.nans;
}",0,0
321,Math_54,"    public double toDouble() {

        if (isInfinite()) {
            if (lessThan(getZero())) {
                return Double.NEGATIVE_INFINITY;
            } else {
                return Double.POSITIVE_INFINITY;
            }
        }

        if (isNaN()) {
            return Double.NaN;
        }

        Dfp y = this;
        boolean negate = false;
        if (lessThan(getZero())) {
            y = negate();
            negate = true;
        }

        /* Find the exponent, first estimate by integer log10, then adjust.
         Should be faster than doing a natural logarithm.  */
        int exponent = (int)(y.log10() * 3.32);
        if (exponent < 0) {
            exponent--;
        }

        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);
        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {
            tempDfp = tempDfp.multiply(2);
            exponent++;
        }
        exponent--;

        /* We have the exponent, now work on the mantissa */

        y = y.divide(DfpMath.pow(getTwo(), exponent));
        if (exponent > -1023) {
            y = y.subtract(getOne());
        }

        if (exponent < -1074) {
            return 0;
        }

        if (exponent > 1023) {
            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
        }


        y = y.multiply(newInstance(4503599627370496l)).rint();
        String str = y.toString();
        str = str.substring(0, str.length()-1);
        long mantissa = Long.parseLong(str);

        if (mantissa == 4503599627370496L) {
            // Handle special case where we round up to next power of two
            mantissa = 0;
            exponent++;
        }

        /* Its going to be subnormal, so make adjustments */
        if (exponent <= -1023) {
            exponent--;
        }

        while (exponent < -1023) {
            exponent++;
            mantissa >>>= 1;
        }

        long bits = mantissa | ((exponent + 1023L) << 52);
        double x = Double.longBitsToDouble(bits);

        if (negate) {
            x = -x;
        }

        return x;

    }
","public double toDouble() {

    if (isInfinite()) {
        return lessThan(getZero()) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
    }

    if (isNaN()) {
        return Double.NaN;
    }

    Dfp y = this;
    boolean negate = false;
    if (lessThan(getZero())) {
        y = y.negate();
        negate = true;
    }

    // Find the exponent
    int exponent = (int) (y.log10() * 3.32);
    if (exponent < 0) {
        exponent--;
    }

    Dfp tempDfp = DfpMath.pow(getTwo(), exponent);
    while (tempDfp.lessThan(y)) {
        tempDfp = tempDfp.multiply(2);
        exponent++;
    }
    while (tempDfp.greaterThan(y)) {
        tempDfp = tempDfp.divide(2);
        exponent--;
    }

    // Work on the mantissa
    y = y.divide(DfpMath.pow(getTwo(), exponent));
    if (exponent > -1023) {
        y = y.subtract(getOne());
    }

    if (exponent < -1074) {
        return 0;
    }

    if (exponent > 1023) {
        return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
    }

    y = y.multiply(newInstance(4503599627370496L)).rint();
    long mantissa = y.toLong();

    if (mantissa == 4503599627370496L) {
        mantissa = 0;
        exponent++;
    }

    if (exponent <= -1023) {
        exponent = -1023;
        mantissa >>>= 1;
    }

    while (exponent < -1023) {
        exponent++;
        mantissa >>>= 1;
    }

    long bits = mantissa | ((long) (exponent + 1023) << 52);
    double x = Double.longBitsToDouble(bits);

    return negate ? -x : x;
}",0,0
322,Math_6,"@Override
    protected PointValuePair doOptimize() {
        checkParameters();

        final GoalType goal = getGoalType();
        final double[] guess = getStartPoint();
        final int n = guess.length;

        final double[][] direc = new double[n][n];
        for (int i = 0; i < n; i++) {
            direc[i][i] = 1;
        }

        final ConvergenceChecker<PointValuePair> checker
            = getConvergenceChecker();

         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
         int iter = 0;
         while (true) {
             ++iter;
 
             double fX = fVal;
             double fX2 = 0;
            double delta = 0;
            int bigInd = 0;
            double alphaMin = 0;

            for (int i = 0; i < n; i++) {
                final double[] d = MathArrays.copyOf(direc[i]);

                fX2 = fVal;

                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];

                if ((fX2 - fVal) > delta) {
                    delta = fX2 - fVal;
                    bigInd = i;
                }
            }

            // Default convergence check.
            boolean stop = 2 * (fX - fVal) <=
                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +
                 absoluteThreshold);

            final PointValuePair previous = new PointValuePair(x1, fX);
            final PointValuePair current = new PointValuePair(x, fVal);
            if (!stop) { // User-defined stopping criteria.
                if (checker != null) {
                    stop = checker.converged(iter, previous, current);
                }
            }
            if (stop) {
                if (goal == GoalType.MINIMIZE) {
                    return (fVal < fX) ? current : previous;
                } else {
                    return (fVal > fX) ? current : previous;
                }
            }

            final double[] d = new double[n];
            final double[] x2 = new double[n];
            for (int i = 0; i < n; i++) {
                d[i] = x[i] - x1[i];
                x2[i] = 2 * x[i] - x1[i];
            }

            x1 = x.clone();
            fX2 = computeObjectiveValue(x2);

            if (fX > fX2) {
                double t = 2 * (fX + fX2 - 2 * fVal);
                double temp = fX - fVal - delta;
                t *= temp * temp;
                temp = fX - fX2;
                t -= delta * temp * temp;

                if (t < 0.0) {
                    final UnivariatePointValuePair optimum = line.search(x, d);
                    fVal = optimum.getValue();
                    alphaMin = optimum.getPoint();
                    final double[][] result = newPointAndDirection(x, d, alphaMin);
                    x = result[0];

                    final int lastInd = n - 1;
                    direc[bigInd] = direc[lastInd];
                    direc[lastInd] = result[1];
                }
            }
        }
    }",Match failed,0,0
322,Math_6,"@Override
    protected PointValuePair doOptimize() {
        checkParameters();

        // Indirect call to ""computeObjectiveValue"" in order to update the
        // evaluations counter.
        final MultivariateFunction evalFunc
            = new MultivariateFunction() {
                public double value(double[] point) {
                    return computeObjectiveValue(point);
                }
            };

        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final Comparator<PointValuePair> comparator
            = new Comparator<PointValuePair>() {
            public int compare(final PointValuePair o1,
                               final PointValuePair o2) {
                final double v1 = o1.getValue();
                final double v2 = o2.getValue();
                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
            }
        };

        // Initialize search.
        simplex.build(getStartPoint());
        simplex.evaluate(evalFunc, comparator);

        PointValuePair[] previous = null;
        int iteration = 0;
        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
        while (true) {
            if (iteration > 0) {
                boolean converged = true;
                for (int i = 0; i < simplex.getSize(); i++) {
                    PointValuePair prev = previous[i];
                    converged = converged &&
                        checker.converged(iteration, prev, simplex.getPoint(i));
                }
                if (converged) {
                    // We have found an optimum.
                    return simplex.getPoint(0);
                }
            }

            // We still need to search.
             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
 
+			++iteration;
         }
     }",Match failed,0,0
322,Math_6,"@Override
    protected PointVectorValuePair doOptimize() {
        checkParameters();

        final int nR = getTarget().length; // Number of observed data.
        final double[] currentPoint = getStartPoint();
        final int nC = currentPoint.length; // Number of parameters.

        // arrays shared with the other private methods
        solvedCols  = FastMath.min(nR, nC);
        diagR       = new double[nC];
        jacNorm     = new double[nC];
        beta        = new double[nC];
        permutation = new int[nC];
        lmDir       = new double[nC];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[nC];
        double[] oldX    = new double[nC];
        double[] oldRes  = new double[nR];
        double[] oldObj  = new double[nR];
        double[] qtf     = new double[nR];
        double[] work1   = new double[nC];
        double[] work2   = new double[nC];
        double[] work3   = new double[nC];

        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();

        // Evaluate the function at the starting point and calculate its norm.
        double[] currentObjective = computeObjectiveValue(currentPoint);
        double[] currentResiduals = computeResiduals(currentObjective);
        PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);
        double currentCost = computeCost(currentResiduals);

        // Outer loop.
        lmPar = 0;
        boolean firstIteration = true;
        int iter = 0;
        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
        while (true) {
            ++iter;
            final PointVectorValuePair previous = current;

            // QR decomposition of the jacobian matrix
            qrDecomposition(computeWeightedJacobian(currentPoint));

            weightedResidual = weightMatrixSqrt.operate(currentResiduals);
            for (int i = 0; i < nR; i++) {
                qtf[i] = weightedResidual[i];
            }

            // compute Qt.res
            qTy(qtf);

            // now we don't need Q anymore,
            // so let jacobian contain the R matrix with its diagonal elements
            for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                weightedJacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {
                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * currentPoint[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = FastMath.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (currentCost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += weightedJacobian[i][pj] * qtf[i];
                        }
                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // Convergence has been reached.
                setCost(currentCost);
                return current;
            }

            // rescale if necessary
            for (int j = 0; j < nC; ++j) {
                diag[j] = FastMath.max(diag[j], jacNorm[j]);
            }

            // Inner loop.
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = currentPoint[pj];
                }
                final double previousCost = currentCost;
                double[] tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes    = tmpVec;
                tmpVec    = currentObjective;
                currentObjective = oldObj;
                oldObj    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(qtf, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    currentPoint[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = FastMath.sqrt(lmNorm);
                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = FastMath.min(delta, lmNorm);
                }

                // Evaluate the function at x + p and calculate its norm.
                currentObjective = computeObjectiveValue(currentPoint);
                currentResiduals = computeResiduals(currentObjective);
                current = new PointVectorValuePair(currentPoint, currentObjective);
                currentCost = computeCost(currentResiduals);

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * currentCost < previousCost) {
                    double r = currentCost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += weightedJacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < nC; ++k) {
                        double xK = diag[k] * currentPoint[k];
                        xNorm += xK * xK;
                    }
                    xNorm = FastMath.sqrt(xNorm);

                     // tests for convergence.
                     if (checker != null) {
                         // we use the vectorial convergence checker
                         if (checker.converged(iter, previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
                    }
                } else {
                    // failed iteration, reset the previous values
                    currentCost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        currentPoint[pj] = oldX[pj];
                    }
                    tmpVec    = weightedResidual;
                    weightedResidual = oldRes;
                    oldRes    = tmpVec;
                    tmpVec    = currentObjective;
                    currentObjective = oldObj;
                    oldObj    = tmpVec;
                    // Reset ""current"" to previous values.
                    current = new PointVectorValuePair(currentPoint, currentObjective);
                }

                // Default convergence criteria.
                if ((FastMath.abs(actRed) <= costRelativeTolerance &&
                     preRed <= costRelativeTolerance &&
                     ratio <= 2.0) ||
                    delta <= parRelativeTolerance * xNorm) {
                    setCost(currentCost);
                    return current;
                }

                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                                                   costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                                                   parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                                                   orthoTolerance);
                }
            }
        }
    }",Match failed,0,0
322,Math_6,"@Override
    public PointVectorValuePair doOptimize() {
        checkParameters();

        final ConvergenceChecker<PointVectorValuePair> checker
            = getConvergenceChecker();

        // Computation will be useless without a checker (see ""for-loop"").
        if (checker == null) {
            throw new NullArgumentException();
        }

        final double[] targetValues = getTarget();
        final int nR = targetValues.length; // Number of observed data.

        final RealMatrix weightMatrix = getWeight();
        // Diagonal of the weight matrix.
        final double[] residualsWeights = new double[nR];
        for (int i = 0; i < nR; i++) {
            residualsWeights[i] = weightMatrix.getEntry(i, i);
        }

        final double[] currentPoint = getStartPoint();
        final int nC = currentPoint.length;

        // iterate until convergence is reached
        PointVectorValuePair current = null;
        int iter = 0;
        for (boolean converged = false; !converged;) {
            ++iter;

            // evaluate the objective function and its jacobian
            PointVectorValuePair previous = current;
            // Value of the objective function at ""currentPoint"".
            final double[] currentObjective = computeObjectiveValue(currentPoint);
            final double[] currentResiduals = computeResiduals(currentObjective);
            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);
            current = new PointVectorValuePair(currentPoint, currentObjective);

            // build the linear problem
            final double[]   b = new double[nC];
            final double[][] a = new double[nC][nC];
            for (int i = 0; i < nR; ++i) {

                final double[] grad   = weightedJacobian.getRow(i);
                final double weight   = residualsWeights[i];
                final double residual = currentResiduals[i];

                // compute the normal equation
                final double wr = weight * residual;
                for (int j = 0; j < nC; ++j) {
                    b[j] += wr * grad[j];
                }

                // build the contribution matrix for measurement i
                for (int k = 0; k < nC; ++k) {
                    double[] ak = a[k];
                    double wgk = weight * grad[k];
                    for (int l = 0; l < nC; ++l) {
                        ak[l] += wgk * grad[l];
                    }
                }
            }

            try {
                // solve the linearized least squares problem
                RealMatrix mA = new BlockRealMatrix(a);
                DecompositionSolver solver = useLU ?
                        new LUDecomposition(mA).getSolver() :
                        new QRDecomposition(mA).getSolver();
                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();
                // update the estimated parameters
                for (int i = 0; i < nC; ++i) {
                    currentPoint[i] += dX[i];
                }
            } catch (SingularMatrixException e) {
                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
            }
 
             // Check convergence.
             if (previous != null) {
                 converged = checker.converged(iter, previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;
                }
            }
        }
        // Must never happen.
        throw new MathInternalError();
    }",Match failed,0,0
322,Math_6,"@Override
    protected PointValuePair doOptimize() {
        checkParameters();

        // Indirect call to ""computeObjectiveValue"" in order to update the
        // evaluations counter.
        final MultivariateFunction evalFunc
            = new MultivariateFunction() {
                public double value(double[] point) {
                    return computeObjectiveValue(point);
                }
            };

        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final Comparator<PointValuePair> comparator
            = new Comparator<PointValuePair>() {
            public int compare(final PointValuePair o1,
                               final PointValuePair o2) {
                final double v1 = o1.getValue();
                final double v2 = o2.getValue();
                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
            }
        };

        // Initialize search.
        simplex.build(getStartPoint());
        simplex.evaluate(evalFunc, comparator);

        PointValuePair[] previous = null;
         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
             if (iteration > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];
                    converged = converged &&
                        checker.converged(iteration, prev, simplex.getPoint(i));
                }
                if (converged) {
                    // We have found an optimum.
                    return simplex.getPoint(0);
                }
            }

            // We still need to search.
            previous = simplex.getPoints();
            simplex.iterate(evalFunc, comparator);

			++iteration;
        }
    }",Match failed,0,0
322,Math_6,"@Override
    protected PointValuePair doOptimize() {
         // -------------------- Initialization --------------------------------
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
        final FitnessFunction fitfun = new FitnessFunction();
        final double[] guess = getStartPoint();
        // number of objective variables/problem dimension
        dimension = guess.length;
        initializeCMA(guess);
        iterations = 0;
        double bestValue = fitfun.value(guess);
        push(fitnessHistory, bestValue);
        PointValuePair optimum
            = new PointValuePair(getStartPoint(),
                                 isMinimize ? bestValue : -bestValue);
        PointValuePair lastResult = null;

        // -------------------- Generation Loop --------------------------------
 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
 
             // Generate and evaluate lambda offspring
             final RealMatrix arz = randn1(dimension, lambda);
            final RealMatrix arx = zeros(dimension, lambda);
            final double[] fitness = new double[lambda];
            // generate random offspring
            for (int k = 0; k < lambda; k++) {
                RealMatrix arxk = null;
                for (int i = 0; i < checkFeasableCount + 1; i++) {
                    if (diagonalOnly <= 0) {
                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)
                    } else {
                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
                                         .scalarMultiply(sigma));
                    }
                    if (i >= checkFeasableCount ||
                        fitfun.isFeasible(arxk.getColumn(0))) {
                        break;
                    }
                    // regenerate random arguments for row
                    arz.setColumn(k, randn(dimension));
                }
                copyColumn(arxk, 0, arx, k);
                try {
                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
                } catch (TooManyEvaluationsException e) {
                    break generationLoop;
                }
            }
            // Sort by fitness and compute weighted mean into xmean
            final int[] arindex = sortedIndices(fitness);
            // Calculate new xmean, this is selection and recombination
            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
            xmean = bestArx.multiply(weights);
            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
            final RealMatrix zmean = bestArz.multiply(weights);
            final boolean hsig = updateEvolutionPaths(zmean, xold);
            if (diagonalOnly <= 0) {
                updateCovariance(hsig, bestArx, arz, arindex, xold);
            } else {
                updateCovarianceDiagonalOnly(hsig, bestArz);
            }
            // Adapt step size sigma - Eq. (5)
            sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));
            final double bestFitness = fitness[arindex[0]];
            final double worstFitness = fitness[arindex[arindex.length - 1]];
            if (bestValue > bestFitness) {
                bestValue = bestFitness;
                lastResult = optimum;
                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),
                                             isMinimize ? bestFitness : -bestFitness);
                if (getConvergenceChecker() != null &&
                    lastResult != null) {
                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                        break generationLoop;
                    }
                }
            }
            // handle termination criteria
            // Break, if fitness is good enough
            if (stopFitness != 0) { // only if stopFitness is defined
                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                    break generationLoop;
                }
            }
            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
            final double[] pcCol = pc.getColumn(0);
            for (int i = 0; i < dimension; i++) {
                if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                    break;
                }
                if (i >= dimension - 1) {
                    break generationLoop;
                }
            }
            for (int i = 0; i < dimension; i++) {
                if (sigma * sqrtDiagC[i] > stopTolUpX) {
                    break generationLoop;
                }
            }
            final double historyBest = min(fitnessHistory);
            final double historyWorst = max(fitnessHistory);
            if (iterations > 2 &&
                Math.max(historyWorst, worstFitness) -
                Math.min(historyBest, bestFitness) < stopTolFun) {
                break generationLoop;
            }
            if (iterations > fitnessHistory.length &&
                historyWorst - historyBest < stopTolHistFun) {
                break generationLoop;
            }
            // condition number of the covariance matrix exceeds 1e14
            if (max(diagD) / min(diagD) > 1e7) {
                break generationLoop;
            }
            // user defined termination
            if (getConvergenceChecker() != null) {
                final PointValuePair current
                    = new PointValuePair(bestArx.getColumn(0),
                                         isMinimize ? bestFitness : -bestFitness);
                if (lastResult != null &&
                    getConvergenceChecker().converged(iterations, current, lastResult)) {
                    break generationLoop;
                    }
                lastResult = current;
            }
            // Adjust step size in case of equal function values (flat fitness)
            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
                sigma = sigma * Math.exp(0.2 + cs / damps);
            }
            if (iterations > 2 && Math.max(historyWorst, bestFitness) -
                Math.min(historyBest, bestFitness) == 0) {
                sigma = sigma * Math.exp(0.2 + cs / damps);
            }
            // store best in history
            push(fitnessHistory,bestFitness);
            fitfun.setValueRange(worstFitness-bestFitness);
            if (generateStatistics) {
                statisticsSigmaHistory.add(sigma);
                statisticsFitnessHistory.add(bestFitness);
                statisticsMeanHistory.add(xmean.transpose());
                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
            }
        }
        return optimum;
    }",Match failed,0,0
322,Math_6,"@Override
    protected PointValuePair doOptimize() {
        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
        final double[] point = getStartPoint();
        final GoalType goal = getGoalType();
        final int n = point.length;
        double[] r = computeObjectiveGradient(point);
        if (goal == GoalType.MINIMIZE) {
            for (int i = 0; i < n; i++) {
                r[i] = -r[i];
            }
        }

        // Initial search direction.
        double[] steepestDescent = preconditioner.precondition(point, r);
        double[] searchDirection = steepestDescent.clone();

        double delta = 0;
        for (int i = 0; i < n; ++i) {
            delta += r[i] * searchDirection[i];
        }

        PointValuePair current = null;
        int iter = 0;
        int maxEval = getMaxEvaluations();
        while (true) {
            ++iter;

            final double objective = computeObjectiveValue(point);
            PointValuePair previous = current;
            current = new PointValuePair(point, objective);
            if (previous != null) {
                if (checker.converged(iter, previous, current)) {
                    // We have found an optimum.
                    return current;
                }
            }

            // Find the optimal step in the search direction.
            final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);
            final double uB = findUpperBound(lsf, 0, initialStep);
            // XXX Last parameters is set to a value close to zero in order to
            // work around the divergence problem in the ""testCircleFitting""
            // unit test (see MATH-439).
            final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);
            maxEval -= solver.getEvaluations(); // Subtract used up evaluations.

            // Validate new point.
            for (int i = 0; i < point.length; ++i) {
                point[i] += step * searchDirection[i];
            }

            r = computeObjectiveGradient(point);
            if (goal == GoalType.MINIMIZE) {
                for (int i = 0; i < n; ++i) {
                    r[i] = -r[i];
                }
            }

            // Compute beta.
            final double deltaOld = delta;
            final double[] newSteepestDescent = preconditioner.precondition(point, r);
            delta = 0;
            for (int i = 0; i < n; ++i) {
                delta += r[i] * newSteepestDescent[i];
            }

            final double beta;
            switch (updateFormula) {
            case FLETCHER_REEVES:
                beta = delta / deltaOld;
                break;
            case POLAK_RIBIERE:
                double deltaMid = 0;
                for (int i = 0; i < r.length; ++i) {
                    deltaMid += r[i] * steepestDescent[i];
                }
                beta = (delta - deltaMid) / deltaOld;
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
            }
             steepestDescent = newSteepestDescent;
 
             // Compute conjugate search direction.
             if (iter % n == 0 ||
                 beta < 0) {
                 // Break conjugation: reset search direction.
                 searchDirection = steepestDescent.clone();
            } else {
                // Compute new conjugate search direction.
                for (int i = 0; i < n; ++i) {
                    searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
                }
            }
        }
    }",Match failed,0,0
323,Math_61,"    public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
        if (p <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
        }
        mean = p;
        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
        this.epsilon = epsilon;
        this.maxIterations = maxIterations;
    }
","public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
    if (p <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, Double.valueOf(p));
    }
    mean = p;
    normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
    this.epsilon = epsilon;
    this.maxIterations = maxIterations;

    if (epsilon <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_EPSILON, Double.valueOf(epsilon));
    }

    if (maxIterations <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_MAX_ITERATIONS, Integer.valueOf(maxIterations));
    }
}",0,0
324,Math_62,"public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,
                                                 final double min, final double max,
                                                 final double startValue)
        throws FunctionEvaluationException {
        optima = new UnivariateRealPointValuePair[starts];
        totalEvaluations = 0;

         // Multi-start loop.
         for (int i = 0; i < starts; ++i) {
             try {
                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
                 optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
             } catch (FunctionEvaluationException fee) {
                 optima[i] = null;
             } catch (ConvergenceException ce) {
                optima[i] = null;
            }

            final int usedEvaluations = optimizer.getEvaluations();
            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
            totalEvaluations += usedEvaluations;
        }

        sortPairs(goal);

        if (optima[0] == null) {
            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,
                                           starts);
        }

        // Return the point with the best objective function value.
        return optima[0];
    }","public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,
                                             final double min, final double max,
                                             final double startValue)
        throws FunctionEvaluationException {
    optima = new UnivariateRealPointValuePair[starts];
    totalEvaluations = 0;
    
    // Multi-start loop.
    for (int i = 0; i < starts; ++i) {
        try {
            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
            double lowerBound = FastMath.min(bound1, bound2);
            double upperBound = FastMath.max(bound1, bound2);
            if (lowerBound > upperBound) {
                throw new IllegalArgumentException(""Invalid bounds: lower bound > upper bound."");
            }
            optima[i] = optimizer.optimize(f, goal, lowerBound, upperBound);
        } catch (FunctionEvaluationException | ConvergenceException e) {
            optima[i] = null;
        }

        final int usedEvaluations = optimizer.getEvaluations();
        final int maxEvaluations = optimizer.getMaxEvaluations();
        if (usedEvaluations > maxEvaluations) {
            throw new IllegalArgumentException(""Used evaluations exceed max evaluations."");
        }
        optimizer.setMaxEvaluations(maxEvaluations - usedEvaluations);
        totalEvaluations += usedEvaluations;
    }

    sortPairs(goal);

    if (optima[0] == null) {
        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);
    }

    // Return the point with the best objective function value.
    return optima[0];
}",0,0
324,Math_62,"public UnivariateRealPointValuePair optimize(final FUNC f,
                                                  final GoalType goal,
                                                  final double min, final double max)
         throws FunctionEvaluationException {
         return optimize(f, goal, min, max, 0);
     }","public UnivariateRealPointValuePair optimize(final FUNC f,
                                             final GoalType goal,
                                             final double min, final double max)
        throws FunctionEvaluationException {
    if (min >= max) {
        throw new IllegalArgumentException(""Invalid bounds: min must be less than max."");
    }
    return optimize(f, goal, min, max, (min + max) / 2);  // Start with a sensible midpoint value.
}",0,0
325,Math_65,"public double getChiSquare() {
         double chiSquare = 0;
         for (int i = 0; i < rows; ++i) {
             final double residual = residuals[i];
             chiSquare += residual * residual / residualsWeights[i];
         }
         return chiSquare;
     }","public double getChiSquare() {
    double chiSquare = 0;
    for (int i = 0; i < rows; ++i) {
        if (i < residuals.length && i < residualsWeights.length) { // Ensure indices are within valid bounds
            final double residual = residuals[i];
            chiSquare += residual * residual / residualsWeights[i];
        }
    }
    return chiSquare;
}",0,0
326,Math_66,"private double localMin(boolean isMinim,
                            UnivariateRealFunction f,
                            GoalType goalType,
                            double lo, double mid, double hi,
                            double eps, double t)
        throws MaxIterationsExceededException, FunctionEvaluationException {
        if (eps <= 0) {
            throw new NotStrictlyPositiveException(eps);
        }
        if (t <= 0) {
            throw new NotStrictlyPositiveException(t);
        }
        double a, b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
         double w = x;
         double d = 0;
         double e = 0;
         double fx = computeObjectiveValue(f, x);
         if (goalType == GoalType.MAXIMIZE) {
             fx = -fx;
         }
         double fv = fx;
         double fw = fx;
 
         int count = 0;
         while (count < maximalIterationCount) {
             double m = 0.5 * (a + b);
             final double tol1 = eps * Math.abs(x) + t;
             final double tol2 = 2 * tol1;

            // Check stopping criterion.
            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (Math.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x)
                        && p < q * (b - x)
                        && Math.abs(p) < Math.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2
                            || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (Math.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(f, u);
                if (goalType == GoalType.MAXIMIZE) {
                    fu = -fu;
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw
                        || w == x) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv
                               || v == x
                               || v == w) {
                        v = u;
                        fv = fu;
                    }
                }
            } else { // termination
                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
                return x;
            }
            ++count;
        }
        throw new MaxIterationsExceededException(maximalIterationCount);
    }","private double localMin(boolean isMinim,
                        UnivariateRealFunction f,
                        GoalType goalType,
                        double lo, double mid, double hi,
                        double eps, double t)
        throws MaxIterationsExceededException, FunctionEvaluationException {
    if (eps <= 0) {
        throw new NotStrictlyPositiveException(eps);
    }
    if (t <= 0) {
        throw new NotStrictlyPositiveException(t);
    }
    if (maximalIterationCount <= 0) {
        throw new MaxIterationsExceededException(maximalIterationCount);
    }

    double a, b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(f, x);
    if (goalType == GoalType.MAXIMIZE) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    int count = 0;
    while (count < maximalIterationCount) {
        double m = 0.5 * (a + b);
        final double tol1 = eps * Math.abs(x) + t;
        final double tol2 = 2 * tol1;

        if (Math.abs(x - m) <= (tol2 - 0.5 * (b - a))) {
            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
            return x;
        }

        double p = 0;
        double q = 0;
        double r = 0;

        if (Math.abs(e) > tol1) {
            // Fit parabola
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            r = e;
            e = d;

            if (p > (q * (a - x)) && p < (q * (b - x)) && Math.abs(p) < Math.abs(0.5 * q * r)) {
                // Parabolic interpolation step.
                d = p / q;
                double u = x + d;

                if (u - a < tol2 || b - u < tol2) {
                    d = (x <= m) ? tol1 : -tol1;
                }
            } else {
                // Golden section step
                e = (x < m) ? (b - x) : (a - x);
                d = GOLDEN_SECTION * e;
            }
        } else {
            // Golden section step
            e = (x < m) ? (b - x) : (a - x);
            d = GOLDEN_SECTION * e;
        }

        // Update by at least ""tol1"".
        if (Math.abs(d) < tol1) {
            d = (d >= 0) ? tol1 : -tol1;
        }

        double u = x + d;
        double fu = computeObjectiveValue(f, u);
        if (goalType == GoalType.MAXIMIZE) {
            fu = -fu;
        }

        // Update a, b, v, w, and x.
        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || w == x) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || v == x || v == w) {
                v = u;
                fv = fu;
            }
        }
        ++count;
    }
    throw new MaxIterationsExceededException(maximalIterationCount);
}",0,0
327,Math_67,"    public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,
                                             final int starts,
                                             final RandomGenerator generator) {
        this.optimizer        = optimizer;
        this.totalIterations  = 0;
        this.starts           = starts;
        this.generator        = generator;
        this.optima           = null;
        setMaximalIterationCount(Integer.MAX_VALUE);
        setMaxEvaluations(Integer.MAX_VALUE);
    }
","public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,
                                             final int starts,
                                             final RandomGenerator generator) {
    if (optimizer == null) {
        throw new IllegalArgumentException(""Optimizer must not be null."");
    }
    if (generator == null) {
        throw new IllegalArgumentException(""Random generator must not be null."");
    }
    if (starts < 1) {
        throw new IllegalArgumentException(""Number of starts must be at least 1."");
    }
    
    this.optimizer        = optimizer;
    this.totalIterations  = 0;
    this.starts           = starts;
    this.generator        = generator;
    this.optima           = null;
    setMaximalIterationCount(Integer.MAX_VALUE);
    setMaxEvaluations(Integer.MAX_VALUE);
}",0,0
328,Math_68,"@Override
    protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        // arrays shared with the other private methods
        solvedCols  = Math.min(rows, cols);
        diagR       = new double[cols];
        jacNorm     = new double[cols];
        beta        = new double[cols];
        permutation = new int[cols];
        lmDir       = new double[cols];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[cols];
        double[] oldX    = new double[cols];
        double[] oldRes  = new double[rows];
        double[] work1   = new double[cols];
        double[] work2   = new double[cols];
        double[] work3   = new double[cols];

        // evaluate the function at the starting point and calculate its norm
        updateResidualsAndCost();

         // outer loop
         lmPar = 0;
         boolean firstIteration = true;
         while (true) {
 
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
             updateJacobian();
             qrDecomposition();
 
            // compute Qt.res
            qTy(residuals);

            // now we don't need Q anymore,
            // so let jacobian contain the R matrix with its diagonal elements
            for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                jacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {

                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * point[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = Math.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (cost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // convergence has been reached
                return new VectorialPointValuePair(point, objective);
            }

            // rescale if necessary
            for (int j = 0; j < cols; ++j) {
                diag[j] = Math.max(diag[j], jacNorm[j]);
            }

            // inner loop
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }
                double previousCost = cost;
                double[] tmpVec = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(oldRes, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = Math.sqrt(lmNorm);

                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = Math.min(delta, lmNorm);
                }

                // evaluate the function at x + p and calculate its norm
                updateResidualsAndCost();

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * cost < previousCost) {
                    double r = cost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += jacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * Math.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < cols; ++k) {
                        double xK = diag[k] * point[k];
                        xNorm    += xK * xK;
                    }
                    xNorm = Math.sqrt(xNorm);
                } else {
                    // failed iteration, reset the previous values
                    cost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }
                    tmpVec    = residuals;
                    residuals = oldRes;
                    oldRes    = tmpVec;
                }

                // tests for convergence.
                    // we use the vectorial convergence checker
                    // we use the Levenberg-Marquardt specific convergence parameters
                    if (((Math.abs(actRed) <= costRelativeTolerance) &&
                         (preRed <= costRelativeTolerance) &&
                         (ratio <= 2.0)) ||
                        (delta <= parRelativeTolerance * xNorm)) {
                        return new VectorialPointValuePair(point, objective);
                    }

                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new OptimizationException(""cost relative tolerance is too small ({0}),"" +
                            "" no further reduction in the"" +
                            "" sum of squares is possible"",
                            costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new OptimizationException(""parameters relative tolerance is too small"" +
                            "" ({0}), no further improvement in"" +
                            "" the approximate solution is possible"",
                            parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new OptimizationException(""orthogonality tolerance is too small ({0}),"" +
                            "" solution is orthogonal to the jacobian"",
                            orthoTolerance);
                }

            }

        }

    }","@Override
protected VectorialPointValuePair doOptimize()
    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];

    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];

    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();

    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    while (true) {
        incrementIterationsCounter();

        // compute the Q.R. decomposition of the jacobian matrix
        updateJacobian();
        qrDecomposition();

        // compute Qt.res
        qTy(residuals);

        // now we don't need Q anymore,
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }

        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);

            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }

        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return new VectorialPointValuePair(point, objective);
        }

        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }

        // inner loop
        double ratio = 0;
        while (true) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;

            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);

            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);

            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }

            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();

            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }

            // compute the scaled predicted reduction
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (double value : work1) {
                coeff1 += value * value;
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);

            // ratio of the actual to the predicted reduction
            if (preRed != 0) {
                ratio = actRed / preRed;
            }

            // update the step bound
            if (ratio <= 0.25) {
                double tmp =
                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }

            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
                break;
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }

            // tests for convergence
            if (((Math.abs(actRed) <= costRelativeTolerance) &&
                 (preRed <= costRelativeTolerance) &&
                 (ratio <= 2.0)) ||
                (delta <= parRelativeTolerance * xNorm)) {
                return new VectorialPointValuePair(point, objective);
            }

            // tests for termination and stringent tolerances
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(""cost relative tolerance is too small ({0}),"" +
                        "" no further reduction in the"" +
                        "" sum of squares is possible"",
                        costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(""parameters relative tolerance is too small"" +
                        "" ({0}), no further improvement in"" +
                        "" the approximate solution is possible"",
                        parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(""orthogonality tolerance is too small ({0}),"" +
                        "" solution is orthogonal to the jacobian"",
                        orthoTolerance);
            }
        }
    }
}",0,0
329,Math_71,"@Override
  public double integrate(final FirstOrderDifferentialEquations equations,
                          final double t0, final double[] y0,
                          final double t, final double[] y)
  throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart         = t0;
    double  hNew      = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      double error = 0;
      for (boolean loop = true; loop;) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[y0.length];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
              }
            } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
              }
            }
          hNew = initializeStep(equations, forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
        }

        stepSize = hNew;

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error <= 1.0) {

          // discrete events handling
          interpolator.storeTime(stepStart + stepSize);
          if (manager.evaluateStep(interpolator)) {
              final double dt = manager.getEventTime() - stepStart;
              if (Math.abs(dt) <= Math.ulp(stepStart)) {
                  // we cannot simply truncate the step, reject the current computation
                  // and let the loop compute another state with the truncated step.
                   // it is so small (much probably exactly 0 due to limited accuracy)
                   // that the code above would fail handling it.
                   // So we set up an artificial 0 size step by copying states
                   loop     = false;
               } else {
                   // reject the step to match exactly the next switch time
                  hNew = dt;
              }
          } else {
            // accept the step
            loop = false;
          }

        } else {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              Math.min(maxGrowth,
                       Math.max(minReduction, safety * Math.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
          handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (fsal) {
        // save the last evaluation for the next step
        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
      }

      if (manager.reset(stepStart, y) && ! lastStep) {
        // some event handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      if (! lastStep) {
        // in some rare cases we may get here with stepSize = 0, for example
        // when an event occurs at integration start, reducing the first step
        // to zero; we have to reset the step to some safe non zero value
          stepSize = filterStep(stepSize, forward, true);

        // stepsize control for next step
        final double factor = Math.min(maxGrowth,
                                       Math.max(minReduction,
                                                safety * Math.pow(error, exp)));
        final double  scaledH    = stepSize * factor;
        final double  nextT      = stepStart + scaledH;
        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
        hNew = filterStep(scaledH, forward, nextIsLast);
      }

    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;

  }","@Override
public double integrate(final FirstOrderDifferentialEquations equations,
                        final double t0, final double[] y0,
                        final double t, final double[] y)
        throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

        interpolator.shift();

        double error = 0;
        for (boolean loop = true; loop;) {

            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }

            if (firstTime) {
                final double[] scale = new double[y0.length];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
                    }
                }
                hNew = initializeStep(equations, forward, getOrder(), scale,
                        stepStart, y, yDotK[0], yTmp, yDotK[1]);
                if (hNew == 0.0 || Double.isNaN(hNew)) {
                    throw new IntegratorException(""Initial step size cannot be zero or NaN"");
                }
                firstTime = false;
            }

            stepSize = hNew;

            // next stages
            for (int k = 1; k < stages; ++k) {

                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }

                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);

            }

            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {

                // discrete events handling
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        loop = false; // avoid division by zero in future steps
                    } else {
                        hNew = dt;
                    }
                } else {
                    loop = false;
                }

            } else {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }

        }

        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();

        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;

        if (fsal) {
            // save the last evaluation for the next step
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }

        if (manager.reset(stepStart, y) && !lastStep) {
            computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (!lastStep) {
            stepSize = filterStep(stepSize, forward, true);

            // stepsize control for next step
            final double factor = Math.min(maxGrowth,
                    Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);

            if (hNew == 0.0 || Double.isNaN(hNew)) {
                throw new IntegratorException(""Step size cannot be zero or NaN"");
            }
        }
    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}",0,0
329,Math_71,"public double integrate(final FirstOrderDifferentialEquations equations,
                          final double t0, final double[] y0,
                          final double t, final double[] y)
  throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
      yDotK [i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart = t0;
    stepSize  = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      for (boolean loop = true; loop;) {

        // first stage
        computeDerivatives(stepStart, y, yDotK[0]);

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // discrete events handling
        interpolator.storeTime(stepStart + stepSize);
        if (manager.evaluateStep(interpolator)) {
            final double dt = manager.getEventTime() - stepStart;
            if (Math.abs(dt) <= Math.ulp(stepStart)) {
                // we cannot simply truncate the step, reject the current computation
                // and let the loop compute another state with the truncated step.
                 // it is so small (much probably exactly 0 due to limited accuracy)
                 // that the code above would fail handling it.
                 // So we set up an artificial 0 size step by copying states
                 loop     = false;
             } else {
                 // reject the step to match exactly the next switch time
                stepSize = dt;
            }
        } else {
          loop = false;
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
          handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (manager.reset(stepStart, y) && ! lastStep) {
        // some events handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      // make sure step size is set to default before next step
      stepSize = forward ? step : -step;

    }

    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize  = Double.NaN;
    return stopTime;

  }","@Override
public double integrate(final FirstOrderDifferentialEquations equations,
                        final double t0, final double[] y0,
                        final double t, final double[] y)
        throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart = t0;
    stepSize = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

        interpolator.shift();

        for (boolean loop = true; loop;) {

            // first stage
            computeDerivatives(stepStart, y, yDotK[0]);

            // next stages
            for (int k = 1; k < stages; ++k) {

                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }

                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);

            }

            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            // discrete events handling
            interpolator.storeTime(stepStart + stepSize);
            if (manager.evaluateStep(interpolator)) {
                final double dt = manager.getEventTime() - stepStart;
                if (Math.abs(dt) <= Math.ulp(stepStart)) {
                    loop = false;
                } else {
                    stepSize = dt;
                }
            } else {
                loop = false;
            }
        }

        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();

        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;

        if (manager.reset(stepStart, y) && !lastStep) {
            computeDerivatives(stepStart, y, yDotK[0]);
        }

        // stepsize reset for next step
        stepSize = forward ? step : -step;
    }

    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize = Double.NaN;
    return stopTime;
}",0,0
330,Math_76,"public RealMatrix getU()
        throws InvalidMatrixException {

        if (cachedU == null) {

            final int p = singularValues.length;
             if (m >= n) {
                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                 final RealMatrix e =
                     eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
                 for (int i = 0; i < p - 1; ++i) {
                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                 }
                         for (int j = 0; j < p; ++j) {
                             wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
                         }
 
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];
                }
                cachedU =
                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
            } else {
                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
                cachedU = transformer.getU().multiply(e);
            }

        }

        // return the cached matrix
        return cachedU;

    }","public RealMatrix getU() throws InvalidMatrixException {
    if (cachedU == null) {
        final int p = singularValues.length;
        if (m >= n) {
            if (singularValues.length == 0) {
                throw new InvalidMatrixException(""Singular values array is empty."");
            }
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[m][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p - 1; ++i) {
                // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                ei1 = eData[i + 1];
                final double si = secondaryBidiagonal[i];
                for (int j = 0; j < p; ++j) {
                    wi[j] = (mi * ei0[j] + si * ei1[j]) / (singularValues[j] != 0 ? singularValues[j] : Double.MIN_VALUE);
                }
            }
            for (int j = 0; j < p; ++j) {
                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
            }

            for (int i = p; i < m; ++i) {
                wData[i] = new double[p];
            }
            cachedU =
                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
            cachedU = transformer.getU().multiply(e);
        }
    }
    return cachedU;
}",0,0
330,Math_76,"public RealMatrix getV()
        throws InvalidMatrixException {

        if (cachedV == null) {

            final int p = singularValues.length;
            if (m >= n) {
                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
                cachedV = transformer.getV().multiply(e);
            } else {
                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
                 final RealMatrix e =
                     eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
                 for (int i = 0; i < p - 1; ++i) {
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                 }
                         for (int j = 0; j < p; ++j) {
                             wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
                         }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }
                cachedV =
                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));
            }

        }

        // return the cached matrix
        return cachedV;

    }","public RealMatrix getV() throws InvalidMatrixException {
    if (cachedV == null) {
        final int p = singularValues.length;
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
            cachedV = transformer.getV().multiply(e);
        } else {
            if (singularValues.length == 0) {
                throw new InvalidMatrixException(""Singular values array is empty."");
            }
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
            final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[n][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p - 1; ++i) {
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                ei1 = eData[i + 1];
                final double si = secondaryBidiagonal[i];
                for (int j = 0; j < p; ++j) {
                    wi[j] = (mi * ei0[j] + si * ei1[j]) / (singularValues[j] != 0 ? singularValues[j] : Double.MIN_VALUE);
                }
            }
            for (int j = 0; j < p; ++j) {
                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
            }
            for (int i = p; i < n; ++i) {
                wData[i] = new double[p];
            }
            cachedV =
                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));
        }
    }
    return cachedV;
}",0,0
331,Math_77,"@Override
     public double getLInfNorm() {
         double max = 0;
         for (double a : data) {
             max += Math.max(max, Math.abs(a));
         }
         return max;
     }","@Override
public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max = Math.max(max, Math.abs(a));
    }
    return max;
}",0,0
332,Math_81,"private void computeShiftIncrement(final int start, final int end, final int deflated) {

        final double cnst1 = 0.563;
        final double cnst2 = 1.010;
        final double cnst3 = 1.05;

        // a negative dMin forces the shift to take that absolute value
        // tType records the type of shift.
        if (dMin <= 0.0) {
            tau = -dMin;
            tType = -1;
            return;
        }

        int nn = 4 * end + pingPong - 1;
        switch (deflated) {

        case 0 : // no realEigenvalues deflated.
            if (dMin == dN || dMin == dN1) {

                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];

                if (dMin == dN && dMin1 == dN1) {
                    // cases 2 and 3.
                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau   = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                    // case 4.
                    tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5]  >  work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4]  >  work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9]  >  work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }

                    // approximate contribution to norm squared from i < nn-1.
                    a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if(b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;

                    // rayleigh quotient residual bound.
                    if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;

                }
            } else if (dMin == dN2) {

                // case 5.
                tType = -5;
                double s = 0.25 * dMin;

                // compute contribution to norm squared from i > nn-2.
                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
 
                 // approximate contribution to norm squared from i < nn-2.
                 if (end - start > 2) {
                     b2 = work[nn - 13] / work[nn - 15];
                     a2 = a2 + b2;
                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }

                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }

            } else {

                // case 6, no information to guide us.
                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau   = g * dMin;
                tType = -6;

            }
            break;

        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
            if (dMin1 == dN1 && dMin2 == dN2) {

                // cases 7 and 8.
                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {

                // case 9.
                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;

        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.

            // cases 10 and 11.
            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0){
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] -
                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau   = 0.25 * dMin2;
                tType = -11;
            }
            break;

        default : // case 12, more than two realEigenvalues deflated. no information.
            tau   = 0.0;
            tType = -12;
        }

    }","private void computeShiftIncrement(final int start, final int end, final int deflated) {
    final double cnst1 = 0.563;
    final double cnst2 = 1.010;
    final double cnst3 = 1.05;

    // Check if dMin is non-positive
    if (dMin <= 0.0) {
        tau = -dMin;
        tType = -1;
        return;
    }

    final int nn = 4 * end + pingPong - 1;
    switch (deflated) {

    case 0:
        if (dMin == dN || dMin == dN1) {
            final double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
            final double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
            double a2 = work[nn - 7] + work[nn - 5];

            if (dMin == dN && dMin1 == dN1) {
                final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                if (gap1 > 0.0 && gap1 > b1) {
                    tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                    tType = -2;
                } else {
                    double s = Math.max(dN - b1, 0.333 * dMin);
                    tau = Math.max(s, 0.333 * dMin);
                    tType = -3;
                }
            } else {
                double s = Math.max(0.25 * dMin, 0.0);
                tau = s;
                tType = -4;
            }
        } else if (dMin == dN2) {
            double s = Math.max(0.25 * dMin, 0.0);
            tau = s;
            tType = -5;
        } else {
            double g = (tType == -6) ? (0.333 * (1 - g)) : 0.25;
            tau = g * dMin;
            tType = -6;
        }
        break;

    case 1:
        if (dMin1 == dN1 && dMin2 == dN2) {
            final double s = 0.333 * dMin1;
            final double a2 = dMin1 / (1.0 + cnst2);
            tau = Math.max(s, a2 * (1 - cnst2));
            tType = -7;
        } else {
            tau = 0.5 * dMin1;
            tType = -9;
        }
        break;

    case 2:
        if (dMin2 == dN2) {
            final double s = 0.333 * dMin2;
            tau = Math.max(s, 0.25 * dMin2);
            tType = -10;
        } else {
            tau = 0.25 * dMin2;
            tType = -11;
        }
        break;

    default:
        tau = 0.0;
        tType = -12;
    }
}",0,0
332,Math_81,"private void processGeneralBlock(final int n)
        throws InvalidMatrixException {

        // check decomposed matrix data range
        double sumOffDiag = 0;
        for (int i = 0; i < n - 1; ++i) {
            final int fourI = 4 * i;
            final double ei = work[fourI + 2];
            sumOffDiag += ei;
        }

        if (sumOffDiag == 0) {
            // matrix is already diagonal
            return;
        }

        // initial checks for splits (see Parlett & Marques section 3.3)
        flipIfWarranted(n, 2);

        // two iterations with Li's test for initial splits
        initialSplits(n);

        // initialize parameters used by goodStep
        tType = 0;
        dMin1 = 0;
        dMin2 = 0;
        dN    = 0;
        dN1   = 0;
        dN2   = 0;
        tau   = 0;

        // process split segments
        int i0 = 0;
        int n0 = n;
        while (n0 > 0) {

            // retrieve shift that was temporarily stored as a negative off-diagonal element
            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];
            sigmaLow = 0;

            // find start of a new split segment to process
            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];
            double offDiagMax = 0;
            double diagMax    = work[4 * n0 - 4];
            double diagMin    = diagMax;
            i0 = 0;
            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
                if (work[i + 2] <= 0) {
                    i0 = 1 + i / 4;
                    break;
                }
                if (diagMin >= 4 * offDiagMax) {
                    diagMin    = Math.min(diagMin, work[i + 4]);
                    offDiagMax = Math.max(offDiagMax, work[i + 2]);
                }
                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);
                offDiagMin = Math.min(offDiagMin, work[i + 2]);
            }
            work[4 * n0 - 2] = offDiagMin;

            // lower bound of Gershgorin disk
            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));

            pingPong = 0;
            int maxIter = 30 * (n0 - i0);
            for (int k = 0; i0 < n0; ++k) {
                if (k >= maxIter) {
                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
                }

                // perform one step
                n0 = goodStep(i0, n0);
                pingPong = 1 - pingPong;

                // check for new splits after ""ping"" steps
                // when the last elements of qd array are very small
                if ((pingPong == 0) && (n0 - i0 > 3) &&
                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&
                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
                    int split  = i0 - 1;
                     diagMax    = work[4 * i0];
                     offDiagMin = work[4 * i0 + 2];
                     double previousEMin = work[4 * i0 + 3];
                     for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
                         if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
                             (work[i + 2] <= TOLERANCE_2 * sigma)) {
                             // insert a split
                             work[i + 2]  = -sigma;
                            split        = i / 4;
                            diagMax      = 0;
                            offDiagMin   = work[i + 6];
                            previousEMin = work[i + 7];
                        } else {
                            diagMax      = Math.max(diagMax, work[i + 4]);
                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);
                            previousEMin = Math.min(previousEMin, work[i + 3]);
                        }
                    }
                    work[4 * n0 - 2] = offDiagMin;
                    work[4 * n0 - 1] = previousEMin;
                    i0 = split + 1;
                }
            }

        }

    }","private void processGeneralBlock(final int n) throws InvalidMatrixException {
    double sumOffDiag = 0;
    for (int i = 0; i < n - 1; ++i) {
        sumOffDiag += work[4 * i + 2];
    }

    if (sumOffDiag == 0.0) {
        return;
    }

    flipIfWarranted(n, 2);
    initialSplits(n);

    tType = 0;
    dMin1 = dMin2 = dN = dN1 = dN2 = tau = 0;

    int i0 = 0;
    int n0 = n;
    while (n0 > 0) {
        sigma = (n0 == n) ? 0 : -work[4 * n0 - 2];
        sigmaLow = 0;

        double diagMax = work[4 * n0 - 4];
        i0 = 0;
        for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
            if (work[i + 2] <= 0) {
                i0 = 1 + i / 4;
                break;
            }
        }

        pingPong = 0;
        int maxIter = 30 * (n0 - i0);
        for (int k = 0; i0 < n0; ++k) {
            if (k >= maxIter) {
                throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
            }

            n0 = goodStep(i0, n0);
            pingPong = 1 - pingPong;

            if (pingPong == 0 && n0 - i0 > 3 && work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) {
                double offDiagMin = work[4 * n0 - 6];
                work[4 * n0 - 2] = offDiagMin;
                i0 = n0;
            }
        }
    }
}",0,0
332,Math_81,"private void computeGershgorinCircles() {

        final int m     = main.length;
        final int lowerStart = 4 * m;
        final int upperStart = 5 * m;
        lowerSpectra = Double.POSITIVE_INFINITY;
        upperSpectra = Double.NEGATIVE_INFINITY;
        double eMax = 0;

        double eCurrent = 0;
        for (int i = 0; i < m - 1; ++i) {

            final double dCurrent = main[i];
            final double ePrevious = eCurrent;
            eCurrent = Math.abs(secondary[i]);
            eMax = Math.max(eMax, eCurrent);
            final double radius = ePrevious + eCurrent;

            final double lower = dCurrent - radius;
            work[lowerStart + i] = lower;
            lowerSpectra = Math.min(lowerSpectra, lower);

            final double upper = dCurrent + radius;
            work[upperStart + i] = upper;
            upperSpectra = Math.max(upperSpectra, upper);

        }

        final double dCurrent = main[m - 1];
        final double lower = dCurrent - eCurrent;
        work[lowerStart + m - 1] = lower;
         lowerSpectra = Math.min(lowerSpectra, lower);
         final double upper = dCurrent + eCurrent;
         work[upperStart + m - 1] = upper;
         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
 
     }","private void computeGershgorinCircles() {
    final int m = main.length;
    final int lowerStart = 4 * m;
    final int upperStart = 5 * m;
    lowerSpectra = Double.POSITIVE_INFINITY;
    upperSpectra = Double.NEGATIVE_INFINITY;
    double eMax = 0;

    double eCurrent = 0;
    for (int i = 0; i < m - 1; ++i) {
        final double dCurrent = main[i];
        final double ePrevious = eCurrent;
        eCurrent = Math.abs(secondary[i]);
        eMax = Math.max(eMax, eCurrent);
        final double radius = ePrevious + eCurrent;

        final double lower = dCurrent - radius;
        work[lowerStart + i] = lower;
        lowerSpectra = Math.min(lowerSpectra, lower);

        final double upper = dCurrent + radius;
        work[upperStart + i] = upper;
        upperSpectra = Math.max(upperSpectra, upper);
    }

    final double dCurrent = main[m - 1];
    final double lower = dCurrent - eCurrent;
    work[lowerStart + m - 1] = lower;
    lowerSpectra = Math.min(lowerSpectra, lower);

    final double upper = dCurrent + eCurrent;
    work[upperStart + m - 1] = upper;
    minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
}",0,0
333,Math_83,"protected RealPointValuePair getSolution() {
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
       Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
       Set<Integer> basicRows = new HashSet<Integer>();
       for (int i = 0; i < coefficients.length; i++) {
           Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value 
               // then we choose the first and set the rest equal to 0
              coefficients[i] = 0;
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
        return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
    Set<Integer> basicRows = new HashSet<>();
    for (int i = 0; i < coefficients.length; i++) {
        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        if (basicRow != null && basicRows.contains(basicRow)) {
            // if multiple variables can take a given value 
            // then we choose the first and set the rest equal to 0
            coefficients[i] = 0;
        } else {
            if (basicRow != null) {
                basicRows.add(basicRow);
            }
            coefficients[i] =
                (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                (restrictToNonNegative ? 0 : mostNegative);
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,0
333,Math_83,"private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
         int start = getNumObjectiveFunctions();
         for (int i = start; i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                return null;
            }
        }
        return row;
    }","private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
    Integer row = null;
    int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0; // Adjusted to optionally ignore objective rows
    for (int i = start; i < getHeight(); i++) {
        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon)) {
            if (row == null) {
                row = i;
            } else {
                return null; // If more than one row matches, return null as it's not basic
            }
        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
            return null;
        }
    }
    return row;
}",0,0
334,Math_92,"public static long binomialCoefficient(final int n, final int k) {
        if (n < k) {
            throw new IllegalArgumentException(
                ""must have n >= k for binomial coefficient (n,k)"");
        }
        if (n < 0) {
            throw new IllegalArgumentException(
                ""must have n >= 0 for binomial coefficient (n,k)"");
        }
        if ((n == k) || (k == 0)) {
            return 1;
        }
         if ((k == 1) || (k == n - 1)) {
             return n;
         }
         long result = Math.round(binomialCoefficientDouble(n, k));
         if (result == Long.MAX_VALUE) {
             throw new ArithmeticException(
                 ""result too large to represent in a long integer"");
         }
         // Use symmetry for large k
         
         // We use the formula
         // (n choose k) = n! / (n-k)! / k!
         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
         // which could be written
         // (n choose k) == (n-1 choose k-1) * n / k
             // For n <= 61, the naive implementation cannot overflow.
             // For n > 61 but n <= 66, the result cannot overflow,
             // but we must take care not to overflow intermediate values.
                 // We know that (result * i) is divisible by j,
                 // but (result * i) may overflow, so we split j:
                 // Filter out the gcd, d, so j/d and i/d are integer.
                 // result is divisible by (j/d) because (j/d)
                 // is relative prime to (i/d) and is a divisor of
                 // result * (i/d).
             // For n > 66, a result overflow might occur, so we check
             // the multiplication, taking care to not overflow
             // unnecessary.
         return result;
     }","public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficient(n, n - k);
    }
    long result = 1;
    for (int i = 1; i <= k; i++) {
        long nextResult = result * (n - i + 1) / i;
        if (nextResult < result) {
            throw new ArithmeticException(""result too large to represent in a long integer"");
        }
        result = nextResult;
    }
    return result;
}",0,0
334,Math_92,"public static double binomialCoefficientLog(final int n, final int k) {
        if (n < k) {
            throw new IllegalArgumentException(
                ""must have n >= k for binomial coefficient (n,k)"");
        }
        if (n < 0) {
            throw new IllegalArgumentException(
                ""must have n >= 0 for binomial coefficient (n,k)"");
        }
        if ((n == k) || (k == 0)) {
            return 0;
        }
        if ((k == 1) || (k == n - 1)) {
            return Math.log((double) n);
        }
        
        /*
          * For values small enough to do exact integer computation,
          * return the log of the exact value 
          */
         
         /*
          * Return the log of binomialCoefficientDouble for values that will not
          * overflow binomialCoefficientDouble
          */
         
         /*
          * Sum logs for values that could overflow
         */
        double logSum = 0;

        // n!/k!
        for (int i = k + 1; i <= n; i++) {
            logSum += Math.log((double)i);
        }

        // divide by (n-k)!
        for (int i = 2; i <= n - k; i++) {
            logSum -= Math.log((double)i);
        }

        return logSum;      
    }","public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0.0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    double logSum = 0.0;

    // Use symmetry to reduce computation
    int effectiveK = Math.min(k, n - k);

    // Compute the log of the numerator (log(n! / (n-k)!))
    for (int i = 1; i <= effectiveK; i++) {
        logSum += Math.log((double) (n - effectiveK + i));
    }

    // Subtract the log of the denominator (log(k!))
    for (int i = 1; i <= effectiveK; i++) {
        logSum -= Math.log((double) i);
    }

    return logSum;
}",0,0
335,Math_93,"public static double factorialLog(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n > 0 for n!"");
         }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);
        }
        return logSum;
    }","public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n == 0 || n == 1) {
        return 0.0; // log(1) == 0 for factorial of 0 or 1
    }
    double logSum = 0.0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}",0,0
335,Math_93,"public static double factorialDouble(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n >= 0 for n!"");
         }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }","public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n == 0 || n == 1) {
        return 1.0; // factorial of 0 or 1 is 1
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}",0,0
336,Math_98,"public double[] operate(double[] v) throws IllegalArgumentException {
        final int nRows = this.getRowDimension();
        final int nCols = this.getColumnDimension();
         if (v.length != nCols) {
             throw new IllegalArgumentException(""vector has wrong length"");
         }
         final double[] out = new double[v.length];
         for (int row = 0; row < nRows; row++) {
             final double[] dataRow = data[row];
             double sum = 0;
            for (int i = 0; i < nCols; i++) {
                sum += dataRow[i] * v[i];
            }
            out[row] = sum;
        }
        return out;
    }","public double[] operate(double[] v) throws IllegalArgumentException {
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    if (v.length != nCols) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final double[] out = new double[nRows]; // Fix: Adjusted the size of the output array
    for (int row = 0; row < nRows; row++) {
        final double[] dataRow = data[row];
        double sum = 0;
        for (int i = 0; i < nCols; i++) {
            sum += dataRow[i] * v[i];
        }
        out[row] = sum;
    }
    return out;
}",0,0
336,Math_98,"public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
        if (v.length != this.getColumnDimension()) {
            throw new IllegalArgumentException(""vector has wrong length"");
         }
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
         final BigDecimal[] out = new BigDecimal[v.length];
         for (int row = 0; row < nRows; row++) {
             BigDecimal sum = ZERO;
             for (int i = 0; i < nCols; i++) {
                sum = sum.add(data[row][i].multiply(v[i]));
            }
            out[row] = sum;
        }
        return out;
    }","public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
    if (v.length != this.getColumnDimension()) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[nRows]; // Fix: Adjusted the size of the output array
    Arrays.fill(out, BigDecimal.ZERO); // Initialize all entries to BigDecimal.ZERO to prevent null issues
    for (int row = 0; row < nRows; row++) {
        BigDecimal sum = BigDecimal.ZERO;
        for (int i = 0; i < nCols; i++) {
            sum = sum.add(data[row][i].multiply(v[i]));
        }
        out[row] = sum;
    }
    return out;
}",0,0
337,Math_99,"public static int lcm(int a, int b) {
        if (a==0 || b==0){
             return 0;
         }
         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
         return lcm;
     }","public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int gcdValue = gcd(a, b);
    int lcm = Math.abs(mulAndCheck(a / gcdValue, b));
    return lcm;
}",0,0
337,Math_99,"public static int gcd(final int p, final int q) {
         int u = p;
         int v = q;
         if ((u == 0) || (v == 0)) {
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw MathRuntimeException.createArithmeticException(
                    ""overflow: gcd({0}, {1}) is 2^31"",
                    new Object[] { p, q });
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if (u == 0 || v == 0) {
        return Math.abs(u) + Math.abs(v);
    }
    u = Math.abs(u);
    v = Math.abs(v);

    int shifts = 0;
    while ((u & 1) == 0 && (v & 1) == 0) {
        u >>>= 1;
        v >>>= 1;
        shifts++;
    }

    while (u != 0) {
        while ((u & 1) == 0) {
            u >>>= 1;
        }
        while ((v & 1) == 0) {
            v >>>= 1;
        }
        if (u >= v) {
            u = (u - v) >>> 1;
        } else {
            v = (v - u) >>> 1;
        }
    }
    return v << shifts;
}",0,0
338,Mockito_10,"    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
        InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
        InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();

        // matches invocation for verification
        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
            if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
                return stubbedInvocationMatcher.answer(invocation);
            }
        }

        // record deep stub answer
        return recordDeepStubAnswer(
                newDeepStubMock(returnTypeGenericMetadata),
                container
        );
    }
","private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
    InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
    InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();

    // Check if invocation matches any stubbed invocation
    InvocationMatcher currentInvocation = container.getInvocationForStubbing();
    for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
        if (currentInvocation != null && currentInvocation.matches(stubbedInvocationMatcher.getInvocation())) {
            return stubbedInvocationMatcher.answer(invocation);
        }
    }

    // Record deep stub answer by creating a new deep stub mock
    return recordDeepStubAnswer(
            newDeepStubMock(returnTypeGenericMetadata),
            container
    );
}",0,0
338,Mockito_10,"    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
        return mockitoCore().mock(
                returnTypeGenericMetadata.rawType(),
                withSettingsUsing(returnTypeGenericMetadata)
        );
    }
","private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
    if (returnTypeGenericMetadata == null || returnTypeGenericMetadata.rawType() == null) {
        throw new IllegalArgumentException(""The return type metadata or raw type must not be null."");
    }
    return mockitoCore().mock(
            returnTypeGenericMetadata.rawType(),
            withSettingsUsing(returnTypeGenericMetadata)
    );
}",0,0
339,Mockito_11,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.creation;

import org.mockito.internal.invocation.MockitoMethod;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class DelegatingMethod implements MockitoMethod {

    private final Method method;

    public DelegatingMethod(Method method) {
        assert method != null : ""Method cannot be null"";
        this.method = method;
    }

    public Class<?>[] getExceptionTypes() {
        return method.getExceptionTypes();
    }

    public Method getJavaMethod() {
        return method;
    }

    public String getName() {
        return method.getName();
    }

    public Class<?>[] getParameterTypes() {
        return method.getParameterTypes();
    }

    public Class<?> getReturnType() {
        return method.getReturnType();
    }

    public boolean isVarArgs() {
        return method.isVarArgs();
    }

    public boolean isAbstract() {
        return (method.getModifiers() & Modifier.ABSTRACT) != 0;
    }

    /**
     * @return True if the input object is a DelegatingMethod which has an internal Method which is equal to the internal Method of this DelegatingMethod,
     * or if the input object is a Method which is equal to the internal Method of this DelegatingMethod.
     */
    @Override
    public boolean equals(Object o) {
            return method.equals(o);
    }

    @Override
    public int hashCode() {
        return 1;
    }
}","@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o instanceof DelegatingMethod) {
        DelegatingMethod that = (DelegatingMethod) o;
        return method.equals(that.method);
    }
    if (o instanceof Method) {
        return method.equals(o);
    }
    return false;
}

@Override
public int hashCode() {
    return method.hashCode();
}",0,0
340,Mockito_14,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
         }
         
         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }","public Object handle(Invocation invocation) throws Throwable {
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(
                mockingProgress.getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }

    VerificationMode verificationMode = mockingProgress.pullVerificationMode();
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(
            mockingProgress.getArgumentMatcherStorage(), invocation);

    mockingProgress.validateState();

    if (verificationMode != null) {
        VerificationDataImpl data = new VerificationDataImpl(
                invocationContainerImpl.getInvocations(), invocationMatcher);
        verificationMode.verify(data);
        return null;
    }

    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);

    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret;
        try {
            ret = mockSettings.getDefaultAnswer().answer(invocation);
        } catch (Throwable throwable) {
            // Ensure proper handling when the default answer throws an exception
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            throw throwable;
        }

        // Reset the invocation for potential stubbing to handle partial mocks/spies properly
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}",0,0
340,Mockito_14,"public <T> T verify(T mock, VerificationMode mode) {
        if (mock == null) {
            reporter.nullPassedToVerify();
         } else if (!mockUtil.isMock(mock)) {
             reporter.notAMockPassedToVerify();
         }
         mockingProgress.verificationStarted(mode);
         return mock;
     }","public <T> T verify(T mock, VerificationMode mode) {
    if (mock == null) {
        reporter.nullPassedToVerify();
        return null; // Ensure consistency in return when null is passed
    } else if (!mockUtil.isMock(mock)) {
        reporter.notAMockPassedToVerify();
        return null; // Ensure consistency in return when a non-mock is passed
    }

    mockingProgress.verificationStarted(mode);
    return mock;
}",0,0
341,Mockito_15,"public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
        if(mocks.size() == 1) {
            final Object matchingMock = mocks.iterator().next();

             return new OngoingInjecter() {
                 public boolean thenInject() {
                     try {
                             new FieldSetter(fieldInstance, field).set(matchingMock);
                     } catch (Exception e) {
                         throw new MockitoException(""Problems injecting dependency in "" + field.getName(), e);
                     }
                    return true;
                }
            };
        }

        return new OngoingInjecter() {
            public boolean thenInject() {
                return false;
            }
        };

    }","public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
    if (mocks.size() == 1) {
        final Object matchingMock = mocks.iterator().next();

        return new OngoingInjecter() {
            public boolean thenInject() {
                try {
                    if (matchingMock != null && fieldInstance != null && field != null) {
                        new FieldSetter(fieldInstance, field).set(matchingMock);
                    } else {
                        throw new MockitoException(""Cannot inject null dependency in "" + field.getName());
                    }
                } catch (Exception e) {
                    throw new MockitoException(""Problems injecting dependency in "" + field.getName(), e);
                }
                return true;
            }
        };
    }

    return new OngoingInjecter() {
        public boolean thenInject() {
            return false;
        }
    };
}",0,0
342,Mockito_16,"public static <T> T spy(T object) {
         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
                 .spiedInstance(object)
                 .defaultAnswer(CALLS_REAL_METHODS)); 
     }","public static <T> T spy(T object) {
    if (object == null) {
        throw new IllegalArgumentException(""Object to spy on cannot be null"");
    }
    return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
            .spiedInstance(object)
            .defaultAnswer(CALLS_REAL_METHODS));
}",0,0
343,Mockito_17,"public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {
        creationValidator.validateType(classToMock);
        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());
        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());

        settings.initiateMockName(classToMock);

        MockHandler<T> mockHandler = new MockHandler<T>(settings);
        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);
         Class<?>[] interfaces = settings.getExtraInterfaces();
 
         Class<?>[] ancillaryTypes;
             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
 
         Object spiedInstance = settings.getSpiedInstance();
         
        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);
        
        if (spiedInstance != null) {
            new LenientCopyTool().copyToMock(spiedInstance, mock);
        }
        
        return mock;
    }","public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {
    // Validate types and settings
    creationValidator.validateType(classToMock);
    creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());
    creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());

    // Initialize mock name
    settings.initiateMockName(classToMock);

    // Create mock handler and filter
    MockHandler<T> mockHandler = new MockHandler<>(settings);
    MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);

    // Retrieve extra interfaces
    Class<?>[] interfaces = settings.getExtraInterfaces();
    Class<?>[] ancillaryTypes = (interfaces == null) ? new Class<?>[0] : interfaces;

    // Retrieve spied instance
    Object spiedInstance = settings.getSpiedInstance();

    // Check spied instance type consistency
    if (spiedInstance != null && !classToMock.isInstance(spiedInstance)) {
        throw new IllegalArgumentException(""Spied instance type inconsistent with the class to mock."");
    }

    // Create proxy object
    T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);

    // Copy spied instance data to mock, if applicable
    if (spiedInstance != null) {
        new LenientCopyTool().copyToMock(spiedInstance, mock);
    }

    return mock;
}",0,0
344,Mockito_19,"public class NameBasedCandidateFilter implements MockCandidateFilter {
 private final MockCandidateFilter next;
 private final MockUtil mockUtil = new MockUtil();

 public NameBasedCandidateFilter(MockCandidateFilter next) {
  this.next = next;
 }

 public OngoingInjecter filterCandidate(Collection<Object> mocks,
   Field field, Object fieldInstance) {
  List<Object> mockNameMatches = new ArrayList<Object>();
  if (mocks.size() > 1) {
   for (Object mock : mocks) {
    if (field.getName().equals(mockUtil.getMockName(mock).toString())) {
     mockNameMatches.add(mock);
    }
   }
   return next.filterCandidate(mockNameMatches, field,
     fieldInstance);
   /*
    * In this case we have to check whether we have conflicting naming
    * fields. E.g. 2 fields of the same type, but we have to make sure
    * we match on the correct name.
    * 
    * Therefore we have to go through all other fields and make sure
    * whenever we find a field that does match its name with the mock
    * name, we should take that field instead.
    */
  }
  return next.filterCandidate(mocks, field, fieldInstance);
 }
}","public class NameBasedCandidateFilter implements MockCandidateFilter {
    private final MockCandidateFilter next;
    private final MockUtil mockUtil = new MockUtil();

    public NameBasedCandidateFilter(MockCandidateFilter next) {
        this.next = next;
    }

    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
        List<Object> mockNameMatches = new ArrayList<>();
        if (mocks != null && mocks.size() > 1) {
            for (Object mock : mocks) {
                if (field.getName().equals(mockUtil.getMockName(mock).toString())) {
                    mockNameMatches.add(mock);
                }
            }
            // Proceed to next filter with matched mocks
            return next.filterCandidate(mockNameMatches, field, fieldInstance);
        }
        return next.filterCandidate(mocks, field, fieldInstance);
    }
}",0,0
344,Mockito_19,"
import java.lang.reflect.Field;
import java.util.Collection;

public interface MockCandidateFilter {

    OngoingInjecter filterCandidate(
            Collection<Object> mocks,
            Field fieldToBeInjected,
            Object fieldInstance
    );

}
","import java.lang.reflect.Field;
import java.util.Collection;

public interface MockCandidateFilter {
    OngoingInjecter filterCandidate(
        Collection<Object> mocks,
        Field fieldToBeInjected,
        Object fieldInstance
    );
}",0,0
344,Mockito_19,"public class TypeBasedCandidateFilter implements MockCandidateFilter {

    MockCandidateFilter next;

    public TypeBasedCandidateFilter(MockCandidateFilter next) {
        this.next = next;
    }

    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
        List<Object> mockTypeMatches = new ArrayList<Object>();
        for (Object mock : mocks) {
            if (field.getType().isAssignableFrom(mock.getClass())) {
                mockTypeMatches.add(mock);
            }
        }

        return next.filterCandidate(mockTypeMatches, field, fieldInstance);
    }
}
","public class TypeBasedCandidateFilter implements MockCandidateFilter {
    private final MockCandidateFilter next;

    public TypeBasedCandidateFilter(MockCandidateFilter next) {
        this.next = next;
    }

    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
        List<Object> mockTypeMatches = new ArrayList<>();
        if (mocks != null) {
            for (Object mock : mocks) {
                if (field.getType().isAssignableFrom(mock.getClass())) {
                    mockTypeMatches.add(mock);
                }
            }
        }
        return next.filterCandidate(mockTypeMatches, field, fieldInstance);
    }
}",0,0
344,Mockito_19,"    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {
        for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {
            Field field = it.next();
            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();
            if (injected != null) {
                injectionOccurred |= true;
                mocks.remove(injected);
                it.remove();
            }
        }
        return injectionOccurred;
    }
","private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {
    if (mocks == null || orderedInstanceFields == null) {
        throw new IllegalArgumentException(""Mocks and orderedInstanceFields cannot be null"");
    }
    Iterator<Field> it = orderedInstanceFields.iterator();
    while (it.hasNext()) {
        Field field = it.next();
        OngoingInjecter ongoingInjecter = mockCandidateFilter.filterCandidate(mocks, field, instance);
        Object injected = ongoingInjecter.thenInject();
        if (injected != null) {
            injectionOccurred = true;
            mocks.remove(injected);
            it.remove();
        }
    }
    return injectionOccurred;
}",0,0
344,Mockito_19,"    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
        if(mocks.size() == 1) {
            final Object matchingMock = mocks.iterator().next();

            return new OngoingInjecter() {
                public Object thenInject() {
                    try {
                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {
                            new FieldSetter(fieldInstance, field).set(matchingMock);
                        }
                    } catch (RuntimeException e) {
                        new Reporter().cannotInjectDependency(field, matchingMock, e);
                    }
                    return matchingMock;
                }
            };
        }

        return new OngoingInjecter() {
            public Object thenInject() {
                return null;
            }
        };

    }
","public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
    if (mocks == null || field == null || fieldInstance == null) {
        throw new IllegalArgumentException(""Mocks, field, and fieldInstance cannot be null"");
    }

    if (mocks.size() == 1) {
        final Object matchingMock = mocks.iterator().next();

        return new OngoingInjecter() {
            public Object thenInject() {
                try {
                    BeanPropertySetter propertySetter = new BeanPropertySetter(fieldInstance, field);
                    FieldSetter fieldSetter = new FieldSetter(fieldInstance, field);
                    if (!propertySetter.set(matchingMock)) {
                        fieldSetter.set(matchingMock);
                    }
                } catch (RuntimeException e) {
                    new Reporter().cannotInjectDependency(field, matchingMock, e);
                }
                return matchingMock;
            }
        };
    }

    return new OngoingInjecter() {
        public Object thenInject() {
            return null;
        }
    };
}",0,0
345,Mockito_2,"    public void start() {
        startTime = System.currentTimeMillis();
    }
","public void start() {
    if (startTime != 0) {
        throw new IllegalStateException(""Timer has already been started!"");
    }
    startTime = System.currentTimeMillis();
}",0,0
345,Mockito_2,"    public Timer(long durationMillis) {
        this.durationMillis = durationMillis;
    }
","public Timer(long durationMillis) {
    if (durationMillis < 0) {
        throw new IllegalArgumentException(""Duration must be non-negative."");
    }
    this.durationMillis = durationMillis;
}",0,0
346,Mockito_21,"    public <T> T newInstance(Class<T> cls) {
        if (outerClassInstance == null) {
            return noArgConstructor(cls);
        }
        return withOuterClass(cls);
    }
","public <T> T newInstance(Class<T> cls) {
    try {
        if (outerClassInstance == null) {
            return noArgConstructor(cls);
        }
        return withOuterClass(cls);
    } catch (Exception e) {
        throw paramsException(cls, e);
    }
}",0,0
346,Mockito_21,"    private static <T> InstantationException paramsException(Class<T> cls, Exception e) {
        return new InstantationException(""Unable to create mock instance of '""
                + cls.getSimpleName() + ""'.\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor."", e);
    }
","private static <T> InstantiationException paramsException(Class<T> cls, Exception e) {
    return new InstantiationException(""Unable to create mock instance of '""
            + cls.getSimpleName() + ""'.\nPlease ensure that the outer instance has correct type and that the target class has a parameter-less constructor."", e);
}",0,0
347,Mockito_23,"private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
        MockSettings mockSettings =
                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
                : withSettings();

        return mockSettings
                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
    }","private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
    MockSettings mockSettings =
            returnTypeGenericMetadata.rawExtraInterfaces() != null && returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
            withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
            : withSettings();

    if (mockSettings == null) {
        throw new IllegalStateException(""MockSettings cannot be null"");
    }

    return mockSettings
            .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
}",0,0
347,Mockito_23,"private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
         container.addAnswer(new Answer<Object>() {
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 return mock;
             }
        }, false);

        return mock;
    }","private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
    if (mock == null || container == null) {
        throw new IllegalArgumentException(""Mock and container cannot be null"");
    }

    container.addAnswer(new Answer<Object>() {
        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            return mock;
        }
    }, false);

    return mock;
}",0,0
348,Mockito_25,"    public Object answer(InvocationOnMock invocation) throws Throwable {
        GenericMetadataSupport returnTypeGenericMetadata =
                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());

        Class<?> rawType = returnTypeGenericMetadata.rawType();
        if (!new MockCreationValidator().isTypeMockable(rawType)) {
            return delegate.returnValueFor(rawType);
        }

        return getMock(invocation);
    }
","public Object answer(InvocationOnMock invocation) throws Throwable {
    GenericMetadataSupport returnTypeGenericMetadata =
            actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());

    Class<?> rawType = returnTypeGenericMetadata.rawType();
    if (rawType == null || !new MockCreationValidator().isTypeMockable(rawType)) {
        return delegate.returnValueFor(rawType);
    }

    return getMock(invocation);
}",0,0
348,Mockito_25,"    private Object getMock(InvocationOnMock invocation) throws Throwable {
    	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
    	InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();

        // matches invocation for verification
        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
    		if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
    			return stubbedInvocationMatcher.answer(invocation);
    		}
		}

        // deep stub
        return recordDeepStubMock(invocation, container);
    }
","private Object getMock(InvocationOnMock invocation) throws Throwable {
    InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
    InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();

    // Ensure invocationForStubbing is not null and matches invocation for verification
    if (container.getInvocationForStubbing() != null) {
        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
            if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
                return stubbedInvocationMatcher.answer(invocation);
            }
        }
    }

    // Deep stub for unmatched invocation
    return recordDeepStubMock(invocation, container);
}",0,0
348,Mockito_25,"    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {
        Class<?> clz = invocation.getMethod().getReturnType();
        final Object mock = org.mockito.Mockito.mock(clz, this);

        container.addAnswer(new Answer<Object>() {
            public Object answer(InvocationOnMock invocation) throws Throwable {
                return mock;
            }
        }, false);

        return mock;
    }
","private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) throws Throwable {
    Class<?> clz = invocation.getMethod().getReturnType();

    // Ensure clz is not null before trying to mock
    if (clz == null) {
        throw new MockitoException(""Cannot create a mock for a null return type"");
    }

    final Object mock = org.mockito.Mockito.mock(clz, this);

    container.addAnswer(new Answer<Object>() {
        public Object answer(InvocationOnMock invocation) throws Throwable {
            return mock;
        }
    }, false);

    return mock;
}",0,0
349,Mockito_3,"    public void captureArgumentsFrom(Invocation invocation) {
        if (invocation.getMethod().isVarArgs()) {
            int indexOfVararg = invocation.getRawArguments().length - 1;
            for (int position = 0; position < indexOfVararg; position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
            for (int position = indexOfVararg; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
                }
            }
        } else {
            for (int position = 0; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
        }
    }
","public void captureArgumentsFrom(Invocation invocation) {
    if (invocation.getMethod().isVarArgs()) {
        int indexOfVararg = invocation.getRawArguments().length - 1;

        // Handle non-vararg arguments
        for (int position = 0; position < indexOfVararg; position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments) {
                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
            }
        }

        // Handle vararg arguments
        Object[] varargsArray = (Object[]) invocation.getRawArguments()[indexOfVararg];
        for (int position = indexOfVararg; position < matchers.size(); position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments && (position - indexOfVararg) < varargsArray.length) {
                ((CapturesArguments) m).captureFrom(varargsArray[position - indexOfVararg]);
            }
        }
    } else {
        for (int position = 0; position < matchers.size(); position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments) {
                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
            }
        }
    }
}",0,0
350,Mockito_30,"public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
            if (new ObjectMethodsGuru().isToString(method)) {
                 return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
             }
 
             new Reporter().smartNullPointerException(location);
             return null;
         }","public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
    if (new ObjectMethodsGuru().isToString(method)) {
        return ""SmartNull returned by unstubbed "" + formatMethodCall(method, args) + "" method on mock"";
    }

    throw new Reporter().smartNullPointerException(location);
}

// Helper method used to format the method call
private String formatMethodCall(Method method, Object[] args) {
    StringBuilder formattedCall = new StringBuilder(method.getName() + ""("");
    if (args != null) {
        for (int i = 0; i < args.length; i++) {
            formattedCall.append(args[i] == null ? ""null"" : args[i].toString());
            if (i < args.length - 1) {
                formattedCall.append("", "");
            }
        }
    }
    formattedCall.append("")"");
    return formattedCall.toString();
}",0,0
351,Mockito_31,"        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
            if (new ObjectMethodsGuru().isToString(method)) {
                return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
            }

            new Reporter().smartNullPointerException(location);
            return null;
        }
","public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
    if (new ObjectMethodsGuru().isToString(method)) {
        return ""SmartNull returned by unstubbed "" + formatMethodCall(method, args) + "" method on mock"";
    }

    new Reporter().smartNullPointerException(location);
    return null;
}

private String formatMethodCall(Method method, Object[] args) {
    StringBuilder sb = new StringBuilder(method.getName());
    sb.append(""("");
    if (args != null) {
        for (int i = 0; i < args.length; i++) {
            sb.append(args[i]);
            if (i < args.length - 1) {
                sb.append("", "");
            }
        }
    }
    sb.append("")"");
    return sb.toString();
}",0,0
352,Mockito_32,"@SuppressWarnings(""deprecation"")
    public void process(Class<?> context, Object testClass) {
        Field[] fields = context.getDeclaredFields();
        for (Field field : fields) {
            if (field.isAnnotationPresent(Spy.class)) {
                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);
                boolean wasAccessible = field.isAccessible();
                field.setAccessible(true);
                try {
                    Object instance = field.get(testClass);
                    if (instance == null) {
                        throw new MockitoException(""Cannot create a @Spy for '"" + field.getName() + ""' field because the *instance* is missing\n"" +
                        		  ""The instance must be created *before* initMocks();\n"" +
                                  ""Example of correct usage of @Spy:\n"" +
                            	  ""   @Spy List mock = new LinkedList();\n"" +
                            	  ""   //also, don't forget about MockitoAnnotations.initMocks();"");

                    }
                    if (new MockUtil().isMock(instance)) { 
                         // instance has been spied earlier
                         Mockito.reset(instance);
                     } else {
                         field.set(testClass, Mockito.spy(instance));
                     }
                 } catch (IllegalAccessException e) {
                     throw new MockitoException(""Problems initiating spied field "" + field.getName(), e);
                } finally {
                    field.setAccessible(wasAccessible);
                }
            }
        }
    }","@SuppressWarnings(""deprecation"")
public void process(Class<?> context, Object testClass) {
    Field[] fields = context.getDeclaredFields();
    for (Field field : fields) {
        if (field.isAnnotationPresent(Spy.class)) {
            assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);
            boolean wasAccessible = field.canAccess(testClass); // Use canAccess() for better compatibility.
            field.setAccessible(true);
            try {
                Object instance = field.get(testClass);
                if (instance == null) {
                    throw new MockitoException(""Cannot create a @Spy for '"" + field.getName()
                            + ""' field because the *instance* is missing\n""
                            + ""The instance must be created *before* initMocks();\n""
                            + ""Example of correct usage of @Spy:\n""
                            + ""   @Spy List mock = new LinkedList();\n""
                            + ""   //also, don't forget about MockitoAnnotations.initMocks();"");
                }
                if (new MockUtil().isMock(instance)) {
                    // Instance has been spied earlier
                    Mockito.reset(instance);
                } else {
                    field.set(testClass, Mockito.spy(instance));
                }
            } catch (IllegalAccessException e) {
                throw new MockitoException(""Problems initiating spied field "" + field.getName(), e);
            } finally {
                field.setAccessible(wasAccessible);
            }
        }
    }
}",0,0
353,Mockito_35,"    public static <T> T same(T value) {
        return reportMatcher(new Same(value)).<T>returnNull();
    }
","public static <T> T same(T value) {
    if (value == null) {
        throw new IllegalArgumentException(""The value cannot be null"");
    }
    return reportMatcher(new Same(value)).<T>returnNull();
}",0,0
353,Mockito_35,"    public static <T> T eq(T value) {
        return reportMatcher(new Equals(value)).<T>returnNull();
    }  
","public static <T> T eq(T value) {
    if (value == null) {
        throw new IllegalArgumentException(""The value cannot be null"");
    }
    return reportMatcher(new Equals(value)).<T>returnNull();
}",0,0
353,Mockito_35,"    public static <T> T isA(Class<T> clazz) {
        return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
    }
","public static <T> T isA(Class<T> clazz) {
    if (clazz == null) {
        throw new IllegalArgumentException(""The class cannot be null"");
    }
    return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
}",0,0
354,Mockito_36,"    public Object[] getRawArguments() {
        return this.rawArguments;
    }
","public Object[] getRawArguments() {
    // Ensure a defensive copy of the rawArguments array is returned 
    // to prevent external modification of the internal array.
    return this.rawArguments != null ? this.rawArguments.clone() : null;
}",0,0
355,Mockito_37,"    public void validate(Answer<?> answer, Invocation invocation) {
        if (answer instanceof ThrowsException) {
            validateException((ThrowsException) answer, invocation);
        }
        
        if (answer instanceof Returns) {
            validateReturnValue((Returns) answer, invocation);
        }
        
        if (answer instanceof DoesNothing) {
            validateDoNothing((DoesNothing) answer, invocation);
        }
        
    }
","public void validate(Answer<?> answer, Invocation invocation) {
    if (answer == null || invocation == null) {
        throw new IllegalArgumentException(""Answer and Invocation must not be null"");
    }

    if (answer instanceof ThrowsException) {
        validateException((ThrowsException) answer, invocation);
    } else if (answer instanceof Returns) {
        validateReturnValue((Returns) answer, invocation);
    } else if (answer instanceof DoesNothing) {
        validateDoNothing((DoesNothing) answer, invocation);
    } else if (answer instanceof CallsRealMethods) {
        validateCallRealMethod((CallsRealMethods) answer, invocation);
    } else {
        throw new IllegalArgumentException(""Unsupported Answer type: "" + answer.getClass().getName());
    }
}

private void validateCallRealMethod(CallsRealMethods answer, Invocation invocation) {
    // Add specific validation for CallsRealMethods if needed
}",0,0
356,Mockito_4,"    public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {
        throw new MockitoException(join(
                ""Mockito couldn't inject mock dependency '"" + safelyGetMockName(matchingMock) + ""' on field "",
                ""'"" + field + ""'"",
                ""whose type '"" + field.getDeclaringClass().getCanonicalName() + ""' was annotated by @InjectMocks in your test."",
                ""Also I failed because: "" + exceptionCauseMessageIfAvailable(details),
                """"
        ), details);
    }
","public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {
    throw new MockitoException(join(
            ""Mockito couldn't inject mock dependency '"" + safelyGetMockName(matchingMock) + ""' on field "",
            ""'"" + field.getName() + ""'"",
            ""whose type '"" + field.getType().getCanonicalName() + ""' was annotated by @InjectMocks in your test."",
            ""Also I failed because: "" + exceptionCauseMessageIfAvailable(details),
            """"
    ), details);
}",0,0
356,Mockito_4,"    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {
        ScenarioPrinter scenarioPrinter = new ScenarioPrinter();
        String scenario = scenarioPrinter.print(invocations);

        throw new NoInteractionsWanted(join(
                ""No interactions wanted here:"",
                new LocationImpl(),
                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
                undesired.getLocation(),
                scenario
        ));
    }
","public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {
    ScenarioPrinter scenarioPrinter = new ScenarioPrinter();
    String scenario = scenarioPrinter.print(invocations);

    throw new NoInteractionsWanted(join(
            ""No interactions wanted here:"",
            new LocationImpl().toString(),
            ""But found this interaction on mock '"" + undesired.getMock().toString() + ""':"",
            undesired.getLocation().toString(),
            scenario
    ));
}",0,0
356,Mockito_4,"    public void noMoreInteractionsWantedInOrder(Invocation undesired) {
        throw new VerificationInOrderFailure(join(
                ""No interactions wanted here:"",
                new LocationImpl(),
                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
                undesired.getLocation()
        ));
    }
","public void noMoreInteractionsWantedInOrder(Invocation undesired) {
    throw new VerificationInOrderFailure(join(
            ""No interactions wanted here:"",
            new LocationImpl().toString(),
            ""But found this interaction on mock '"" + undesired.getMock().toString() + ""':"",
            undesired.getLocation().toString()
    ));
}",0,0
357,Mockito_6,"    public static char anyChar() {
        return reportMatcher(Any.ANY).returnChar();
    }
","public static char anyChar() {
    return reportMatcher(Any.ANY).returnChar();
}",0,0
357,Mockito_6,"    public static double anyDouble() {
        return reportMatcher(Any.ANY).returnZero();
    }
","public static double anyDouble() {
    return reportMatcher(Any.ANY).returnZero().doubleValue();
}",0,0
357,Mockito_6,"    public static Collection anyCollection() {
        return reportMatcher(Any.ANY).returnList();
    }    
","public static Collection anyCollection() {
    return reportMatcher(Any.ANY).returnList();
}",0,0
357,Mockito_6,"    public static Set anySet() {
        return reportMatcher(Any.ANY).returnSet();
    }
","public static Set anySet() {
    return reportMatcher(Any.ANY).returnSet();
}",0,0
357,Mockito_6,"    public static short anyShort() {
        return reportMatcher(Any.ANY).returnZero();
    }
","public static short anyShort() {
    return reportMatcher(Any.ANY).returnZero().shortValue();
}",0,0
357,Mockito_6,"    public static <T> T anyObject() {
        return (T) reportMatcher(Any.ANY).returnNull();
    }
","public static <T> T anyObject() {
    return (T) reportMatcher(Any.ANY).returnNull();
}",0,0
357,Mockito_6,"    public static <T> T any(Class<T> clazz) {
        return (T) reportMatcher(Any.ANY).returnFor(clazz);
    }
","public static <T> T any(Class<T> clazz) {
    if (clazz == null) {
        throw new IllegalArgumentException(""Class type cannot be null"");
    }
    return (T) reportMatcher(Any.ANY).returnFor(clazz);
}",0,0
357,Mockito_6,"    public static <T> T any() {
        return (T) anyObject();
    }
","public static <T> T any() {
    return anyObject();
}",0,0
357,Mockito_6,"    public static String anyString() {
        return reportMatcher(Any.ANY).returnString();
    }
","public static String anyString() {
    return reportMatcher(Any.ANY).returnString();
}",0,0
357,Mockito_6,"    public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
        return reportMatcher(Any.ANY).returnMap();
    }
","public static <K, V> Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
    if (keyClazz == null || valueClazz == null) {
        throw new IllegalArgumentException(""Key and value class types cannot be null"");
    }
    return reportMatcher(Any.ANY).returnMap();
}",0,0
357,Mockito_6,"    public static long anyLong() {
        return reportMatcher(Any.ANY).returnZero();
    }
","public static long anyLong() {
    return reportMatcher(Any.ANY).returnZero().longValue();
}",0,0
357,Mockito_6,"    public static <T> List<T> anyListOf(Class<T> clazz) {
        return (List) reportMatcher(Any.ANY).returnList();
    }    
","public static <T> List<T> anyListOf(Class<T> clazz) {
    if (clazz == null) {
        throw new IllegalArgumentException(""Class type cannot be null"");
    }
    return (List<T>) reportMatcher(Any.ANY).returnList();
}",0,0
357,Mockito_6,"    public static float anyFloat() {
        return reportMatcher(Any.ANY).returnZero();
    }
","public static float anyFloat() {
    return reportMatcher(Any.ANY).returnZero().floatValue();
}",0,0
357,Mockito_6,"    public static boolean anyBoolean() {
        return reportMatcher(Any.ANY).returnFalse();
    }
","public static boolean anyBoolean() {
    return reportMatcher(Any.ANY).returnFalse();
}",0,0
357,Mockito_6,"    public static byte anyByte() {
        return reportMatcher(Any.ANY).returnZero();
    }
","public static byte anyByte() {
    return reportMatcher(Any.ANY).returnZero().byteValue();
}",0,0
357,Mockito_6,"    public static int anyInt() {
        return reportMatcher(Any.ANY).returnZero();
    }
","public static int anyInt() {
    return reportMatcher(Any.ANY).returnZero().intValue();
}",0,0
357,Mockito_6,"    public static <T> Set<T> anySetOf(Class<T> clazz) {
        return (Set) reportMatcher(Any.ANY).returnSet();
    }
","public static <T> Set<T> anySetOf(Class<T> clazz) {
    if (clazz == null) {
        throw new IllegalArgumentException(""Class type cannot be null"");
    }
    return (Set<T>) reportMatcher(Any.ANY).returnSet();
}",0,0
357,Mockito_6,"    public static Map anyMap() {
        return reportMatcher(Any.ANY).returnMap();
    }
","public static Map anyMap() {
    return reportMatcher(Any.ANY).returnMap();
}",0,0
357,Mockito_6,"    public static List anyList() {
        return reportMatcher(Any.ANY).returnList();
    }    
","public static List anyList() {
    return reportMatcher(Any.ANY).returnList();
}",0,0
357,Mockito_6,"    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
        return (Collection) reportMatcher(Any.ANY).returnList();
    }    
","public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
    if (clazz == null) {
        throw new IllegalArgumentException(""Class type cannot be null"");
    }
    return (Collection<T>) reportMatcher(Any.ANY).returnList();
}",0,0
358,Mockito_9,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.stubbing.answers;

import java.io.Serializable;

import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

/**
 * Optional Answer that adds partial mocking support
 * <p>
 * {@link Answer} can be used to define the return values of unstubbed invocations.
 * <p>
 * This implementation can be helpful when working with legacy code.
 * When this implementation is used, unstubbed methods will delegate to the real implementation.
 * This is a way to create a partial mock object that calls real methods by default.
 * <p>
 * As usual you are going to read <b>the partial mock warning</b>:
 * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 * How does partial mock fit into this paradigm? Well, it just doesn't... 
 * Partial mock usually means that the complexity has been moved to a different method on the same object.
 * In most cases, this is not the way you want to design your application.
 * <p>
 * However, there are rare cases when partial mocks come handy: 
 * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
 * <p>
 */
public class CallsRealMethods implements Answer<Object>, Serializable {
    private static final long serialVersionUID = 9057165148930624087L;

    public Object answer(InvocationOnMock invocation) throws Throwable {
        return invocation.callRealMethod();
    }
}","/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.stubbing.answers;

import java.io.Serializable;

import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

/**
 * Optional Answer that adds partial mocking support
 * <p>
 * {@link Answer} can be used to define the return values of unstubbed invocations.
 * <p>
 * This implementation can be helpful when working with legacy code.
 * When this implementation is used, unstubbed methods will delegate to the real implementation.
 * This is a way to create a partial mock object that calls real methods by default.
 * <p>
 * As usual you are going to read <b>the partial mock warning</b>:
 * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 * How does partial mock fit into this paradigm? Well, it just doesn't... 
 * Partial mock usually means that the complexity has been moved to a different method on the same object.
 * In most cases, this is not the way you want to design your application.
 * <p>
 * However, there are rare cases when partial mocks come handy: 
 * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
 * <p>
 */
public class CallsRealMethods implements Answer<Object>, Serializable {
    private static final long serialVersionUID = 9057165148930624087L;

    public Object answer(InvocationOnMock invocation) throws Throwable {
        if (invocation.getMethod().isDefault()) {
            // Handle default methods gracefully to prevent exceptions
            return invocation.getMethod().invoke(invocation.getMock(), invocation.getArguments());
        }
        return invocation.callRealMethod();
    }
}",0,0
359,Time_1,"    public int compareTo(DurationField durationField) {
        if (durationField.isSupported()) {
            return 1;
        }
        return 0;
    }
","public int compareTo(DurationField durationField) {
    if (durationField == null) {
        throw new IllegalArgumentException(""DurationField must not be null"");
    }
    if (this == durationField) {
        return 0;
    }
    if (!this.isSupported() && !durationField.isSupported()) {
        return 0;
    }
    if (this.isSupported() && !durationField.isSupported()) {
        return 1;
    }
    if (!this.isSupported() && durationField.isSupported()) {
        return -1;
    }
    // Additional comparison logic could be added here if needed
    return 0;
}",0,0
359,Time_1,"    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
        super();
        chronology = DateTimeUtils.getChronology(chronology).withUTC();
        iChronology = chronology;
        if (types == null) {
            throw new IllegalArgumentException(""Types array must not be null"");
        }
        if (values == null) {
            throw new IllegalArgumentException(""Values array must not be null"");
        }
        if (values.length != types.length) {
            throw new IllegalArgumentException(""Values array must be the same length as the types array"");
        }
        if (types.length == 0) {
            iTypes = types;
            iValues = values;
            return;
        }
        for (int i = 0; i < types.length; i++) {
            if (types[i] == null) {
                throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
            }
        }
        DurationField lastUnitField = null;
        for (int i = 0; i < types.length; i++) {
            DateTimeFieldType loopType = types[i];
            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
            if (i > 0) {
                int compare = lastUnitField.compareTo(loopUnitField);
                if (compare < 0) {
                    throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                            types[i - 1].getName() + "" < "" + loopType.getName());
                } else if (compare == 0) {
                    if (types[i - 1].getRangeDurationType() == null) {
                        if (loopType.getRangeDurationType() == null) {
                            throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
                                            types[i - 1].getName() + "" and "" + loopType.getName());
                        }
                    } else {
                        if (loopType.getRangeDurationType() == null) {
                            throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                                    types[i - 1].getName() + "" < "" + loopType.getName());
                        }
                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (lastRangeField.compareTo(loopRangeField) < 0) {
                            throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                                    types[i - 1].getName() + "" < "" + loopType.getName());
                        }
                        if (lastRangeField.compareTo(loopRangeField) == 0) {
                            throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
                                            types[i - 1].getName() + "" and "" + loopType.getName());
                        }
                    }
                }
            }
            lastUnitField = loopUnitField;
        }
        
        iTypes = (DateTimeFieldType[]) types.clone();
        chronology.validate(this, values);
        iValues = (int[]) values.clone();
    }
","public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types.clone();
        iValues = values.clone();
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (loopUnitField == null || !loopUnitField.isSupported()) {
            throw new IllegalArgumentException(""Unsupported duration field: "" + loopType.getName());
        }
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                        types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
                                types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                                types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                                types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
                                types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }

    iTypes = types.clone();
    chronology.validate(this, values);
    iValues = values.clone();
}",0,0
360,Time_10,"protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {
        if (start == null || end == null) {
            throw new IllegalArgumentException(""ReadablePartial objects must not be null"");
        }
        if (start.size() != end.size()) {
            throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
        }
        for (int i = 0, isize = start.size(); i < isize; i++) {
            if (start.getFieldType(i) != end.getFieldType(i)) {
                throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
            }
        }
        if (DateTimeUtils.isContiguous(start) == false) {
             throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
         }
         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
         int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
         return values[0];
     }","protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadablePartial objects must not be null"");
    }
    if (start.size() != end.size()) {
        throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
    }
    for (int i = 0, isize = start.size(); i < isize; i++) {
        if (!start.getFieldType(i).equals(end.getFieldType(i))) {
            throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
        }
    }
    if (!DateTimeUtils.isContiguous(start)) {
        throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
    }
    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
    long startMillis = chrono.set(start, 0L);
    long endMillis = chrono.set(end, 0L);
    int[] values = chrono.get(zeroInstance, startMillis, endMillis);
    return values.length > 0 ? values[0] : 0;
}",0,0
361,Time_12,"@SuppressWarnings(""deprecation"")
    public static LocalDateTime fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
             // handle years in era BC
         return new LocalDateTime(
             date.getYear() + 1900,
             date.getMonth() + 1,
            date.getDate(),
            date.getHours(),
            date.getMinutes(),
            date.getSeconds(),
            (((int) (date.getTime() % 1000)) + 1000) % 1000
        );
    }","@SuppressWarnings(""deprecation"")
public static LocalDateTime fromDateFields(Date date) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    // Avoid deprecated Date methods
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(date);
    return new LocalDateTime(
        calendar.get(Calendar.YEAR),
        calendar.get(Calendar.MONTH) + 1,
        calendar.get(Calendar.DAY_OF_MONTH),
        calendar.get(Calendar.HOUR_OF_DAY),
        calendar.get(Calendar.MINUTE),
        calendar.get(Calendar.SECOND),
        calendar.get(Calendar.MILLISECOND)
    );
}",0,0
361,Time_12,"public static LocalDateTime fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDateTime(
             yearOfEra,
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH),
             calendar.get(Calendar.HOUR_OF_DAY),
            calendar.get(Calendar.MINUTE),
            calendar.get(Calendar.SECOND),
            calendar.get(Calendar.MILLISECOND)
        );
    }","public static LocalDateTime fromCalendarFields(Calendar calendar) {
    if (calendar == null) {
        throw new IllegalArgumentException(""The calendar must not be null"");
    }
    return new LocalDateTime(
        calendar.get(Calendar.YEAR),
        calendar.get(Calendar.MONTH) + 1,
        calendar.get(Calendar.DAY_OF_MONTH),
        calendar.get(Calendar.HOUR_OF_DAY),
        calendar.get(Calendar.MINUTE),
        calendar.get(Calendar.SECOND),
        calendar.get(Calendar.MILLISECOND)
    );
}",0,0
361,Time_12,"@SuppressWarnings(""deprecation"")
    public static LocalDate fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
             // handle years in era BC
         return new LocalDate(
             date.getYear() + 1900,
             date.getMonth() + 1,
            date.getDate()
        );
    }","@SuppressWarnings(""deprecation"")
public static LocalDate fromDateFields(Date date) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    // Avoid deprecated Date methods
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(date);
    return new LocalDate(
        calendar.get(Calendar.YEAR),
        calendar.get(Calendar.MONTH) + 1,
        calendar.get(Calendar.DAY_OF_MONTH)
    );
}",0,0
361,Time_12,"public static LocalDate fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDate(
             yearOfEra,
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH)
         );
    }","public static LocalDate fromCalendarFields(Calendar calendar) {
    if (calendar == null) {
        throw new IllegalArgumentException(""The calendar must not be null"");
    }
    return new LocalDate(
        calendar.get(Calendar.YEAR),
        calendar.get(Calendar.MONTH) + 1,
        calendar.get(Calendar.DAY_OF_MONTH)
    );
}",0,0
362,Time_13,"public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
            long valueLong = getFieldValue(period);
            if (valueLong == Long.MAX_VALUE) {
                return 0;
            }

            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);
             if (iFieldType >= SECONDS_MILLIS) {
                 // valueLong contains the seconds and millis fields
                 // the minimum output is 0.000, which is 4 or 5 digits with a negative
                 sum = Math.max(sum, 4);
                 // plus one for the decimal point
                 sum++;
                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&
                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {
                    sum -= 4; // remove three digits and decimal point
                }
                // reset valueLong to refer to the seconds part for the prefic/suffix calculation
                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;
            }
            int value = (int) valueLong;

            if (iPrefix != null) {
                sum += iPrefix.calculatePrintedLength(value);
            }
            if (iSuffix != null) {
                sum += iSuffix.calculatePrintedLength(value);
            }

            return sum;
        }","public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
    long valueLong = getFieldValue(period);
    if (valueLong == Long.MAX_VALUE) {
        return 0;
    }

    int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);
    if (iFieldType >= SECONDS_MILLIS) {
        // valueLong contains the seconds and millis fields
        // the minimum output is 0.000, which is 4 or 5 digits with a negative
        sum = Math.max(sum, 4);
        // plus one for the decimal point
        sum++;
        if (iFieldType == SECONDS_OPTIONAL_MILLIS &&
                (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {
            sum -= 4; // remove three digits and decimal point
        }
        // reset valueLong to refer to the seconds part for the prefix/suffix calculation
        valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;
    }

    // Account for potential overflow by explicitly casting to avoid issues
    int value = (valueLong >= Integer.MIN_VALUE && valueLong <= Integer.MAX_VALUE) ? (int) valueLong : 0;

    if (iPrefix != null) {
        sum += iPrefix.calculatePrintedLength(value);
    }
    if (iSuffix != null) {
        sum += iSuffix.calculatePrintedLength(value);
    }

    return sum;
}",0,0
362,Time_13,"public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
            long valueLong = getFieldValue(period);
            if (valueLong == Long.MAX_VALUE) {
                return;
            }
            int value = (int) valueLong;
            if (iFieldType >= SECONDS_MILLIS) {
                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);
            }

             if (iPrefix != null) {
                 iPrefix.printTo(buf, value);
             }
             int minDigits = iMinPrintedDigits;
             if (minDigits <= 1) {
                 FormatUtils.appendUnpaddedInteger(buf, value);
            } else {
                FormatUtils.appendPaddedInteger(buf, value, minDigits);
            }
            if (iFieldType >= SECONDS_MILLIS) {
                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
                if (iFieldType == SECONDS_MILLIS || dp > 0) {
                    buf.append('.');
                    FormatUtils.appendPaddedInteger(buf, dp, 3);
                }
            }
            if (iSuffix != null) {
                iSuffix.printTo(buf, value);
            }
        }","public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
    long valueLong = getFieldValue(period);
    if (valueLong == Long.MAX_VALUE) {
        return;
    }

    int value = (valueLong >= Integer.MIN_VALUE && valueLong <= Integer.MAX_VALUE) ? (int) valueLong : 0;
    if (iFieldType >= SECONDS_MILLIS) {
        value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);
    }

    if (iPrefix != null) {
        iPrefix.printTo(buf, value);
    }

    int minDigits = iMinPrintedDigits;
    if (minDigits <= 1) {
        FormatUtils.appendUnpaddedInteger(buf, value);
    } else {
        FormatUtils.appendPaddedInteger(buf, value, minDigits);
    }

    if (iFieldType >= SECONDS_MILLIS) {
        int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
        if (iFieldType == SECONDS_MILLIS || dp > 0) {
            buf.append('.');
            FormatUtils.appendPaddedInteger(buf, dp, 3);
        }
    }

    if (iSuffix != null) {
        iSuffix.printTo(buf, value);
    }
}",0,0
363,Time_2,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
            // use public constructor to ensure full validation
            // this isn't overly efficient, but is safe
            Partial newPartial = new Partial(newTypes, newValues, iChronology);
            iChronology.validate(newPartial, newValues);
            return newPartial;
        }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }

    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];

        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField != null && unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField != null && loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType() != null 
                                                        ? fieldType.getRangeDurationType().getField(iChronology)
                                                        : null;
                        DurationField loopRangeField = loopType.getRangeDurationType() != null 
                                                        ? loopType.getRangeDurationType().getField(iChronology)
                                                        : null;
                        if (rangeField != null && rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);

        // use public constructor to ensure full validation
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }

    if (value == getValue(index)) {
        return this;
    }

    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}",0,0
364,Time_26,"public long roundCeiling(long instant) {
            if (iTimeField) {
                int offset = getOffsetToAdd(instant);
                instant = iField.roundCeiling(instant + offset);
                return instant - offset;
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundCeiling(localInstant);
                 return iZone.convertLocalToUTC(localInstant, false);
             }
         }","public long roundCeiling(long instant) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        instant = iField.roundCeiling(instant + offset);
        return instant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.roundCeiling(localInstant);
        return iZone.convertLocalToUTC(localInstant, true); // Ensure correct conversion
    }
}",0,0
364,Time_26,"public long roundFloor(long instant) {
            if (iTimeField) {
                int offset = getOffsetToAdd(instant);
                instant = iField.roundFloor(instant + offset);
                return instant - offset;
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundFloor(localInstant);
                 return iZone.convertLocalToUTC(localInstant, false);
             }
         }","public long roundFloor(long instant) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        instant = iField.roundFloor(instant + offset);
        return instant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.roundFloor(localInstant);
        return iZone.convertLocalToUTC(localInstant, true); // Ensure correct conversion
    }
}",0,0
364,Time_26,"public long set(long instant, int value) {
        // lenient needs to handle time zone chronologies
        // so we do the calculation using local milliseconds
         long localInstant = iBase.getZone().convertUTCToLocal(instant);
         long difference = FieldUtils.safeSubtract(value, get(instant));
         localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);
         return iBase.getZone().convertLocalToUTC(localInstant, false);
     }","public long set(long instant, int value) {
    long localInstant = iBase.getZone().convertUTCToLocal(instant);
    long difference = FieldUtils.safeSubtract(value, get(localInstant)); // Use localInstant for consistent results
    localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);
    return iBase.getZone().convertLocalToUTC(localInstant, true); // Correct UTC conversion
}",0,0
364,Time_26,"public long add(long instant, long value) {
            if (iTimeField) {
                int offset = getOffsetToAdd(instant);
                long localInstant = iField.add(instant + offset, value);
                return localInstant - offset;
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
                return iZone.convertLocalToUTC(localInstant, false);
             }","public long add(long instant, long value) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        long localInstant = iField.add(instant + offset, value);
        return localInstant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.add(localInstant, value);
        return iZone.convertLocalToUTC(localInstant, true); // Accurate conversion to UTC
    }
}",0,0
364,Time_26,"public long add(long instant, int value) {
            if (iTimeField) {
                int offset = getOffsetToAdd(instant);
                long localInstant = iField.add(instant + offset, value);
                return localInstant - offset;
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
                return iZone.convertLocalToUTC(localInstant, false);
             }
         }","public long add(long instant, int value) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        long localInstant = iField.add(instant + offset, value);
        return localInstant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.add(localInstant, value);
        return iZone.convertLocalToUTC(localInstant, true); // Accurate conversion to UTC
    }
}",0,0
364,Time_26,"public long set(long instant, String text, Locale locale) {
             // cannot verify that new value stuck because set may be lenient
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, text, locale);
             return iZone.convertLocalToUTC(localInstant, false);
         }","public long set(long instant, String text, Locale locale) {
    long localInstant = iZone.convertUTCToLocal(instant);
    localInstant = iField.set(localInstant, text, locale);
    return iZone.convertLocalToUTC(localInstant, true); // Accurate conversion to UTC
}",0,0
365,Time_3,"public void add(DurationFieldType type, int amount) {
         if (type == null) {
             throw new IllegalArgumentException(""Field must not be null"");
         }
             setMillis(type.getField(getChronology()).add(getMillis(), amount));
     }","public void add(DurationFieldType type, int amount) {
    if (type == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    DurationField field = type.getField(getChronology());
    if (!field.isSupported()) {
        throw new IllegalArgumentException(""Field '"" + type.getName() + ""' is not supported"");
    }
    setMillis(field.add(getMillis(), amount));
}",0,0
366,Time_6,"public static synchronized GJChronology getInstance(
            DateTimeZone zone,
            ReadableInstant gregorianCutover,
            int minDaysInFirstWeek) {
        
        zone = DateTimeUtils.getZone(zone);
        Instant cutoverInstant;
        if (gregorianCutover == null) {
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
         }
 
         GJChronology chrono;
        synchronized (cCache) {
            ArrayList<GJChronology> chronos = cCache.get(zone);
            if (chronos == null) {
                chronos = new ArrayList<GJChronology>(2);
                cCache.put(zone, chronos);
            } else {
                for (int i = chronos.size(); --i >= 0;) {
                    chrono = chronos.get(i);
                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&
                        cutoverInstant.equals(chrono.getGregorianCutover())) {
                        
                        return chrono;
                    }
                }
            }
            if (zone == DateTimeZone.UTC) {
                chrono = new GJChronology
                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),
                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),
                     cutoverInstant);
            } else {
                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);
                chrono = new GJChronology
                    (ZonedChronology.getInstance(chrono, zone),
                     chrono.iJulianChronology,
                     chrono.iGregorianChronology,
                     chrono.iCutoverInstant);
            }
            chronos.add(chrono);
        }
        return chrono;
    }","public static synchronized GJChronology getInstance(
            DateTimeZone zone,
            ReadableInstant gregorianCutover,
            int minDaysInFirstWeek) {
        
        zone = DateTimeUtils.getZone(zone);
        Instant cutoverInstant;
        if (gregorianCutover == null) {
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
         }
 
         GJChronology chrono;
        synchronized (cCache) {
            ArrayList<GJChronology> chronos = cCache.get(zone);
            if (chronos == null) {
                chronos = new ArrayList<GJChronology>(2);
                cCache.put(zone, chronos);
            } else {
                for (int i = chronos.size(); --i >= 0;) {
                    chrono = chronos.get(i);
                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&
                        cutoverInstant.equals(chrono.getGregorianCutover())) {
                        
                        return chrono;
                    }
                }
            }
            if (zone.equals(DateTimeZone.UTC)) {
                chrono = new GJChronology
                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),
                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),
                     cutoverInstant);
            } else {
                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);
                chrono = new GJChronology
                    (ZonedChronology.getInstance(chrono, zone),
                     chrono.iJulianChronology,
                     chrono.iGregorianChronology,
                     chrono.iCutoverInstant);
            }
            chronos.add(chrono);
        }
        return chrono;
    }",0,0
366,Time_6,"ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
                              DurationField durationField,
                              long cutoverMillis, boolean convertByWeekyear)
        {
            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);
            if (durationField == null) {
                durationField = new LinkedDurationField(iDurationField, this);
            }
            iDurationField = durationField;
        }

        public long add(long instant, int value) {
            if (instant >= iCutover) {
                instant = iGregorianField.add(instant, value);
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
                         instant = gregorianToJulian(instant);
                     }
                 }
            } else {","ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
                              DurationField durationField,
                              long cutoverMillis, boolean convertByWeekyear)
        {
            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);
            if (durationField == null) {
                iDurationField = new LinkedDurationField(iDurationField, this);
            } else {
                iDurationField = durationField;
            }
        }

        public long add(long instant, int value) {
            if (instant >= iCutover) {
                instant = iGregorianField.add(instant, value);
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
                         instant = gregorianToJulian(instant);
                     }
                 }
            } else {
                instant = iJulianField.add(instant, value);
                if (instant >= iCutover) {
                    // Only adjust if gap fully crossed.
                    if (instant - iGapDuration >= iCutover) {
                        // no special handling for year zero as cutover always after year zero
                        instant = julianToGregorian(instant);
                    }
                }
            }
            return instant;
        }",0,0
366,Time_6,"instant = gregorianToJulian(instant);
                     }
                 }
            } else {
                instant = iJulianField.add(instant, value);
                if (instant >= iCutover) {
                    // Only adjust if gap fully crossed.
                    if (instant - iGapDuration >= iCutover) {
                        // no special handling for year zero as cutover always after year zero
                        instant = julianToGregorian(instant);
                    }
                }
            }
            return instant;
        }
        
        public long add(long instant, long value) {
            if (instant >= iCutover) {
                instant = iGregorianField.add(instant, value);
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {","public long add(long instant, long value) {
    if (instant >= iCutover) {
        instant = iGregorianField.add(instant, value);
        if (instant < iCutover) {
            // Only adjust if gap fully crossed.
            if (instant + iGapDuration < iCutover) {
                instant = gregorianToJulian(instant);
            }
        }
    } else {
        instant = iJulianField.add(instant, value);
        if (instant >= iCutover) {
            // Only adjust if gap fully crossed.
            if (instant - iGapDuration >= iCutover) {
                // no special handling for year zero as cutover always after year zero
                instant = julianToGregorian(instant);
            }
        }
    }
    return instant;
}",0,0
367,Time_9,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
         if (hoursOffset == 0 && minutesOffset == 0) {
             return DateTimeZone.UTC;
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
             if (hoursInMinutes < 0) {
                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
             } else {
                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
             }
             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
         } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }","public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
    if (hoursOffset == 0 && minutesOffset == 0) {
        return DateTimeZone.UTC;
    }
    if (minutesOffset < 0 || minutesOffset > 59) {
        throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
    }
    if (hoursOffset < -23 || hoursOffset > 23) {
        throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
    }
    int offset = 0;
    try {
        int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
        if (hoursInMinutes < 0) {
            offset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
        } else {
            offset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
        }
        offset = FieldUtils.safeMultiply(offset, DateTimeConstants.MILLIS_PER_MINUTE);
    } catch (ArithmeticException ex) {
        throw new IllegalArgumentException(""Offset is too large"");
    }
    return forOffsetMillis(offset);
}",0,0
