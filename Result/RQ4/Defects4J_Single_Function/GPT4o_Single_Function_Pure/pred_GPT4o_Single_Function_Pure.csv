ID,slug,bug,fix,width_attempt,iteration
0,Chart_1,"public LegendItemCollection getLegendItems() {
        LegendItemCollection result = new LegendItemCollection();
        if (this.plot == null) {
            return result;
         }
         int index = this.plot.getIndexOf(this);
         CategoryDataset dataset = this.plot.getDataset(index);
         if (dataset != null) {
             return result;
         }
         int seriesCount = dataset.getRowCount();
        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {
            for (int i = 0; i < seriesCount; i++) {
                if (isSeriesVisibleInLegend(i)) {
                    LegendItem item = getLegendItem(index, i);
                    if (item != null) {
                        result.add(item);
                    }
                }
            }
        }
        else {
            for (int i = seriesCount - 1; i >= 0; i--) {
                if (isSeriesVisibleInLegend(i)) {
                    LegendItem item = getLegendItem(index, i);
                    if (item != null) {
                        result.add(item);
                    }
                }
            }
        }
        return result;
    }","public LegendItemCollection getLegendItems() {
        LegendItemCollection result = new LegendItemCollection();
        if (this.plot == null) {
            return result;
        }
        int index = this.plot.getIndexOf(this);
        CategoryDataset dataset = this.plot.getDataset(index);
        if (dataset == null) {
            return result;
        }
        int seriesCount = dataset.getRowCount();
        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {
            for (int i = 0; i < seriesCount; i++) {
                if (isSeriesVisibleInLegend(i)) {
                    LegendItem item = getLegendItem(index, i);
                    if (item != null) {
                        result.add(item);
                    }
                }
            }
        } else {
            for (int i = seriesCount - 1; i >= 0; i--) {
                if (isSeriesVisibleInLegend(i)) {
                    LegendItem item = getLegendItem(index, i);
                    if (item != null) {
                        result.add(item);
                    }
                }
            }
        }
        return result;
    }",0,0
1,Chart_10,"    public String generateToolTipFragment(String toolTipText) {
        return "" title=\"""" + toolTipText
            + ""\"" alt=\""\"""";
    }
",Match failed,0,0
2,Chart_11,"public static boolean equal(GeneralPath p1, GeneralPath p2) {
        if (p1 == null) {
            return (p2 == null);
        }
        if (p2 == null) {
            return false;
        }
        if (p1.getWindingRule() != p2.getWindingRule()) {
             return false;
         }
         PathIterator iterator1 = p1.getPathIterator(null);
         PathIterator iterator2 = p1.getPathIterator(null);
         double[] d1 = new double[6];
         double[] d2 = new double[6];
         boolean done = iterator1.isDone() && iterator2.isDone();
        while (!done) {
            if (iterator1.isDone() != iterator2.isDone()) {
                return false;
            }
            int seg1 = iterator1.currentSegment(d1);
            int seg2 = iterator2.currentSegment(d2);
            if (seg1 != seg2) {
                return false;
            }
            if (!Arrays.equals(d1, d2)) {
                return false;
            }
            iterator1.next();
            iterator2.next();
            done = iterator1.isDone() && iterator2.isDone();
        }
        return true;
    }","public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p2.getPathIterator(null); // Corrected: changed from p1 to p2
    double[] d1 = new double[6];
    double[] d2 = new double[6];
    while (!iterator1.isDone() && !iterator2.isDone()) { // Corrected: simplified loop condition
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
    }
    return iterator1.isDone() && iterator2.isDone(); // Validates both iterators are done
}",0,0
3,Chart_12,"    public MultiplePiePlot(CategoryDataset dataset) {
        super();
        this.dataset = dataset;
        PiePlot piePlot = new PiePlot(null);
        this.pieChart = new JFreeChart(piePlot);
        this.pieChart.removeLegend();
        this.dataExtractOrder = TableOrder.BY_COLUMN;
        this.pieChart.setBackgroundPaint(null);
        TextTitle seriesTitle = new TextTitle(""Series Title"",
                new Font(""SansSerif"", Font.BOLD, 12));
        seriesTitle.setPosition(RectangleEdge.BOTTOM);
        this.pieChart.setTitle(seriesTitle);
        this.aggregatedItemsKey = ""Other"";
        this.aggregatedItemsPaint = Color.lightGray;
        this.sectionPaints = new HashMap();
    }
","public MultiplePiePlot(CategoryDataset dataset) {
        super();
        this.dataset = dataset;

        PiePlot piePlot = new PiePlot(null);
        this.pieChart = new JFreeChart(piePlot);
        this.pieChart.removeLegend();
        this.dataExtractOrder = TableOrder.BY_COLUMN;
        // Set a default background color for the pie chart to avoid potential null issues
        this.pieChart.setBackgroundPaint(Color.WHITE); 

        // Temporarily set default title using a constructor
        TextTitle seriesTitle = new TextTitle(""Series Title"",
                new Font(""SansSerif"", Font.BOLD, 12));

        seriesTitle.setPosition(RectangleEdge.BOTTOM);
        this.pieChart.setTitle(seriesTitle);
        
        this.aggregatedItemsKey = ""Other"";
        this.aggregatedItemsPaint = Color.lightGray;
        
        // Explicitly define the type of HashMap to avoid unchecked warnings
        this.sectionPaints = new HashMap<String, Paint>();
    }",0,0
4,Chart_13,"protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                               RectangleConstraint constraint) {
        double[] w = new double[5];
        double[] h = new double[5];
        w[0] = constraint.getWidth();
        if (this.topBlock != null) {
            RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0,
                    new Range(0.0, constraint.getHeight()),
                    LengthConstraintType.RANGE);
            Size2D size = this.topBlock.arrange(g2, c1);
            h[0] = size.height;
        }
        w[1] = w[0];
        if (this.bottomBlock != null) {
            RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0, new Range(0.0,
                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
            Size2D size = this.bottomBlock.arrange(g2, c2);
            h[1] = size.height;
        }
        h[2] = constraint.getHeight() - h[1] - h[0];
        if (this.leftBlock != null) {
            RectangleConstraint c3 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth()),
                    LengthConstraintType.RANGE, h[2], null,
                    LengthConstraintType.FIXED);
            Size2D size = this.leftBlock.arrange(g2, c3);
            w[2] = size.width;
        }
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                     new Range(0.0, constraint.getWidth() - w[2]),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
            w[3] = size.width;
        }
        h[4] = h[2];
        w[4] = constraint.getWidth() - w[3] - w[2];
        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
        if (this.centerBlock != null) {
            this.centerBlock.arrange(g2, c5);
        }

        if (this.topBlock != null) {
            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],
                    h[0]));
        }
        if (this.bottomBlock != null) {
            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],
                    w[1], h[1]));
        }
        if (this.leftBlock != null) {
            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
                    h[2]));
        }
        if (this.rightBlock != null) {
            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],
                    w[3], h[3]));
        }
        if (this.centerBlock != null) {
            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],
                    h[4]));
        }
        return new Size2D(constraint.getWidth(), constraint.getHeight());
    }","protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                           RectangleConstraint constraint) {
    double[] w = new double[5];
    double[] h = new double[5];
    w[0] = constraint.getWidth();
    
    if (this.topBlock != null) {
        RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                LengthConstraintType.FIXED, 0.0,
                new Range(0.0, constraint.getHeight()),
                LengthConstraintType.RANGE);
        Size2D size = this.topBlock.arrange(g2, c1);
        h[0] = size.height;
    }
    
    w[1] = w[0];
    if (this.bottomBlock != null) {
        RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                LengthConstraintType.FIXED, 0.0, new Range(0.0,
                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
        Size2D size = this.bottomBlock.arrange(g2, c2);
        h[1] = size.height;
    }
    
    h[2] = Math.max(0.0, constraint.getHeight() - h[1] - h[0]);
    if (this.leftBlock != null) {
        RectangleConstraint c3 = new RectangleConstraint(0.0,
                new Range(0.0, constraint.getWidth()),
                LengthConstraintType.RANGE, h[2], null,
                LengthConstraintType.FIXED);
        Size2D size = this.leftBlock.arrange(g2, c3);
        w[2] = size.width;
    }
    
    h[3] = h[2];
    if (this.rightBlock != null) {
        RectangleConstraint c4 = new RectangleConstraint(0.0,
                new Range(0.0, constraint.getWidth() - w[2]),
                LengthConstraintType.RANGE, h[2], null,
                LengthConstraintType.FIXED);
        Size2D size = this.rightBlock.arrange(g2, c4);
        w[3] = size.width;
    }
    
    h[4] = h[2];
    w[4] = Math.max(0.0, constraint.getWidth() - w[3] - w[2]);
    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
    if (this.centerBlock != null) {
        this.centerBlock.arrange(g2, c5);
    }

    if (this.topBlock != null) {
        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0]));
    }
    if (this.bottomBlock != null) {
        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1]));
    }
    if (this.leftBlock != null) {
        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2]));
    }
    if (this.rightBlock != null) {
        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3]));
    }
    if (this.centerBlock != null) {
        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4]));
    }
    return new Size2D(constraint.getWidth(), constraint.getHeight());
}",0,0
5,Chart_17,"    public Object clone() throws CloneNotSupportedException {
        Object clone = createCopy(0, getItemCount() - 1);
        return clone;
    }
","@Override
public Object clone() throws CloneNotSupportedException {
    try {
        // Assuming createCopy is a method to copy the object and getItemCount() provides the count of items to copy
        return createCopy(0, getItemCount() - 1);
    } catch (Exception e) {
        // Exception handling if createCopy encounters an issue
        throw new CloneNotSupportedException(""Clone failed: "" + e.getMessage());
    }
}",0,0
6,Chart_20,"    public ValueMarker(double value, Paint paint, Stroke stroke, 
                       Paint outlinePaint, Stroke outlineStroke, float alpha) {
        super(paint, stroke, paint, stroke, alpha);
        this.value = value;
    }
","public ValueMarker(double value, Paint paint, Stroke stroke, 
                   Paint outlinePaint, Stroke outlineStroke, float alpha) {
    super(paint, stroke, outlinePaint, outlineStroke, alpha);
    this.value = value;
}",0,0
7,Chart_24,"public Paint getPaint(double value) {
         double v = Math.max(value, this.lowerBound);
         v = Math.min(v, this.upperBound);
         int g = (int) ((value - this.lowerBound) / (this.upperBound 
                 - this.lowerBound) * 255.0);
         return new Color(g, g, g);
     }","public Paint getPaint(double value) {
    // Clamp the value within the bounds
    double v = Math.max(value, this.lowerBound);
    v = Math.min(v, this.upperBound);

    // Compute the color gradient value
    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0);

    // Ensure the computed value for the color is within valid range (0-255)
    g = Math.max(0, Math.min(255, g));
    
    return new Color(g, g, g);
}",0,0
8,Chart_26,"    protected AxisState drawLabel(String label, Graphics2D g2, 
            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, 
            AxisState state, PlotRenderingInfo plotState) {

        // it is unlikely that 'state' will be null, but check anyway...
        if (state == null) {
            throw new IllegalArgumentException(""Null 'state' argument."");
        }
        
        if ((label == null) || (label.equals(""""))) {
            return state;
        }

        Font font = getLabelFont();
        RectangleInsets insets = getLabelInsets();
        g2.setFont(font);
        g2.setPaint(getLabelPaint());
        FontMetrics fm = g2.getFontMetrics();
        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);
        Shape hotspot = null;
        
        if (edge == RectangleEdge.TOP) {
            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle(), labelBounds.getCenterX(), 
                    labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) dataArea.getCenterX();
            float labely = (float) (state.getCursor() - insets.getBottom() 
                    - h / 2.0);
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorUp(insets.getTop() + labelBounds.getHeight() 
                    + insets.getBottom());
        }
        else if (edge == RectangleEdge.BOTTOM) {
            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle(), labelBounds.getCenterX(), 
                    labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) dataArea.getCenterX();
            float labely = (float) (state.getCursor() + insets.getTop() 
                    + h / 2.0);
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorDown(insets.getTop() + labelBounds.getHeight() 
                    + insets.getBottom());
        }
        else if (edge == RectangleEdge.LEFT) {
            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), 
                    labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) (state.getCursor() - insets.getRight() 
                    - w / 2.0);
            float labely = (float) dataArea.getCenterY();
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, 
                    TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() 
                    + insets.getRight());
        }
        else if (edge == RectangleEdge.RIGHT) {

            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle() + Math.PI / 2.0, 
                    labelBounds.getCenterX(), labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) (state.getCursor() 
                            + insets.getLeft() + w / 2.0);
            float labely = (float) (dataArea.getY() + dataArea.getHeight() 
                    / 2.0);
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, 
                    TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorRight(insets.getLeft() + labelBounds.getWidth() 
                    + insets.getRight());

        }
        if (plotState != null && hotspot != null) {
            ChartRenderingInfo owner = plotState.getOwner();
                EntityCollection entities = owner.getEntityCollection();
                if (entities != null) {
                    entities.add(new AxisLabelEntity(this, hotspot, 
                            this.labelToolTip, this.labelURL));
                }
        }
        return state;

    }
","protected AxisState drawLabel(String label, Graphics2D g2, 
            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, 
            AxisState state, PlotRenderingInfo plotState) {

    // ensure the 'state' argument is not null
    if (state == null) {
        throw new IllegalArgumentException(""Null 'state' argument."");
    }

    // check if the label is empty, return state as is
    if ((label == null) || label.isEmpty()) {
        return state;
    }

    Font font = getLabelFont();
    RectangleInsets insets = getLabelInsets();
    g2.setFont(font);
    g2.setPaint(getLabelPaint());
    FontMetrics fm = g2.getFontMetrics();
    Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);
    Shape hotspot = null;

    // Label drawing logic based on the edge
    if (edge == RectangleEdge.TOP) {
        AffineTransform t = AffineTransform.getRotateInstance(
                getLabelAngle(), labelBounds.getCenterX(), 
                labelBounds.getCenterY());
        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
        labelBounds = rotatedLabelBounds.getBounds2D();

        float w = (float) labelBounds.getWidth();
        float h = (float) labelBounds.getHeight();
        float labelx = (float) dataArea.getCenterX();
        float labely = (float) (state.getCursor() - insets.getBottom() 
                - h / 2.0);
        TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                labely - h / 2.0f, w, h);
        state.cursorUp(insets.getTop() + h + insets.getBottom());
    } 
    else if (edge == RectangleEdge.BOTTOM) {
        AffineTransform t = AffineTransform.getRotateInstance(
                getLabelAngle(), labelBounds.getCenterX(), 
                labelBounds.getCenterY());
        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
        labelBounds = rotatedLabelBounds.getBounds2D();

        float w = (float) labelBounds.getWidth();
        float h = (float) labelBounds.getHeight();
        float labelx = (float) dataArea.getCenterX();
        float labely = (float) (state.getCursor() + insets.getTop() 
                + h / 2.0);
        TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                labely - h / 2.0f, w, h);
        state.cursorDown(insets.getTop() + h + insets.getBottom());
    } 
    else if (edge == RectangleEdge.LEFT) {
        AffineTransform t = AffineTransform.getRotateInstance(
                getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), 
                labelBounds.getCenterY());
        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
        labelBounds = rotatedLabelBounds.getBounds2D();

        float w = (float) labelBounds.getWidth();
        float h = (float) labelBounds.getHeight();
        float labelx = (float) (state.getCursor() - insets.getRight() 
                - w / 2.0);
        float labely = (float) dataArea.getCenterY();
        TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, 
                TextAnchor.CENTER);
        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                labely - h / 2.0f, w, h);
        state.cursorLeft(insets.getLeft() + w + insets.getRight());
    } 
    else if (edge == RectangleEdge.RIGHT) {
        AffineTransform t = AffineTransform.getRotateInstance(
                getLabelAngle() + Math.PI / 2.0, 
                labelBounds.getCenterX(), labelBounds.getCenterY());
        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
        labelBounds = rotatedLabelBounds.getBounds2D();

        float w = (float) labelBounds.getWidth();
        float h = (float) labelBounds.getHeight();
        float labelx = (float) (state.getCursor() + insets.getLeft() 
                + w / 2.0);
        float labely = (float) (dataArea.getCenterY());
        TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, 
                TextAnchor.CENTER);
        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                labely - h / 2.0f, w, h);
        state.cursorRight(insets.getLeft() + w + insets.getRight());
    }

    // Add label entity to chart rendering info if available
    if (plotState != null && hotspot != null) {
        ChartRenderingInfo owner = plotState.getOwner();
        if (owner != null) {
            EntityCollection entities = owner.getEntityCollection();
            if (entities != null) {
                entities.add(new AxisLabelEntity(this, hotspot, 
                        this.labelToolTip, this.labelURL));
            }
        }
    }
    return state;
}",0,0
9,Chart_3,"public TimeSeries createCopy(int start, int end)
            throws CloneNotSupportedException {
        if (start < 0) {
            throw new IllegalArgumentException(""Requires start >= 0."");
        }
        if (end < start) {
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
                TimeSeriesDataItem item
                        = (TimeSeriesDataItem) this.data.get(index);
                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
                try {
                    copy.add(clone);
                }
                catch (SeriesException e) {
                    e.printStackTrace();
                }
            }
        }
        return copy;
    }","public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {
    if (start < 0) {
        throw new IllegalArgumentException(""Requires start >= 0."");
    }
    if (end < start) {
        throw new IllegalArgumentException(""Requires start <= end."");
    }
    
    TimeSeries copy = (TimeSeries) super.clone();
    copy.data = new java.util.ArrayList<>();
    
    if (this.data.size() > 0) {
        // Adjust end to be within bounds
        end = Math.min(end, this.data.size() - 1);
        
        for (int index = start; index <= end; index++) {
            TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);
            TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
            try {
                copy.add(clone);
            } catch (SeriesException e) {
                e.printStackTrace();
            }
        }
    }
    return copy;
}",0,0
10,Chart_4,"    public Range getDataRange(ValueAxis axis) {

        Range result = null;
        List mappedDatasets = new ArrayList();
        List includedAnnotations = new ArrayList();
        boolean isDomainAxis = true;

        // is it a domain axis?
        int domainIndex = getDomainAxisIndex(axis);
        if (domainIndex >= 0) {
            isDomainAxis = true;
            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(
                    new Integer(domainIndex)));
            if (domainIndex == 0) {
                // grab the plot's annotations
                Iterator iterator = this.annotations.iterator();
                while (iterator.hasNext()) {
                    XYAnnotation annotation = (XYAnnotation) iterator.next();
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }

        // or is it a range axis?
        int rangeIndex = getRangeAxisIndex(axis);
        if (rangeIndex >= 0) {
            isDomainAxis = false;
            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(
                    new Integer(rangeIndex)));
            if (rangeIndex == 0) {
                Iterator iterator = this.annotations.iterator();
                while (iterator.hasNext()) {
                    XYAnnotation annotation = (XYAnnotation) iterator.next();
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }

        // iterate through the datasets that map to the axis and get the union
        // of the ranges.
        Iterator iterator = mappedDatasets.iterator();
        while (iterator.hasNext()) {
            XYDataset d = (XYDataset) iterator.next();
            if (d != null) {
                XYItemRenderer r = getRendererForDataset(d);
                if (isDomainAxis) {
                    if (r != null) {
                        result = Range.combine(result, r.findDomainBounds(d));
                    }
                    else {
                        result = Range.combine(result,
                                DatasetUtilities.findDomainBounds(d));
                    }
                }
                else {
                    if (r != null) {
                        result = Range.combine(result, r.findRangeBounds(d));
                    }
                    else {
                        result = Range.combine(result,
                                DatasetUtilities.findRangeBounds(d));
                    }
                }
                
                    Collection c = r.getAnnotations();
                    Iterator i = c.iterator();
                    while (i.hasNext()) {
                        XYAnnotation a = (XYAnnotation) i.next();
                        if (a instanceof XYAnnotationBoundsInfo) {
                            includedAnnotations.add(a);
                        }
                    }
            }
        }

        Iterator it = includedAnnotations.iterator();
        while (it.hasNext()) {
            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();
            if (xyabi.getIncludeInDataBounds()) {
                if (isDomainAxis) {
                    result = Range.combine(result, xyabi.getXRange());
                }
                else {
                    result = Range.combine(result, xyabi.getYRange());
                }
            }
        }

        return result;

    }","public Range getDataRange(ValueAxis axis) {
    
        Range result = null;
        List<XYDataset> mappedDatasets = new ArrayList<>();
        List<XYAnnotation> includedAnnotations = new ArrayList<>();
        boolean isDomainAxis = true;

        // is it a domain axis?
        int domainIndex = getDomainAxisIndex(axis);
        if (domainIndex >= 0) {
            isDomainAxis = true;
            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(domainIndex));
            if (domainIndex == 0) {
                // grab the plot's annotations
                for (XYAnnotation annotation : this.annotations) {
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }

        // or is it a range axis?
        int rangeIndex = getRangeAxisIndex(axis);
        if (rangeIndex >= 0) {
            isDomainAxis = false;
            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(rangeIndex));
            if (rangeIndex == 0) {
                for (XYAnnotation annotation : this.annotations) {
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }

        // iterate through the datasets that map to the axis and get the union
        // of the ranges.
        for (XYDataset d : mappedDatasets) {
            if (d != null) {
                XYItemRenderer r = getRendererForDataset(d);
                if (isDomainAxis) {
                    if (r != null) {
                        result = Range.combine(result, r.findDomainBounds(d));
                    } else {
                        result = Range.combine(result, DatasetUtilities.findDomainBounds(d));
                    }
                } else {
                    if (r != null) {
                        result = Range.combine(result, r.findRangeBounds(d));
                    } else {
                        result = Range.combine(result, DatasetUtilities.findRangeBounds(d));
                    }
                }

                if (r != null) {
                    for (XYAnnotation a : r.getAnnotations()) {
                        if (a instanceof XYAnnotationBoundsInfo) {
                            includedAnnotations.add(a);
                        }
                    }
                }
            }
        }

        for (XYAnnotation a : includedAnnotations) {
            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) a;
            if (xyabi.getIncludeInDataBounds()) {
                if (isDomainAxis) {
                    result = Range.combine(result, xyabi.getXRange());
                } else {
                    result = Range.combine(result, xyabi.getYRange());
                }
            }
        }

        return result;
    }",0,0
11,Chart_5,"public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
         if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
            }
            catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
        else {
            // if the series is sorted, the negative index is a result from
            // Collections.binarySearch() and tells us where to insert the
            // new item...otherwise it will be just -1 and we should just
            // append the value to the list...
            if (this.autoSort) {
                this.data.add(-index - 1, new XYDataItem(x, y));
            }
            else {
                this.data.add(new XYDataItem(x, y));
            }
            // check if this addition will exceed the maximum item count...
            if (getItemCount() > this.maximumItemCount) {
                this.data.remove(0);
            }
        }
        fireSeriesChanged();
        return overwritten;
    }","public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }
    
    XYDataItem overwritten = null;
    int index = indexOf(x);
    if (index >= 0) {
        // Found an existing item, check if we allow duplicate X values
        if (!this.allowDuplicateXValues) {
            XYDataItem existing = (XYDataItem) this.data.get(index);
            try {
                overwritten = (XYDataItem) existing.clone();
            } catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        } else {
            // Allow duplicate, so add a new item instead of updating
            this.data.add(new XYDataItem(x, y));
            if (this.autoSort) {
                Collections.sort(this.data);
            }
        }
    } else {
        if (this.autoSort) {
            this.data.add(-index - 1, new XYDataItem(x, y));
        } else {
            this.data.add(new XYDataItem(x, y));
        }
    }
    
    // Check if this addition will exceed the maximum item count...
    if (getItemCount() > this.maximumItemCount) {
        this.data.remove(0);
    }
    
    fireSeriesChanged();
    return overwritten;
}",0,0
12,Chart_6,"public boolean equals(Object obj) {

        if (obj == this) {
            return true;
        }
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }","public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof ShapeList)) {
        return false;
    }
    ShapeList other = (ShapeList) obj;
    return super.equals(other);
}",0,0
13,Chart_7,"private void updateBounds(TimePeriod period, int index) {
        
        long start = period.getStart().getTime();
        long end = period.getEnd().getTime();
        long middle = start + ((end - start) / 2);

        if (this.minStartIndex >= 0) {
            long minStart = getDataItem(this.minStartIndex).getPeriod()
                .getStart().getTime();
            if (start < minStart) {
                this.minStartIndex = index;           
            }
        }
        else {
            this.minStartIndex = index;
        }
        
        if (this.maxStartIndex >= 0) {
            long maxStart = getDataItem(this.maxStartIndex).getPeriod()
                .getStart().getTime();
            if (start > maxStart) {
                this.maxStartIndex = index;           
            }
        }
        else {
            this.maxStartIndex = index;
        }
        
        if (this.minMiddleIndex >= 0) {
            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                .getTime();
            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                .getTime();
            long minMiddle = s + (e - s) / 2;
            if (middle < minMiddle) {
                this.minMiddleIndex = index;           
            }
        }
        else {
            this.minMiddleIndex = index;
        }
        
        if (this.maxMiddleIndex >= 0) {
            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                .getTime();
            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                .getTime();
            long maxMiddle = s + (e - s) / 2;
            if (middle > maxMiddle) {
                this.maxMiddleIndex = index;           
            }
        }
        else {
            this.maxMiddleIndex = index;
        }
        
        if (this.minEndIndex >= 0) {
            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()
                .getTime();
            if (end < minEnd) {
                this.minEndIndex = index;           
            }
        }
        else {
            this.minEndIndex = index;
        }
       
        if (this.maxEndIndex >= 0) {
            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()
                .getTime();
            if (end > maxEnd) {
                this.maxEndIndex = index;           
            }
        }
        else {
            this.maxEndIndex = index;
        }
        
    }","private void updateBounds(TimePeriod period, int index) {
        
        long start = period.getStart().getTime();
        long end = period.getEnd().getTime();
        long middle = start + ((end - start) / 2);

        if (this.minStartIndex >= 0) {
            long minStart = getDataItem(this.minStartIndex).getPeriod()
                .getStart().getTime();
            if (start < minStart) {
                this.minStartIndex = index;           
            }
        }
        else {
            this.minStartIndex = index;
        }
        
        if (this.maxStartIndex >= 0) {
            long maxStart = getDataItem(this.maxStartIndex).getPeriod()
                .getStart().getTime();
            if (start > maxStart) {
                this.maxStartIndex = index;           
            }
        }
        else {
            this.maxStartIndex = index;
        }
        
        if (this.minMiddleIndex >= 0) {
            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                .getTime();
            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                .getTime();
            long minMiddle = s + (e - s) / 2;
            if (middle < minMiddle) {
                this.minMiddleIndex = index;           
            }
        }
        else {
            this.minMiddleIndex = index;
        }
        
        if (this.maxMiddleIndex >= 0) {
            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()
                .getTime(); // Corrected to use maxMiddleIndex instead of minMiddleIndex
            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()
                .getTime(); // Corrected to use maxMiddleIndex instead of minMiddleIndex
            long maxMiddle = s + (e - s) / 2;
            if (middle > maxMiddle) {
                this.maxMiddleIndex = index;           
            }
        }
        else {
            this.maxMiddleIndex = index;
        }
        
        if (this.minEndIndex >= 0) {
            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()
                .getTime();
            if (end < minEnd) {
                this.minEndIndex = index;           
            }
        }
        else {
            this.minEndIndex = index;
        }
       
        if (this.maxEndIndex >= 0) {
            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()
                .getTime();
            if (end > maxEnd) {
                this.maxEndIndex = index;           
            }
        }
        else {
            this.maxEndIndex = index;
        }
        
    }",0,0
14,Chart_8,"    public Week(Date time, TimeZone zone) {
        // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
    }
","public Week(Date time, TimeZone zone) {
    // ensure proper argument checking
    if (time == null) {
        throw new IllegalArgumentException(""Null 'time' argument."");
    }
    if (zone == null) {
        throw new IllegalArgumentException(""Null 'zone' argument."");
    }
    this(time, zone, Locale.getDefault());
}",0,0
15,Chart_9,"public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

        if (start == null) {
            throw new IllegalArgumentException(""Null 'start' argument."");
        }
        if (end == null) {
            throw new IllegalArgumentException(""Null 'end' argument."");
        }
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(
                    ""Requires start on or before end."");
        }
        boolean emptyRange = false;
        int startIndex = getIndex(start);
        if (startIndex < 0) {
            startIndex = -(startIndex + 1);
            if (startIndex == this.data.size()) {
                emptyRange = true;  // start is after last data item
            }
        }
        int endIndex = getIndex(end);
        if (endIndex < 0) {             // end period is not in original series
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
         if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
            TimeSeries copy = (TimeSeries) super.clone();
            copy.data = new java.util.ArrayList();
            return copy;
        }
        else {
            return createCopy(startIndex, endIndex);
        }

    }","public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

    if (start == null) {
        throw new IllegalArgumentException(""Null 'start' argument."");
    }
    if (end == null) {
        throw new IllegalArgumentException(""Null 'end' argument."");
    }
    if (start.compareTo(end) > 0) {
        throw new IllegalArgumentException(
                ""Requires start on or before end."");
    }
    boolean emptyRange = false;
    int startIndex = getIndex(start);
    if (startIndex < 0) {
        startIndex = -(startIndex + 1);
        if (startIndex >= this.data.size()) {
            emptyRange = true;  // start is after last data item
        }
    }
    int endIndex = getIndex(end);
    if (endIndex < 0) {             // end period is not in original series
        endIndex = -(endIndex + 1); // this is first item AFTER end period
        endIndex = endIndex - 1;    // so this is last item BEFORE end
    }
    if (endIndex < 0 || startIndex > endIndex) {
        emptyRange = true;
    }
    if (emptyRange) {
        TimeSeries copy = (TimeSeries) super.clone();
        copy.data = new java.util.ArrayList();
        return copy;
    } else {
        return createCopy(startIndex, endIndex);
    }
}",0,0
16,Cli_11,"private static void appendOption(final StringBuffer buff, 
                                     final Option option, 
                                     final boolean required)
    {
        if (!required)
        {
            buff.append(""["");
        }

        if (option.getOpt() != null)
        {
            buff.append(""-"").append(option.getOpt());
        }
        else
        {
            buff.append(""--"").append(option.getLongOpt());
         }
 
         // if the Option has a value
         if (option.hasArg() && (option.getArgName() != null))
         {
             buff.append("" <"").append(option.getArgName()).append("">"");
         }

        // if the Option is not a required option
        if (!required)
        {
            buff.append(""]"");
        }
    }","private static void appendOption(final StringBuffer buff, 
                                     final Option option, 
                                     final boolean required)
    {
        if (buff == null || option == null) {
            throw new IllegalArgumentException(""Buffer and Option cannot be null."");
        }

        if (!required)
        {
            buff.append(""["");
        }

        if (option.getOpt() != null && !option.getOpt().isEmpty())
        {
            buff.append(""-"").append(option.getOpt());
        }
        else if (option.getLongOpt() != null && !option.getLongOpt().isEmpty())
        {
            buff.append(""--"").append(option.getLongOpt());
        }
        else
        {
            throw new IllegalArgumentException(""Option must have either a short or long name."");
        }
 
        // if the Option has a value
        if (option.hasArg() && option.getArgName() != null && !option.getArgName().isEmpty())
        {
            buff.append("" <"").append(option.getArgName()).append("">"");
        }

        // if the Option is not a required option
        if (!required)
        {
            buff.append(""]"");
        }
    }",0,0
17,Cli_12,"protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        List tokens = new ArrayList();

        boolean eatTheRest = false;

        for (int i = 0; i < arguments.length; i++)
        {
            String arg = arguments[i];

            if (""--"".equals(arg))
            {
                eatTheRest = true;
                tokens.add(""--"");
            }
            else if (""-"".equals(arg))
            {
                tokens.add(""-"");
            }
            else if (arg.startsWith(""-""))
            {
                String opt = Util.stripLeadingHyphens(arg);

                if (options.hasOption(opt))
                {
                    tokens.add(arg);
                 }
                 else
                 {
                     if (options.hasOption(arg.substring(0, 2)))
                     {
                         // the format is --foo=value or -foo=value
                         // the format is a special properties option (-Dproperty=value)
                         tokens.add(arg.substring(0, 2)); // -D
                         tokens.add(arg.substring(2)); // property=value
                    }
                    else
                    {
                        eatTheRest = stopAtNonOption;
                        tokens.add(arg);
                    }
                }
            }
            else
            {
                tokens.add(arg);
            }

            if (eatTheRest)
            {
                for (i++; i < arguments.length; i++)
                {
                    tokens.add(arguments[i]);
                }
            }
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    List<String> tokens = new ArrayList<>();

    boolean eatTheRest = false;

    for (int i = 0; i < arguments.length; i++) {
        String arg = arguments[i];

        if (""--"".equals(arg)) {
            eatTheRest = true;
            tokens.add(""--"");
        } else if (""-"".equals(arg)) {
            tokens.add(""-"");
        } else if (arg.startsWith(""-"")) {
            String opt = Util.stripLeadingHyphens(arg);

            if (options.hasOption(opt)) {
                tokens.add(arg);
            } else {
                if (arg.length() > 1 && options.hasOption(arg.substring(0, 2))) { // Ensure proper string length for substring
                    // the format is --foo=value or -foo=value
                    // the format is a special properties option (-Dproperty=value)
                    tokens.add(arg.substring(0, 2)); // -D
                    if (arg.length() > 2) { // Ensure there's more after ""-D""
                        tokens.add(arg.substring(2)); // property=value
                    }
                } else {
                    eatTheRest = stopAtNonOption;
                    tokens.add(arg);
                }
            }
        } else {
            tokens.add(arg);
        }

        if (eatTheRest) {
            for (i++; i < arguments.length; i++) {
                tokens.add(arguments[i]);
            }
            break; // Ensure processing stops after ""eatTheRest"" condition
        }
    }

    return tokens.toArray(new String[0]); // Use a correctly typed array conversion
}",0,0
18,Cli_14,"public void validate(final WriteableCommandLine commandLine)
        throws OptionException {
        // number of options found
        int present = 0;

        // reference to first unexpected option
        Option unexpected = null;

        for (final Iterator i = options.iterator(); i.hasNext();) {
            final Option option = (Option) i.next();
 
             // needs validation?
             boolean validate = option.isRequired() || option instanceof Group;
             if (validate) {
                 option.validate(commandLine);
             }
 
             // if the child option is present then validate it
             if (commandLine.hasOption(option)) {
                if (++present > maximum) {
                    unexpected = option;

                    break;
                }

                option.validate(commandLine);
            }
        }

        // too many options
        if (unexpected != null) {
            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,
                                      unexpected.getPreferredName());
        }

        // too few option
        if (present < minimum) {
            throw new OptionException(this, ResourceConstants.MISSING_OPTION);
        }

        // validate each anonymous argument
        for (final Iterator i = anonymous.iterator(); i.hasNext();) {
            final Option option = (Option) i.next();
            option.validate(commandLine);
        }
    }","public void validate(final WriteableCommandLine commandLine)
        throws OptionException {
    // number of options found
    int present = 0;

    // reference to first unexpected option
    Option unexpected = null;

    for (final Iterator<Option> i = options.iterator(); i.hasNext();) {
        final Option option = i.next();

        // needs validation?
        boolean validate = option.isRequired() || option instanceof Group;
        if (validate) {
            option.validate(commandLine);
        }

        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
        }
    }

    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,
                                  unexpected.getPreferredName());
    }

    // too few options
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }

    // validate each anonymous argument
    for (final Iterator<Option> i = anonymous.iterator(); i.hasNext();) {
        final Option option = i.next();
        option.validate(commandLine);
    }
}",0,0
19,Cli_15,"public List getValues(final Option option,
                          List defaultValues) {
        // initialize the return list
         List valueList = (List) values.get(option);
 
         // grab the correct default values
         if ((valueList == null) || valueList.isEmpty()) {
             valueList = defaultValues;
         }
 
         // augment the list with the default values
         if ((valueList == null) || valueList.isEmpty()) {
             valueList = (List) this.defaultValues.get(option);
         }
                 // if there are more default values as specified, add them to
                 // the list.
                     // copy the list first
         
         return valueList == null ? Collections.EMPTY_LIST : valueList;
     }","public List<?> getValues(final Option option, List<?> defaultValues) {
    // initialize the return list
    List<?> valueList = (List<?>) values.get(option);

    // grab the correct default values
    if ((valueList == null) || valueList.isEmpty()) {
        valueList = defaultValues;
    }

    // augment the list with the default values
    if ((valueList == null) || valueList.isEmpty()) {
        valueList = (List<?>) this.defaultValues.get(option);
    }

    // return the list, ensuring it's never null
    return valueList == null ? Collections.emptyList() : valueList;
}",0,0
20,Cli_17,"protected void burstToken(String token, boolean stopAtNonOption)
    {
        for (int i = 1; i < token.length(); i++)
        {
            String ch = String.valueOf(token.charAt(i));

            if (options.hasOption(ch))
            {
                tokens.add(""-"" + ch);
                currentOption = options.getOption(ch);

                if (currentOption.hasArg() && (token.length() != (i + 1)))
                {
                    tokens.add(token.substring(i + 1));

                    break;
                }
            }
             else if (stopAtNonOption)
             {
                 process(token.substring(i));
             }
             else
             {
                tokens.add(token);
                break;
            }
        }
    }","protected void burstToken(String token, boolean stopAtNonOption) {
    if (token == null || token.length() < 2) {
        // Handle invalid input gracefully
        return;
    }
    
    for (int i = 1; i < token.length(); i++) {
        String ch = String.valueOf(token.charAt(i));

        if (options.hasOption(ch)) {
            tokens.add(""-"" + ch);
            currentOption = options.getOption(ch);

            if (currentOption != null && currentOption.hasArg() && (token.length() > (i + 1))) {
                tokens.add(token.substring(i + 1));
                break;
            }
        } else if (stopAtNonOption) {
            process(token.substring(i));
            break; // Ensure we stop processing further once a non-option is handled
        } else {
            tokens.add(token);
            break;
        }
    }
}",0,0
21,Cli_19,"private void processOptionToken(String token, boolean stopAtNonOption)
    {
        if (options.hasOption(token))
        {
            currentOption = options.getOption(token);
            tokens.add(token);
        }
        else if (stopAtNonOption)
        {
            eatTheRest = true;
            tokens.add(token);
        }
    }","private void processOptionToken(String token, boolean stopAtNonOption) {
    if (token == null || token.isEmpty()) {
        throw new IllegalArgumentException(""Token cannot be null or empty."");
    }

    if (options.hasOption(token)) {
        currentOption = options.getOption(token);
        tokens.add(token);
    } else if (stopAtNonOption) {
        eatTheRest = true;
        tokens.add(token);
    } else {
        tokens.add(token); // Ensure non-options are still added when stopAtNonOption is false
    }
}",0,0
22,Cli_2,"protected void burstToken(String token, boolean stopAtNonOption)
    {
        int tokenLength = token.length();

        for (int i = 1; i < tokenLength; i++)
        {
            String ch = String.valueOf(token.charAt(i));
            boolean hasOption = options.hasOption(ch);

            if (hasOption)
            {
                tokens.add(""-"" + ch);
                currentOption = options.getOption(ch);

                if (currentOption.hasArg() && (token.length() != (i + 1)))
                {
                    tokens.add(token.substring(i + 1));

                    break;
                }
            }
            else if (stopAtNonOption)
            {
                process(token.substring(i));
            }
            else
            {
                tokens.add(""-"" + ch);
            }
        }
    }
}","protected void burstToken(String token, boolean stopAtNonOption)
{
    int tokenLength = token.length();

    for (int i = 1; i < tokenLength; i++)
    {
        String ch = String.valueOf(token.charAt(i));
        boolean hasOption = options.hasOption(ch);

        if (hasOption)
        {
            tokens.add(""-"" + ch);
            currentOption = options.getOption(ch);

            if (currentOption.hasArg() && (token.length() > (i + 1)))
            {
                tokens.add(token.substring(i + 1)); // Ensure token is split properly
                break;
            }
        }
        else if (stopAtNonOption)
        {
            process(token.substring(i)); // Process remaining part of token directly
            break; // Stop processing further if stopAtNonOption is true
        }
        else
        {
            tokens.add(""-"" + ch);
        }
    }
}",0,0
23,Cli_20,"protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle long option --foo or --foo=bar
            if (token.startsWith(""--""))
            {
                if (token.indexOf('=') != -1)
                {
                    tokens.add(token.substring(0, token.indexOf('=')));
                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
                }
                else
                {
                    tokens.add(token);
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                tokens.add(token);
            }
            else if (token.startsWith(""-""))
            {
                if (token.length() == 2)
                {
                    processOptionToken(token, stopAtNonOption);
                }
                else if (options.hasOption(token))
                {
                    tokens.add(token);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                process(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }","protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;

    // an iterator for the command line tokens
    List<String> tokenList = Arrays.asList(arguments);
    Iterator<String> iter = tokenList.iterator();

    // process each command line token
    while (iter.hasNext()) {
        // get the next command line token
        String token = iter.next();

        // handle long option --foo or --foo=bar
        if (token.startsWith(""--"")) {
            if (token.indexOf('=') != -1) {
                tokens.add(token.substring(0, token.indexOf('=')));
                tokens.add(token.substring(token.indexOf('=') + 1));
            } else {
                tokens.add(token);
            }
        }
        // single hyphen
        else if (""-"".equals(token)) {
            tokens.add(token);
        }
        // handle short options starting with a single '-'
        else if (token.startsWith(""-"")) {
            if (token.length() == 2 || options.hasOption(token)) {
                processOptionToken(token, stopAtNonOption);
            } else {
                burstToken(token, stopAtNonOption);
            }
        }
        // non-option argument
        else if (stopAtNonOption) {
            process(token);
        } else {
            tokens.add(token);
        }

        // ensure the iterator continues without skipping tokens (original gobble logic fixed)
        while (iter.hasNext()) {
            tokens.add(iter.next());
        }
    }

    return tokens.toArray(new String[0]); // Simplified array creation
}",0,0
24,Cli_23,"protected StringBuffer renderWrappedText(StringBuffer sb, int width, 
                                             int nextLineTabStop, String text)
    {
        int pos = findWrapPos(text, width, 0);

        if (pos == -1)
        {
            sb.append(rtrim(text));

            return sb;
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);

        // all following lines must be padded with nextLineTabStop space 
        // characters
        final String padding = createPadding(nextLineTabStop);
 
         while (true)
         {
             int lastPos = pos;
             text = padding + text.substring(pos).trim();
             pos = findWrapPos(text, width, 0);
 
            if (pos == -1)
            {
                sb.append(text);

                return sb;
            } else
            if (pos == lastPos)
            {
                throw new RuntimeException(""Text too long for line - throwing exception to avoid infinite loop [CLI-162]: "" + text);
            }

            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
        }
    }","protected StringBuffer renderWrappedText(StringBuffer sb, int width, 
                                             int nextLineTabStop, String text)
    {
        int pos = findWrapPos(text, width, 0);

        // Handle cases where the entire text fits within the width
        if (pos == -1)
        {
            sb.append(rtrim(text));
            return sb;
        }

        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);

        // Pad subsequent lines with spaces as per nextLineTabStop
        final String padding = createPadding(nextLineTabStop);

        while (true)
        {
            int lastPos = pos;
            // Ensure proper trimming and prepending padding
            text = padding + rtrim(text.substring(pos).trim());
            pos = findWrapPos(text, width, 0);

            // Handle cases where the remaining text fits within the width
            if (pos == -1)
            {
                sb.append(text);
                return sb;
            }

            // Avoid infinite loops by checking for no progress in wrapping
            if (pos <= lastPos)
            {
                throw new RuntimeException(""Text too long for line - throwing exception to avoid infinite loop [CLI-162]: "" + text);
            }

            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
        }
    }",0,0
25,Cli_24,"protected StringBuffer renderWrappedText(StringBuffer sb, int width, 
                                             int nextLineTabStop, String text)
    {
        int pos = findWrapPos(text, width, 0);

        if (pos == -1)
        {
            sb.append(rtrim(text));

            return sb;
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);

         if (nextLineTabStop >= width)
         {
             // stops infinite loop happening
             throw new IllegalStateException(""Total width is less than the width of the argument and indent "" + 
                                             ""- no room for the description"");
         }
 
         // all following lines must be padded with nextLineTabStop space 
        // characters
        final String padding = createPadding(nextLineTabStop);

        while (true)
        {
            text = padding + text.substring(pos).trim();
            pos = findWrapPos(text, width, 0);

            if (pos == -1)
            {
                sb.append(text);

                return sb;
            }
            
            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) 
            {
                pos = width;
            }

            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
        }
    }","protected StringBuffer renderWrappedText(StringBuffer sb, int width, 
                                         int nextLineTabStop, String text) {
    int pos = findWrapPos(text, width, 0);

    if (pos == -1) {
        sb.append(rtrim(text));
        return sb;
    }
    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);

    if (nextLineTabStop >= width) {
        // stops infinite loop happening
        throw new IllegalStateException(""Total width is less than the width of the argument and indent "" + 
                                        ""- no room for the description"");
    }

    // all following lines must be padded with nextLineTabStop space characters
    final String padding = createPadding(nextLineTabStop);

    while (true) {
        text = padding + text.substring(pos).trim();
        if (text.isEmpty()) {
            return sb; // avoid infinite loop when padding leads to empty text
        }
        pos = findWrapPos(text, width, nextLineTabStop);

        if (pos == -1) {
            sb.append(text);
            return sb;
        }

        // Corrected condition to avoid infinite loop for edge cases
        if ((text.length() > width) && (pos <= nextLineTabStop)) {
            pos = Math.min(width, text.length());
        }

        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    }
}",0,0
26,Cli_25,"protected StringBuffer renderWrappedText(StringBuffer sb, int width, 
                                             int nextLineTabStop, String text)
    {
        int pos = findWrapPos(text, width, 0);

        if (pos == -1)
        {
            sb.append(rtrim(text));

            return sb;
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);

         if (nextLineTabStop >= width)
         {
             // stops infinite loop happening
             nextLineTabStop = width - 1;
         }
 
         // all following lines must be padded with nextLineTabStop space 
        // characters
        final String padding = createPadding(nextLineTabStop);

        while (true)
        {
            text = padding + text.substring(pos).trim();
            pos = findWrapPos(text, width, 0);

            if (pos == -1)
            {
                sb.append(text);

                return sb;
            }
            
            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) 
            {
                pos = width;
            }

            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
        }
    }","protected StringBuffer renderWrappedText(StringBuffer sb, int width, 
                                             int nextLineTabStop, String text)
{
    int pos = findWrapPos(text, width, 0);

    if (pos == -1)
    {
        sb.append(rtrim(text));

        return sb;
    }
    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);

     if (nextLineTabStop >= width)
     {
         // stops infinite loop happening
         nextLineTabStop = width - 1;
     }

     // all following lines must be padded with nextLineTabStop space 
    // characters
    final String padding = createPadding(nextLineTabStop);

    while (true)
    {
        text = padding + text.substring(pos).trim();
        pos = findWrapPos(text, width, nextLineTabStop);

        if (pos == -1)
        {
            sb.append(text);

            return sb;
        }
        
        if ( (text.length() > width) && (pos == nextLineTabStop) ) 
        {
            pos = width;
        }

        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    }
}",0,0
27,Cli_26,"public static Option create(String opt) throws IllegalArgumentException
     {
             // create the option
         Option option = new Option(opt, description);
 
             // set the option properties
             option.setLongOpt(longopt);
            option.setRequired(required);
            option.setOptionalArg(optionalArg);
            option.setArgs(numberOfArgs);
            option.setType(type);
            option.setValueSeparator(valuesep);
            option.setArgName(argName);
            // reset the OptionBuilder properties
            OptionBuilder.reset();

        // return the Option instance
        return option;
    }","public static Option create(String opt) throws IllegalArgumentException {
    if (opt == null || opt.trim().isEmpty()) {
        throw new IllegalArgumentException(""Option name cannot be null or empty"");
    }

    // Ensure other properties like description and longopt are initialized (if needed)
    if (description == null) {
        description = """"; // Default to empty description if not set
    }
    if (longopt != null && longopt.trim().isEmpty()) {
        longopt = null; // Nullify empty long option for safety
    }

    // create the option
    Option option = new Option(opt, description);

    // set the option properties
    option.setLongOpt(longopt);
    option.setRequired(required);
    option.setOptionalArg(optionalArg);
    option.setArgs(numberOfArgs);
    option.setType(type);
    option.setValueSeparator(valuesep);
    option.setArgName(argName);

    // reset the OptionBuilder properties
    OptionBuilder.reset();

    // return the Option instance
    return option;
}",0,0
28,Cli_27,"public void setSelected(Option option) throws AlreadySelectedException
    {
        if (option == null)
        {
            // reset the option previously selected
            selected = null;
            return;
        }
        
         // if no option has already been selected or the 
         // same option is being reselected then set the
         // selected member variable
         if (selected == null || selected.equals(option.getOpt()))
         {
             selected = option.getOpt();
         }
         else
         {
            throw new AlreadySelectedException(this, option);
        }
    }","public void setSelected(Option option) throws AlreadySelectedException {
    if (option == null) {
        // reset the option previously selected
        selected = null;
        return;
    }
    
    // if no option has already been selected or the 
    // same option is being reselected then set the
    // selected member variable
    if (selected == null || selected.equals(option.getOpt())) {
        selected = option.getOpt();
    } else {
        throw new AlreadySelectedException(this, option.getOpt());
    }
}",0,0
29,Cli_28,"protected void processProperties(Properties properties)
    {
        if (properties == null)
        {
            return;
        }

        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)
        {
            String option = e.nextElement().toString();

            if (!cmd.hasOption(option))
            {
                Option opt = getOptions().getOption(option);

                // get the value from the properties instance
                String value = properties.getProperty(option);

                if (opt.hasArg())
                {
                    if (opt.getValues() == null || opt.getValues().length == 0)
                    {
                        try
                        {
                            opt.addValueForProcessing(value);
                        }
                        catch (RuntimeException exp)
                        {
                            // if we cannot add the value don't worry about it
                        }
                    }
                }
                else if (!(""yes"".equalsIgnoreCase(value)
                        || ""true"".equalsIgnoreCase(value)
                        || ""1"".equalsIgnoreCase(value)))
                 {
                     // if the value is not yes, true or 1 then don't add the
                     // option to the CommandLine
                     break;
                 }
 
                 cmd.addOption(opt);
            }
        }
    }","protected void processProperties(Properties properties)
{
    if (properties == null)
    {
        return;
    }

    for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)
    {
        String option = e.nextElement().toString();

        if (!cmd.hasOption(option))
        {
            Option opt = getOptions().getOption(option);

            // Ensure opt is not null before proceeding
            if (opt == null)
            {
                continue;
            }

            // get the value from the properties instance
            String value = properties.getProperty(option);

            if (opt.hasArg())
            {
                if (opt.getValues() == null || opt.getValues().length == 0)
                {
                    try
                    {
                        opt.addValueForProcessing(value);
                    }
                    catch (RuntimeException exp)
                    {
                        // if we cannot add the value don't worry about it
                    }
                }
            }
            else if (!(""yes"".equalsIgnoreCase(value)
                    || ""true"".equalsIgnoreCase(value)
                    || ""1"".equalsIgnoreCase(value)))
            {
                // if the value is not yes, true or 1 then don't add the
                // option to the CommandLine
                continue;
            }

            cmd.addOption(opt);
        }
    }
}",0,0
30,Cli_29,"static String stripLeadingAndTrailingQuotes(String str)
     {
         if (str.startsWith(""\""""))
         {
             str = str.substring(1, str.length());
         }
         int length = str.length();
         if (str.endsWith(""\""""))
         {
             str = str.substring(0, length - 1);
         }
         
         return str;
    }","static String stripLeadingAndTrailingQuotes(String str) {
    if (str == null || str.isEmpty()) {
        return str;
    }

    if (str.startsWith(""\"""")) {
        str = str.substring(1);
    }
    if (str.endsWith(""\"""")) {
        str = str.substring(0, str.length() - 1);
    }

    return str;
}",0,0
31,Cli_32,"protected int findWrapPos(String text, int width, int startPos)
    {
        int pos;
        
        // the line ends before the max wrap pos or a new line char found
        if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width)
                || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width))
        {
            return pos + 1;
        }
        else if (startPos + width >= text.length())
        {
            return -1;
        }


        // look for the last whitespace character before startPos+width
        pos = startPos + width;

        char c;

        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')
                && (c != '\n') && (c != '\r'))
        {
            --pos;
        }

        // if we found it - just return
        if (pos > startPos)
        {
            return pos;
        }
         
         // if we didn't find one, simply chop at startPos+width
         pos = startPos + width;
         while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')
                && (c != '\n') && (c != '\r'))
         {
             ++pos;
         }        
         return pos == text.length() ? -1 : pos;
     }","protected int findWrapPos(String text, int width, int startPos) {
    int pos;

    // the line ends before the max wrap pos or a new line char found
    if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= startPos + width)
            || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= startPos + width)) {
        return pos + 1;
    } else if (startPos + width >= text.length()) {
        return -1;
    }

    // look for the last whitespace character before startPos+width
    pos = startPos + width;

    char c;

    while (pos > startPos) {
        c = text.charAt(pos);
        if (c == ' ' || c == '\n' || c == '\r') {
            break;
        }
        --pos;
    }

    // if we found it - just return
    if (pos > startPos) {
        return pos;
    }

    // if we didn't find one, simply chop at startPos+width
    pos = startPos + width;
    while (pos < text.length()) {
        c = text.charAt(pos);
        if (c == ' ' || c == '\n' || c == '\r') {
            break;
        }
        ++pos;
    }
    
    return pos >= text.length() ? -1 : pos;
}",0,0
32,Cli_35,"public List<String> getMatchingOptions(String opt)
    {
        opt = Util.stripLeadingHyphens(opt);
        
         List<String> matchingOpts = new ArrayList<String>();
 
         // for a perfect match return the single option only
 
         for (String longOpt : longOpts.keySet())
         {
            if (longOpt.startsWith(opt))
            {
                matchingOpts.add(longOpt);
            }
        }
        
        return matchingOpts;
    }","public List<String> getMatchingOptions(String opt) {
    if (opt == null) {
        throw new IllegalArgumentException(""Option cannot be null."");
    }
    
    opt = Util.stripLeadingHyphens(opt);
    
    List<String> matchingOpts = new ArrayList<String>();
    
    // Ensure longOpts is not null before proceeding
    if (longOpts == null || longOpts.isEmpty()) {
        return matchingOpts; // Return an empty list if no options are defined
    }
    
    // For a perfect match return the single option only
    for (String longOpt : longOpts.keySet()) {
        if (longOpt.startsWith(opt)) {
            matchingOpts.add(longOpt);
        }
    }
    
    return matchingOpts;
}",0,0
33,Cli_37,"private boolean isShortOption(String token)
     {
         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)
         return token.startsWith(""-"") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));
 
         // remove leading ""-"" and ""=value""
     }","private boolean isShortOption(String token) {
    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)
    if (token == null || token.length() < 2 || !token.startsWith(""-"")) {
        return false;
    }

    // remove leading ""-"" and check the first character after ""-""
    String option = token.substring(1);
    String firstChar = option.substring(0, 1);

    return options.hasShortOption(firstChar);
}",0,0
34,Cli_38,"private boolean isShortOption(String token)
    {
        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)
        if (!token.startsWith(""-"") || token.length() == 1)
        {
            return false;
        }

         // remove leading ""-"" and ""=value""
         int pos = token.indexOf(""="");
         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);
         return options.hasShortOption(optName);
         // check for several concatenated short options
     }","private boolean isShortOption(String token) {
    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)
    if (token == null || !token.startsWith(""-"") || token.length() == 1) {
        return false;
    }

    // remove leading ""-"" and ""=value""
    int pos = token.indexOf(""="");
    String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);
    
    // check for several concatenated short options
    for (int i = 0; i < optName.length(); i++) {
        if (!options.hasShortOption(String.valueOf(optName.charAt(i)))) {
            return false;
        }
    }
    
    return true;
}",0,0
35,Cli_4,"private void checkRequiredOptions()
        throws MissingOptionException
    {
        // if there are required options that have not been
        // processsed
         if (requiredOptions.size() > 0)
         {
             Iterator iter = requiredOptions.iterator();
             StringBuffer buff = new StringBuffer();
 
 
             // loop through the required options
            while (iter.hasNext())
            {
                buff.append(iter.next());
            }

            throw new MissingOptionException(buff.toString());
        }
    }","private void checkRequiredOptions() throws MissingOptionException {
    // if there are required options that have not been processed
    if (!requiredOptions.isEmpty()) {
        StringBuilder buff = new StringBuilder();

        // loop through the required options
        for (Object option : requiredOptions) {
            if (buff.length() > 0) {
                buff.append("", "");
            }
            buff.append(option);
        }

        throw new MissingOptionException(buff.toString());
    }
}",0,0
36,Cli_40,"@SuppressWarnings(""unchecked"") // returned value will have type T because it is fixed by clazz
    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException
    {
        if (PatternOptionBuilder.STRING_VALUE == clazz)
        {
            return (T) str;
        }
        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)
        {
            return (T) createObject(str);
        }
        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)
        {
            return (T) createNumber(str);
        }
        else if (PatternOptionBuilder.DATE_VALUE == clazz)
        {
            return (T) createDate(str);
        }
        else if (PatternOptionBuilder.CLASS_VALUE == clazz)
        {
            return (T) createClass(str);
        }
        else if (PatternOptionBuilder.FILE_VALUE == clazz)
        {
            return (T) createFile(str);
        }
        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)
        {
            return (T) openFile(str);
        }
        else if (PatternOptionBuilder.FILES_VALUE == clazz)
        {
            return (T) createFiles(str);
        }
        else if (PatternOptionBuilder.URL_VALUE == clazz)
        {
            return (T) createURL(str);
         }
         else
         {
             return null;
         }
     }","@SuppressWarnings(""unchecked"") // returned value will have type T because it is fixed by clazz
public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException {
    if (PatternOptionBuilder.STRING_VALUE.isAssignableFrom(clazz)) {
        return (T) str;
    } else if (PatternOptionBuilder.OBJECT_VALUE.isAssignableFrom(clazz)) {
        return (T) createObject(str);
    } else if (PatternOptionBuilder.NUMBER_VALUE.isAssignableFrom(clazz)) {
        return (T) createNumber(str);
    } else if (PatternOptionBuilder.DATE_VALUE.isAssignableFrom(clazz)) {
        return (T) createDate(str);
    } else if (PatternOptionBuilder.CLASS_VALUE.isAssignableFrom(clazz)) {
        return (T) createClass(str);
    } else if (PatternOptionBuilder.FILE_VALUE.isAssignableFrom(clazz)) {
        return (T) createFile(str);
    } else if (PatternOptionBuilder.EXISTING_FILE_VALUE.isAssignableFrom(clazz)) {
        return (T) openFile(str);
    } else if (PatternOptionBuilder.FILES_VALUE.isAssignableFrom(clazz)) {
        return (T) createFiles(str);
    } else if (PatternOptionBuilder.URL_VALUE.isAssignableFrom(clazz)) {
        return (T) createURL(str);
    } else {
        throw new ParseException(""Cannot handle given class type: "" + clazz.getName(), 0);
    }
}",0,0
37,Cli_5,"static String stripLeadingHyphens(String str)
     {
         if (str.startsWith(""--""))
         {
             return str.substring(2, str.length());
        }
        else if (str.startsWith(""-""))
        {
            return str.substring(1, str.length());
        }

        return str;
    }","static String stripLeadingHyphens(String str) {
    if (str == null) {
        return null;
    }

    if (str.startsWith(""--"")) {
        return str.substring(2);
    } else if (str.startsWith(""-"")) {
        return str.substring(1);
    }

    return str;
}",0,0
38,Cli_8,"protected StringBuffer renderWrappedText(StringBuffer sb, int width, 
                                             int nextLineTabStop, String text)
    {
        int pos = findWrapPos(text, width, 0);

        if (pos == -1)
        {
            sb.append(rtrim(text));

            return sb;
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);

        // all following lines must be padded with nextLineTabStop space 
        // characters
        final String padding = createPadding(nextLineTabStop);

         while (true)
         {
             text = padding + text.substring(pos).trim();
             pos = findWrapPos(text, width, nextLineTabStop);
 
             if (pos == -1)
             {
                sb.append(text);

                return sb;
            }

            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
        }
    }","protected StringBuffer renderWrappedText(StringBuffer sb, int width, 
                                             int nextLineTabStop, String text) 
{
    int pos = findWrapPos(text, width, 0);
    if (pos == -1) {
        sb.append(rtrim(text));
        return sb;
    }
    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);

    // all following lines must be padded with nextLineTabStop space 
    // characters
    final String padding = createPadding(nextLineTabStop);

    while (true) {
        text = text.substring(pos).trim();

        if (text.isEmpty()) {
            return sb;
        }

        text = padding + text;
        pos = findWrapPos(text, width, nextLineTabStop);

        if (pos == -1) {
            sb.append(text);
            return sb;
        }

        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    }
}",0,0
39,Cli_9,"protected void checkRequiredOptions()
        throws MissingOptionException
    {
        // if there are required options that have not been
        // processsed
        if (getRequiredOptions().size() > 0)
        {
            Iterator iter = getRequiredOptions().iterator();
            StringBuffer buff = new StringBuffer(""Missing required option"");
            buff.append(getRequiredOptions().size() == 1 ? """" : ""s"");
            buff.append("": "");


            // loop through the required options
             while (iter.hasNext())
             {
                 buff.append(iter.next());
             }
 
             throw new MissingOptionException(buff.toString());
         }
     }","protected void checkRequiredOptions() throws MissingOptionException {
    // if there are required options that have not been processed
    if (!getRequiredOptions().isEmpty()) {
        Iterator iter = getRequiredOptions().iterator();
        StringBuilder buff = new StringBuilder(""Missing required option"");
        buff.append(getRequiredOptions().size() == 1 ? """" : ""s"");
        buff.append("": "");
        
        // loop through the required options
        while (iter.hasNext()) {
            buff.append(iter.next());
            if (iter.hasNext()) {
                buff.append("", "");
            }
        }

        throw new MissingOptionException(buff.toString());
    }
}",0,0
40,Closure_1,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
      // The parameters object literal setters can not be removed.
      return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
      // Strip unreferenced args off the end of the function declaration.
      Node lastArg;
      while ((lastArg = argList.getLastChild()) != null) {
        Var var = fnScope.getVar(lastArg.getString());
        if (!referenced.contains(var)) {
          argList.removeChild(lastArg);
          compiler.reportCodeChange();
        } else {
          break;
        }
      }
    } else {
      callSiteOptimizer.optimize(fnScope, referenced);
    }
  }","private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
    // is removing globals, then it's OK to remove unused function args.
    //
    // See http://code.google.com/p/closure-compiler/issues/detail?id=253

    Node function = fnScope.getRootNode();

    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
        // The parameters object literal setters can not be removed.
        return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
        // Strip unreferenced args off the end of the function declaration.
        Node lastArg;
        while ((lastArg = argList.getLastChild()) != null) {
            Var var = fnScope.getVar(lastArg.getString());
            if (var != null && !referenced.contains(var)) {
                argList.removeChild(lastArg);
                compiler.reportCodeChange();
            } else {
                break;
            }
        }
    } else {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}",0,0
41,Closure_10,"static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
  }","static boolean mayBeString(Node n, boolean recurse) {
    if (n == null) {
        return false;
    }
    if (recurse) {
        return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
    } else {
        return mayBeStringHelper(n);
    }
}",0,0
42,Closure_101,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
     if (flags.process_closure_primitives) {
       options.closurePass = true;
     }
 
     initOptionsFromFlags(options);
     return options;
   }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());

    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }

    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);

    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }

    if (flags.process_closure_primitives) {
        options.setClosurePass(true);
    }

    initOptionsFromFlags(options);
    return options;
}",0,0
43,Closure_102,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }","@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, this);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    removeDuplicateDeclarations(root);
    new PropagateConstantAnnotations(compiler, assertOnChange)
        .process(externs, root);
}",0,0
44,Closure_104,"JSType meet(JSType that) {
    UnionTypeBuilder builder = new UnionTypeBuilder(registry);
    for (JSType alternate : alternates) {
      if (alternate.isSubtype(that)) {
        builder.addAlternate(alternate);
      }
    }

    if (that instanceof UnionType) {
      for (JSType otherAlternate : ((UnionType) that).alternates) {
        if (otherAlternate.isSubtype(this)) {
          builder.addAlternate(otherAlternate);
        }
      }
    } else if (that.isSubtype(this)) {
       builder.addAlternate(that);
     }
     JSType result = builder.build();
     if (result != null) {
       return result;
     } else if (this.isObject() && that.isObject()) {
       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    } else {
      return getNativeType(JSTypeNative.NO_TYPE);
    }
  }","JSType meet(JSType that) {
    UnionTypeBuilder builder = new UnionTypeBuilder(registry);
    for (JSType alternate : alternates) {
        if (alternate.isSubtype(that)) {
            builder.addAlternate(alternate);
        }
    }

    if (that instanceof UnionType) {
        for (JSType otherAlternate : ((UnionType) that).alternates) {
            if (otherAlternate.isSubtype(this)) {
                builder.addAlternate(otherAlternate);
            }
        }
    } else if (that.isSubtype(this)) {
        builder.addAlternate(that);
    }

    JSType result = builder.build();
    if (result != null && !result.isEmptyType()) {
        return result;
    } else if (this.isObject() && that.isObject()) {
        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    } else {
        return getNativeType(JSTypeNative.NO_TYPE);
    }
}",0,0
45,Closure_105,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
         if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
         if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
           sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = left.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }

    String joinString = NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem)) {
        if (sb.length() > 0) {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getStringValue(elem));
      } else {
        if (sb.length() > 0) {
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(Node.newString(sb.toString()));
          sb = new StringBuilder();
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem.cloneNode());
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }",0,0
46,Closure_107,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
      options.setCodingConvention(new JqueryCodingConvention());
    } else {
      options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
      level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
      options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (!flags.translationsFile.isEmpty()) {
      try {
        options.messageBundle = new XtbMessageBundle(
            new FileInputStream(flags.translationsFile),
            flags.translationsProject);
      } catch (IOException e) {
        throw new RuntimeException(""Reading XTB file"", e);
      }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
      // translations file, they might reasonably try to write their own
      // implementation of goog.getMsg that makes the substitution at
      // run-time.
      //
      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
  }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
        options.setCodingConvention(new JqueryCodingConvention());
    } else {
        options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }

    options.setGenerateExports(flags.generateExports);

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (flags.translationsFile != null && !flags.translationsFile.isEmpty()) {
        try {
        options.messageBundle = new XtbMessageBundle(
                new FileInputStream(flags.translationsFile),
                flags.translationsProject);
        } catch (IOException e) {
            throw new RuntimeException(""Reading XTB file"", e);
        }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
        // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
        // translations file, they might reasonably try to write their own
        // implementation of goog.getMsg that makes the substitution at
        // run-time.
        //
        // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
        // so we might as well inline it. But shut off the i18n warnings,
        // because the user didn't really ask for i18n.
        options.messageBundle = new EmptyMessageBundle();
    }

    return options;
}",0,0
47,Closure_109,"  private Node parseContextTypeExpression(JsDocToken token) {
          return parseTypeName(token);
  }
","private Node parseContextTypeExpression(JsDocToken token) {
    if (token == null) {
        throw new IllegalArgumentException(""Token cannot be null"");
    }
    return parseTypeName(token);
}",0,0
48,Closure_11,"private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    // Lots of types can appear on the left, a call to a void function can
    // never be on the left. getPropertyType will decide what is acceptable
    // and what isn't.
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
     } else if (n.getJSType() != null && parent.isAssign()) {
       return;
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
  }","private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    // Lots of types can appear on the left, a call to a void function can
    // never be on the left. getPropertyType will decide what is acceptable
    // and what isn't.
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
   
    // Add a check for objNode existence and null childType
    if (objNode == null || childType == null) {
        return; 
    }
    
    if (childType.isDict()) {
        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
    } else if (n.getJSType() != null && parent.isAssign()) {
        return;
    } else if (validator.expectNotNullOrUndefined(t, n, childType,
        ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
        checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
}",0,0
49,Closure_111,"        protected JSType caseTopType(JSType topType) {
          return topType;
        }
","protected JSType caseTopType(JSType topType) {
    // Check for null and handle accordingly
    if (topType == null) {
        throw new IllegalArgumentException(""Top type cannot be null"");
    }
    return topType;
}",0,0
50,Closure_112,"    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()
        .getTemplateKeys();
    if (keys.isEmpty()) {
      return false;
    }
","final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()
        .getTemplateKeys();
if (keys == null || keys.isEmpty()) {
    return false;
}",0,0
51,Closure_113,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
      String ns = arg.getString();
      ProvidedName provided = providedNames.get(ns);
      if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
      } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
          compiler.report(
              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                  providedModule.getName(),
                  module.getName()));
        }
      }

      maybeAddToSymbolTable(left);
      maybeAddStringNodeToSymbolTable(arg);

      // Requires should be removed before further processing.
      // Some clients run closure pass multiple times, first with
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
       if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
    }
  }","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
        String ns = arg.getString();
        ProvidedName provided = providedNames.get(ns);
        if (provided == null || !provided.isExplicitlyProvided()) {
            unrecognizedRequires.add(
                new UnrecognizedRequire(n, ns, t.getSourceName()));
        } else {
            JSModule providedModule = provided.explicitModule;

            // This must be non-null, because there was an explicit provide.
            Preconditions.checkNotNull(providedModule);

            JSModule module = t.getModule();
            if (moduleGraph != null &&
                module != providedModule &&
                !moduleGraph.dependsOn(module, providedModule)) {
                compiler.report(
                    t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                        providedModule.getName(),
                        module.getName()));
            }
        }

        maybeAddToSymbolTable(left);
        maybeAddStringNodeToSymbolTable(arg);

        // Detach the node if the `provided` is non-null and it's
        // explicitly provided to ensure broken requires are preserved
        if (provided != null && provided.isExplicitlyProvided()) {
            parent.detachFromParent();
            compiler.reportCodeChange();
        }
    }
}",0,0
52,Closure_114,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
      Node nameNode = n.getFirstChild();
      Node parent = n.getParent();
      NameInformation ns = createNameInformation(t, nameNode);
      if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
          // Patch for assignments that appear in the init,
          // condition or iteration part of a FOR loop.  Without
          // this change, all 3 of those parts try to claim the for
          // loop as their dependency scope.  The last assignment in
          // those three fields wins, which can result in incorrect
          // reference edges between referenced and assigned variables.
          //
          // TODO(user) revisit the dependency scope calculation
          // logic.
          if (parent.getFirstChild().getNext() != n) {
            recordDepScope(recordNode, ns);
           } else {
             recordDepScope(nameNode, ns);
           }
         } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
          // caller expression, but it could be nested deeper in the caller and
          // we would still get a bug.
          // See testAssignWithCall2 for an example of this.
          recordDepScope(recordNode, ns);
        }
      }
    }","private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    Node nameNode = n.getFirstChild();
    Node parent = n.getParent();
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // Patch for assignments that appear in the init, condition, or iteration part of a FOR loop.
            // Handle cases where `n` is not the first child of the parent node, ensuring the correct scope is recorded.
            if (parent.getFirstChild() != n && parent.getFirstChild().getNext() != n) {
                recordDepScope(recordNode, ns);
            } else {
                recordDepScope(nameNode, ns);
            }
        } else if (parent.isCall()) {
            // Special handling for cases where the assignment is inside a CALL expression.
            // Ensures dependencies are correctly calculated for the rhs of the assignment.
            if (parent.getFirstChild() == recordNode) {
                recordDepScope(recordNode, ns);
            }
        } else {
            // Default behavior for other cases.
            recordDepScope(recordNode, ns);
        }
    }
}",0,0
53,Closure_115,"private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
             return CanInlineResult.NO;
           }
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }","private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
        // Ensure that the state of the block is valid before proceeding
        // and guard against potential missing child nodes.
        Preconditions.checkState(block.hasOneChild());
        Node stmt = block.getFirstChild();
        if (stmt.isReturn()) {
            Node returnExpr = stmt.getFirstChild();
            if (returnExpr != null) {
                hasSideEffects = NodeUtil.mayHaveSideEffects(returnExpr, compiler);
            }
        }
    }

    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // Handle the 'this' case consistently.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // Ensure '.apply' calls are filtered beforehand.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        // For each named parameter, check if a mutable argument is used more than once.
        if (fnParam != null) {
            if (cArg != null) {
                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
                    return CanInlineResult.NO;
                }

                // Check for arguments that are evaluated more than once.
                if (NodeUtil.mayEffectMutableState(cArg, compiler)
                    && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }

            // Move to the next parameter.
            fnParam = fnParam.getNext();
        }

        // For every call argument, check for side-effects, even if there
        // isn't a named parameter to match.
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }

    return CanInlineResult.YES;
}",0,0
54,Closure_116,"private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }
 
     Node block = fnNode.getLastChild();
 
 
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
      // For each named parameter check if a mutable argument use more than one.
      if (fnParam != null) {
        if (cArg != null) {

          // Check for arguments that are evaluated more than once.
          // Note: Unlike block inlining, there it is not possible that a
          // parameter reference will be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }","private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }
 
     Node block = fnNode.getLastChild();
 
 
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
      // For each named parameter check if a mutable argument use is more than once.
      if (fnParam != null) {
        if (cArg != null) {

          // Check for arguments that are evaluated more than once.
          // Note: Unlike block inlining, it is not possible for a
          // parameter reference to be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }",0,0
55,Closure_117,"String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
      ObjectType objectType = getJSType(n.getFirstChild()).dereference();
      if (objectType != null) {
        String propName = n.getLastChild().getString();
        if (objectType.getConstructor() != null &&
            objectType.getConstructor().isInterface()) {
          objectType = FunctionType.getTopDefiningInterface(
              objectType, propName);
        } else {
          // classes
          while (objectType != null && !objectType.hasOwnProperty(propName)) {
            objectType = objectType.getImplicitPrototype();
          }
        }

        // Don't show complex function names or anonymous types.
        // Instead, try to get a human-readable type name.
        if (objectType != null &&
            (objectType.getConstructor() != null ||
             objectType.isFunctionPrototypeType())) {
          return objectType.toString() + ""."" + propName;
        }
      }
    }

    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
      return qualifiedName;
    } else if (type.isFunctionType()) {
      // Don't show complex function names.
      return ""function"";
    } else {
      return type.toString();
    }
  }","String getReadableJSTypeName(Node n, boolean dereference) {

    // The best type name is the actual type name.

    // If we're analyzing a GETPROP, the property may be inherited by the
    // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            if (objectType.getConstructor() != null &&
                    objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(objectType, propName);
            } else {
                // classes
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }

            // Don't show complex function names or anonymous types.
            // Instead, try to get a human-readable type name.
            if (objectType != null &&
                    (objectType.getConstructor() != null ||
                            objectType.isFunctionPrototypeType())) {
                return objectType.getReferenceName() + ""."" + propName;
            }
        }
    }

    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    if (type.isFunctionPrototypeType() ||
            (type.toObjectType() != null &&
                    type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        // Don't show complex function names.
        return ""function"";
    } else {
        return type.toString();
    }
}",0,0
56,Closure_118,"private void handleObjectLit(NodeTraversal t, Node n) {
      for (Node child = n.getFirstChild();
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
          // TODO(user): It doesn't look like the user can do much in this
          // case right now.
          if (propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(
                t.getSourceName(), child, propertiesToErrorFor.get(name),
                Warnings.INVALIDATION, name,
                (type == null ? ""null"" : type.toString()), n.toString(), """"));
          }
        }
      }
    }","private void handleObjectLit(NodeTraversal t, Node n) {
    if (n == null) {
        return;
    }
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        // Maybe STRING, GET, SET

        // We should never see a mix of numbers and strings.
        String name = child.getString();
        if (name == null || name.isEmpty()) {
            continue;
        }
        
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) {
            // TODO(user): It doesn't look like the user can do much in this
            // case right now.
            if (propertiesToErrorFor.containsKey(name)) {
                compiler.report(JSError.make(
                    t.getSourceName(), child, propertiesToErrorFor.get(name),
                    Warnings.INVALIDATION, name,
                    (type == null ? ""null"" : type.toString()), n.toString(), """"));
            }
        }
    }
}",0,0
57,Closure_119,"public void collect(JSModule module, Scope scope, Node n) {
      Node parent = n.getParent();

      String name;
      boolean isSet = false;
      Name.Type type = Name.Type.OTHER;
      boolean isPropAssign = false;

      switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
          // This may be a key in an object literal declaration.
          name = null;
          if (parent != null && parent.isObjectLit()) {
            name = getNameForObjLitKey(n);
          }
          if (name == null) {
            return;
          }
          isSet = true;
          switch (n.getType()) {
            case Token.STRING_KEY:
              type = getValueType(n.getFirstChild());
              break;
            case Token.GETTER_DEF:
              type = Name.Type.GET;
              break;
            case Token.SETTER_DEF:
              type = Name.Type.SET;
              break;
            default:
              throw new IllegalStateException(""unexpected:"" + n);
          }
          break;
        case Token.NAME:
          // This may be a variable get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.VAR:
                isSet = true;
                Node rvalue = n.getFirstChild();
                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                break;
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                }
                break;
              case Token.GETPROP:
                return;
              case Token.FUNCTION:
                Node gramps = parent.getParent();
                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                  return;
                }
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
                type = Name.Type.OTHER;
                break;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getString();
          break;
        case Token.GETPROP:
          // This may be a namespaced name get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                  isPropAssign = true;
                }
                break;
              case Token.INC:
              case Token.DEC:
                isSet = true;
                type = Name.Type.OTHER;
                break;
              case Token.GETPROP:
                return;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getQualifiedName();
          if (name == null) {
            return;
          }
          break;
        default:
          return;
      }

      // We are only interested in global names.
      if (!isGlobalNameReference(name, scope)) {
        return;
      }

      if (isSet) {
        if (isGlobalScope(scope)) {
          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
          handleSetFromLocal(module, scope, n, parent, name);
        }
      } else {
        handleGet(module, scope, n, parent, name);
      }
    }","public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();

    String name;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;

    switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            // This may be a key in an object literal declaration.
            name = null;
            if (parent != null && parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
            }
            if (name == null) {
                return;
            }
            isSet = true;
            switch (n.getType()) {
                case Token.STRING_KEY:
                    type = getValueType(n.getFirstChild());
                    break;
                case Token.GETTER_DEF:
                    type = Name.Type.GET;
                    break;
                case Token.SETTER_DEF:
                    type = Name.Type.SET;
                    break;
                default:
                    throw new IllegalStateException(""unexpected:"" + n);
            }
            break;
        case Token.NAME:
            // This may be a variable get or set.
            if (parent != null) {
                switch (parent.getType()) {
                    case Token.VAR:
                        isSet = true;
                        Node rvalue = n.getFirstChild();
                        type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                        break;
                    case Token.ASSIGN:
                        if (parent.getFirstChild() == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                        }
                        break;
                    case Token.GETPROP:
                        return;
                    case Token.FUNCTION:
                        Node gramps = parent.getParent();
                        if (gramps != null && !NodeUtil.isFunctionExpression(parent)) {
                            isSet = true;
                            type = Name.Type.FUNCTION;
                        }
                        break;
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) &&
                            parent.getFirstChild() == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getString();
            break;
        case Token.GETPROP:
            // This may be a namespaced name get or set.
            if (parent != null) {
                switch (parent.getType()) {
                    case Token.ASSIGN:
                        if (parent.getFirstChild() == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                            isPropAssign = true;
                        }
                        break;
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    case Token.GETPROP:
                        return;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) &&
                            parent.getFirstChild() == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;
        default:
            return;
    }

    // We are only interested in global names.
    if (!isGlobalNameReference(name, scope)) {
        return;
    }

    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}",0,0
58,Closure_12,"    public ReachingUses apply(List<ReachingUses> from) {
      ReachingUses result = new ReachingUses();
      for (ReachingUses uses : from) {
        result.mayUseMap.putAll(uses.mayUseMap);
      }
      return result;
    }
",Match failed,0,0
59,Closure_120,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
      }

      // Make sure this assignment is not in a loop.
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
        }
      }

      return true;
    }","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }

    // Make sure this assignment is not in a loop.
    BasicBlock block = ref.getBasicBlock();
    while (block != null) {
        if (block.isFunctionBlock()) {  // Change isFunction to isFunctionBlock
            break;
        }

        if (block.isLoopBlock()) {  // Change isLoop to isLoopBlock
            return false;
        }

        block = block.getParent();
    }

    return true;
}",0,0
60,Closure_121,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }",0,0
61,Closure_122,"  private void handleBlockComment(Comment comment) {
    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
      errorReporter.warning(
          SUSPICIOUS_COMMENT_WARNING,
          sourceName,
          comment.getLineno(), """", 0);
    }
  }
","private void handleBlockComment(Comment comment) {
    String commentValue = comment.getValue();
    if (commentValue.contains(""/* @"") || commentValue.contains(""\n * @"")) {
        errorReporter.warning(
            SUSPICIOUS_COMMENT_WARNING,
            sourceName,
            comment.getLineno(), """", 0);
    }
}",0,0
62,Closure_123,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context,
            getContextForNoInOperator(context), 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // Unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top-level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3
            && TokenStream.isKeyword(last.getString())) {
          // Check for ECMASCRIPT3 keywords.
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(
            childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(
            childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString()
                && !(languageMode == LanguageMode.ECMASCRIPT3
                    && TokenStream.isKeyword(key))
                && TokenStream.isJSIdentifier(key)
                // do not encode literally any non-literal characters that
                // were Unicode escaped.
                && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Check if the node has children before operations
    if (first == null || last == null) {
        cc.endSourceMapping(n);
        return;
    }

    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(
            childCount == 2,
            ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
            opstr, childCount);
        int p = NodeUtil.precedence(type);

        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);

        // Handle associativity.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        cc.endSourceMapping(n);
        return;
    }

    cc.startSourceMapping(n);

    switch (type) {
        case Token.TRY:
            Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
            Preconditions.checkState(childCount >= 2 && childCount <= 3);

            add(""try"");
            add(first, Context.PRESERVE_BLOCK);

            Node catchblock = first.getNext().getFirstChild();
            if (catchblock != null) {
                add(catchblock);
            }

            if (childCount == 3) {
                add(""finally"");
                add(last, Context.PRESERVE_BLOCK);
            }
            break;

        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;

        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);

            // Must have a ';' after a throw statement, otherwise Safari can't parse this.
            cc.endStatement(true);
            break;

        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;

        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;

        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;

        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;

        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;

        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;

        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, getContextForNoInOperator(context), 0, 0);
            break;

        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;

        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            Preconditions.checkState(childCount == 1);
            cc.addOp(NodeUtil.opToStrNoFail(type), false);
            addExpr(first, NodeUtil.precedence(type), Context.OTHER);
            break;

        case Token.NEG:
            Preconditions.checkState(childCount == 1);
            if (n.getFirstChild().isNumber()) {
                cc.addNumber(-n.getFirstChild().getDouble());
            } else {
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
            }
            break;

        case Token.HOOK:
            Preconditions.checkState(childCount == 3);
            int p = NodeUtil.precedence(type);
            Context rhsContext = Context.OTHER;
            addExpr(first, p + 1, context);
            cc.addOp(""?"", true);
            addExpr(first.getNext(), 1, rhsContext);
            cc.addOp("":"", true);
            addExpr(last, 1, rhsContext);
            break;

        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }

            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;

        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }

            add(""function"");
            add(first);

            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);

            if (funcNeedsParens) {
                add("")"");
            }
            break;

        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());

            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }

            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();

            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
                add(name);
            } else {
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }

            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;

        case Token.SCRIPT:
        case Token.BLOCK:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            boolean preserveBlock = context == Context.PRESERVE_BLOCK;
            if (preserveBlock) {
                cc.beginBlock();
            }

            boolean preferLineBreaks =
                type == Token.SCRIPT ||
                (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
            for (Node c = first; c != null; c = c.getNext()) {
                add(c, Context.STATEMENT);

                if (c.isVar()) {
                    cc.endStatement();
                }

                if (c.isFunction()) {
                    cc.maybeLineBreak();
                }

                if (preferLineBreaks) {
                    cc.notePreferredLineBreak();
                }
            }
            if (preserveBlock) {
                cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
            }
            break;

        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;

        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;

        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;

        case Token.GETPROP:
            Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
            Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
            boolean needsParens = (first.isNumber());
            if (needsParens) {
                add(""("");
            }
            addExpr(first, NodeUtil.precedence(type), context);
            if (needsParens) {
                add("")"");
            }
            if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                add(""["");
                add(last);
                add(""]"");
            } else {
                add(""."");
                addIdentifier(last.getString());
            }
            break;

        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;

        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.INC:
        case Token.DEC:
            Preconditions.checkState(childCount == 1);
            String o = type == Token.INC ? ""++"" : ""--"";
            int postProp = n.getIntProp(Node.INCRDECR_PROP);
            if (postProp != 0) {
                addExpr(first, NodeUtil.precedence(type), context);
                cc.addOp(o, false);
            } else {
                cc.addOp(o, false);
                add(first);
            }
            break;

        case Token.CALL:
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;

        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }

            add(""if("");
            add(first);
            add("")"");

            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }

            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;

        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;

        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;

        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;

        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;

        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;

        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;

        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);

            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);

            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;

        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;

        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;

        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;

        case Token.OBJECTLIT:
            boolean needsParensObjLit = (context == Context.START_OF_EXPR);
            if (needsParensObjLit) {
                add(""("");
            }
            add(""{"");
            for (Node c = first; c != null; c = c.getNext()) {
                if (c != first) {
                    cc.listSeparator();
                }

                if (c.isGetterDef() || c.isSetterDef()) {
                    add(c);
                } else {
                    Preconditions.checkState(c.isStringKey());
                    String key = c.getString();
                    if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key))
                        && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) {
                        add(key);
                    } else {
                        double d = getSimpleNumber(key);
                        if (!Double.isNaN(d)) {
                            cc.addNumber(d);
                        } else {
                            addExpr(c, 1, Context.OTHER);
                        }
                    }
                    add("":"");
                    addExpr(c.getFirstChild(), 1, Context.OTHER);
                }
            }
            add(""}"");
            if (needsParensObjLit) {
                add("")"");
            }
            break;

        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;

        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;

        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;

        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;

        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;

        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
}",0,0
63,Closure_124,"private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
      return true;
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
    }

    return true;
  }","private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
        return true;
    }
    Preconditions.checkArgument(node.isGetProp());

    Node firstChild = node.getFirstChild();
    if (firstChild != null && firstChild.isName()
        && isNameAssignedTo(firstChild.getString(), replacement)) {
        return false;
    }

    return true;
}",0,0
64,Closure_125,"private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
       if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
        ensureTyped(t, n);
      }
    } else {
      report(t, n, NOT_A_CONSTRUCTOR);
      ensureTyped(t, n);
    }
  }","private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
        FunctionType fnType = type.toMaybeFunctionType();
        if (fnType != null) {
            visitParameterList(t, n, fnType);
            ensureTyped(t, n, fnType.getInstanceType());
        } else if (type.isEmptyType() || type.isUnknownType()) {
            ensureTyped(t, n, getNativeType(UNKNOWN_TYPE));
        } else {
            ensureTyped(t, n);
        }
    } else {
        report(t, n, NOT_A_CONSTRUCTOR);
        ensureTyped(t, n);
    }
}",0,0
65,Closure_126,"void tryMinimizeExits(Node n, int exitType, String labelName) {

    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
      NodeUtil.removeChild(n.getParent(), n);
      compiler.reportCodeChange();
      return;
    }

    // Just an 'if'.
    if (n.isIf()) {
      Node ifBlock = n.getFirstChild().getNext();
      tryMinimizeExits(ifBlock, exitType, labelName);
      Node elseBlock = ifBlock.getNext();
      if (elseBlock != null) {
        tryMinimizeExits(elseBlock, exitType, labelName);
      }
      return;
    }

    // Just a 'try/catch/finally'.
    if (n.isTry()) {
      Node tryBlock = n.getFirstChild();
      tryMinimizeExits(tryBlock, exitType, labelName);
      Node allCatchNodes = NodeUtil.getCatchBlock(n);
      if (NodeUtil.hasCatchHandler(allCatchNodes)) {
        Preconditions.checkState(allCatchNodes.hasOneChild());
        Node catchNode = allCatchNodes.getFirstChild();
        Node catchCodeBlock = catchNode.getLastChild();
        tryMinimizeExits(catchCodeBlock, exitType, labelName);
      }
      /* Don't try to minimize the exits of finally blocks, as this
        * can cause problems if it changes the completion type of the finally
        * block. See ECMA 262 Sections 8.9 & 12.14
        */
       if (NodeUtil.hasFinally(n)) {
         Node finallyBlock = n.getLastChild();
         tryMinimizeExits(finallyBlock, exitType, labelName);
       }
     }
 
     // Just a 'label'.
    if (n.isLabel()) {
      Node labelBlock = n.getLastChild();
      tryMinimizeExits(labelBlock, exitType, labelName);
    }

    // TODO(johnlenz): The last case of SWITCH statement?

    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
      return;
    }

    // Multiple if-exits can be converted in a single pass.
    // Convert ""if (blah) break;  if (blah2) break; other_stmt;"" to
    // become ""if (blah); else { if (blah2); else { other_stmt; } }""
    // which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
    for (Node c : n.children()) {

      // An 'if' block to process below.
      if (c.isIf()) {
        Node ifTree = c;
        Node trueBlock, falseBlock;

        // First, the true condition block.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        tryMinimizeIfBlockExits(trueBlock, falseBlock,
            ifTree, exitType, labelName);

        // Now the else block.
        // The if blocks may have changed, get them again.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        if (falseBlock != null) {
          tryMinimizeIfBlockExits(falseBlock, trueBlock,
              ifTree, exitType, labelName);
        }
      }

      if (c == n.getLastChild()) {
        break;
      }
    }

    // Now try to minimize the exits of the last child, if it is removed
    // look at what has become the last child.
    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
      tryMinimizeExits(c, exitType, labelName);
      // If the node is still the last child, we are done.
      if (c == n.getLastChild()) {
        break;
      }
    }
  }","void tryMinimizeExits(Node n, int exitType, String labelName) {
    
    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
        NodeUtil.removeChild(n.getParent(), n);
        compiler.reportCodeChange();
        return;
    }
    
    // Just an 'if'.
    if (n.isIf()) {
        Node ifBlock = n.getFirstChild().getNext();
        tryMinimizeExits(ifBlock, exitType, labelName);
        Node elseBlock = ifBlock.getNext();
        if (elseBlock != null) {
            tryMinimizeExits(elseBlock, exitType, labelName);
        }
        return;
    }

    // Just a 'try/catch/finally'.
    if (n.isTry()) {
        Node tryBlock = n.getFirstChild();
        tryMinimizeExits(tryBlock, exitType, labelName);
        Node allCatchNodes = NodeUtil.getCatchBlock(n);
        if (NodeUtil.hasCatchHandler(allCatchNodes)) {
            Preconditions.checkState(allCatchNodes.hasOneChild());
            Node catchNode = allCatchNodes.getFirstChild();
            Node catchCodeBlock = catchNode.getLastChild();
            tryMinimizeExits(catchCodeBlock, exitType, labelName);
        }
        // Do not try to minimize exits from finally blocks as it can affect completion type.
        return; // Return after catch block processing to skip finally block
    }
    
    // Just a 'label'.
    if (n.isLabel()) {
        Node labelBlock = n.getLastChild();
        tryMinimizeExits(labelBlock, exitType, labelName);
        return; // Return after label block processing
    }

    // Handle SWITCH statement case
    if (n.isSwitch()) {
        for (Node caseNode : n.children()) {
            tryMinimizeExits(caseNode.getLastChild(), exitType, labelName);
        }
        return; // Return after switch cases processing
    }

    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
        return;
    }

    // Process children of the block.
    Node c = n.getFirstChild();
    while (c != null) {
        Node next = c.getNext();

        // An 'if' block to process below.
        if (c.isIf()) {
            Node ifTree = c;
            Node trueBlock, falseBlock;

            // First, the true condition block.
            trueBlock = ifTree.getFirstChild().getNext();
            falseBlock = trueBlock.getNext();
            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);

            // Now the else block.
            trueBlock = ifTree.getFirstChild().getNext();
            falseBlock = trueBlock.getNext();
            if (falseBlock != null) {
                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);
            }
        }

        c = next;
    }

    // Now try to minimize the exits of the last child, if it is removed
    // look at what has become the last child.
    Node lastChild;
    while ((lastChild = n.getLastChild()) != null) {
        tryMinimizeExits(lastChild, exitType, labelName);
        // If the node is still the last child, we are done.
        if (n.getLastChild() == lastChild) {
            break;
        }
    }
}",0,0
66,Closure_128,"static boolean isSimpleNumber(String s) {
     int len = s.length();
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
       if (c < '0' || c > '9') {
         return false;
       }
     }
     return len > 0 && s.charAt(0) != '0';
   }","static boolean isSimpleNumber(String s) {
    int len = s.length();
    if (len == 0 || s.charAt(0) == '0') {
        return false;
    }
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return true;
}",0,0
67,Closure_129,"private void annotateCalls(Node n) {
      Preconditions.checkState(n.isCall());

      // Keep track of of the ""this"" context of a call.  A call without an
      // explicit ""this"" is a free call.
       Node first = n.getFirstChild();
 
       // ignore cast nodes.
 
       if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
      }

      // Keep track of the context in which eval is called. It is important
      // to distinguish between ""(0, eval)()"" and ""eval()"".
      if (first.isName() &&
          ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
      }
    }","private void annotateCalls(Node n) {
      Preconditions.checkState(n.isCall());

      // Keep track of the ""this"" context of a call. A call without an
      // explicit ""this"" is a free call.
      Node first = n.getFirstChild();

      if (first == null) {
         return;
      }

      // ignore cast nodes.
      if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
      }

      // Keep track of the context in which eval is called. It is important
      // to distinguish between ""(0, eval)()"" and ""eval()"".
      if (first.isName() &&
          ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
      }
    }",0,0
68,Closure_13,"private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
      return;
    }

    int visits = 0;
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
      visit(node);
      visits++;

      Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));

    exitNode(node);
  }","private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
        return;
    }

    int visits = 0;
    do {
        Node c = node.getFirstChild();
        while (c != null) {
            Node next = c.getNext();
            traverse(c);
            c = next; // Move to the next node after traversal
        }

        visit(node);
        visits++;

        // Handle potential infinite loops gracefully
        Preconditions.checkState(visits < 10000, ""Too many iterations during traversal"");
    } while (shouldRetraverse(node));

    exitNode(node);
}",0,0
69,Closure_130,"private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
      Name name = workList.pop();

      // Don't attempt to inline a getter or setter property as a variable.
      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
         continue;
       }
 
       if (name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
        List<Ref> refs = Lists.newArrayList(name.getRefs());
        for (Ref ref : refs) {
          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
            // {@code name} meets condition (c). Try to inline it.
            if (inlineAliasIfPossible(ref, namespace)) {
              name.removeRef(ref);
            }
          }
        }
      }

      // Check if {@code name} has any aliases left after the
      // local-alias-inlining above.
      if ((name.type == Name.Type.OBJECTLIT ||
           name.type == Name.Type.FUNCTION) &&
          name.aliasingGets == 0 && name.props != null) {
        // All of {@code name}'s children meet condition (a), so they can be
        // added to the worklist.
        workList.addAll(name.props);
      }
    }
  }","private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();

        // Don't attempt to inline a getter or setter property as a variable.
        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }

        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
            // {@code name} meets condition (b). Find all of its local aliases
            // and try to inline them.
            List<Ref> refs = Lists.newArrayList(name.getRefs());
            for (Ref ref : refs) {
                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
                    // {@code name} meets condition (c). Try to inline it.
                    if (inlineAliasIfPossible(ref, namespace)) {
                        name.removeRef(ref);
                        // Decrement aliasingGets as the ref was successfully inlined
                        name.aliasingGets--;
                    }
                }
            }
        }

        // Check if {@code name} has any aliases left after the
        // local-alias-inlining above.
        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) &&
            name.aliasingGets == 0 && name.props != null) {
            // All of {@code name}'s children meet condition (a), so they can be
            // added to the worklist.
            workList.addAll(name.props);
        }
    }
}",0,0
70,Closure_131,"public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
         if (
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
      }

      return true;
    }","public static boolean isJSIdentifier(String s) {
    int length = s.length();
    
    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
        return false;
    }
    
    for (int i = 1; i < length; i++) {
        char c = s.charAt(i);
        if (!Character.isJavaIdentifierPart(c) && c != '$' && c != '_') {
            return false;
        }
    }
    
    return true;
}",0,0
71,Closure_132,"private Node tryMinimizeIf(Node n) {

    Node parent = n.getParent();

    Node cond = n.getFirstChild();

    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
      return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
      if (isFoldableExpressBlock(thenBranch)) {
        Node expr = getBlockExpression(thenBranch);
        if (!late && isPropertyAssignmentInExpression(expr)) {
          // Keep opportunities for CollapseProperties such as
          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
          // until CollapseProperties has been run.
          return n;
        }

        if (cond.isNot()) {
          // if(!x)bar(); -> x||bar();
          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
              isLowerPrecedenceInExpression(expr.getFirstChild(),
                  OR_PRECEDENCE)) {
            // It's not okay to add two sets of parentheses.
            return n;
          }

          Node or = IR.or(
              cond.removeFirstChild(),
              expr.removeFirstChild()).srcref(n);
          Node newExpr = NodeUtil.newExpr(or);
          parent.replaceChild(n, newExpr);
          reportCodeChange();

          return newExpr;
        }

        // if(x)foo(); -> x&&foo();
        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
            isLowerPrecedenceInExpression(expr.getFirstChild(),
                AND_PRECEDENCE)) {
          // One additional set of parentheses is worth the change even if
          // there is no immediate code size win. However, two extra pair of
          // {}, we would have to think twice. (unless we know for sure the
          // we can further optimize its parent.
          return n;
        }

        n.removeChild(cond);
        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
        Node newExpr = NodeUtil.newExpr(and);
        parent.replaceChild(n, newExpr);
        reportCodeChange();

        return newExpr;
      } else {

        // Try to combine two IF-ELSE
        if (NodeUtil.isStatementBlock(thenBranch) &&
            thenBranch.hasOneChild()) {
          Node innerIf = thenBranch.getFirstChild();

          if (innerIf.isIf()) {
            Node innerCond = innerIf.getFirstChild();
            Node innerThenBranch = innerCond.getNext();
            Node innerElseBranch = innerThenBranch.getNext();

            if (innerElseBranch == null &&
                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
              n.detachChildren();
              n.addChildToBack(
                  IR.and(
                      cond,
                      innerCond.detachFromParent())
                      .srcref(cond));
              n.addChildrenToBack(innerThenBranch.detachFromParent());
              reportCodeChange();
              // Not worth trying to fold the current IF-ELSE into && because
              // the inner IF-ELSE wasn't able to be folded into && anyways.
              return n;
            }
          }
        }
      }

      return n;
    }

    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);

    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
      n.replaceChild(cond, cond.removeFirstChild());
      n.removeChild(thenBranch);
      n.addChildToBack(thenBranch);
      reportCodeChange();
      return n;
    }

    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
      Node thenExpr = getBlockReturnExpression(thenBranch);
      Node elseExpr = getBlockReturnExpression(elseBranch);
      n.removeChild(cond);
      thenExpr.detachFromParent();
      elseExpr.detachFromParent();

      // note - we ignore any cases with ""return;"", technically this
      // can be converted to ""return undefined;"" or some variant, but
      // that does not help code size.
      Node returnNode = IR.returnNode(
                            IR.hook(cond, thenExpr, elseExpr)
                                .srcref(n));
      parent.replaceChild(n, returnNode);
      reportCodeChange();
      return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
      Node thenOp = getBlockExpression(thenBranch).getFirstChild();
      Node elseOp = getBlockExpression(elseBranch).getFirstChild();
      if (thenOp.getType() == elseOp.getType()) {
        // if(x)a=1;else a=2; -> a=x?1:2;
        if (NodeUtil.isAssignmentOp(thenOp)) {
          Node lhs = thenOp.getFirstChild();
          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
              // if LHS has side effects, don't proceed [since the optimization
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
               !mayEffectMutableState(lhs)) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
            Node thenExpr = thenOp.removeFirstChild();
            Node elseExpr = elseOp.getLastChild();
            elseOp.removeChild(elseExpr);

            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            Node assign = new Node(thenOp.getType(), assignName, hookNode)
                              .srcref(thenOp);
            Node expr = NodeUtil.newExpr(assign);
            parent.replaceChild(n, expr);
            reportCodeChange();

            return expr;
          }
        }
      }
      // if(x)foo();else bar(); -> x?foo():bar()
      n.removeChild(cond);
      thenOp.detachFromParent();
      elseOp.detachFromParent();
      Node expr = IR.exprResult(
          IR.hook(cond, thenOp, elseOp).srcref(n));
      parent.replaceChild(n, expr);
      reportCodeChange();
      return expr;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(thenBranch);
      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

      Node name1 = var.getFirstChild();
      Node maybeName2 = elseAssign.getFirstChild();

      if (name1.hasChildren()
          && maybeName2.isName()
          && name1.getString().equals(maybeName2.getString())) {
        Node thenExpr = name1.removeChildren();
        Node elseExpr = elseAssign.getLastChild().detachFromParent();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name1.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();
        return var;
      }

    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
        getBlockExpression(thenBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(elseBranch);
      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

      Node maybeName1 = thenAssign.getFirstChild();
      Node name2 = var.getFirstChild();

      if (name2.hasChildren()
          && maybeName1.isName()
          && maybeName1.getString().equals(name2.getString())) {
        Node thenExpr = thenAssign.getLastChild().detachFromParent();
        Node elseExpr = name2.removeChildren();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name2.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();

        return var;
      }
    }

    return n;
  }","private Node tryMinimizeIf(Node n) {
    if (n == null || !n.isIf()) {
        return n;
    }

    Node parent = n.getParent();
    if (parent == null) {
        return n;
    }

    Node cond = n.getFirstChild();
    if (cond == null) {
        return n;
    }

    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }

    Node thenBranch = cond.getNext();
    if (thenBranch == null) {
        return n;
    }

    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (expr == null || (!late && isPropertyAssignmentInExpression(expr))) {
                return n;
            }

            if (cond.isNot()) {
                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
                    isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {
                    return n;
                }

                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }

            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {
                return n;
            }

            n.removeChild(cond);
            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        } else if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
            Node innerIf = thenBranch.getFirstChild();
            if (innerIf.isIf()) {
                Node innerCond = innerIf.getFirstChild();
                if (innerCond != null && !isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                    !isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE)) {
                    n.detachChildren();
                    n.addChildToBack(
                        IR.and(cond, innerCond.detachFromParent()).srcref(cond));
                    n.addChildrenToBack(innerIf.getSecondChild().detachFromParent());
                    reportCodeChange();
                    return n;
                }
            }
        }
        return n;
    }

    tryRemoveRepeatedStatements(n);

    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }

    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        if (thenExpr != null && elseExpr != null) {
            n.removeChild(cond);
            thenExpr.detachFromParent();
            elseExpr.detachFromParent();
            Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));
            parent.replaceChild(n, returnNode);
            reportCodeChange();
            return returnNode;
        }
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp != null && elseOp != null && thenOp.getType() == elseOp.getType()) {
            if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (lhs != null && areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
                    !mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    reportCodeChange();
                    return expr;
                }
            }
        }
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));
        parent.replaceChild(n, expr);
        reportCodeChange();
        return expr;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        if (var != null && elseAssign != null) {
            Node name1 = var.getFirstChild();
            Node maybeName2 = elseAssign.getFirstChild();
            if (name1 != null && maybeName2.isName() &&
                name1.getString().equals(maybeName2.getString())) {
                Node thenExpr = name1.removeChildren();
                Node elseExpr = elseAssign.getLastChild().detachFromParent();
                cond.detachFromParent();
                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                var.detachFromParent();
                name1.addChildrenToBack(hookNode);
                parent.replaceChild(n, var);
                reportCodeChange();
                return var;
            }
        }
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
               getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        if (var != null && thenAssign != null) {
            Node maybeName1 = thenAssign.getFirstChild();
            Node name2 = var.getFirstChild();
            if (name2 != null && maybeName1.isName() &&
                maybeName1.getString().equals(name2.getString())) {
                Node thenExpr = thenAssign.getLastChild().detachFromParent();
                Node elseExpr = name2.removeChildren();
                cond.detachFromParent();
                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                var.detachFromParent();
                name2.addChildrenToBack(hookNode);
                parent.replaceChild(n, var);
                reportCodeChange();
                return var;
            }
        }
    }

    return n;
}",0,0
72,Closure_133,"private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }","private String getRemainingJSDocLine() {
    if (stream == null) {
        return null; // Handle case where stream might be null
    }
    String result = stream.getRemainingJSDocLine();
    return result != null ? result : """"; // Ensure a non-null result is returned
}",0,0
73,Closure_14,"private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
      return null;
    }

    // If we are just before a IF/WHILE/DO/FOR:
    switch (parent.getType()) {
      // The follow() of any of the path from IF would be what follows IF.
      case Token.IF:
        return computeFollowNode(fromNode, parent, cfa);
      case Token.CASE:
      case Token.DEFAULT_CASE:
        // After the body of a CASE, the control goes to the body of the next
        // case, without having to go to the case condition.
        if (parent.getNext() != null) {
          if (parent.getNext().isCase()) {
            return parent.getNext().getFirstChild().getNext();
          } else if (parent.getNext().isDefaultCase()) {
            return parent.getNext().getFirstChild();
          } else {
            Preconditions.checkState(false, ""Not reachable"");
          }
        } else {
          return computeFollowNode(fromNode, parent, cfa);
        }
        break;
      case Token.FOR:
        if (NodeUtil.isForIn(parent)) {
          return parent;
        } else {
          return parent.getFirstChild().getNext().getNext();
        }
      case Token.WHILE:
      case Token.DO:
        return parent;
      case Token.TRY:
        // If we are coming out of the TRY block...
        if (parent.getFirstChild() == node) {
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(parent.getLastChild());
          } else { // and have no FINALLY.
            return computeFollowNode(fromNode, parent, cfa);
          }
        // CATCH block.
        } else if (NodeUtil.getCatchBlock(parent) == node){
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(node.getNext());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        // If we are coming out of the FINALLY block...
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
        }
    }

    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();

    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
      nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
      return computeFallThrough(nextSibling);
    } else {
      // If there are no more siblings, control is transferred up the AST.
      return computeFollowNode(fromNode, parent, cfa);
    }
  }","private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
      return null;
    }

    // If we are just before a IF/WHILE/DO/FOR:
    switch (parent.getType()) {
      case Token.IF:
        return computeFollowNode(fromNode, parent, cfa);
      case Token.CASE:
      case Token.DEFAULT_CASE:
        if (parent.getNext() != null) {
          if (parent.getNext().isCase()) {
            return parent.getNext().getFirstChild().getNext();
          } else if (parent.getNext().isDefaultCase()) {
            return parent.getNext().getFirstChild();
          } else {
            throw new IllegalStateException(""Unexpected node type in switch"");
          }
        } else {
          return computeFollowNode(fromNode, parent, cfa);
        }
      case Token.FOR:
        if (NodeUtil.isForIn(parent)) {
          return parent;
        } else {
          Node initOrFirstChild = parent.getFirstChild();
          if (initOrFirstChild != null) {
            return initOrFirstChild.getNext().getNext();
          } else {
            throw new IllegalStateException(""FOR node structure is malformed"");
          }
        }
      case Token.WHILE:
      case Token.DO:
        return parent;
      case Token.TRY:
        if (parent.getFirstChild() == node) {
          if (NodeUtil.hasFinally(parent)) {
            return computeFallThrough(parent.getLastChild());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        } else if (NodeUtil.getCatchBlock(parent) == node) {
          if (NodeUtil.hasFinally(parent)) {
            return computeFallThrough(node.getNext());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        } else if (parent.getLastChild() == node) {
          if (cfa != null) {
            for (Node finallyNode : cfa.finallyMap.getOrDefault(parent, Collections.emptyList())) {
              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
            }
          }
          return computeFollowNode(fromNode, parent, cfa);
        }
        break;
      default:
        // No explicit cases match, continue normal traversal.
    }

    // Handle traversal when moving to siblings.
    Node nextSibling = node.getNext();

    // Skip function declarations since they don't transfer control explicitly.
    while (nextSibling != null && nextSibling.isFunction()) {
      nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
      return computeFallThrough(nextSibling);
    } else {
      // No more siblings; transfer control upwards in the AST hierarchy.
      return computeFollowNode(fromNode, parent, cfa);
    }
  }",0,0
74,Closure_145,"  private boolean isOneExactlyFunctionOrDo(Node n) {
        // For labels with block children, we need to ensure that a
        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs 
        // are skipped. 
          // Either a empty statement or an block with more than one child,
          // way it isn't a FUNCTION or DO.
      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);
  }
","private boolean isOneExactlyFunctionOrDo(Node n) {
    // For labels with block children, we need to ensure that a
    // labeled FUNCTION or DO isn't mistakenly identified when extraneous BLOCKs 
    // are skipped. This includes checking for valid children within the node.
    if (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {
        // Ensure it's a single identifiable FUNCTION or DO and not an empty or invalid structure.
        if (n.hasChildren() && n.getFirstChild().getType() == Token.BLOCK) {
            return n.getFirstChild().getChildCount() == 1; // Must have exactly one child in the block.
        }
        return true; // FUNCTION or DO without a block is valid.
    }
    return false; // Not a FUNCTION or DO type.
}",0,0
75,Closure_146,"public TypePair getTypesUnderInequality(JSType that) {
    // unions types
    if (that instanceof UnionType) {
      TypePair p = that.getTypesUnderInequality(this);
      return new TypePair(p.typeB, p.typeA);
    }

     // other types
     switch (this.testForEquality(that)) {
       case TRUE:
         return new TypePair(null, null);
 
       case FALSE:
       case UNKNOWN:
        return new TypePair(this, that);
    }

    // switch case is exhaustive
    throw new IllegalStateException();
  }","public TypePair getTypesUnderInequality(JSType that) {
    // unions types
    if (that instanceof UnionType) {
        TypePair p = that.getTypesUnderInequality(this);
        return new TypePair(p.typeB, p.typeA);
    }

    // other types
    EqualityResult result = this.testForEquality(that); // Ensure proper handling for testForEquality return value
    if (result != null) {
        switch (result) {
            case TRUE:
                return new TypePair(null, null);

            case FALSE:
            case UNKNOWN:
                return new TypePair(this, that);
        }
    }

    // Add null-check handling and ensure the switch is exhaustive
    throw new IllegalStateException(""Unexpected state encountered during inequality test."");
}",0,0
76,Closure_15,"@Override
      public boolean apply(Node n) {
        // When the node is null it means, we reached the implicit return
        // where the function returns (possibly without an return statement)
        if (n == null) {
          return false;
        }

        // TODO(user): We only care about calls to functions that
        // passes one of the dependent variable to a non-side-effect free
        // function.
        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
          return true;
        }

        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
           return true;
         }
 
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
          }
        }
        return false;
      }","@Override
public boolean apply(Node n) {
    // When the node is null it means we reached the implicit return
    // where the function returns (possibly without a return statement)
    if (n == null) {
        return false;
    }

    // Check if the node is a call and if the function call has side effects
    if (n.isCall()) {
        Boolean hasSideEffects = NodeUtil.functionCallHasSideEffects(n);
        if (hasSideEffects != null && hasSideEffects) {
            return true;
        }
    }

    // Check if the node is a constructor call and if it has side effects
    if (n.isNew()) {
        Boolean hasSideEffects = NodeUtil.constructorCallHasSideEffects(n);
        if (hasSideEffects != null && hasSideEffects) {
            return true;
        }
    }

    // Traverse child nodes recursively, ensuring no new control flow graph node is entered
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
        }
    }

    return false;
}",0,0
77,Closure_150,"    @Override public void visit(NodeTraversal t, Node n, Node parent) {
      if (n == scope.getRootNode()) return;

      if (n.getType() == Token.LP && parent == scope.getRootNode()) {
        handleFunctionInputs(parent);
        return;
      }

      attachLiteralTypes(n);
      switch (n.getType()) {
        case Token.FUNCTION:
          if (parent.getType() == Token.NAME) {
            return;
          }
          defineDeclaredFunction(n, parent);
          break;
        case Token.CATCH:
          defineCatch(n, parent);
          break;
        case Token.VAR:
          defineVar(n, parent);
          break;
      }
    }","@Override 
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n == null || parent == null || scope == null || scope.getRootNode() == null) {
        return;
    }

    if (n == scope.getRootNode()) {
        return;
    }

    if (n.getType() == Token.LP && parent == scope.getRootNode()) {
        handleFunctionInputs(parent);
        return;
    }

    attachLiteralTypes(n);
    switch (n.getType()) {
        case Token.FUNCTION:
            if (parent.getType() == Token.NAME || parent.getType() != Token.SCRIPT) { // Ensure FUNCTION is valid within the parent context
                return;
            }
            defineDeclaredFunction(n, parent);
            break;

        case Token.CATCH:
            if (parent.getType() != Token.BLOCK) { // Ensure CATCH is valid within the parent context
                return;
            }
            defineCatch(n, parent);
            break;

        case Token.VAR:
            if (parent.getType() != Token.SCRIPT && parent.getType() != Token.BLOCK) { // Ensure VAR is within valid scope
                return;
            }
            defineVar(n, parent);
            break;

        default: 
            // Optional: handle other node types or log unhandled cases
            break;
    }
}",0,0
78,Closure_152,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
    setResolvedTypeInternal(this);

    call = (ArrowType) safeResolve(call, t, scope);
    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);

     // Warning about typeOfThis if it doesn't resolve to an ObjectType
     // is handled further upstream.
     // TODO(nicksantos): Handle this correctly if we have a UnionType.
     typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);
 
     boolean changed = false;
     ImmutableList.Builder<ObjectType> resolvedInterfaces =
        ImmutableList.builder();
    for (ObjectType iface : implementedInterfaces) {
      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);
      resolvedInterfaces.add(resolvedIface);
      changed |= (resolvedIface != iface);
    }
    if (changed) {
      implementedInterfaces = resolvedInterfaces.build();
    }

    if (subTypes != null) {
      for (int i = 0; i < subTypes.size(); i++) {
        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));
      }
    }

    return super.resolveInternal(t, scope);
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
    setResolvedTypeInternal(this);

    call = (ArrowType) safeResolve(call, t, scope);
    if (call == null) {
        call = createDefaultCallType(); // Add a fallback to handle unresolved call
    }

    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);
    if (prototype == null) {
        prototype = createDefaultPrototypeType(); // Add a fallback to handle unresolved prototype
    }

    // Warning about typeOfThis if it doesn't resolve to an ObjectType
    // is handled further upstream.
    // TODO: Handle this correctly if we have a UnionType.
    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);
    if (typeOfThis == null) {
        typeOfThis = createDefaultObjectType(); // Add a fallback to handle unresolved typeOfThis
    }

    boolean changed = false;
    ImmutableList.Builder<ObjectType> resolvedInterfaces =
        ImmutableList.builder();
    for (ObjectType iface : implementedInterfaces) {
        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);
        if (resolvedIface == null) {
            resolvedIface = createDefaultInterfaceType(); // Add a fallback for unresolved interfaces
        }
        resolvedInterfaces.add(resolvedIface);
        changed |= (resolvedIface != iface);
    }
    if (changed) {
        implementedInterfaces = resolvedInterfaces.build();
    }

    if (subTypes != null) {
        for (int i = 0; i < subTypes.size(); i++) {
            FunctionType resolvedSubType = (FunctionType) subTypes.get(i).resolve(t, scope);
            if (resolvedSubType == null) {
                resolvedSubType = createDefaultFunctionType(); // Add a fallback for unresolved subTypes
            }
            subTypes.set(i, resolvedSubType);
        }
    }

    return super.resolveInternal(t, scope);
}",0,0
79,Closure_159,"private void findCalledFunctions(
       Node node, Set<String> changed) {
     Preconditions.checkArgument(changed != null);
     // For each referenced function, add a new reference
     if (node.getType() == Token.CALL) {
       Node child = node.getFirstChild();
       if (child.getType() == Token.NAME) {
         changed.add(child.getString());
       }
     }
 
    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
      findCalledFunctions(c, changed);
    }
  }",Match failed,0,0
80,Closure_160,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
          CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
      options.setWarningLevel(
          DiagnosticGroups.GLOBAL_THIS,
          options.checkGlobalThisLevel);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());


    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
     // about missing variable declarations, we shut that specific
     // error off.
     if (!options.checkSymbols &&
         (warningsGuard == null || !warningsGuard.disables(
             DiagnosticGroups.CHECK_VARIABLES))) {
       guards.add(new DiagnosticGroupWarningsGuard(
           DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
     }
 
     this.warningsGuard = new ComposeWarningsGuard(guards);
   }","public void initOptions(CompilerOptions options) {
    if (options == null) {
        throw new IllegalArgumentException(""CompilerOptions cannot be null"");
    }
    this.options = options;

    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(
                new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer =
                new PrintStreamErrorManager(createMessageFormatter(), outStream);
            if (options.summaryDetailLevel != null) { // Ensure summaryDetailLevel is not null
                printer.setSummaryDetailLevel(options.summaryDetailLevel);
            }
            setErrorManager(printer);
        }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (!options.checkTypes) {
        // If DiagnosticGroups did not override the plain checkTypes
        // option, and checkTypes is enabled, then turn off the
        // parser type warnings.
        options.setWarningLevel(
            DiagnosticGroup.forType(
                RhinoErrorReporter.TYPE_PARSE_ERROR),
            CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel != null && options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(
            DiagnosticGroups.GLOBAL_THIS,
            options.checkGlobalThisLevel);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));

    if (options.getWarningsGuard() != null) {
        guards.add(options.getWarningsGuard());
    }

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        (warningsGuard == null || !warningsGuard.disables(
            DiagnosticGroups.CHECK_VARIABLES))) {
        guards.add(new DiagnosticGroupWarningsGuard(
            DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = new ComposeWarningsGuard(guards);
}",0,0
81,Closure_161,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
     // If GETPROP/GETELEM is used as assignment target the array literal is
     // acting as a temporary we can't fold it here:
     //    ""[][0] += 1""
 
     if (right.getType() != Token.NUMBER) {
       // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    Node elem = left.getFirstChild();
    for (int i = 0; elem != null && i < intIndex; i++) {
      elem = elem.getNext();
    }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.getType() == Token.EMPTY) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
  }","private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();

    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (parent != null && (parent.getType() == Token.ASSIGN || parent.getType() == Token.ASSIGN_ADD || parent.getType() == Token.ASSIGN_SUB ||
            parent.getType() == Token.ASSIGN_MUL || parent.getType() == Token.ASSIGN_DIV || parent.getType() == Token.ASSIGN_MOD)) {
        return n;
    }

    if (right.getType() != Token.NUMBER) {
        // Sometimes people like to use complex expressions to index into
        // arrays, or strings to index into array methods.
        return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
        error(INVALID_GETELEM_INDEX_ERROR, right);
        return n;
    }

    if (intIndex < 0) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }

    Node elem = left.getFirstChild();
    for (int i = 0; elem != null && i < intIndex; i++) {
        elem = elem.getNext();
    }

    if (elem == null) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }

    if (elem.getType() == Token.EMPTY) {
        elem = NodeUtil.newUndefinedNode(elem);
    } else {
        left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    if (parent != null) {
        parent.replaceChild(n, elem);
    }
    reportCodeChange();
    return elem;
}",0,0
82,Closure_164,"@Override
  public boolean isSubtype(JSType other) {
    if (!(other instanceof ArrowType)) {
      return false;
    }

    ArrowType that = (ArrowType) other;

    // This is described in Draft 2 of the ES4 spec,
    // Section 3.4.7: Subtyping Function Types.

    // this.returnType <: that.returnType (covariant)
    if (!this.returnType.isSubtype(that.returnType)) {
      return false;
    }

    // that.paramType[i] <: this.paramType[i] (contravariant)
    //
    // If this.paramType[i] is required,
    // then that.paramType[i] is required.
    //
    // In theory, the ""required-ness"" should work in the other direction as
    // well. In other words, if we have
    //
    // function f(number, number) {}
    // function g(number) {}
    //
    // Then f *should* not be a subtype of g, and g *should* not be
    // a subtype of f. But in practice, we do not implement it this way.
    // We want to support the use case where you can pass g where f is
    // expected, and pretend that g ignores the second argument.
    // That way, you can have a single ""no-op"" function, and you don't have
    // to create a new no-op function for every possible type signature.
    //
    // So, in this case, g < f, but f !< g
    Node thisParam = parameters.getFirstChild();
    Node thatParam = that.parameters.getFirstChild();
    while (thisParam != null && thatParam != null) {
      JSType thisParamType = thisParam.getJSType();
      JSType thatParamType = thatParam.getJSType();
      if (thisParamType != null) {
        if (thatParamType == null ||
            !thatParamType.isSubtype(thisParamType)) {
          return false;
        }
      }

      boolean thisIsVarArgs = thisParam.isVarArgs();
      boolean thatIsVarArgs = thatParam.isVarArgs();

      // ""that"" can't be a supertype, because it's missing a required argument.
        // NOTE(nicksantos): In our type system, we use {function(...?)} and
        // {function(...NoType)} to to indicate that arity should not be
        // checked. Strictly speaking, this is not a correct formulation,
        // because now a sub-function can required arguments that are var_args
        // in the super-function. So we special-case this.

      // don't advance if we have variable arguments
      if (!thisIsVarArgs) {
        thisParam = thisParam.getNext();
      }
      if (!thatIsVarArgs) {
        thatParam = thatParam.getNext();
      }

      // both var_args indicates the end
      if (thisIsVarArgs && thatIsVarArgs) {
        thisParam = null;
        thatParam = null;
      }
     }
 
     // ""that"" can't be a supertype, because it's missing a required arguement.
 
     return true;
   }","@Override
public boolean isSubtype(JSType other) {
    if (!(other instanceof ArrowType)) {
        return false;
    }

    ArrowType that = (ArrowType) other;

    // This is described in Draft 2 of the ES4 spec,
    // Section 3.4.7: Subtyping Function Types.

    // this.returnType <: that.returnType (covariant)
    if (!this.returnType.isSubtype(that.returnType)) {
        return false;
    }

    // that.paramType[i] <: this.paramType[i] (contravariant)
    Node thisParam = parameters.getFirstChild();
    Node thatParam = that.parameters.getFirstChild();
    while (thisParam != null || thatParam != null) {

        // ""that"" can't be a supertype, because it's missing a required argument.
        if (thisParam != null && !thisParam.isVarArgs() && thatParam == null) {
            return false;
        }

        JSType thisParamType = (thisParam != null) ? thisParam.getJSType() : null;
        JSType thatParamType = (thatParam != null) ? thatParam.getJSType() : null;

        if (thisParamType != null) {
            if (thatParamType == null || !thatParamType.isSubtype(thisParamType)) {
                return false;
            }
        }

        boolean thisIsVarArgs = (thisParam != null && thisParam.isVarArgs());
        boolean thatIsVarArgs = (thatParam != null && thatParam.isVarArgs());

        // Special handling for variable arguments
        if (thisIsVarArgs && thatIsVarArgs) {
            break;
        }

        // Don't advance if we have variable arguments
        if (!thisIsVarArgs && thisParam != null) {
            thisParam = thisParam.getNext();
        }
        if (!thatIsVarArgs && thatParam != null) {
            thatParam = thatParam.getNext();
        }
    }

    // ""that"" can't be a supertype, because it's missing a required argument.
    if (thisParam != null && !thisParam.isVarArgs()) {
        return false;
    }

    return true;
}",0,0
83,Closure_166,"@Override
  public void matchConstraint(JSType constraint) {
    // We only want to match constraints on anonymous types.
    if (hasReferenceName()) {
      return;
    }

    // Handle the case where the constraint object is a record type.
    //
    // param constraint {{prop: (number|undefined)}}
    // function f(constraint) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
     // properties on this object.
     if (constraint.isRecordType()) {
       matchRecordTypeConstraint(constraint.toObjectType());
     }
   }","@Override
public void matchConstraint(JSType constraint) {
    // We only want to match constraints on anonymous types.
    if (hasReferenceName()) {
        return;
    }

    // Handle the case where the constraint object is a record type.
    if (constraint != null && constraint.isRecordType()) {
        matchRecordTypeConstraint(constraint.toObjectType());
    }
}",0,0
84,Closure_168,"@Override public void visit(NodeTraversal t, Node n, Node parent) {
      if (t.inGlobalScope()) {
        return;
      }

      if (n.isReturn() && n.getFirstChild() != null) {
         data.get(t.getScopeRoot()).recordNonEmptyReturn();
       }
 
       if (t.getScopeDepth() <= 2) {
         // The first-order function analyzer looks at two types of variables:
         //
         // 1) Local variables that are assigned in inner scopes (""escaped vars"")
        //
        // 2) Local variables that are assigned more than once.
        //
        // We treat all global variables as escaped by default, so there's
        // no reason to do this extra computation for them.
        return;
      }

      if (n.isName() && NodeUtil.isLValue(n) &&
          // Be careful of bleeding functions, which create variables
          // in the inner scope, not the scope where the name appears.
          !NodeUtil.isBleedingFunctionName(n)) {
        String name = n.getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
          Scope ownerScope = var.getScope();
          if (ownerScope.isLocal()) {
            data.get(ownerScope.getRootNode()).recordAssignedName(name);
          }

          if (scope != ownerScope && ownerScope.isLocal()) {
            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);
          }
        }
      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&
          NodeUtil.isLValue(n)) {
        String name = NodeUtil.getRootOfQualifiedName(n).getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
          Scope ownerScope = var.getScope();
          if (scope != ownerScope && ownerScope.isLocal()) {
            data.get(ownerScope.getRootNode())
                .recordEscapedQualifiedName(n.getQualifiedName());
          }
        }
      }
    }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (t.inGlobalScope()) {
        return;
    }

    if (n.isReturn() && n.getFirstChild() != null) {
        data.get(t.getScopeRoot()).recordNonEmptyReturn();
    }

    if (t.getScopeDepth() > 2) {
        if (n.isName() && NodeUtil.isLValue(n) &&
                // Be careful of bleeding functions, which create variables
                // in the inner scope, not the scope where the name appears.
                !NodeUtil.isBleedingFunctionName(n)) {
            String name = n.getString();
            Scope scope = t.getScope();
            Var var = scope.getVar(name);
            if (var != null) {
                Scope ownerScope = var.getScope();
                if (ownerScope.isLocal()) {
                    data.get(ownerScope.getRootNode()).recordAssignedName(name);
                }

                if (scope != ownerScope && ownerScope.isLocal()) {
                    data.get(ownerScope.getRootNode()).recordEscapedVarName(name);
                }
            }
        } else if (n.isGetProp() && NodeUtil.isUnscopedQualifiedName(n) &&
                NodeUtil.isLValue(n)) {
            String name = NodeUtil.getRootOfQualifiedName(n).getString();
            Scope scope = t.getScope();
            Var var = scope.getVar(name);
            if (var != null) {
                Scope ownerScope = var.getScope();
                if (scope != ownerScope && ownerScope.isLocal()) {
                    data.get(ownerScope.getRootNode())
                            .recordEscapedQualifiedName(n.getQualifiedName());
                }
            }
        }
    }
}",0,0
85,Closure_17,"private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else {
          // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
              } else if (rValue.isOr()) {
                // Check for a very specific JS idiom:
                // var x = x || TYPE;
                // This is used by Closure's base namespace for esoteric
                // reasons.
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName()
                    && lValue.isName()
                    && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null
                    && !secondClause.getJSType().isUnknownType()) {
                  return secondClause.getJSType();
                }
              }
            }
          }
        }
      }

      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }","private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
    if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    } else if (rValue != null && rValue.isFunction() &&
            shouldUseFunctionLiteralType(
                    JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    } else if (info != null) {
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit() && rValue.getJSType() != null) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(
                        rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(
                    rValue, lValue.getQualifiedName(), info, lValue);
        } else {
            // Check if this is constant, and if it has a known type.
            if (info.isConstant()) {
                if (rValue != null) {
                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                        // If rValue has a type-cast, we use the type in the type-cast.
                        // If rValue's type was already computed during scope creation,
                        // then we can safely use that.
                        return rValue.getJSType();
                    } else if (rValue.isOr()) {
                        // Check for a very specific JS idiom:
                        // var x = x || TYPE;
                        // This is used by Closure's base namespace for esoteric
                        // reasons.
                        Node firstClause = rValue.getFirstChild();
                        Node secondClause = firstClause.getNext();
                        if (firstClause != null && secondClause != null) {
                            boolean namesMatch = firstClause.isName()
                                    && lValue.isName()
                                    && firstClause.getString().equals(lValue.getString());
                            if (namesMatch && secondClause.getJSType() != null
                                    && !secondClause.getJSType().isUnknownType()) {
                                return secondClause.getJSType();
                            }
                        }
                    }
                }
            }
        }
    }

    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}",0,0
86,Closure_172,"    private boolean isQualifiedNameInferred(
        String qName, Node n, JSDocInfo info,
        Node rhsValue, JSType valueType) {
      if (valueType == null) {
        return true;
      }

      // Prototypes of constructors and interfaces are always declared.
      if (qName != null && qName.endsWith("".prototype"")) {
          return false;
      }

      boolean inferred = true;
      if (info != null) {
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (isConstantSymbol(info, n) && valueType != null
                && !valueType.isUnknownType())
            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
      }

      if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
          return false;
        } else if (!scope.isDeclared(qName, false) &&
            n.isUnscopedQualifiedName()) {

          // Check if this is in a conditional block.
          // Functions assigned in conditional blocks are inferred.
          for (Node current = n.getParent();
               !(current.isScript() || current.isFunction());
               current = current.getParent()) {
            if (NodeUtil.isControlStructure(current)) {
              return true;
            }
          }

          // Check if this is assigned in an inner scope.
          // Functions assigned in inner scopes are inferred.
          AstFunctionContents contents =
              getFunctionAnalysisResults(scope.getRootNode());
          if (contents == null ||
              !contents.getEscapedQualifiedNames().contains(qName)) {
            return false;
          }
        }
      }
      return inferred;
    }
","private boolean isQualifiedNameInferred(
        String qName, Node n, JSDocInfo info,
        Node rhsValue, JSType valueType) {
    if (valueType == null) {
        return true;
    }

    // Prototypes of constructors and interfaces are always declared.
    if (qName != null && qName.endsWith("".prototype"")) {
        return false;
    }

    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (isConstantSymbol(info, n) && valueType != null
                && !valueType.isUnknownType())
            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }

    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) &&
                   n.isUnscopedQualifiedName()) {

            // Check if this is in a conditional block.
            // Functions assigned in conditional blocks are inferred.
            Node current = n.getParent();
            while (current != null && !current.isScript() && !current.isFunction()) {
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
                current = current.getParent();
            }

            // Check if this is assigned in an inner scope.
            // Functions assigned in inner scopes are inferred.
            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }

    return inferred;
}",0,0
87,Closure_176,"  private void updateScopeForTypeChange(
      FlowScope scope, Node left, JSType leftType, JSType resultType) {
    Preconditions.checkNotNull(resultType);
    switch (left.getType()) {
      case Token.NAME:
        String varName = left.getString();
        Var var = syntacticScope.getVar(varName);
        boolean isVarDeclaration = left.hasChildren();

        // When looking at VAR initializers for declared VARs, we tend
        // to use the declared type over the type it's being
        // initialized to in the global scope.
        //
        // For example,
        // /** @param {number} */ var f = goog.abstractMethod;
        // it's obvious that the programmer wants you to use
        // the declared function signature, not the inferred signature.
        //
        // Or,
        // /** @type {Object.<string>} */ var x = {};
        // the one-time anonymous object on the right side
        // is as narrow as it can possibly be, but we need to make
        // sure we back-infer the <string> element constraint on
        // the left hand side, so we use the left hand side.

        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();
            // Makes it easier to check for NPEs.

        // TODO(nicksantos): This might be a better check once we have
        // back-inference of object/array constraints.  It will probably
        // introduce more type warnings.  It uses the result type iff it's
        // strictly narrower than the declared var type.
        //
        //boolean isVarTypeBetter = isVarDeclaration &&
        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)
        //     || !resultType.isSubtype(varType));


        if (isVarTypeBetter) {
          redeclareSimpleVar(scope, left, resultType);
        }
        left.setJSType(isVarDeclaration || leftType == null ?
            resultType : null);

        if (var != null && var.isTypeInferred()) {
          JSType oldType = var.getType();
          var.setType(oldType == null ?
              resultType : oldType.getLeastSupertype(resultType));
        }
        break;
      case Token.GETPROP:
        String qualifiedName = left.getQualifiedName();
        if (qualifiedName != null) {
          scope.inferQualifiedSlot(left, qualifiedName,
              leftType == null ? unknownType : leftType,
              resultType);
        }

        left.setJSType(resultType);
        ensurePropertyDefined(left, resultType);
        break;
    }
  }
","private void updateScopeForTypeChange(
      FlowScope scope, Node left, JSType leftType, JSType resultType) {
    Preconditions.checkNotNull(resultType);

    switch (left.getType()) {
      case Token.NAME:
        String varName = left.getString();
        Var var = syntacticScope != null ? syntacticScope.getVar(varName) : null;
        boolean isVarDeclaration = left.hasChildren();

        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();

        if (isVarTypeBetter) {
          redeclareSimpleVar(scope, left, resultType);
        }
        left.setJSType(isVarDeclaration || leftType == null ? resultType : leftType);

        if (var != null && var.isTypeInferred()) {
          JSType oldType = var.getType();
          var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));
        }
        break;
      case Token.GETPROP:
        String qualifiedName = left.getQualifiedName();
        if (qualifiedName != null) {
          scope.inferQualifiedSlot(left, qualifiedName,
              leftType == null ? unknownType : leftType,
              resultType);
        }

        left.setJSType(resultType);
        ensurePropertyDefined(left, resultType);
        break;
    }
  }",0,0
88,Closure_18,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      hoistExterns(externsRoot);
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
       if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      hoistNoCompileFiles();

      if (staleInputs) {
        repartitionInputs();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                // Handle null AST root for externs gracefully
                report(JSError.make(""Null externs AST root""));
                return null;
            }
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        hoistExterns(externsRoot);

        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare all the provided types, so they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs =
                    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                    .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(
                    JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(
                    MISSING_ENTRY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }

        hoistNoCompileFiles();

        if (staleInputs) {
            repartitionInputs();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                // Handle null AST root for inputs gracefully
                report(JSError.make(""Null JS AST root in input: "" + input.getName()));
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null ||
                options.nameReferenceReportPath != null) {

                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia =
                    new SourceInformationAnnotator(
                        input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",0,0
89,Closure_19,"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch (node.getType()) {
      case Token.NAME:
        scope.inferSlotType(node.getString(), type);
        break;

      case Token.GETPROP:
        String qualifiedName = node.getQualifiedName();
        Preconditions.checkNotNull(qualifiedName);

        JSType origType = node.getJSType();
        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
         scope.inferQualifiedSlot(node, qualifiedName, origType, type);
         break;
 
         // ""this"" references aren't currently modeled in the CFG.
 
       default:
         throw new IllegalArgumentException(""Node cannot be refined. \n"" +
            node.toStringTree());
    }
  }","protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch (node.getType()) {
        case Token.NAME:
            Preconditions.checkNotNull(node.getString(), ""Node name must not be null"");
            scope.inferSlotType(node.getString(), type);
            break;

        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName, ""Qualified name must not be null"");
            
            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;

            Preconditions.checkNotNull(scope, ""FlowScope must not be null"");
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;

        // ""this"" references aren't currently modeled in the CFG.

        default:
            throw new IllegalArgumentException(""Node of type "" + node.getType() + "" cannot be refined.\n"" +
                node.toStringTree());
    }
}",0,0
90,Closure_2,"private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
      String functionName, HashMap<String, ObjectType> properties,
      HashMap<String, ObjectType> currentProperties,
       ObjectType interfaceType) {
     ObjectType implicitProto = interfaceType.getImplicitPrototype();
     Set<String> currentPropertyNames;
       // This can be the case if interfaceType is proxy to a non-existent
       // object (which is a bad type annotation, but shouldn't crash).
       currentPropertyNames = implicitProto.getOwnPropertyNames();
     for (String name : currentPropertyNames) {
       ObjectType oType = properties.get(name);
       if (oType != null) {
        if (!interfaceType.getPropertyType(name).isEquivalentTo(
            oType.getPropertyType(name))) {
          compiler.report(
              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
                  functionName, name, oType.toString(),
                  interfaceType.toString()));
        }
      }
      currentProperties.put(name, interfaceType);
    }
    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
      checkInterfaceConflictProperties(t, n, functionName, properties,
          currentProperties, iType);
    }
  }","private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
      String functionName, HashMap<String, ObjectType> properties,
      HashMap<String, ObjectType> currentProperties,
      ObjectType interfaceType) {
    ObjectType implicitProto = interfaceType.getImplicitPrototype();
    if (implicitProto == null) {
        // If the implicit prototype is null, there's nothing to check for conflicts.
        return;
    }

    // Retrieve current property names safely.
    Set<String> currentPropertyNames = implicitProto.getOwnPropertyNames();
    if (currentPropertyNames == null) {
        // If property names are null, skip processing to prevent crashes.
        return;
    }

    for (String name : currentPropertyNames) {
        ObjectType oType = properties.get(name);
        if (oType != null) {
            // Check equivalence safely for property types.
            Property oProperty = oType.getPropertyType(name);
            Property interfaceProperty = interfaceType.getPropertyType(name);
            if (oProperty != null && interfaceProperty != null && 
                !interfaceProperty.isEquivalentTo(oProperty)) {
                compiler.report(
                    t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
                        functionName, name, oType.toString(),
                        interfaceType.toString()));
            }
        }
        currentProperties.put(name, interfaceType);
    }

    // Check extended interfaces recursively.
    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
        if (iType != null) {
            checkInterfaceConflictProperties(t, n, functionName, properties,
                currentProperties, iType);
        }
    }
}",0,0
91,Closure_20,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
       if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
      }
    }
    return n;
  }","private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          ""String"".equals(callTarget.getString())) { // Fixed null-check and comparison
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
      // slightly different semantics than '' + (a). See
      // http://code.google.com/p/closure-compiler/issues/detail?id=759
      Node value = callTarget.getNext();
      if (value != null && value.getParent() == n) { // Added check for parent consistency
        Node addition = IR.add(
            IR.string("""").srcref(callTarget),
            value.detachFromParent());
        if (n.getParent() != null) { // Ensure parent exists before replacing
          n.getParent().replaceChild(n, addition);
          reportCodeChange();
          return addition;
        }
      }
    }
    return n;
}",0,0
92,Closure_21,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
      return;
    }

    // This no-op statement was there so that JSDoc information could
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
         return;
       }
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA) continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
           else break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
         return;
       }
     }
     if (
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
        msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // This is generally not indicative of a bug, so we allow them.
    if (n == null || parent == null || n.isEmpty() || n.isComma()) {
        return;
    }

    // Do not handle cases for `EXPR_RESULT` directly here, as these are
    // better managed by child visits and peephole passes.
    if (n.isExprResult()) {
        return;
    }

    // Skip no-op statements added purely for attached JSDoc information.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    // Special handling for nodes under a COMMA parent
    if (parent.getType() == Token.COMMA) {
        if (isResultUsed) {
            return;
        }
        if (n == parent.getLastChild()) {
            for (Node ancestor : parent.getAncestors()) {
                int ancestorType = ancestor.getType();
                if (ancestorType == Token.COMMA) {
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                }
                break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        // Allow cases where the node is part of a FOR loop declaration
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 &&
                (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    // Report issues with side-effect free code
    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
                  ""' operator is not being used."";
        }

        t.getCompiler().report(
            t.makeError(n, level, USELESS_CODE_ERROR, msg)
        );

        // Protect side-effect free statements, if relevant.
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",0,0
93,Closure_22,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
     if (parent.getType() == Token.COMMA) {
       Node gramps = parent.getParent();
       if (gramps.isCall() && parent == gramps.getFirstChild()) {
         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
         }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA)
             continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
             return;
           else
             break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
            n == parent.getFirstChild().getNext().getNext())) {
       } else {
       return;
       }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       if (n.isQualifiedName() && n.getJSDocInfo() != null) {
         return;
       } else if (n.isExprResult()) {
         return;
       }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (parent.getToken() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps != null && gramps.isCall() && parent == gramps.getFirstChild()) {
            if (n == parent.getFirstChild()
                    && parent.getChildCount() == 2
                    && n.getNext() != null
                    && n.getNext().isName()
                    && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }

        // This no-op statement was there so that JSDoc information could
        // be attached to the name. This check should not complain about it.
        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getToken();
                if (ancestorType == Token.COMMA) {
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                } else {
                    break;
                }
            }
        }
    } else if (parent.getToken() != Token.EXPR_RESULT && parent.getToken() != Token.BLOCK) {
        if (parent.getToken() == Token.FOR
                && parent.getChildCount() == 4
                && (n == parent.getFirstChild()
                        || n == parent.getFirstChild().getNext().getNext())) {
            // Valid 'FOR' loop structure, do nothing
        } else {
            return;
        }
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getToken());
    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        if (n.isQualifiedName() && n.getJSDocInfo() != null) {
            return;
        } else if (n.isExprResult()) {
            return;
        }
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getToken()).toLowerCase() + ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        // TODO(johnlenz): determine if it is necessary to
        // try to protect side-effect free statements as well.
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",0,0
94,Closure_23,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }
 
     Node current = left.getFirstChild();
     Node elem = null;
     for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
  }","private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();

    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
        return n;
    }

    if (!right.isNumber()) {
        // Sometimes people like to use complex expressions to index into
        // arrays, or strings to index into array methods.
        return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
        error(INVALID_GETELEM_INDEX_ERROR, right);
        return n;
    }

    if (intIndex < 0) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }

    Node current = left.getFirstChild();
    Node elem = null;
    for (int i = 0; current != null; i++) {
        if (i == intIndex) {
            elem = current;
            break;
        }
        current = current.getNext();
    }

    if (elem == null) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }

    // Ensure the element is properly handled
    if (elem.isEmpty()) {
        elem = NodeUtil.newUndefinedNode(elem);
    } else {
        left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    parent.replaceChild(n, elem);
    reportCodeChange();
    return elem;
}",0,0
95,Closure_24,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
         if (parent.isVar()) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);

          String qualifiedName =
              aliasVar.getInitialValue().getQualifiedName();
          transformation.addAlias(name, qualifiedName);
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else {
          // TODO(robbyw): Support using locals for private variables.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
        }
      }
    }","private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        
        if (parent != null && parent.isVar()) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);

                if (aliasVar != null && aliasVar.getInitialValue() != null) {
                    aliases.put(name, aliasVar);

                    String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                    if (qualifiedName != null) {
                        transformation.addAlias(name, qualifiedName);
                    }
                }
                // Bleeding functions already get a BAD_PARAMETERS error, so just
                // do nothing.
                // Parameters of the scope function also get a BAD_PARAMETERS error.
            } else {
                // TODO(robbyw): Support using locals for private variables.
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",0,0
96,Closure_25,"private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
      constructorType = constructorType.restrictByNotNullOrUndefined();
      if (constructorType.isUnknownType()) {
        type = getNativeType(UNKNOWN_TYPE);
      } else {
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct == null && constructorType instanceof FunctionType) {
          // If constructorType is a NoObjectType, then toMaybeFunctionType will
          // return null. But NoObjectType implements the FunctionType
          // interface, precisely because it can validly construct objects.
          ct = (FunctionType) constructorType;
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
       scope = traverse(arg, scope);
     }
     return scope;
   }","private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    
    // Ensure constructorType is verified before usage
    if (constructorType != null) {
        constructorType = constructorType.restrictByNotNullOrUndefined();
        if (constructorType.isUnknownType()) {
            type = getNativeType(UNKNOWN_TYPE);
        } else {
            FunctionType ct = constructorType.toMaybeFunctionType();

            // Ensure it handles NoObjectType correctly
            if (ct == null && constructorType instanceof FunctionType) {
                ct = (FunctionType) constructorType;
            }

            // Check if ct is a valid constructor, then get its instance type
            if (ct != null && ct.isConstructor()) {
                type = ct.getInstanceType();
            }
        }
    }

    n.setJSType(type);

    // Traverse the arguments of the constructor
    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
        scope = traverse(arg, scope);
    }

    return scope;
}",0,0
97,Closure_28,"/*
 * Copyright 2008 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      add(ESTIMATED_IDENTIFIER);
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}
",Match failed,0,0
98,Closure_29,"private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target maybe using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-refential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }


          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            
            // A call target may be using the object as a 'this' value.
            if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            // NOTE: Ensure we continue for references related to property access.
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }

        // Make sure that the value is not self-referential.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }

            Node childVal = child.getFirstChild();
            // Check if childVal is the parent of any of the passed-in references,
            // as that is how self-referential assignments will happen.
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment.
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }

        // We have found an acceptable object literal assignment. As long as
        // there are no other assignments that mess things up, we can inline.
        ret = true;
    }
    return ret;
}",0,0
99,Closure_31,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
           !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            if (n != null) {
                externsRoot.addChildToBack(n);
            }
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        // Check if inputs need to be rebuilt from modules.
        boolean staleInputs = false;

        // Check if the sources need to be re-ordered.
        if (options.dependencyOptions.needsManagement() &&
            !options.skipAllPasses &&
            options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs =
                    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                    .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(
                    JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(
                    MISSING_ENTRY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }

        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);

            // Inputs can have a null AST during initial parse.
            if (n == null) {
                continue;
            }

            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    // If the input file is explicitly marked as an externs file, then
                    // assume the programmer made a mistake and throw it into
                    // the externs pile anyways.
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);

                    input.getModule().remove(input);

                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }

        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null ||
                options.nameReferenceReportPath != null) {

                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia =
                    new SourceInformationAnnotator(
                        input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",0,0
100,Closure_32,"@SuppressWarnings(""fallthrough"")
  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                      WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
      return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
      line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.

    do {
      switch (token) {
        case STAR:
          if (ignoreStar) {
            // Mark the position after the star as the new start of the line.
          } else {
            // The star is part of the comment.
            if (builder.length() > 0) {
              builder.append(' ');
            }

            builder.append('*');
          }

          token = next();
          continue;

        case EOL:
          if (option != WhitespaceOption.SINGLE_LINE) {
            builder.append(""\n"");
           }
 
           ignoreStar = true;
           token = next();
           continue;
 
        default:
          ignoreStar = false;
          state = State.SEARCHING_ANNOTATION;

              // All tokens must be separated by a space.

          if (token == JsDocToken.EOC ||
              token == JsDocToken.EOF ||
              // When we're capturing a license block, annotations
              // in the block are ok.
              (token == JsDocToken.ANNOTATION &&
               option != WhitespaceOption.PRESERVE)) {
            String multilineText = builder.toString();

            if (option != WhitespaceOption.PRESERVE) {
              multilineText = multilineText.trim();
            }

            int endLineno = stream.getLineno();
            int endCharno = stream.getCharno();

            if (multilineText.length() > 0) {
              jsdocBuilder.markText(multilineText, startLineno, startCharno,
                  endLineno, endCharno);
            }

            return new ExtractionInfo(multilineText, token);
          }

          if (builder.length() > 0) {
            builder.append(' ');
          }
          builder.append(toString(token));

          line = stream.getRemainingJSDocLine();

          if (option != WhitespaceOption.PRESERVE) {
            line = trimEnd(line);
          }

          builder.append(line);
          token = next();
      }
    } while (true);
  }","@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                    WhitespaceOption option) {
    
    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.

    do {
        switch (token) {
            case STAR:
                if (ignoreStar) {
                    // Mark the position after the star as the new start of the line.
                } else {
                    // The star is part of the comment.
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                ignoreStar = true;
                token = next();
                break;

            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                break;

            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;

                // All tokens must be separated by a space.
                if (token == JsDocToken.EOC ||
                    token == JsDocToken.EOF ||
                    (token == JsDocToken.ANNOTATION &&
                     option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString();

                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }

                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();

                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno,
                            endLineno, endCharno);
                    }

                    return new ExtractionInfo(multilineText, token);
                }

                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));

                line = stream.getRemainingJSDocLine();

                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }

                builder.append(line);
                token = next();
        }
    } while (true);
}",0,0
101,Closure_33,"@Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj.isRecordType()) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!hasProperty(prop)) {
            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                .getLeastSupertype(propType);
          }
          defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
  }","@Override
public void matchConstraint(ObjectType constraintObj) {
    // We only want to match constraints on anonymous types.

    // Handle the case where the constraint object is a record type.
    //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any property on the record and trying to match
    // properties on this object.
    if (constraintObj != null && constraintObj.isRecordType()) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
            JSType propType = constraintObj.getPropertyType(prop);
            if (propType != null && !isPropertyTypeDeclared(prop)) {
                JSType typeToInfer = propType;
                if (!hasProperty(prop)) {
                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                        .getLeastSupertype(propType);
                }
                defineInferredProperty(prop, typeToInfer, null);
            }
        }
    }
}",0,0
102,Closure_35,"private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     if (constraintObj != null && constraintObj.isRecordType()) {
       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
       if (objType != null) {
         for (String prop : constraintObj.getOwnPropertyNames()) {
           JSType propType = constraintObj.getPropertyType(prop);
           if (!objType.isPropertyTypeDeclared(prop)) {
             JSType typeToInfer = propType;
             if (!objType.hasProperty(prop)) {
               typeToInfer =
                   getNativeType(VOID_TYPE).getLeastSupertype(propType);
             }
             objType.defineInferredProperty(prop, typeToInfer, null);
           }
         }
       }
     }
   }","private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
        return;
    }

    ObjectType constraintObj =
        ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null && constraintObj.isRecordType()) {
        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
        if (objType != null) {
            for (String prop : constraintObj.getOwnPropertyNames()) {
                JSType propType = constraintObj.getPropertyType(prop);
                if (propType == null) { // Avoid null property type
                    continue;
                }
                if (!objType.isPropertyTypeDeclared(prop)) {
                    JSType typeToInfer = propType;
                    if (!objType.hasProperty(prop)) {
                        typeToInfer =
                            getNativeType(VOID_TYPE).getLeastSupertype(propType);
                    }
                    objType.defineInferredProperty(prop, typeToInfer, null);
                }
            }
        }
    }
}",0,0
103,Closure_36,"private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Be very conservative and do no cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is ok.
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confused class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }","private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (declaration == null || initialization == null || reference == null) {
        return false; // Null check for the input parameters.
      }

      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          (initialization.getGrandparent() == null || !initialization.getGrandparent().isExprResult())) {
        return false;
      }

      // Be very conservative and do not cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() == null 
          || initialization.getBasicBlock() == null 
          || reference.getBasicBlock() == null
          || declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is ok.
      Node value = initialization.getAssignedValue();
      if (value == null) {
        return false; // Ensure the assigned value is not null.
      }

      if (value.isGetProp()
          && reference.getParent() != null
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (callNode != null && callNode.isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confuses class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }

          // Issue 668: Don't inline singleton getter methods
          // calls as this confuses class removing logic.
        }
      }

      return (canMoveAggressively(value) ||
          canMoveModerately(initialization, reference));
    }",0,0
104,Closure_38,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
     if (x < 0 && prev == '-') {
       add("" "");
     }
 
    if ((long) x == x && !negativeZero) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }
  }","void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);
    if (x < 0 && prev == '-') {
        add("" "");
    }

    if ((long) x == x && !negativeZero) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;

        // Adjusted check to ensure proper handling of edge cases during normalization.
        if (Math.abs(value) >= 100) {
            while (mantissa % 10 == 0 && mantissa / 10 * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }

        // Ensure exponent formatting is correct
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        // Utilize proper handling for String conversion
        add(Double.toString(x));
    }
}",0,0
105,Closure_39,"@Override
  String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
      return getReferenceName();
    } else if (prettyPrint) {
      // Don't pretty print recursively.
      prettyPrint = false;

      // Use a tree set so that the properties are sorted.
      Set<String> propertyNames = Sets.newTreeSet();
      for (ObjectType current = this;
           current != null && !current.isNativeObjectType() &&
               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
           current = current.getImplicitPrototype()) {
        propertyNames.addAll(current.getOwnPropertyNames());
      }

      StringBuilder sb = new StringBuilder();
      sb.append(""{"");

      int i = 0;
      for (String property : propertyNames) {
        if (i > 0) {
          sb.append("", "");
        }

        sb.append(property);
        sb.append("": "");
        sb.append(getPropertyType(property).toString());

        ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
          sb.append("", ..."");
          break;
        }
      }

      sb.append(""}"");

       prettyPrint = true;
       return sb.toString();
     } else {
       return ""{...}"";
     }
   }",Match failed,0,0
106,Closure_4,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
      handleTypeCycle(t);
    }

    if (resolved) {
      super.resolveInternal(t, enclosing);
      finishPropertyContinuations();
      return registry.isLastGeneration() ?
          getReferencedType() : this;
     }
 
     resolveViaProperties(t, enclosing);
     if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
      finishPropertyContinuations();
    }
    return registry.isLastGeneration() ?
        getReferencedType() : this;
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
        return this; // Return early if a cycle is detected
    }

    if (resolved) {
        super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ?
                getReferencedType() : this;
    }

    resolveViaProperties(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
        return this; // Return early if a cycle is detected
    }

    super.resolveInternal(t, enclosing);
    if (isResolved()) {
        finishPropertyContinuations();
    }

    return registry.isLastGeneration() ?
            getReferencedType() : this;
}",0,0
107,Closure_40,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          Preconditions.checkNotNull(ns);
          recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            recordSet(nameInfo.name, nameNode);
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
           }
         }
       }
     }","@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            if (nameInfo != null) {
              recordSet(nameInfo.name, nameNode);
            }
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
             if (parent != null && parent.getParent() != null) {
               refNodes.add(new ClassDefiningFunctionNode(
                 name, n, parent, parent.getParent()));
             }
           }
         }
       }
     }",0,0
108,Closure_42,"@Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
          transform(loopNode.getIteratedObject()),
          transformBlock(loopNode.getBody()));
    }","@Override
Node processForInLoop(ForInLoop loopNode) {
    // Check if any component is null before transforming
    Node iteratorNode = loopNode.getIterator() != null ? transform(loopNode.getIterator()) : null;
    Node iteratedObjectNode = loopNode.getIteratedObject() != null ? transform(loopNode.getIteratedObject()) : null;
    Node bodyNode = loopNode.getBody() != null ? transformBlock(loopNode.getBody()) : null;

    // Return the bare minimum to put the AST in a valid state.
    return newNode(Token.FOR, iteratorNode, iteratedObjectNode, bodyNode);
}",0,0
109,Closure_44,"void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
      return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar())) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
  }",Match failed,0,0
110,Closure_46,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
","public ObjectType getImplicitPrototype() {
    ObjectType objectType = registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    return (objectType != null) ? objectType.getImplicitPrototype() : null;
}",0,0
111,Closure_48,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }",0,0
112,Closure_5,"private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);

            // A call target may be using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            // Deleting a property should not be inlined.
            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(name, parent)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!NodeUtil.isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }

        // Make sure that the value is not self-referential.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }

            validProperties.add(child.getString());

            Node childVal = child.getFirstChild();
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }

        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}",0,0
113,Closure_50,"private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
      return n;
    }
 
     Node right = callTarget.getNext();
     if (right != null) {
       if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return n;
    }

      // "","" is the default, it doesn't need to be explicit

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getArrayElementStringValue(elem));
      } else {
        if (sb != null) {
          Preconditions.checkNotNull(prev);
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(
              Node.newString(sb.toString()).copyInformationFrom(prev));
          sb = null;
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem);
      }
      prev = elem;
      elem = elem.getNext();
    }

    if (sb != null) {
      Preconditions.checkNotNull(prev);
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(
          Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        n.getParent().replaceChild(n, emptyStringNode);
        reportCodeChange();
        return emptyStringNode;
      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString("""").copyInformationFrom(n),
              foldedStringNode);
          foldedStringNode = replacement;
        }
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return n;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        reportCodeChange();
        break;
    }

    return n;
  }",Match failed,0,0
114,Closure_51,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
      add("" "");
    }

    if ((long) x == x) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }

  }","void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
        add("" "");
    }

    if ((long) x == x) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(value) >= 100) {  // Ensure to check the long value
            while (mantissa % 10 == 0 && mantissa != 0) { // Correct the loop condition for mantissa
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        add(String.valueOf(x));
    }
}",0,0
115,Closure_52,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
      char c = s.charAt(index);
      if (c < '0' || c > '9') {
         return false;
       }
     }
     return len > 0;
   }",Match failed,0,0
116,Closure_53,"private void replaceAssignmentExpression(Var v, Reference ref,
                                             Map<String, String> varmap) {
      // Compute all of the assignments necessary
      List<Node> nodes = Lists.newArrayList();
      Node val = ref.getAssignedValue();
      blacklistVarReferencesInTree(val, v.scope);
      Preconditions.checkState(val.getType() == Token.OBJECTLIT);
      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
      for (Node key = val.getFirstChild(); key != null;
           key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
      }

      // TODO(user): Better source information.
      for (String var : all) {
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)),
                   NodeUtil.newUndefinedNode(null)));
       }
 
       Node replacement;
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));

        // Join these using COMMA.  A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
          cur.addChildToFront(nodes.get(i));
          Node t = new Node(Token.COMMA);
          cur.addChildToFront(t);
          cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));

      Node replace = ref.getParent();
      replacement.copyInformationFromForTree(replace);

      if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(
            replace, NodeUtil.newExpr(replacement));
      } else {
        replace.getParent().replaceChild(replace, replacement);
      }
    }","private void replaceAssignmentExpression(Var v, Reference ref,
                                             Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    if (val == null || blacklistVarReferencesInTree(val, v.scope)) {
        return;
    }
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
    for (Node key = val.getFirstChild(); key != null;
         key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // Ensure varmap contains the variable.
        if (varmap.containsKey(var)) {
            // TODO: Copy type information.
            nodes.add(
                new Node(Token.ASSIGN,
                         Node.newString(Token.NAME, varmap.get(var)), value));
            all.remove(var);
        }
    }

    // TODO: Better source information.
    for (String var : all) {
        nodes.add(
            new Node(Token.ASSIGN,
                     Node.newString(Token.NAME, varmap.get(var)),
                     NodeUtil.newUndefinedNode()));
    }

    Node replacement;
    // All assignments evaluate to true, so make sure that the
    // expr statement evaluates to true in case it matters.
    nodes.add(new Node(Token.TRUE));

    // Join these using COMMA. A COMMA node must have 2 children, so we
    // create a tree. In the tree the first child be the COMMA to match
    // the parser, otherwise tree equality tests fail.
    nodes = Lists.reverse(nodes);
    replacement = new Node(Token.COMMA);
    Node cur = replacement;
    int i;
    for (i = 0; i < nodes.size() - 2; i++) {
        cur.addChildToFront(nodes.get(i));
        Node t = new Node(Token.COMMA);
        cur.addChildToFront(t);
        cur = t;
    }
    cur.addChildToFront(nodes.get(i));
    cur.addChildToFront(nodes.get(i + 1));

    Node replace = ref.getParent();
    if (replace == null) {
        return;
    }
    replacement.copyInformationFromForTree(replace);

    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(
            replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}",0,0
117,Closure_55,"  public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }
","public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().getName() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.getFirstChild().detach() : null;
}",0,0
118,Closure_56,"public String getLine(int lineNumber) {
    String js = """";
    try {
      // NOTE(nicksantos): Right now, this is optimized for few warnings.
      // This is probably the right trade-off, but will be slow if there
      // are lots of warnings in one file.
      js = getCode();
    } catch (IOException e) {
      return null;
    }

    int pos = 0;
    int startLine = 1;

    // If we've saved a previous offset and it's for a line less than the
    // one we're searching for, then start at that point.
    if (lineNumber >= lastLine) {
      pos = lastOffset;
      startLine = lastLine;
    }

    for (int n = startLine; n < lineNumber; n++) {
      int nextpos = js.indexOf('\n', pos);
      if (nextpos == -1) {
        return null;
      }
      pos = nextpos + 1;
    }

    // Remember this offset for the next search we do.
    lastOffset = pos;
    lastLine = lineNumber;

    if (js.indexOf('\n', pos) == -1) {
       // If next new line cannot be found, there are two cases
       // 1. pos already reaches the end of file, then null should be returned
       // 2. otherwise, return the contents between pos and the end of file.
         return null;
     } else {
       return js.substring(pos, js.indexOf('\n', pos));
     }
  }","public String getLine(int lineNumber) {
    String js;
    try {
        // NOTE(nicksantos): Right now, this is optimized for few warnings.
        // This is probably the right trade-off, but will be slow if there
        // are lots of warnings in one file.
        js = getCode();
    } catch (IOException e) {
        return null;
    }

    int pos = 0;
    int startLine = 1;

    // If we've saved a previous offset and it's for a line less than the
    // one we're searching for, then start at that point.
    if (lineNumber >= lastLine) {
        pos = lastOffset;
        startLine = lastLine;
    }

    for (int n = startLine; n < lineNumber; n++) {
        int nextpos = js.indexOf('\n', pos);
        if (nextpos == -1) {
            return null;
        }
        pos = nextpos + 1;
    }

    // Remember this offset for the next search we do.
    lastOffset = pos;
    lastLine = lineNumber;

    int nextNewLinePos = js.indexOf('\n', pos);
    if (nextNewLinePos == -1) {
        return pos >= js.length() ? null : js.substring(pos);
    } else {
        return js.substring(pos, nextNewLinePos);
    }
}",0,0
119,Closure_57,"private static String extractClassNameIfGoog(Node node, Node parent,
      String functionName){
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
      Node callee = node.getFirstChild();
      if (callee != null && callee.getType() == Token.GETPROP) {
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
           if (target != null) {
             className = target.getString();
           }
         }
      }
    }
    return className;
  }","private static String extractClassNameIfGoog(Node node, Node parent,
      String functionName) {
    String className = null;
    if (NodeUtil.isExprCall(node)) {
        Node callee = node.getFirstChild();
        if (callee != null && callee.getType() == Token.GETPROP) {
            String qualifiedName = callee.getQualifiedName();
            if (qualifiedName != null && functionName.equals(qualifiedName)) {
                Node target = callee.getNext();
                if (target != null && target.isString()) {
                    className = target.getString();
                }
            }
        }
    }
    return className;
}",0,0
120,Closure_58,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }","private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    if (n == null) {
        return;
    }

    switch (n.getType()) {
        case Token.SCRIPT:
        case Token.BLOCK:
        case Token.FUNCTION:
            return;

        case Token.WHILE:
        case Token.DO:
        case Token.IF:
            computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);
            return;

        case Token.FOR:
            if (!NodeUtil.isForIn(n)) {
                computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);
            } else {
                // for(x in y) {...}
                Node lhs = n.getFirstChild();
                Node rhs = lhs != null ? lhs.getNext() : null;
                if (NodeUtil.isVar(lhs)) {
                    // for(var x in y) {...}
                    lhs = lhs.getLastChild();
                }
                if (lhs != null) {
                    addToSetIfLocal(lhs, kill);
                    addToSetIfLocal(lhs, gen);
                }
                computeGenKill(rhs, gen, kill, conditional);
            }
            return;

        case Token.VAR:
            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
                if (c.hasChildren()) {
                    computeGenKill(c.getFirstChild(), gen, kill, conditional);
                    if (!conditional) {
                        addToSetIfLocal(c, kill);
                    }
                }
            }
            return;

        case Token.AND:
        case Token.OR:
            computeGenKill(n.getFirstChild(), gen, kill, conditional);
            // May short circuit.
            computeGenKill(n.getLastChild(), gen, kill, true);
            return;

        case Token.HOOK:
            computeGenKill(n.getFirstChild(), gen, kill, conditional);
            // Assume both sides are conditional.
            computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
            computeGenKill(n.getLastChild(), gen, kill, true);
            return;

        case Token.NAME:
            if (isArgumentsName(n)) {
                markAllParametersEscaped();
            } else {
                addToSetIfLocal(n, gen);
            }
            return;

        default:
            if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
                Node lhs = n.getFirstChild();
                if (!conditional) {
                    addToSetIfLocal(lhs, kill);
                }
                if (!NodeUtil.isAssign(n)) {
                    // assignments such as a += 1 read a.
                    addToSetIfLocal(lhs, gen);
                }
                computeGenKill(lhs.getNext(), gen, kill, conditional);
            } else {
                for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
                    computeGenKill(c, gen, kill, conditional);
                }
            }
            return;
    }
}",0,0
121,Closure_59,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
           CheckLevel.OFF);
     }
 
     if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }","public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            LoggerErrorManager loggerErrorManager = new LoggerErrorManager(createMessageFormatter(), logger);
            setErrorManager(loggerErrorManager);
        } else {
            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (!options.checkTypes) {
        // If DiagnosticGroups did not override the plain checkTypes
        // option, and checkTypes is enabled, then turn off the
        // parser type warnings.
        options.setWarningLevel(
            DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR),
            CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(
            DiagnosticGroups.GLOBAL_THIS,
            options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
        options.setWarningLevel(
            DiagnosticGroups.ES5_STRICT,
            CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));
    WarningsGuard optionsGuard = options.getWarningsGuard();
    if (optionsGuard != null) {
        guards.add(optionsGuard);
    }

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
            DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
}",0,0
122,Closure_61,"static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }","static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
  
    if (callNode.getType() != Token.CALL) {
        throw new IllegalStateException(
            ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
        return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
        String name = nameNode.getString();
        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
            return false;
        }
    } else if (nameNode.getType() == Token.GETPROP) {
        if (nameNode.hasOneChild()
            && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                  nameNode.getLastChild().getString())) {
            return false;
        }
  
        if (callNode.isOnlyModifiesThisCall()
            && evaluatesToLocalValue(nameNode.getFirstChild())) {
            return false;
        }

        // Functions in the ""Math"" namespace have no side effects.
        if (nameNode.getFirstChild().getType() == Token.NAME
            && nameNode.getFirstChild().getString().equals(""Math"")) {
            return true;
        }

        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
            if (nameNode.getFirstChild().getType() == Token.REGEXP
                && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                return false;
            } else if (nameNode.getFirstChild().getType() == Token.STRING
                && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                Node param = callNode.getSecondChild();
                if (param != null &&
                    (param.getType() == Token.STRING
                        || param.getType() == Token.REGEXP)) {
                    return false;
                }
            }
        }
    }

    return true;
}",0,0
123,Closure_62,"private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null :
        excerpt.get(
            source, error.sourceName, error.lineNumber, excerptFormatter);

    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
      b.append(error.sourceName);
      if (error.lineNumber > 0) {
        b.append(':');
        b.append(error.lineNumber);
      }
      b.append("": "");
    }

    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");

    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
      b.append(sourceExcerpt);
      b.append('\n');
      int charno = error.getCharno();

      // padding equal to the excerpt and arrow at the end
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
           && 0 <= charno && charno < sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
            b.append(c);
          } else {
            b.append(' ');
          }
        }
        b.append(""^\n"");
      }
    }
    return b.toString();
  }","private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null :
        excerpt.get(
            source, error.sourceName, error.lineNumber, excerptFormatter);

    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
      b.append(error.sourceName);
      if (error.lineNumber > 0) {
        b.append(':');
        b.append(error.lineNumber);
      }
      b.append("": "");
    }

    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");

    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
      b.append(sourceExcerpt);
      b.append('\n');
      int charno = error.getCharno();

      // padding equal to the excerpt and arrow at the end
      // charno == sourceExcerpt.length() means something is missing
      // at the end of the line
      if (excerpt.equals(LINE)
          && 0 <= charno && charno <= sourceExcerpt.length()) {
        for (int i = 0; i < charno; i++) {
          char c = sourceExcerpt.charAt(i);
          if (Character.isWhitespace(c)) {
            b.append(c);
          } else {
            b.append(' ');
          }
        }
        b.append(""^\n"");
      }
    }
    return b.toString();
  }",0,0
124,Closure_65,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c < 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0': sb.append(""\\0""); break;
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";

                if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                                    END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                           START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null && !outputCharsetEncoder.canEncode(c)) {
                    appendHexJavaScriptRepresentation(sb, c);
                } else {
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,0
125,Closure_66,"public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }","public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
        // Object literal keys are handled with OBJECTLIT
        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
          ensureTyped(t, n, STRING_TYPE);
        } else {
          typeable = false; // Object literal keys are not typeable
        }
        break;

      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        typeable = false;
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT,
              leftType.toString(), rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
        visitBinaryOperator(n.getType(), t, n);
        typeable = false;
        break;

      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        typeable = false;
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        typeable = false;
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        typeable = false;
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }",0,0
126,Closure_67,"private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
           ) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;

        if (isChainedProperty) {
          Node child = n.getFirstChild().getFirstChild().getNext();

          if (child.getType() == Token.STRING &&
              child.getString().equals(""prototype"")) {
            return true;
          }
        }
      }

      return false;
    }","private boolean isPrototypePropertyAssign(Node assign) {
    if (assign == null) {
        return false;
    }

    Node n = assign.getFirstChild();
    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) 
        && n.getType() == Token.GETPROP) {

        // We want to exclude the assignment itself from the usage list
        boolean isChainedProperty = 
            n.getFirstChild() != null && n.getFirstChild().getType() == Token.GETPROP;

        if (isChainedProperty) {
            Node child = n.getFirstChild().getFirstChild();
            if (child != null) {
                child = child.getNext();
            }

            if (child != null && child.getType() == Token.STRING && 
                ""prototype"".equals(child.getString())) {
                return true;
            }
        }
    }

    return false;
}",0,0
127,Closure_69,"private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
      report(t, n, NOT_CALLABLE, childType.toString());
      ensureTyped(t, n);
      return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
      FunctionType functionType = (FunctionType) childType;

      boolean isExtern = false;
      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
      if(functionJSDocInfo != null) {
        String sourceName = functionJSDocInfo.getSourceName();
        CompilerInput functionSource = compiler.getInput(sourceName);
        isExtern = functionSource.isExtern();
      }

      // Non-native constructors should not be called directly
      // unless they specify a return type and are defined
      // in an extern.
      if (functionType.isConstructor() &&
          !functionType.isNativeObjectType() &&
          (functionType.getReturnType().isUnknownType() ||
           functionType.getReturnType().isVoidType() ||
           !isExtern)) {
        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
      }
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
    } else {
      ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
  }","private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;

        boolean isExtern = false;
        JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
        if(functionJSDocInfo != null) {
            String sourceName = functionJSDocInfo.getSourceName();
            CompilerInput functionSource = compiler.getInput(sourceName);
            isExtern = functionSource != null && functionSource.isExtern();
        }

        // Non-native constructors should not be called directly
        // unless they specify a return type and are defined
        // in an extern.
        if (functionType.isConstructor() &&
            !functionType.isNativeObjectType() &&
            (functionType.getReturnType().isUnknownType() ||
             functionType.getReturnType().isVoidType() ||
             !isExtern)) {
            report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
        }

        // Functions with explicit 'this' types must be called in a GETPROP
        // or GETELEM.

        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
}",0,0
128,Closure_7,"@Override
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }","@Override
public JSType caseObjectType(ObjectType type) {
    if (value.equals(""function"")) {
        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        if (ctorType != null && ctorType.isSubtype(type)) {
            return resultEqualsValue ? ctorType : null;
        }
        return null;
    }
    return matchesExpectation(""object"") ? type : null;
}",0,0
129,Closure_70,"private void declareArguments(Node functionNode) {
      Node astParameters = functionNode.getFirstChild().getNext();
      Node body = astParameters.getNext();
      FunctionType functionType = (FunctionType) functionNode.getJSType();
      if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
          Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                   jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
            }
          }
        }
      }
    } // end declareArguments","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Node jsDocParameter = jsDocParameters.getFirstChild();
            for (Node astParameter : astParameters.children()) {
                if (jsDocParameter != null) {
                    defineSlot(astParameter, functionNode,
                            jsDocParameter.getJSType(), true);
                    jsDocParameter = jsDocParameter.getNext();
                } else {
                    defineSlot(astParameter, functionNode, null, true);
                }
            }
        } else {
            for (Node astParameter : astParameters.children()) {
                defineSlot(astParameter, functionNode, null, true);
            }
        }
    } else {
        for (Node astParameter : astParameters.children()) {
            defineSlot(astParameter, functionNode, null, true);
        }
    }
} // end declareArguments",0,0
130,Closure_71,"private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
       boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
      // Find the lowest property defined on a class with visibility
      // information.
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      for (; objectType != null;
           objectType = objectType.getImplicitPrototype()) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
      }

      if (objectType == null) {
        // We couldn't find a visibility modifier; assume it's public.
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);
      if (isOverride) {
        // Check an ASSIGN statement that's trying to override a property
        // on a superclass.
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check that (a) the property *can* be overridden, and
        // (b) that the visibility of the override is the same as the
        // visibility of the original property.
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          // private access is always allowed in the same file.
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          // private access is not allowed outside the file from a different
          // enclosing class.
          compiler.report(
              t.makeError(getprop,
                  BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          // There are 3 types of legal accesses of a protected property:
          // 1) Accesses in the same file
          // 2) Overriding the property in a subclass
          // 3) Accessing the property from inside a subclass
          // The first two have already been checked for.
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
  }","private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

    if (objectType != null) {
        boolean isOverride = t.inGlobalScope() &&
            parent.getType() == Token.ASSIGN &&
            parent.getFirstChild() == getprop;

        // Initialize docInfo as null before the loop
        JSDocInfo docInfo = null;
        for (ObjectType currentObjectType = objectType; currentObjectType != null;
             currentObjectType = currentObjectType.getImplicitPrototype()) {
            docInfo = currentObjectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null &&
                docInfo.getVisibility() != Visibility.INHERITED) {
                objectType = currentObjectType;  // Update objectType correctly
                break;
            }
        }

        if (docInfo == null) {
            // We couldn't find a visibility modifier; assume it's public.
            return;
        }

        boolean sameInput =
            t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(objectType);
        if (isOverride) {
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ?
                Visibility.INHERITED : overridingInfo.getVisibility();

            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(
                    t.makeError(getprop, PRIVATE_OVERRIDE,
                        objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED &&
                overridingVisibility != visibility) {
                compiler.report(
                    t.makeError(getprop, VISIBILITY_MISMATCH,
                        visibility.name(), objectType.toString(),
                        overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                return;
            } else if (visibility == Visibility.PRIVATE &&
                (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() &&
                    isValidPrivateConstructorAccess(parent)) {
                    return;
                }
                compiler.report(
                    t.makeError(getprop,
                        BAD_PRIVATE_PROPERTY_ACCESS,
                        propertyName,
                        validator.getReadableJSTypeName(
                            getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED &&
                (currentClass == null || !currentClass.isSubtype(ownerType))) {
                compiler.report(
                    t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,
                        propertyName,
                        validator.getReadableJSTypeName(
                            getprop.getFirstChild(), true)));
            }
        }
    }
}",0,0
131,Closure_73,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      switch (c) {
        case '\0': sb.append(""\\0""); break;
        case '\n': sb.append(""\\n""); break;
        case '\r': sb.append(""\\r""); break;
        case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
             if (c > 0x1f && c <= 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                        String doublequoteEscape,
                        String singlequoteEscape,
                        String backslashEscape,
                        CharsetEncoder outputCharsetEncoder) {
    if (s == null) {
        throw new IllegalArgumentException(""Input string cannot be null"");
    }

    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0': sb.append(""\\0""); break;
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                if (i >= 2 &&
                        ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                        (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";

                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    if (c > 0x1f && c <= 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,0
132,Closure_77,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c <= 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case '>':
                // Break --> into --\> or ]]> into ]]\>
                if (i >= 2 &&
                        ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                        (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";

                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";

                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // If we're given an outputCharsetEncoder, then check if the
                //  character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // No charsetEncoder provided - pass straight latin characters
                    // through, and escape the rest.  Doing the explicit character
                    // check is measurably faster than using the CharsetEncoder.
                    if (c > 0x1f && c <= 0x7f) {
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,0
133,Closure_78,"private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
         break;
       case Token.MOD:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // TODO(johnlenz): consider removing the result length check.
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }","private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // Handle possible NaN with unknown value for BIT operations.
    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null || lValObj.isNaN()) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null || rValObj.isNaN()) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
        break;
      case Token.MOD:
        if (rval == 0) {
          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
          return null;
        }
        result = lval % rval;
        break;
      case Token.DIV:
        if (rval == 0) {
          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
          return null;
        }
        result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // Consider removing the result length check.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Fixed-point math accuracy check.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      return Node.newNumber(result);
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }",0,0
134,Closure_81,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.LP);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
      node.addChildToBack(lp);

      Node bodyNode = transform(functionNode.getBody());
      parseDirectives(bodyNode);
      node.addChildToBack(bodyNode);
     return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    boolean isUnnamedFunction = false;

    // Ensure function name is handled properly even if it's unnamed
    if (name == null) {
        name = new Name();
        name.setIdentifier("""");
        isUnnamedFunction = true;
    }

    // Create new function node
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);

    if (isUnnamedFunction) {
        // Set the line number and character number for unnamed function
        newName.setLineno(functionNode.getLineno());
        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
    }

    // Add function name node
    node.addChildToBack(newName);

    // Create left parenthesis node (`LP`)
    Node lp = newNode(Token.LP);
    
    // Set line number for the left parenthesis
    if (functionNode.getFunctionName() != null) {
        lp.setLineno(functionNode.getFunctionName().getLineno());
    } else {
        lp.setLineno(functionNode.getLineno()); // Default to function node if name is null
    }

    // Set character number for the left parenthesis
    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));

    // Transform and add function parameters to `LP` node
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);

    // Transform the body of the function and process directives
    Node bodyNode = transform(functionNode.getBody());
    if (bodyNode != null) {
        parseDirectives(bodyNode);
        node.addChildToBack(bodyNode);
    } else {
        // Handle case where the function body is missing or invalid
        node.addChildToBack(newNode(Token.EMPTY));
    }

    return node;
}",0,0
135,Closure_82,"  public boolean isNoObjectType() {
    return false;
  }
","public boolean isNoObjectType(Class<?> clazz) {
    return clazz == null;
}",0,0
136,Closure_83,"      public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
      }
","public BooleanOptionHandler(
        CmdLineParser parser, OptionDef option,
        Setter<? super Boolean> setter) {
    super(parser, option, setter);
    if (setter == null) {
        throw new IllegalArgumentException(""Setter cannot be null"");
    }
    if (parser == null) {
        throw new IllegalArgumentException(""CmdLineParser cannot be null"");
    }
    if (option == null) {
        throw new IllegalArgumentException(""OptionDef cannot be null"");
    }
}",0,0
137,Closure_86,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        // Literals objects with non-literal children are allowed.
        return true;
      case Token.IN:
        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
        return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
        case Token.ASSIGN:
            // Check if the last child is non-null to avoid potential null pointer issues
            Node lastChild = value.getLastChild();
            return lastChild != null && (NodeUtil.isImmutableValue(lastChild)
                || (locals.test(value) && evaluatesToLocalValue(lastChild, locals)));
        case Token.COMMA:
            // Ensure the last child is non-null
            Node commaLastChild = value.getLastChild();
            return commaLastChild != null && evaluatesToLocalValue(commaLastChild, locals);
        case Token.AND:
        case Token.OR:
            Node firstChild = value.getFirstChild();
            Node lastChildAndOr = value.getLastChild();
            return firstChild != null && lastChildAndOr != null
               && evaluatesToLocalValue(firstChild, locals)
               && evaluatesToLocalValue(lastChildAndOr, locals);
        case Token.HOOK:
            Node secondChild = value.getFirstChild() != null ? value.getFirstChild().getNext() : null;
            Node lastChildHook = value.getLastChild();
            return secondChild != null && lastChildHook != null
               && evaluatesToLocalValue(secondChild, locals)
               && evaluatesToLocalValue(lastChildHook, locals);
        case Token.INC:
        case Token.DEC:
            Node firstChildIncDec = value.getFirstChild();
            if (value.getBooleanProp(Node.INCRDECR_PROP)) {
                return firstChildIncDec != null && evaluatesToLocalValue(firstChildIncDec, locals);
            } else {
                return true;
            }
        case Token.THIS:
            return locals.test(value);
        case Token.NAME:
            return isImmutableValue(value) || locals.test(value);
        case Token.GETELEM:
        case Token.GETPROP:
            // No changes in this case since it's checking locality assumptions correctly
            return locals.test(value);
        case Token.CALL:
            return callHasLocalResult(value)
                || isToStringMethodCall(value)
                || locals.test(value);
        case Token.NEW:
            // No changes needed, as this comment specifies that improvements are TODO
            return true;
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return true;
        case Token.IN:
            return true;
        default:
            // Ensure the node is valid before processing
            if (isAssignmentOp(value)
                || isSimpleOperator(value)
                || isImmutableValue(value)) {
                return true;
            }

            throw new IllegalStateException(
                ""Unexpected expression node: "" + value +
                ""\n parent: "" + (value.getParent() != null ? value.getParent() : ""null""));
    }
}",0,0
138,Closure_87,"private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
 
           return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
    return false;
  }","private boolean isFoldableExpressBlock(Node n) {
    if (n != null && n.getType() == Token.BLOCK) {
        if (n.hasOneChild()) {
            Node maybeExpr = n.getFirstChild();
            // IE has a bug where event handlers behave differently when
            // their return value is used vs. when their return value is in
            // an EXPR_RESULT. It's pretty freaking weird. See:
            // http://code.google.com/p/closure-compiler/issues/detail?id=291
            // We try to detect this case, and not fold EXPR_RESULTs
            // into other expressions.

            // We only have to worry about methods with an implicit 'this'
            // param, or this doesn't happen.

            return maybeExpr != null && NodeUtil.isExpressionNode(maybeExpr);
        }
    }

    return false;
}",0,0
139,Closure_88,"private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
      }
    }

    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild();
        child != null; child = child.getNext()) {
      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
        VariableLiveness state = isVariableReadBeforeKill(child, variable);
        if (state != VariableLiveness.MAYBE_LIVE) {
          return state;
        }
      }
    }
    return VariableLiveness.MAYBE_LIVE;
  }","private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        if (NodeUtil.isLhs(n, n.getParent())) {
            // The expression to which the assignment is made is evaluated before
            // the RHS is evaluated (normal left to right evaluation) but the KILL
            // occurs after the RHS is evaluated.
            return VariableLiveness.KILL;
        } else {
            return VariableLiveness.READ;
        }
    }

    // Ensure all children are processed and handle null cases safely
    if (n != null) { // Guard against null nodes
        for (Node child = n.getFirstChild();
             child != null; child = child.getNext()) {
            if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
                VariableLiveness state = isVariableReadBeforeKill(child, variable);
                if (state != VariableLiveness.MAYBE_LIVE) {
                    return state;
                }
            }
        }
    }
    return VariableLiveness.MAYBE_LIVE;
}",0,0
140,Closure_91,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||

            // object literal keys
            pType == Token.STRING ||
            pType == Token.NUMBER)) {
        return false;
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.isInterface() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
            return false;
        }

        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() {}; // or
        // function a() {} // or
        // a.x = function() {}; // or
        // var a = {x: function() {}};
        int pType = parent != null ? parent.getType() : Token.INVALID;
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.NAME ||
              pType == Token.ASSIGN ||

              // object literal keys
              pType == Token.STRING ||
              pType == Token.NUMBER)) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            // Always traverse the left side of the assignment. To handle
            // nested assignments properly (e.g., (a = this).property = c;),
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // Only traverse the right side if it's not an assignment to a prototype
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP &&
                    ""prototype"".equals(lhs.getLastChild().getString())) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs != null &&
                    llhs.getType() == Token.GETPROP &&
                    ""prototype"".equals(llhs.getLastChild().getString())) {
                    return false;
                }
            }
        }
    }

    return true;
}",0,0
141,Closure_92,"void replace() {
      if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
      }

      // Handle the case where there is a duplicate definition for an explicitly
      // provided symbol.
      if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
          Node assignNode = candidateDefinition.getFirstChild();
          Node nameNode = assignNode.getFirstChild();
          if (nameNode.getType() == Token.NAME) {
            // Need to convert this assign to a var declaration.
            Node valueNode = nameNode.getNext();
            assignNode.removeChild(nameNode);
            assignNode.removeChild(valueNode);
            nameNode.addChildToFront(valueNode);
            Node varNode = new Node(Token.VAR, nameNode);
            varNode.copyInformationFrom(candidateDefinition);
            candidateDefinition.getParent().replaceChild(
                candidateDefinition, varNode);
            nameNode.setJSDocInfo(assignNode.getJSDocInfo());
            compiler.reportCodeChange();
            replacementNode = varNode;
          }
        }
      } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
          firstNode.getParent().addChildBefore(replacementNode, firstNode);
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
           int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
                .addChildToBack(replacementNode);
          } else {
            // Add it after the parent namespace.
            ProvidedName parentName =
                providedNames.get(namespace.substring(0, indexOfDot));
            Preconditions.checkNotNull(parentName);
            Preconditions.checkNotNull(parentName.replacementNode);
            parentName.replacementNode.getParent().addChildAfter(
                replacementNode, parentName.replacementNode);
          }
        }
        if (explicitNode != null) {
          explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
      }
    }","void replace() {
    if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
    }

    // Handle the case where there is a duplicate definition for an explicitly
    // provided symbol.
    if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
            Node assignNode = candidateDefinition.getFirstChild();
            if (assignNode != null) {
                Node nameNode = assignNode.getFirstChild();
                if (nameNode != null && nameNode.getType() == Token.NAME) {
                    // Need to convert this assign to a var declaration.
                    Node valueNode = nameNode.getNext();
                    if (valueNode != null) {
                        assignNode.removeChild(nameNode);
                        assignNode.removeChild(valueNode);
                        nameNode.addChildToFront(valueNode);
                        Node varNode = new Node(Token.VAR, nameNode);
                        varNode.copyInformationFrom(candidateDefinition);
                        candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);
                        nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                        compiler.reportCodeChange();
                        replacementNode = varNode;
                    }
                }
            }
        }
    } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
            firstNode.getParent().addChildBefore(replacementNode, firstNode);
        } else {
            // In this case, the name was implicitly provided by two independent
            // modules. We need to move this code up to a common module.
            int indexOfDot = namespace.indexOf('.');
            if (indexOfDot == -1) {
                // Any old place is fine.
                Node insertionPoint = compiler.getNodeForCodeInsertion(minimumModule);
                if (insertionPoint != null) {
                    insertionPoint.addChildToBack(replacementNode);
                }
            } else {
                // Add it after the parent namespace.
                ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));
                Preconditions.checkNotNull(parentName);
                Preconditions.checkNotNull(parentName.replacementNode);
                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);
            }
        }
        if (explicitNode != null) {
            explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
    }
}",0,0
142,Closure_94,"static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }","static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
        case Token.STRING:
        case Token.NUMBER:
        case Token.TRUE:
        case Token.FALSE:
            return true;

        // Binary operators are only valid if both children are valid.
        case Token.BITAND:
        case Token.BITOR:
        case Token.BITXOR:
            return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines);

        // Unary operators are valid if the child is valid.
        case Token.BITNOT:
        case Token.NOT:
        case Token.NEG:
            return isValidDefineValue(val.getFirstChild(), defines);

        // Names are valid if and only if they are defines themselves.
        case Token.NAME:
        case Token.GETPROP:
            if (val.isQualifiedName()) {
                return defines.contains(val.getQualifiedName());
            }
            break;
    }
    return false;
}",0,0
143,Closure_95,"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
      Preconditions.checkArgument(inferred || type != null);

      // Only allow declarations of NAMEs and qualfied names.
      boolean shouldDeclareOnGlobalThis = false;
      if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
      } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
      }
      String variableName = n.getQualifiedName();
      Preconditions.checkArgument(!variableName.isEmpty());

      // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
      } else {
        if (!inferred) {
          setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
          ObjectType globalThis =
              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
          boolean isExtern = input.isExtern();
          if (inferred) {
            globalThis.defineInferredProperty(variableName,
                type == null ?
                    getNativeType(JSTypeNative.NO_TYPE) :
                    type,
                isExtern);
          } else {
            globalThis.defineDeclaredProperty(variableName, type, isExtern);
          }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
          FunctionType fnType = (FunctionType) type;
          if (fnType.isConstructor() || fnType.isInterface()) {
            FunctionType superClassCtor = fnType.getSuperClassConstructor();
            scopeToDeclareIn.declare(variableName + "".prototype"", n,
                fnType.getPrototype(), compiler.getInput(sourceName),
                /* declared iff there's an explicit supertype */
                superClassCtor == null ||
                superClassCtor.getInstanceType().equals(
                    getNativeType(OBJECT_TYPE)));
          }
        }
      }
    }","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);

    // Only allow declarations of NAMEs and qualified names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
    }

    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());

    // If n is a property, then we should really declare it in the
    // scope where the root object appears. This helps out people
    // who declare ""global"" names in an anonymous namespace.
    Scope scopeToDeclareIn = scope;

    // Don't try to declare in the global scope if there's
    // already a symbol there with this name.
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis =
                typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName,
                    type == null ?
                        getNativeType(JSTypeNative.NO_TYPE) :
                        type,
                    isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(
                    variableName + "".prototype"", n, fnType.getPrototype(),
                    compiler.getInput(sourceName),
                    /* declared iff there's an explicit supertype */
                    superClassCtor == null ||
                    superClassCtor.getInstanceType().equals(
                        getNativeType(JSTypeNative.OBJECT_TYPE)));
            }
        }
    }
}",0,0
144,Closure_96,"private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
            parameters.hasNext()) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
         parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
      validator.expectArgumentMatchesParameter(t, argument,
          getJSType(argument), getJSType(parameter), call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
      report(t, call, WRONG_ARGUMENT_COUNT,
              validator.getReadableJSTypeName(call.getFirstChild(), false),
              String.valueOf(numArgs), String.valueOf(minArgs),
              maxArgs != Integer.MAX_VALUE ?
              "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
  }","private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;

    while (arguments.hasNext() || parameters.hasNext()) {
        Node parameter = parameters.hasNext() ? parameters.next() : null;
        Node argument = arguments.hasNext() ? arguments.next() : null;
        ordinal++;

        if (parameter != null && argument != null) {
            validator.expectArgumentMatchesParameter(t, argument,
                getJSType(argument), getJSType(parameter), call, ordinal);
        } else if (argument != null && parameter == null && functionType.isVarArgs()) {
            // Handle var_args case where arguments exceed parameters
            validator.expectArgumentMatchesVarArgs(t, argument, getJSType(argument), call, ordinal);
        }
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT,
                validator.getReadableJSTypeName(call.getFirstChild(), false),
                String.valueOf(numArgs), String.valueOf(minArgs),
                maxArgs != Integer.MAX_VALUE ?
                "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}",0,0
145,Closure_97,"private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

      double result;
      double lval = left.getDouble();
      double rval = right.getDouble();

      // check ranges.  We do not do anything that would clip the double to
      // a 32-bit range, since the user likely does not intend that.
      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
      }

      // only the lower 5 bits are used when shifting, so don't do anything
      // if the shift amount is outside [0,32)
      if (!(rval >= 0 && rval < 32)) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
      }

      // Convert the numbers to ints
      int lvalInt = (int) lval;
      if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
      }

      int rvalInt = (int) rval;
      if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
      }

      switch (n.getType()) {
        case Token.LSH:
          result = lvalInt << rvalInt;
          break;
        case Token.RSH:
          result = lvalInt >> rvalInt;
          break;
        case Token.URSH:
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
              Node.tokenToName(n.getType()));
      }

      Node newNumber = Node.newNumber(result);
      n.getParent().replaceChild(n, newNumber);
      reportCodeChange();

      return newNumber;
    }

    return n;
  }","private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();

        // Check ranges. We do not do anything that would clip the double to
        // a 32-bit range, since the user likely does not intend that.
        if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
            error(BITWISE_OPERAND_OUT_OF_RANGE, left);
            return n;
        }

        // Only the lower 5 bits are used when shifting, so don't do anything
        // if the shift amount is outside [0, 31] since 32 is excluded.
        if (!(rval >= 0 && rval <= 31)) {
            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return n;
        }

        // Convert the numbers to ints, ensuring there is no fractional part.
        int lvalInt = (int) lval;
        if ((double) lvalInt != lval) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }

        int rvalInt = (int) rval;
        if ((double) rvalInt != rval) {
            error(FRACTIONAL_BITWISE_OPERAND, right);
            return n;
        }

        switch (n.getType()) {
            case Token.LSH:
                result = (long) lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                // JavaScript handles zero shifts on signed numbers differently than
                // Java as a Java int cannot represent the unsigned 32-bit number
                // where JavaScript can, so use a long here.
                result = lvalInt >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" +
                    Node.tokenToName(n.getType()));
        }

        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();

        return newNumber;
    }

    return n;
}",0,0
146,Closure_99,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
            return false;
          }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
            return false;
        }

        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {};
        int pType = (parent != null) ? parent.getType() : Token.ERROR;
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.NAME ||
              pType == Token.ASSIGN)) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            // Always traverse the left side of the assignment. To handle
            // nested assignments properly (e.g., (a = this).property = c;),
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // Only traverse the right side if it's not an assignment to a prototype
            // property or subproperty.
            if (lhs != null && lhs.getType() == Token.GETPROP &&
                lhs.getLastChild() != null &&
                ""prototype"".equals(lhs.getLastChild().getString())) {
                return false;
            }
            if (lhs != null && lhs.getQualifiedName() != null &&
                lhs.getQualifiedName().contains("".prototype."")) {
                return false;
            }
        }
    }

    return true;
}",0,0
147,Codec_10,"public String caverphone(String txt) {
        // NOTE: Version 1.0 of Caverphone is easily derivable from this code 
        // by commenting out the 2.0 lines and adding in the 1.0 lines

        if( txt == null || txt.length() == 0 ) {
            return ""1111111111"";
        }

        // 1. Convert to lowercase
        txt = txt.toLowerCase(java.util.Locale.ENGLISH);

        // 2. Remove anything not A-Z
        txt = txt.replaceAll(""[^a-z]"", """");

        // 2.5. Remove final e
        txt = txt.replaceAll(""e$"", """");             // 2.0 only

        // 3. Handle various start options
        txt = txt.replaceAll(""^cough"", ""cou2f"");
        txt = txt.replaceAll(""^rough"", ""rou2f"");
        txt = txt.replaceAll(""^tough"", ""tou2f"");
        txt = txt.replaceAll(""^enough"", ""enou2f"");  // 2.0 only
        txt = txt.replaceAll(""^trough"", ""trou2f"");  // 2.0 only - note the spec says ^enough here again, c+p error I assume
         txt = txt.replaceAll(""^gn"", ""2n"");
 
         // End 
         txt = txt.replaceAll(""^mb"", ""m2"");
 
         // 4. Handle replacements
         txt = txt.replaceAll(""cq"", ""2q"");
        txt = txt.replaceAll(""ci"", ""si"");
        txt = txt.replaceAll(""ce"", ""se"");
        txt = txt.replaceAll(""cy"", ""sy"");
        txt = txt.replaceAll(""tch"", ""2ch"");
        txt = txt.replaceAll(""c"", ""k"");
        txt = txt.replaceAll(""q"", ""k"");
        txt = txt.replaceAll(""x"", ""k"");
        txt = txt.replaceAll(""v"", ""f"");
        txt = txt.replaceAll(""dg"", ""2g"");
        txt = txt.replaceAll(""tio"", ""sio"");
        txt = txt.replaceAll(""tia"", ""sia"");
        txt = txt.replaceAll(""d"", ""t"");
        txt = txt.replaceAll(""ph"", ""fh"");
        txt = txt.replaceAll(""b"", ""p"");
        txt = txt.replaceAll(""sh"", ""s2"");
        txt = txt.replaceAll(""z"", ""s"");
        txt = txt.replaceAll(""^[aeiou]"", ""A"");
        txt = txt.replaceAll(""[aeiou]"", ""3"");
        txt = txt.replaceAll(""j"", ""y"");        // 2.0 only
        txt = txt.replaceAll(""^y3"", ""Y3"");     // 2.0 only
        txt = txt.replaceAll(""^y"", ""A"");       // 2.0 only
        txt = txt.replaceAll(""y"", ""3"");        // 2.0 only
        txt = txt.replaceAll(""3gh3"", ""3kh3"");
        txt = txt.replaceAll(""gh"", ""22"");
        txt = txt.replaceAll(""g"", ""k"");
        txt = txt.replaceAll(""s+"", ""S"");
        txt = txt.replaceAll(""t+"", ""T"");
        txt = txt.replaceAll(""p+"", ""P"");
        txt = txt.replaceAll(""k+"", ""K"");
        txt = txt.replaceAll(""f+"", ""F"");
        txt = txt.replaceAll(""m+"", ""M"");
        txt = txt.replaceAll(""n+"", ""N"");
        txt = txt.replaceAll(""w3"", ""W3"");
        //txt = txt.replaceAll(""wy"", ""Wy"");    // 1.0 only
        txt = txt.replaceAll(""wh3"", ""Wh3"");
        txt = txt.replaceAll(""w$"", ""3"");       // 2.0 only
        //txt = txt.replaceAll(""why"", ""Why"");  // 1.0 only
        txt = txt.replaceAll(""w"", ""2"");
        txt = txt.replaceAll(""^h"", ""A"");
        txt = txt.replaceAll(""h"", ""2"");
        txt = txt.replaceAll(""r3"", ""R3"");
        txt = txt.replaceAll(""r$"", ""3"");       // 2.0 only
        //txt = txt.replaceAll(""ry"", ""Ry"");    // 1.0 only
        txt = txt.replaceAll(""r"", ""2"");
        txt = txt.replaceAll(""l3"", ""L3"");
        txt = txt.replaceAll(""l$"", ""3"");       // 2.0 only
        //txt = txt.replaceAll(""ly"", ""Ly"");    // 1.0 only
        txt = txt.replaceAll(""l"", ""2"");
        //txt = txt.replaceAll(""j"", ""y"");      // 1.0 only
        //txt = txt.replaceAll(""y3"", ""Y3"");    // 1.0 only
        //txt = txt.replaceAll(""y"", ""2"");      // 1.0 only

        // 5. Handle removals
        txt = txt.replaceAll(""2"", """");
        txt = txt.replaceAll(""3$"", ""A"");       // 2.0 only
        txt = txt.replaceAll(""3"", """");

        // 6. put ten 1s on the end
        txt = txt + ""111111"" + ""1111"";        // 1.0 only has 6 1s

        // 7. take the first six characters as the code
        return txt.substring(0, 10);          // 1.0 truncates to 6
    }","public String caverphone(String txt) {
    // NOTE: Version 1.0 of Caverphone is easily derivable from this code
    // by commenting out the 2.0 lines and adding in the 1.0 lines

    if (txt == null || txt.isEmpty()) {
        return ""1111111111"";
    }

    // 1. Convert to lowercase
    txt = txt.toLowerCase(java.util.Locale.ENGLISH);

    // 2. Remove anything not A-Z
    txt = txt.replaceAll(""[^a-z]"", """");

    // 2.5. Remove final e
    txt = txt.replaceAll(""e$"", """"); // 2.0 only

    // 3. Handle various start options
    txt = txt.replaceAll(""^cough"", ""cou2f"");
    txt = txt.replaceAll(""^rough"", ""rou2f"");
    txt = txt.replaceAll(""^tough"", ""tou2f"");
    txt = txt.replaceAll(""^enough"", ""enou2f""); // 2.0 only
    txt = txt.replaceAll(""^trough"", ""trou2f""); // 2.0 only - note the spec says ^enough here again, c+p error I assume
    txt = txt.replaceAll(""^gn"", ""2n"");

    // Handle ""mb"" at the end
    txt = txt.replaceAll(""mb$"", ""m2"");

    // 4. Handle replacements
    txt = txt.replaceAll(""cq"", ""2q"");
    txt = txt.replaceAll(""ci"", ""si"");
    txt = txt.replaceAll(""ce"", ""se"");
    txt = txt.replaceAll(""cy"", ""sy"");
    txt = txt.replaceAll(""tch"", ""2ch"");
    txt = txt.replaceAll(""c"", ""k"");
    txt = txt.replaceAll(""q"", ""k"");
    txt = txt.replaceAll(""x"", ""k"");
    txt = txt.replaceAll(""v"", ""f"");
    txt = txt.replaceAll(""dg"", ""2g"");
    txt = txt.replaceAll(""tio"", ""sio"");
    txt = txt.replaceAll(""tia"", ""sia"");
    txt = txt.replaceAll(""d"", ""t"");
    txt = txt.replaceAll(""ph"", ""fh"");
    txt = txt.replaceAll(""b"", ""p"");
    txt = txt.replaceAll(""sh"", ""s2"");
    txt = txt.replaceAll(""z"", ""s"");
    txt = txt.replaceAll(""^[aeiou]"", ""A"");
    txt = txt.replaceAll(""[aeiou]"", ""3"");
    txt = txt.replaceAll(""j"", ""y""); // 2.0 only
    txt = txt.replaceAll(""^y3"", ""Y3""); // 2.0 only
    txt = txt.replaceAll(""^y"", ""A""); // 2.0 only
    txt = txt.replaceAll(""y"", ""3""); // 2.0 only
    txt = txt.replaceAll(""3gh3"", ""3kh3"");
    txt = txt.replaceAll(""gh"", ""22"");
    txt = txt.replaceAll(""g"", ""k"");
    txt = txt.replaceAll(""s+"", ""S"");
    txt = txt.replaceAll(""t+"", ""T"");
    txt = txt.replaceAll(""p+"", ""P"");
    txt = txt.replaceAll(""k+"", ""K"");
    txt = txt.replaceAll(""f+"", ""F"");
    txt = txt.replaceAll(""m+"", ""M"");
    txt = txt.replaceAll(""n+"", ""N"");
    txt = txt.replaceAll(""w3"", ""W3"");
    txt = txt.replaceAll(""wh3"", ""Wh3"");
    txt = txt.replaceAll(""w$"", ""3""); // 2.0 only
    txt = txt.replaceAll(""w"", ""2"");
    txt = txt.replaceAll(""^h"", ""A"");
    txt = txt.replaceAll(""h"", ""2"");
    txt = txt.replaceAll(""r3"", ""R3"");
    txt = txt.replaceAll(""r$"", ""3""); // 2.0 only
    txt = txt.replaceAll(""r"", ""2"");
    txt = txt.replaceAll(""l3"", ""L3"");
    txt = txt.replaceAll(""l$"", ""3""); // 2.0 only
    txt = txt.replaceAll(""l"", ""2"");

    // 5. Handle removals
    txt = txt.replaceAll(""2"", """");
    txt = txt.replaceAll(""3$"", ""A""); // 2.0 only
    txt = txt.replaceAll(""3"", """");

    // 6. Append ten '1's to the end
    txt = txt + ""1111111111"";

    // 7. Return the first ten characters as the code
    return txt.substring(0, 10);
}",0,0
148,Codec_15,"private char getMappingCode(final String str, final int index) {
        // map() throws IllegalArgumentException
         final char mappedChar = this.map(str.charAt(index));
         // HW rule check
         if (index > 1 && mappedChar != '0') {
             final char hwChar = str.charAt(index - 1);
             if ('H' == hwChar || 'W' == hwChar) {
                 final char preHWChar = str.charAt(index - 2);
                 final char firstCode = this.map(preHWChar);
                 if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {
                     return 0;
                 }
             }
         }
         return mappedChar;
    }","private char getMappingCode(final String str, final int index) {
    try {
        // Ensure index is within bounds
        if (index < 0 || index >= str.length()) {
            throw new IndexOutOfBoundsException(""Index is out of bounds for the given string."");
        }

        // map() throws IllegalArgumentException
        final char mappedChar = this.map(str.charAt(index));

        // Check the HW rule
        if (index > 1 && mappedChar != '0') {
            final char hwChar = str.charAt(index - 1);
            if ('H' == hwChar || 'W' == hwChar) {
                final char preHWChar = str.charAt(index - 2);
                final char firstCode = this.map(preHWChar);

                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {
                    return '0'; // Return '0' instead of numeric 0 to ensure it's a valid char
                }
            }
        }

        return mappedChar;

    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(""Failed to map character due to invalid input."", e);
    }
}",0,0
149,Codec_17,"    public static String newStringIso8859_1(final byte[] bytes) {
        return new String(bytes, Charsets.ISO_8859_1);
    }
","public static String newStringIso8859_1(final byte[] bytes) {
    if (bytes == null) {
        throw new IllegalArgumentException(""Input byte array cannot be null"");
    }
    return new String(bytes, java.nio.charset.StandardCharsets.ISO_8859_1);
}",0,0
150,Codec_18,"public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
        if (cs1 == cs2) {
            return true;
        }
        if (cs1 == null || cs2 == null) {
            return false;
        }
         if (cs1 instanceof String && cs2 instanceof String) {
             return cs1.equals(cs2);
         }
         return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
     }","public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    if (cs1.length() != cs2.length()) {
        return false; // Ensure lengths are the same before comparison
    }
    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());
}",0,0
151,Codec_2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buf == null || buf.length - pos < encodeSize) {
                resizeBuf();
            }
            switch (modulus) {
                case 1:
                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buf[pos++] = PAD;
                        buf[pos++] = PAD;
                    }
                    break;

                case 2:
                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buf[pos++] = PAD;
                     }
                     break;
             }
             if (lineLength > 0) {
                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                 pos += lineSeparator.length;
             }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buf == null || buf.length - pos < encodeSize) {
                    resizeBuf();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) { b += 256; }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buf[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }","void encode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    // `inAvail < 0` indicates EOF in the underlying data being encoded.
    if (inAvail < 0) {
        eof = true;
        if (buf == null || buf.length - pos < encodeSize) {
            resizeBuf();
        }
        switch (modulus) {
            case 1:
                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                // Add padding for STANDARD_ENCODE_TABLE but skip for URL-SAFE table
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buf[pos++] = PAD;
                    buf[pos++] = PAD;
                }
                break;

            case 2:
                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                // Add padding for STANDARD_ENCODE_TABLE but skip for URL-SAFE table
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buf[pos++] = PAD;
                }
                break;

            default:
                // No operation needed for modulus = 0 (already handled in the loop)
                break;
        }
        if (lineLength > 0) {
            // Append line separator if line length is specified
            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
            pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            if (buf == null || buf.length - pos < encodeSize) {
                resizeBuf();
            }
            modulus = (++modulus) % 3;
            int b = in[inPos++];
            if (b < 0) {
                b += 256; // Handle unsigned byte conversion
            }
            x = (x << 8) + b;
            if (modulus == 0) {
                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                buf[pos++] = encodeTable[x & MASK_6BITS];
                currentLinePos += 4;
                if (lineLength > 0 && currentLinePos >= lineLength) {
                    // Append line separator when maximum line length is reached
                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                    pos += lineSeparator.length;
                    currentLinePos = 0;
                }
            }
        }
    }
}",0,0
152,Codec_3,"private int handleG(String value, 
                        DoubleMetaphoneResult result, 
                        int index, 
                        boolean slavoGermanic) {
        if (charAt(value, index + 1) == 'H') {
            index = handleGH(value, result, index);
        } else if (charAt(value, index + 1) == 'N') {
            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {
                result.append(""KN"", ""N"");
            } else if (!contains(value, index + 2, 2, ""EY"") && 
                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {
                result.append(""N"", ""KN"");
            } else {
                result.append(""KN"");
            }
            index = index + 2;
        } else if (contains(value, index + 1, 2, ""LI"") && !slavoGermanic) {
            result.append(""KL"", ""L"");
            index += 2;
        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {
            //-- -ges-, -gep-, -gel-, -gie- at beginning --//
            result.append('K', 'J');
            index += 2;
        } else if ((contains(value, index + 1, 2, ""ER"") || 
                    charAt(value, index + 1) == 'Y') &&
                   !contains(value, 0, 6, ""DANGER"", ""RANGER"", ""MANGER"") &&
                   !contains(value, index - 1, 1, ""E"", ""I"") && 
                   !contains(value, index - 1, 3, ""RGY"", ""OGY"")) {
            //-- -ger-, -gy- --//
            result.append('K', 'J');
            index += 2;
        } else if (contains(value, index + 1, 1, ""E"", ""I"", ""Y"") || 
                   contains(value, index - 1, 4, ""AGGI"", ""OGGI"")) {
            //-- Italian ""biaggi"" --//
             if ((contains(value, 0 ,4, ""VAN "", ""VON "") || contains(value, 0, 3, ""SCH"")) || contains(value, index + 1, 2, ""ET"")) {
                 //-- obvious germanic --//
                 result.append('K');
             } else if (contains(value, index + 1, 4, ""IER"")) {
                 result.append('J');
             } else {
                 result.append('J', 'K');
            }
            index += 2;
        } else if (charAt(value, index + 1) == 'G') {
            index += 2;
            result.append('K');
        } else {
            index++;
            result.append('K');
        }
        return index;
    }","private int handleG(String value, 
                        DoubleMetaphoneResult result, 
                        int index, 
                        boolean slavoGermanic) {
        if (index < value.length() - 1 && charAt(value, index + 1) == 'H') {
            index = handleGH(value, result, index);
        } else if (index < value.length() - 1 && charAt(value, index + 1) == 'N') {
            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {
                result.append(""KN"", ""N"");
            } else if (!contains(value, index + 2, 2, ""EY"") && 
                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {
                result.append(""N"", ""KN"");
            } else {
                result.append(""KN"");
            }
            index += 2;
        } else if (index < value.length() - 2 && contains(value, index + 1, 2, ""LI"") && !slavoGermanic) {
            result.append(""KL"", ""L"");
            index += 2;
        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {
            //-- -ges-, -gep-, -gel-, -gie- at beginning --//
            result.append('K', 'J');
            index += 2;
        } else if ((contains(value, index + 1, 2, ""ER"") || 
                    charAt(value, index + 1) == 'Y') &&
                   !contains(value, 0, 6, ""DANGER"", ""RANGER"", ""MANGER"") &&
                   !contains(value, index - 1, 1, ""E"", ""I"") && 
                   !contains(value, index - 1, 3, ""RGY"", ""OGY"")) {
            //-- -ger-, -gy- --//
            result.append('K', 'J');
            index += 2;
        } else if (contains(value, index + 1, 1, ""E"", ""I"", ""Y"") || 
                   contains(value, index - 1, 4, ""AGGI"", ""OGGI"")) {
            //-- Italian ""biaggi"" --//
             if ((contains(value, 0, 4, ""VAN "", ""VON "") || contains(value, 0, 3, ""SCH"")) || contains(value, index + 1, 2, ""ET"")) {
                 //-- obvious germanic --//
                 result.append('K');
             } else if (contains(value, index + 1, 4, ""IER"")) {
                 result.append('J');
             } else {
                 result.append('J', 'K');
             }
            index += 2;
        } else if (index < value.length() - 1 && charAt(value, index + 1) == 'G') {
            index += 2;
            result.append('K');
        } else {
            index++;
            result.append('K');
        }
        return index;
    }",0,0
153,Codec_4,"    public Base64() {
        this(false);
    }
","public Base64() {
    // Ensure proper initialization with default parameters
    this.encode = false; // Assuming 'encode' is the property being set
}",0,0
154,Codec_5,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
         // EOF (-1) and first time '=' character is encountered in stream.
         // This approach makes the '=' padding characters completely optional.
         if (eof && modulus != 0) {
             
             x = x << 6;
             switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
    }","void decode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    if (inAvail < 0) {
        eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        if (buffer == null || buffer.length - pos < decodeSize) {
            resizeBuffer();
        }
        byte b = in[inPos++];
        if (b == PAD) {
            // We're done.
            eof = true;
            break;
        } else {
            if (b >= 0 && b < DECODE_TABLE.length) {
                int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }
    }

    // Two forms of EOF as far as base64 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (eof && modulus != 0) {

        switch (modulus) {
            case 2:
                x = x << 12; // Shift bits to the top 12 bits
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                break;
            case 3:
                x = x << 6; // Shift bits to the top 18 bits
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                break;
        }
    }
}",0,0
155,Codec_6,"public int read(byte b[], int offset, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (offset < 0 || len < 0) {
            throw new IndexOutOfBoundsException();
        } else if (offset > b.length || offset + len > b.length) {
            throw new IndexOutOfBoundsException();
         } else if (len == 0) {
             return 0;
         } else {
             /*
              Rationale for while-loop on (readLen == 0):
              -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
                if (!base64.hasData()) {
                    byte[] buf = new byte[doEncode ? 4096 : 8192];
                    int c = in.read(buf);
                    // A little optimization to avoid System.arraycopy()
                    // when possible.
                    if (c > 0 && b.length == len) {
                        base64.setInitialBuffer(b, offset, len);
                    }
                    if (doEncode) {
                        base64.encode(buf, 0, c);
                    } else {
                        base64.decode(buf, 0, c);
                    }
                }
            return base64.readResults(b, offset, len);
        }
    }","public int read(byte b[], int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException(""Input byte array is null."");
    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {
        // Consolidated IndexOutOfBoundsException checks into one condition for simplicity and correctness
        throw new IndexOutOfBoundsException(""Offset or length is invalid with respect to the byte array boundaries."");
    } else if (len == 0) {
        return 0;
    } else {
        while (!base64.hasData()) {
            byte[] buf = new byte[doEncode ? 4096 : 8192];
            int c = in.read(buf);

            if (c == -1) { // Properly handle EOF case
                return -1;
            } else if (c > 0) {
                // Avoid extra System.arraycopy() when b.length == len
                if (b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
        }

        return base64.readResults(b, offset, len);
    }
}",0,0
156,Codec_7,"    public static String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));
    }
","public static String encodeBase64String(byte[] binaryData) {
    if (binaryData == null) {
        throw new IllegalArgumentException(""Input binaryData cannot be null"");
    }
    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));
}",0,0
157,Codec_9,"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
             return binaryData;
         }
 
         long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
         if (len > maxResultSize) {
             throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                 len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }","public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }

    long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
            len +
            "") than the specified maximum size of "" +
            maxResultSize);
    }

    Base64 b64 = isChunked ? new Base64(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe) : new Base64(0, null, urlSafe);
    return b64.encode(binaryData);
}",0,0
158,Collections_26,"    private Object readResolve() {
        calculateHashCode(keys);
        return this;
    }
","private Object readResolve() {
    if (keys != null) {
        calculateHashCode(keys);
    }
    return this;
}",0,0
159,Compress_1,"    public void close() throws IOException {
        if (!this.closed) {
            super.close();
            this.closed = true;
        }
    }
","@Override
public void close() throws IOException {
    if (!this.closed) {
        try {
            super.close();
        } finally {
            this.closed = true;
        }
    }
}",0,0
160,Compress_10,"private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>
                                            entriesWithoutUTF8Flag)
        throws IOException {
        // changing the name of a ZipArchiveEntry is going to change
         // the hashcode - see COMPRESS-164
         // Map needs to be reconstructed in order to keep central
         // directory order
         for (ZipArchiveEntry ze : entries.keySet()) {
             OffsetEntry offsetEntry = entries.get(ze);
             long offset = offsetEntry.headerOffset;
             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);
             byte[] b = new byte[SHORT];
            archive.readFully(b);
            int fileNameLen = ZipShort.getValue(b);
            archive.readFully(b);
            int extraFieldLen = ZipShort.getValue(b);
            int lenToSkip = fileNameLen;
            while (lenToSkip > 0) {
                int skipped = archive.skipBytes(lenToSkip);
                if (skipped <= 0) {
                    throw new RuntimeException(""failed to skip file name in""
                                               + "" local file header"");
                }
                lenToSkip -= skipped;
            }
            byte[] localExtraData = new byte[extraFieldLen];
            archive.readFully(localExtraData);
            ze.setExtra(localExtraData);
            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH
                + SHORT + SHORT + fileNameLen + extraFieldLen;

            if (entriesWithoutUTF8Flag.containsKey(ze)) {
                String orig = ze.getName();
                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);
                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,
                                                         nc.comment);
                if (!orig.equals(ze.getName())) {
                    nameMap.remove(orig);
                    nameMap.put(ze.getName(), ze);
                }
            }
        }
    }","private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>
                                            entriesWithoutUTF8Flag)
        throws IOException {
        // changing the name of a ZipArchiveEntry is going to change
        // the hashcode - see COMPRESS-164
        // Map needs to be reconstructed in order to keep central
        // directory order
        for (ZipArchiveEntry ze : entries.keySet()) {
            OffsetEntry offsetEntry = entries.get(ze);
            long offset = offsetEntry.headerOffset;

            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);
            byte[] b = new byte[SHORT];
            archive.readFully(b);
            int fileNameLen = ZipShort.getValue(b);

            archive.readFully(b);
            int extraFieldLen = ZipShort.getValue(b);

            int lenToSkip = fileNameLen;
            while (lenToSkip > 0) {
                int skipped = archive.skipBytes(lenToSkip);
                if (skipped < 0) { // Check for negative return from skipBytes
                    throw new IOException(""failed to skip file name in""
                                          + "" local file header"");
                }
                lenToSkip -= skipped;
            }

            byte[] localExtraData = new byte[extraFieldLen];
            archive.readFully(localExtraData); // Ensure proper byte array size before reading
            ze.setExtra(localExtraData);
            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH
                + SHORT + SHORT + fileNameLen + extraFieldLen;

            if (entriesWithoutUTF8Flag.containsKey(ze)) {
                String orig = ze.getName();
                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);
                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,
                                                         nc.comment);
                if (!orig.equals(ze.getName())) {
                    nameMap.remove(orig);
                    nameMap.put(ze.getName(), ze);
                }
            }
        }
    }",0,0
161,Compress_11,"public ArchiveInputStream createArchiveInputStream(final InputStream in)
            throws ArchiveException {
        if (in == null) {
            throw new IllegalArgumentException(""Stream must not be null."");
        }

        if (!in.markSupported()) {
            throw new IllegalArgumentException(""Mark is not supported."");
        }

        final byte[] signature = new byte[12];
        in.mark(signature.length);
        try {
            int signatureLength = in.read(signature);
            in.reset();
            if (ZipArchiveInputStream.matches(signature, signatureLength)) {
                return new ZipArchiveInputStream(in);
            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
                return new JarArchiveInputStream(in);
            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
                return new ArArchiveInputStream(in);
            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
                return new CpioArchiveInputStream(in);
            }

            // Dump needs a bigger buffer to check the signature;
            final byte[] dumpsig = new byte[32];
            in.mark(dumpsig.length);
            signatureLength = in.read(dumpsig);
            in.reset();
            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
                return new DumpArchiveInputStream(in);
            }

            // Tar needs an even bigger buffer to check the signature; read the first block
            final byte[] tarheader = new byte[512];
            in.mark(tarheader.length);
            signatureLength = in.read(tarheader);
            in.reset();
            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
                return new TarArchiveInputStream(in);
            }
            // COMPRESS-117 - improve auto-recognition
            try {
                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                tais.getNextEntry();
                return new TarArchiveInputStream(in);
            } catch (Exception e) { // NOPMD
                // can generate IllegalArgumentException as well as IOException
                 // autodetection, simply not a TAR
                 // ignored
             }
         } catch (IOException e) {
             throw new ArchiveException(""Could not use reset and mark operations."", e);
         }

        throw new ArchiveException(""No Archiver found for the stream signature"");
    }","public ArchiveInputStream createArchiveInputStream(final InputStream in)
        throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }

    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }

    final byte[] signature = new byte[12];
    in.mark(signature.length);
    int signatureLength = -1;
    try {
        signatureLength = in.read(signature);
        in.reset();
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    if (signatureLength < 0) {
        throw new ArchiveException(""Unable to read signature bytes."");
    }

    if (ZipArchiveInputStream.matches(signature, signatureLength)) {
        return new ZipArchiveInputStream(in);
    } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
        return new JarArchiveInputStream(in);
    } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
        return new ArArchiveInputStream(in);
    } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
        return new CpioArchiveInputStream(in);
    }

    // Dump needs a bigger buffer to check the signature;
    final byte[] dumpsig = new byte[32];
    in.mark(dumpsig.length);
    try {
        signatureLength = in.read(dumpsig);
        in.reset();
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    if (signatureLength < 0) {
        throw new ArchiveException(""Unable to read dump signature bytes."");
    }
    if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
        return new DumpArchiveInputStream(in);
    }

    // Tar needs an even bigger buffer to check the signature; read the first block
    final byte[] tarheader = new byte[512];
    in.mark(tarheader.length);
    try {
        signatureLength = in.read(tarheader);
        in.reset();
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    if (signatureLength < 0) {
        throw new ArchiveException(""Unable to read tar header signature bytes."");
    }
    if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
        return new TarArchiveInputStream(in);
    }

    // COMPRESS-117 - improve auto-recognition
    try {
        TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
        tais.getNextEntry();
        return new TarArchiveInputStream(in);
    } catch (Exception e) {
        // autodetection, simply not a TAR - ignored
    }

    throw new ArchiveException(""No Archiver found for the stream signature"");
}",0,0
162,Compress_12,"public TarArchiveEntry getNextTarEntry() throws IOException {
        if (hasHitEOF) {
            return null;
        }

        if (currEntry != null) {
            long numToSkip = entrySize - entryOffset;

            while (numToSkip > 0) {
                long skipped = skip(numToSkip);
                if (skipped <= 0) {
                    throw new RuntimeException(""failed to skip current tar entry"");
                }
                numToSkip -= skipped;
            }

            readBuf = null;
        }

        byte[] headerBuf = getRecord();

        if (hasHitEOF) {
            currEntry = null;
             return null;
         }
 
         currEntry = new TarArchiveEntry(headerBuf);
         entryOffset = 0;
         entrySize = currEntry.getSize();
 
        if (currEntry.isGNULongNameEntry()) {
            // read in the name
            StringBuffer longName = new StringBuffer();
            byte[] buf = new byte[SMALL_BUFFER_SIZE];
            int length = 0;
            while ((length = read(buf)) >= 0) {
                longName.append(new String(buf, 0, length));
            }
            getNextEntry();
            if (currEntry == null) {
                // Bugzilla: 40334
                // Malformed tar file - long entry name not followed by entry
                return null;
            }
            // remove trailing null terminator
            if (longName.length() > 0
                && longName.charAt(longName.length() - 1) == 0) {
                longName.deleteCharAt(longName.length() - 1);
            }
            currEntry.setName(longName.toString());
        }

        if (currEntry.isPaxHeader()){ // Process Pax headers
            paxHeaders();
        }

        if (currEntry.isGNUSparse()){ // Process sparse files
            readGNUSparse();
        }

        // If the size of the next element in the archive has changed
        // due to a new size being reported in the posix header
        // information, we update entrySize here so that it contains
        // the correct value.
        entrySize = currEntry.getSize();
        return currEntry;
    }","public TarArchiveEntry getNextTarEntry() throws IOException {
    if (hasHitEOF) {
        return null;
    }

    if (currEntry != null) {
        long numToSkip = entrySize - entryOffset;

        while (numToSkip > 0) {
            long skipped = skip(numToSkip);
            if (skipped < 0) { // Fixed condition for skip failure
                throw new IOException(""Failed to skip current tar entry""); // Changed exception to IOException for consistency
            }
            numToSkip -= skipped;
        }

        readBuf = null;
    }

    byte[] headerBuf = getRecord();

    if (hasHitEOF) {
        currEntry = null;
        return null;
    }

    currEntry = new TarArchiveEntry(headerBuf);
    entryOffset = 0;
    entrySize = currEntry.getSize();

    if (currEntry.isGNULongNameEntry()) {
        // read in the name
        StringBuilder longName = new StringBuilder(); // Changed from StringBuffer to StringBuilder for better performance
        byte[] buf = new byte[SMALL_BUFFER_SIZE];
        int length;
        while ((length = read(buf)) > 0) { // Fixed loop condition to stop on end of stream
            longName.append(new String(buf, 0, length));
        }
        getNextTarEntry(); // Fixed method call to correct recursive method name
        if (currEntry == null) {
            // Bugzilla: 40334
            // Malformed tar file - long entry name not followed by entry
            return null;
        }
        // remove trailing null terminator
        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == '\0') { // Fixed null character check
            longName.deleteCharAt(longName.length() - 1);
        }
        currEntry.setName(longName.toString());
    }

    if (currEntry.isPaxHeader()) { // Process Pax headers
        paxHeaders();
    }

    if (currEntry.isGNUSparse()) { // Process sparse files
        readGNUSparse();
    }

    // Update entrySize after potential changes due to metadata corrections
    entrySize = currEntry.getSize();
    return currEntry;
}",0,0
163,Compress_13,"    protected void setName(String name) {
        this.name = name;
    }
","protected void setName(String name) {
    if (name == null || name.trim().isEmpty()) {
        throw new IllegalArgumentException(""Name cannot be null or empty"");
    }
    this.name = name;
}",0,0
164,Compress_14,"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        int     end = offset + length;
        int     start = offset;

        if (length < 2){
             throw new IllegalArgumentException(""Length ""+length+"" must be at least 2"");
         }
 
         boolean allNUL = true;
         for (int i = start; i < end; i++){
             if (buffer[i] != 0){
                 allNUL = false;
                 break;
             }
         }
         if (allNUL) {
             return 0L;
         }
 
        // Skip leading spaces
        while (start < end){
            if (buffer[start] == ' '){
                start++;
            } else {
                break;
            }
        }

        // Must have trailing NUL or space
        byte trailer;
        trailer = buffer[end-1];
        if (trailer == 0 || trailer == ' '){
            end--;
        } else {
            throw new IllegalArgumentException(
                    exceptionMessage(buffer, offset, length, end-1, trailer));
        }
        // May have additional NUL or space
        trailer = buffer[end-1];
        if (trailer == 0 || trailer == ' '){
            end--;
        }

        for ( ;start < end; start++) {
            final byte currentByte = buffer[start];
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long result = 0;
        int end = offset + length;
        int start = offset;

        if (length < 2) {
            throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
        }

        // Check for all NUL bytes
        boolean allNUL = true;
        for (int i = start; i < end; i++) {
            if (buffer[i] != 0) {
                allNUL = false;
                break;
            }
        }
        if (allNUL) {
            return 0L;
        }

        // Skip leading spaces
        while (start < end) {
            if (buffer[start] == ' ') {
                start++;
            } else {
                break;
            }
        }

        if (start == end) {
            throw new IllegalArgumentException(""Buffer contains only spaces."");
        }

        // Check for trailing valid NUL or space
        byte trailer = buffer[end - 1];
        if (trailer == 0 || trailer == ' ') {
            end--;
        } else {
            throw new IllegalArgumentException(
                    exceptionMessage(buffer, offset, length, end - 1, trailer));
        }

        // Check for additional trailing NUL or space
        if (end > start) { // Ensure there's still room for parsing
            trailer = buffer[end - 1];
            if (trailer == 0 || trailer == ' ') {
                end--;
            }
        }

        // Parse the octal content
        for (; start < end; start++) {
            final byte currentByte = buffer[start];
            // Validate the byte is in octal range
            if (currentByte < '0' || currentByte > '7') {
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // Convert from ASCII
        }

        if (start == offset) {
            throw new IllegalArgumentException(""No valid octal digits found."");
        }

        return result;
    }",0,0
165,Compress_15,"@Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        ZipArchiveEntry other = (ZipArchiveEntry) obj;
        String myName = getName();
        String otherName = other.getName();
        if (myName == null) {
            if (otherName != null) {
                return false;
            }
        } else if (!myName.equals(otherName)) {
            return false;
        }
         String myComment = getComment();
         String otherComment = other.getComment();
         if (myComment == null) {
             if (otherComment != null) {
                 return false;
             }
         } else if (!myComment.equals(otherComment)) {
             return false;
         }
         return getTime() == other.getTime()
             && getInternalAttributes() == other.getInternalAttributes()
             && getPlatform() == other.getPlatform()
             && getExternalAttributes() == other.getExternalAttributes()
            && getMethod() == other.getMethod()
            && getSize() == other.getSize()
            && getCrc() == other.getCrc()
            && getCompressedSize() == other.getCompressedSize()
            && Arrays.equals(getCentralDirectoryExtra(),
                             other.getCentralDirectoryExtra())
            && Arrays.equals(getLocalFileDataExtra(),
                             other.getLocalFileDataExtra())
            && gpb.equals(other.gpb);
    }","@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ZipArchiveEntry other = (ZipArchiveEntry) obj;
    String myName = getName();
    String otherName = other.getName();
    if (!Objects.equals(myName, otherName)) {
        return false;
    }
    String myComment = getComment();
    String otherComment = other.getComment();
    if (!Objects.equals(myComment, otherComment)) {
        return false;
    }
    return getTime() == other.getTime()
        && getInternalAttributes() == other.getInternalAttributes()
        && getPlatform() == other.getPlatform()
        && getExternalAttributes() == other.getExternalAttributes()
        && getMethod() == other.getMethod()
        && getSize() == other.getSize()
        && getCrc() == other.getCrc()
        && getCompressedSize() == other.getCompressedSize()
        && Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra())
        && Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra())
        && Objects.equals(gpb, other.gpb);
}",0,0
166,Compress_16,"public ArchiveInputStream createArchiveInputStream(final InputStream in)
            throws ArchiveException {
        if (in == null) {
            throw new IllegalArgumentException(""Stream must not be null."");
        }

        if (!in.markSupported()) {
            throw new IllegalArgumentException(""Mark is not supported."");
        }

        final byte[] signature = new byte[12];
        in.mark(signature.length);
        try {
            int signatureLength = in.read(signature);
            in.reset();
            if (ZipArchiveInputStream.matches(signature, signatureLength)) {
                return new ZipArchiveInputStream(in);
            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
                return new JarArchiveInputStream(in);
            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
                return new ArArchiveInputStream(in);
            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
                return new CpioArchiveInputStream(in);
            }

            // Dump needs a bigger buffer to check the signature;
            final byte[] dumpsig = new byte[32];
            in.mark(dumpsig.length);
            signatureLength = in.read(dumpsig);
            in.reset();
            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
                return new DumpArchiveInputStream(in);
            }

            // Tar needs an even bigger buffer to check the signature; read the first block
            final byte[] tarheader = new byte[512];
            in.mark(tarheader.length);
            signatureLength = in.read(tarheader);
            in.reset();
            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
                return new TarArchiveInputStream(in);
            }
            // COMPRESS-117 - improve auto-recognition
            if (signatureLength >= 512) {
                 try {
                     TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                     // COMPRESS-191 - verify the header checksum
                     tais.getNextEntry();
                         return new TarArchiveInputStream(in);
                 } catch (Exception e) { // NOPMD
                     // can generate IllegalArgumentException as well
                     // as IOException
                    // autodetection, simply not a TAR
                    // ignored
                }
            }
        } catch (IOException e) {
            throw new ArchiveException(""Could not use reset and mark operations."", e);
        }

        throw new ArchiveException(""No Archiver found for the stream signature"");
    }","public ArchiveInputStream createArchiveInputStream(final InputStream in)
        throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }

    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }

    in.mark(512); // Maximum mark length needed

    try {
        final byte[] signature = new byte[12];
        int signatureLength = in.read(signature);
        if (signatureLength == -1) {
            throw new ArchiveException(""Stream ended prematurely."");
        }
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            return new ZipArchiveInputStream(in);
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            return new JarArchiveInputStream(in);
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            return new CpioArchiveInputStream(in);
        }

        final byte[] dumpsig = new byte[32];
        signatureLength = in.read(dumpsig);
        if (signatureLength == -1) {
            throw new ArchiveException(""Stream ended prematurely."");
        }
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in);
        }

        final byte[] tarheader = new byte[512];
        signatureLength = in.read(tarheader);
        if (signatureLength == -1) {
            throw new ArchiveException(""Stream ended prematurely."");
        }
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in);
        }

        if (signatureLength >= 512) {
            try {
                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                tais.getNextEntry();
                return new TarArchiveInputStream(in);
            } catch (Exception e) { 
                // autodetection failed, continue as no TAR
            }
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }

    throw new ArchiveException(""No Archiver found for the stream signature."");
}",0,0
167,Compress_17,"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        int     end = offset + length;
        int     start = offset;

        if (length < 2){
            throw new IllegalArgumentException(""Length ""+length+"" must be at least 2"");
        }

        if (buffer[start] == 0) {
            return 0L;
        }

        // Skip leading spaces
        while (start < end){
            if (buffer[start] == ' '){
                start++;
            } else {
                break;
            }
        }

        // Must have trailing NUL or space
        byte trailer;
        trailer = buffer[end-1];
        if (trailer == 0 || trailer == ' '){
            end--;
        } else {
            throw new IllegalArgumentException(
                    exceptionMessage(buffer, offset, length, end-1, trailer));
         }
         // May have additional NULs or spaces
         trailer = buffer[end - 1];
         if (trailer == 0 || trailer == ' '){
             end--;
         }
 
         for ( ;start < end; start++) {
            final byte currentByte = buffer[start];
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long   result = 0;
        int    end = offset + length;
        int    start = offset;

        if (length < 2) {
            throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
        }

        if (buffer[start] == 0) {
            return 0L;
        }

        // Skip leading spaces
        while (start < end) {
            if (buffer[start] == ' ') {
                start++;
            } else {
                break;
            }
        }

        if (start >= end) {
            throw new IllegalArgumentException(""No valid octal number found in buffer"");
        }

        // Must have trailing NUL or space
        byte trailer = buffer[end - 1];
        if (trailer == 0 || trailer == ' ') {
            end--;
        } else {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
        }

        // May have additional NULs or spaces
        while (end > start && (buffer[end - 1] == 0 || buffer[end - 1] == ' ')) {
            end--;
        }

        if (start >= end) {
            throw new IllegalArgumentException(""No valid octal number found in buffer"");
        }

        for (; start < end; start++) {
            final byte currentByte = buffer[start];
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7') {
                throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }",0,0
168,Compress_18,"void writePaxHeaders(String entryName,
                          Map<String, String> headers) throws IOException {
         String name = ""./PaxHeaders.X/"" + stripTo7Bits(entryName);
             // TarEntry's constructor would think this is a directory
             // and not allow any data to be written
         if (name.length() >= TarConstants.NAMELEN) {
             name = name.substring(0, TarConstants.NAMELEN - 1);
         }
        TarArchiveEntry pex = new TarArchiveEntry(name,
                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);

        StringWriter w = new StringWriter();
        for (Map.Entry<String, String> h : headers.entrySet()) {
            String key = h.getKey();
            String value = h.getValue();
            int len = key.length() + value.length()
                + 3 /* blank, equals and newline */
                + 2 /* guess 9 < actual length < 100 */;
            String line = len + "" "" + key + ""="" + value + ""\n"";
            int actualLength = line.getBytes(CharsetNames.UTF_8).length;
            while (len != actualLength) {
                // Adjust for cases where length < 10 or > 100
                // or where UTF-8 encoding isn't a single octet
                // per character.
                // Must be in loop as size may go from 99 to 100 in
                // first pass so we'd need a second.
                len = actualLength;
                line = len + "" "" + key + ""="" + value + ""\n"";
                actualLength = line.getBytes(CharsetNames.UTF_8).length;
            }
            w.write(line);
        }
        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);
        pex.setSize(data.length);
        putArchiveEntry(pex);
        write(data);
        closeArchiveEntry();
    }",Match failed,0,0
169,Compress_19,"public void reparseCentralDirectoryData(boolean hasUncompressedSize,
                                            boolean hasCompressedSize,
                                            boolean hasRelativeHeaderOffset,
                                            boolean hasDiskStart)
        throws ZipException {
        if (rawCentralDirectoryData != null) {
            int expectedLength = (hasUncompressedSize ? DWORD : 0)
                 + (hasCompressedSize ? DWORD : 0)
                 + (hasRelativeHeaderOffset ? DWORD : 0)
                 + (hasDiskStart ? WORD : 0);
             if (rawCentralDirectoryData.length != expectedLength) {
                 throw new ZipException(""central directory zip64 extended""
                                        + "" information extra field's length""
                                        + "" doesn't match central directory""
                                       + "" data.  Expected length ""
                                       + expectedLength + "" but is ""
                                       + rawCentralDirectoryData.length);
            }
            int offset = 0;
            if (hasUncompressedSize) {
                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasCompressedSize) {
                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,
                                                         offset);
                offset += DWORD;
            }
            if (hasRelativeHeaderOffset) {
                relativeHeaderOffset =
                    new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasDiskStart) {
                diskStart = new ZipLong(rawCentralDirectoryData, offset);
                offset += WORD;
            }
        }
    }","public void reparseCentralDirectoryData(boolean hasUncompressedSize,
                                            boolean hasCompressedSize,
                                            boolean hasRelativeHeaderOffset,
                                            boolean hasDiskStart)
        throws ZipException {
        if (rawCentralDirectoryData != null) {
            int expectedLength = (hasUncompressedSize ? DWORD : 0)
                 + (hasCompressedSize ? DWORD : 0)
                 + (hasRelativeHeaderOffset ? DWORD : 0)
                 + (hasDiskStart ? WORD : 0);
                 
            if (rawCentralDirectoryData.length != expectedLength) {
                 throw new ZipException(""central directory zip64 extended""
                                        + "" information extra field's length""
                                        + "" doesn't match central directory""
                                        + "" data. Expected length ""
                                        + expectedLength + "" but is ""
                                        + rawCentralDirectoryData.length);
            }
            
            int offset = 0;
            if (hasUncompressedSize) {
                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasCompressedSize) {
                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasRelativeHeaderOffset) {
                relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);
                offset += DWORD;
            }
            if (hasDiskStart) {
                diskStart = new ZipLong(rawCentralDirectoryData, offset);
                offset += WORD;
            }
        } else {
            throw new ZipException(""rawCentralDirectoryData is null."");
        }
    }",0,0
170,Compress_21,"private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {
        int cache = 0;
         int shift = 7;
         for (int i = 0; i < length; i++) {
             cache |= ((bits.get(i) ? 1 : 0) << shift);
             --shift;
             if (shift == 0) {
                 header.write(cache);
                 shift = 7;
                 cache = 0;
             }
         }
         if (length > 0 && shift > 0) {
             header.write(cache);
         }
     }","private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {
        int cache = 0;
        int shift = 7;
        for (int i = 0; i < length; i++) {
            cache |= ((bits.get(i) ? 1 : 0) << shift);
            --shift;
            if (shift < 0) {
                header.write(cache);
                shift = 7;
                cache = 0;
            }
        }
        if (length > 0 && shift < 7) {
            header.write(cache);
        }
    }",0,0
171,Compress_23,"@Override
        InputStream decode(final InputStream in, final Coder coder,
                byte[] password) throws IOException {
             byte propsByte = coder.properties[0];
             long dictSize = coder.properties[1];
             for (int i = 1; i < 4; i++) {
                 dictSize |= (coder.properties[i + 1] << (8 * i));
             }
             if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {
                 throw new IOException(""Dictionary larger than 4GiB maximum size"");
            }
            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);
        }","@Override
InputStream decode(final InputStream in, final Coder coder,
                   byte[] password) throws IOException {
    if (coder.properties == null || coder.properties.length < 5) {
        throw new IOException(""Invalid coder properties"");
    }
    byte propsByte = coder.properties[0];
    long dictSize = coder.properties[1] & 0xFF;
    for (int i = 1; i < 4; i++) {
        dictSize |= (coder.properties[i + 1] & 0xFF) << (8 * i);
    }
    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {
        throw new IOException(""Dictionary larger than 4GiB maximum size"");
    }
    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);
}",0,0
172,Compress_24,"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        int     end = offset + length;
        int     start = offset;

        if (length < 2){
            throw new IllegalArgumentException(""Length ""+length+"" must be at least 2"");
        }

        if (buffer[start] == 0) {
            return 0L;
        }

        // Skip leading spaces
        while (start < end){
            if (buffer[start] == ' '){
                start++;
            } else {
                break;
            }
        }

        // Trim all trailing NULs and spaces.
        // The ustar and POSIX tar specs require a trailing NUL or
         // space but some implementations use the extra digit for big
         // sizes/uids/gids ...
         byte trailer = buffer[end - 1];
         if (trailer == 0 || trailer == ' '){
             end--;
         } else {
             throw new IllegalArgumentException(
                     exceptionMessage(buffer, offset, length, end-1, trailer));
         }
         trailer = buffer[end - 1];
         while (start < end - 1 && (trailer == 0 || trailer == ' ')) {
             end--;
             trailer = buffer[end - 1];
         }
 
         for ( ;start < end; start++) {
            final byte currentByte = buffer[start];
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;

    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }

    if (buffer[start] == 0) {
        return 0L;
    }

    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }

    // Trim all trailing NULs and spaces.
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        if (end > start) {
            trailer = buffer[end - 1];
        }
    }

    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(
                    exceptionMessage(buffer, offset, length, start, currentByte));
        }
        result = (result << 3) + (currentByte - '0'); // convert from ASCII
    }

    return result;
}",0,0
173,Compress_25,"    public ZipArchiveInputStream(InputStream inputStream,
                                 String encoding,
                                 boolean useUnicodeExtraFields,
                                 boolean allowStoredEntriesWithDataDescriptor) {
        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
        this.useUnicodeExtraFields = useUnicodeExtraFields;
        in = new PushbackInputStream(inputStream, buf.capacity());
        this.allowStoredEntriesWithDataDescriptor =
            allowStoredEntriesWithDataDescriptor;
        // haven't read anything so far
    }
","public ZipArchiveInputStream(InputStream inputStream,
                             String encoding,
                             boolean useUnicodeExtraFields,
                             boolean allowStoredEntriesWithDataDescriptor) {
    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
    this.useUnicodeExtraFields = useUnicodeExtraFields;
    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;

    // Initialize a buffer with a default capacity if not already initialized
    if (buf == null) {
        buf = ByteBuffer.allocate(512); // Assuming 512 as the default capacity
    }

    in = new PushbackInputStream(inputStream, buf.capacity());
    // haven't read anything so far
}",0,0
174,Compress_26,"public static long skip(InputStream input, long numToSkip) throws IOException {
        long available = numToSkip;
        while (numToSkip > 0) {
            long skipped = input.skip(numToSkip);
            if (skipped == 0) {
                break;
            }
             numToSkip -= skipped;
         }
             
         return available - numToSkip;
     }","public static long skip(InputStream input, long numToSkip) throws IOException {
    long skippedTotal = 0;
    while (skippedTotal < numToSkip) {
        long skipped = input.skip(numToSkip - skippedTotal);
        if (skipped == 0) {
            if (input.read() < 0) { // If end of stream, exit loop
                break;
            }
            skipped = 1; // Adjust skipped when read() advances the stream
        }
        skippedTotal += skipped;
    }
    return skippedTotal;
}",0,0
175,Compress_27,"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        int     end = offset + length;
        int     start = offset;

        if (length < 2){
            throw new IllegalArgumentException(""Length ""+length+"" must be at least 2"");
        }

        if (buffer[start] == 0) {
            return 0L;
        }

        // Skip leading spaces
        while (start < end){
            if (buffer[start] == ' '){
                start++;
            } else {
                break;
            }
        }

        // Trim all trailing NULs and spaces.
        // The ustar and POSIX tar specs require a trailing NUL or
        // space but some implementations use the extra digit for big
        // sizes/uids/gids ...
        byte trailer = buffer[end - 1];
        while (start < end && (trailer == 0 || trailer == ' ')) {
             end--;
             trailer = buffer[end - 1];
         }
         if (start == end) {
             throw new IllegalArgumentException(
                     exceptionMessage(buffer, offset, length, start, trailer));
         }
 
         for ( ;start < end; start++) {
             final byte currentByte = buffer[start];
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }

    long result = 0;
    int end = offset + length;
    int start = offset;

    // Validate buffer boundaries
    if (buffer == null || buffer.length < end) {
        throw new IllegalArgumentException(""Buffer length invalid or outside boundaries."");
    }

    if (buffer[start] == 0) {
        return 0L; // Handle zero-length or padded data
    }

    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }

    // Trim all trailing NULs and spaces.
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        if (end > offset) {
            trailer = buffer[end - 1];
        }
    }

    // If no valid octal content
    if (start == end) {
        throw new IllegalArgumentException(
            exceptionMessage(buffer, offset, length, start, trailer));
    }

    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(
                exceptionMessage(buffer, offset, length, start, currentByte));
        }
        result = (result << 3) + (currentByte - '0'); // Convert from ASCII to octal
    }

    return result;
}",0,0
176,Compress_28,"@Override
    public int read(byte[] buf, int offset, int numToRead) throws IOException {
    	int totalRead = 0;

        if (hasHitEOF || entryOffset >= entrySize) {
            return -1;
        }

        if (currEntry == null) {
            throw new IllegalStateException(""No current tar entry"");
        }

         numToRead = Math.min(numToRead, available());
         
         totalRead = is.read(buf, offset, numToRead);
         count(totalRead);
         
         if (totalRead == -1) {
             hasHitEOF = true;
         } else {
             entryOffset += totalRead;
         }
 
        return totalRead;
    }","@Override
public int read(byte[] buf, int offset, int numToRead) throws IOException {
    if (buf == null) {
        throw new NullPointerException(""Buffer cannot be null"");
    }
    if (offset < 0 || numToRead < 0 || offset + numToRead > buf.length) {
        throw new IndexOutOfBoundsException(""Invalid offset or length"");
    }

    int totalRead = 0;

    if (hasHitEOF || entryOffset >= entrySize) {
        return -1;
    }

    if (currEntry == null) {
        throw new IllegalStateException(""No current tar entry"");
    }

    numToRead = Math.min(numToRead, available());

    totalRead = is.read(buf, offset, numToRead);
    if (totalRead == -1) {
        hasHitEOF = true;
    } else {
        entryOffset += totalRead;
        count(totalRead);
    }

    return totalRead;
}",0,0
177,Compress_30,"@Override
    public int read(final byte[] dest, final int offs, final int len)
        throws IOException {
        if (offs < 0) {
            throw new IndexOutOfBoundsException(""offs("" + offs + "") < 0."");
        }
        if (len < 0) {
            throw new IndexOutOfBoundsException(""len("" + len + "") < 0."");
        }
        if (offs + len > dest.length) {
            throw new IndexOutOfBoundsException(""offs("" + offs + "") + len(""
                                                + len + "") > dest.length("" + dest.length + "")."");
        }
         if (this.in == null) {
             throw new IOException(""stream closed"");
         }
 
         final int hi = offs + len;
         int destOffs = offs;
        int b;
        while (destOffs < hi && ((b = read0()) >= 0)) {
            dest[destOffs++] = (byte) b;
            count(1);
        }

        int c = (destOffs == offs) ? -1 : (destOffs - offs);
        return c;
    }","@Override
public int read(final byte[] dest, final int offs, final int len)
    throws IOException {
    if (dest == null) {
        throw new NullPointerException(""Destination array is null."");
    }
    if (offs < 0) {
        throw new IndexOutOfBoundsException(""offs("" + offs + "") < 0."");
    }
    if (len < 0) {
        throw new IndexOutOfBoundsException(""len("" + len + "") < 0."");
    }
    if (offs + len > dest.length) {
        throw new IndexOutOfBoundsException(""offs("" + offs + "") + len(""
                                            + len + "") > dest.length("" + dest.length + "")."");
    }
    if (this.in == null) {
        throw new IOException(""stream closed"");
    }

    final int hi = offs + len;
    int destOffs = offs;
    int b;
    while (destOffs < hi && ((b = read0()) >= 0)) {
        dest[destOffs++] = (byte) b;
        count(1); // Ensure this method is thread-safe or synchronized if applicable
    }

    return (destOffs == offs) ? -1 : (destOffs - offs); // Simplified ternary logic
}",0,0
178,Compress_31,"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        int     end = offset + length;
        int     start = offset;

        if (length < 2){
            throw new IllegalArgumentException(""Length ""+length+"" must be at least 2"");
        }

        if (buffer[start] == 0) {
            return 0L;
        }

        // Skip leading spaces
        while (start < end){
            if (buffer[start] == ' '){
                start++;
            } else {
                break;
            }
        }

        // Trim all trailing NULs and spaces.
        // The ustar and POSIX tar specs require a trailing NUL or
        // space but some implementations use the extra digit for big
        // sizes/uids/gids ...
        byte trailer = buffer[end - 1];
        while (start < end && (trailer == 0 || trailer == ' ')) {
            end--;
            trailer = buffer[end - 1];
        }
 
         for ( ;start < end; start++) {
             final byte currentByte = buffer[start];
             if (currentByte == 0) {
                 break;
             }
             // CheckStyle:MagicNumber OFF
             if (currentByte < '0' || currentByte > '7'){
                 throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }","public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;

    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }

    if (buffer[start] == 0) {
        return 0L;
    }

    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }

    // Ensure there's still data left after skipping leading spaces
    if (start >= end) {
        throw new IllegalArgumentException(""Invalid octal representation: all spaces or empty buffer"");
    }

    // Trim all trailing NULs and spaces
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        if (end > start) {
            trailer = buffer[end - 1];
        }
    }

    // Ensure there's still valid data after trimming trailing spaces/NULs
    if (start >= end) {
        throw new IllegalArgumentException(""Invalid octal representation: no valid digits found"");
    }

    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        if (currentByte == 0) {
            break;
        }
        // Check that the current byte is a valid octal digit
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(
                    exceptionMessage(buffer, offset, length, start, currentByte));
        }
        result = (result << 3) + (currentByte - '0'); // convert from ASCII
    }

    return result;
}",0,0
179,Compress_32,"private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {
        /*
         * The following headers are defined for Pax.
         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields
         * mtime
         * comment
         * gid, gname
         * linkpath
         * size
         * uid,uname
         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those
         */
        for (Entry<String, String> ent : headers.entrySet()){
            String key = ent.getKey();
            String val = ent.getValue();
            if (""path"".equals(key)){
                currEntry.setName(val);
             } else if (""linkpath"".equals(key)){
                 currEntry.setLinkName(val);
             } else if (""gid"".equals(key)){
                 currEntry.setGroupId(Integer.parseInt(val));
             } else if (""gname"".equals(key)){
                 currEntry.setGroupName(val);
             } else if (""uid"".equals(key)){
                 currEntry.setUserId(Integer.parseInt(val));
             } else if (""uname"".equals(key)){
                 currEntry.setUserName(val);
             } else if (""size"".equals(key)){
                currEntry.setSize(Long.parseLong(val));
            } else if (""mtime"".equals(key)){
                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));
            } else if (""SCHILY.devminor"".equals(key)){
                currEntry.setDevMinor(Integer.parseInt(val));
            } else if (""SCHILY.devmajor"".equals(key)){
                currEntry.setDevMajor(Integer.parseInt(val));
            }
        }
    }","private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {
    /*
     * The following headers are defined for Pax.
     * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields
     * mtime
     * comment
     * gid, gname
     * linkpath
     * size
     * uid, uname
     * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those
     */
    for (Entry<String, String> ent : headers.entrySet()) {
        String key = ent.getKey();
        String val = ent.getValue();
        
        try {
            if (""path"".equals(key)) {
                currEntry.setName(val);
            } else if (""linkpath"".equals(key)) {
                currEntry.setLinkName(val);
            } else if (""gid"".equals(key)) {
                currEntry.setGroupId(Integer.parseInt(val));
            } else if (""gname"".equals(key)) {
                currEntry.setGroupName(val);
            } else if (""uid"".equals(key)) {
                currEntry.setUserId(Integer.parseInt(val));
            } else if (""uname"".equals(key)) {
                currEntry.setUserName(val);
            } else if (""size"".equals(key)) {
                currEntry.setSize(Long.parseLong(val));
            } else if (""mtime"".equals(key)) {
                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));
            } else if (""SCHILY.devminor"".equals(key)) {
                currEntry.setDevMinor(Integer.parseInt(val));
            } else if (""SCHILY.devmajor"".equals(key)) {
                currEntry.setDevMajor(Integer.parseInt(val));
            }
        } catch (NumberFormatException e) {
            // Log or handle the exception if the value cannot be parsed to a number
            System.err.println(""Error parsing numeric value for key: "" + key + "", value: "" + val);
        } catch (NullPointerException e) {
            // Log or handle the exception if currEntry is null or any other unexpected null issue
            System.err.println(
                ""Error setting value for key: "" + key + "". Current entry might be null or not initialized."");
        }
    }
}",0,0
180,Compress_35,"public static boolean verifyCheckSum(byte[] header) {
        long storedSum = 0;
        long unsignedSum = 0;
        long signedSum = 0;

        int digits = 0;
         for (int i = 0; i < header.length; i++) {
             byte b = header[i];
             if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {
                 if ('0' <= b && b <= '7' && digits++ < 6) {
                     storedSum = storedSum * 8 + b - '0';
                 } else if (digits > 0) {
                     digits = 6;
                 }
                 b = ' ';
             }
             unsignedSum += 0xff & b;
            signedSum += b;
        }
        return storedSum == unsignedSum || storedSum == signedSum;
    }","public static boolean verifyCheckSum(byte[] header) {
    long storedSum = 0;
    long unsignedSum = 0;
    long signedSum = 0;

    int digits = 0;
    for (int i = 0; i < header.length; i++) {
        byte b = header[i];
        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {
            if ('0' <= b && b <= '7' && digits < 6) { // Ensure proper digit counting condition
                storedSum = storedSum * 8 + b - '0';
                digits++;
            } else if ('0' > b || b > '7') { // Only reset digits when invalid
                digits = 6;
            }
            b = ' ';
        }
        unsignedSum += 0xff & b; // Ensure proper unsigned addition
        signedSum += (byte) b;  // Ensure proper signed addition (explicit cast)
    }
    return storedSum == unsignedSum || storedSum == signedSum;
}",0,0
181,Compress_36,"    public int read() throws IOException {
        return getCurrentStream().read();
    }
","public int read() throws IOException {
    InputStream currentStream = getCurrentStream();
    if (currentStream == null) {
        throw new IOException(""No current stream available to read from"");
    }
    return currentStream.read();
}",0,0
182,Compress_37,"Map<String, String> parsePaxHeaders(final InputStream i)
        throws IOException {
        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);
        // Format is ""length keyword=value\n"";
        while(true){ // get length
            int ch;
            int len = 0;
             int read = 0;
             while((ch = i.read()) != -1) {
                 read++;
                 if (ch == ' '){
                     // Get keyword
                     final ByteArrayOutputStream coll = new ByteArrayOutputStream();
                     while((ch = i.read()) != -1) {
                        read++;
                        if (ch == '='){ // end of keyword
                            final String keyword = coll.toString(CharsetNames.UTF_8);
                            // Get rest of entry
                            final int restLen = len - read;
                            if (restLen == 1) { // only NL
                                headers.remove(keyword);
                            } else {
                                final byte[] rest = new byte[restLen];
                                final int got = IOUtils.readFully(i, rest);
                                if (got != restLen) {
                                    throw new IOException(""Failed to read ""
                                                          + ""Paxheader. Expected ""
                                                          + restLen
                                                          + "" bytes, read ""
                                                          + got);
                                }
                                // Drop trailing NL
                                final String value = new String(rest, 0,
                                                          restLen - 1, CharsetNames.UTF_8);
                                headers.put(keyword, value);
                            }
                            break;
                        }
                        coll.write((byte) ch);
                    }
                    break; // Processed single header
                }
                len *= 10;
                len += ch - '0';
            }
            if (ch == -1){ // EOF
                break;
            }
        }
        return headers;
    }","Map<String, String> parsePaxHeaders(final InputStream i)
        throws IOException {
    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);
    // Format is ""length keyword=value\n"";
    while (true) { // get length
        int ch;
        int len = 0;
        int read = 0;
        while ((ch = i.read()) != -1) {
            read++;
            if (ch == ' ') {
                // Get keyword
                final ByteArrayOutputStream coll = new ByteArrayOutputStream();
                while ((ch = i.read()) != -1) {
                    read++;
                    if (ch == '=') { // end of keyword
                        final String keyword = coll.toString(CharsetNames.UTF_8);
                        // Get rest of entry
                        final int restLen = len - read;
                        if (restLen <= 0) {
                            throw new IOException(""Paxheader entry length mismatch"");
                        }
                        final byte[] rest = new byte[restLen];
                        final int got = IOUtils.readFully(i, rest);
                        if (got != restLen) {
                            throw new IOException(""Failed to read ""
                                                  + ""Paxheader. Expected ""
                                                  + restLen
                                                  + "" bytes, read ""
                                                  + got);
                        }
                        // Drop trailing NL if there is one
                        final String value = new String(rest, 0,
                                                  (restLen > 0 && rest[restLen - 1] == '\n') ? restLen - 1 : restLen, CharsetNames.UTF_8);
                        headers.put(keyword, value);
                        break;
                    }
                    coll.write((byte) ch);
                }
                break; // Processed single header
            }
            if (ch < '0' || ch > '9') {
                throw new IOException(""Invalid character in length field: "" + (char) ch);
            }
            len *= 10;
            len += ch - '0';
        }
        if (ch == -1) { // EOF
            break;
        }
    }
    return headers;
}",0,0
183,Compress_38,"@Override
    public boolean isDirectory() {
        if (file != null) {
            return file.isDirectory();
        }

        if (linkFlag == LF_DIR) {
             return true;
         }
 
         if (getName().endsWith(""/"")) {
             return true;
         }
 
        return false;
    }","@Override
public boolean isDirectory() {
    if (file != null && file.exists()) {
        return file.isDirectory();
    }

    if (linkFlag == LF_DIR) {
        return true;
    }

    if (getName() != null && getName().endsWith(""/"")) {
        return true;
    }

    return false;
}",0,0
184,Compress_40,"public long readBits(final int count) throws IOException {
        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {
            throw new IllegalArgumentException(""count must not be negative or greater than "" + MAXIMUM_CACHE_SIZE);
        }
        while (bitsCachedSize < count) {
            final long nextByte = in.read();
            if (nextByte < 0) {
                return nextByte;
            }
            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
                bitsCached |= (nextByte << bitsCachedSize);
            } else {
                bitsCached <<= 8;
                bitsCached |= nextByte;
             }
             bitsCachedSize += 8;
         }
             // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow
         
         final long bitsOut;
             if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
                 bitsOut = (bitsCached & MASKS[count]);
                 bitsCached >>>= count;
            } else {
                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];
            }
            bitsCachedSize -= count;
        return bitsOut;
    }","public long readBits(final int count) throws IOException {
    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {
        throw new IllegalArgumentException(""count must not be negative or greater than "" + MAXIMUM_CACHE_SIZE);
    }
    while (bitsCachedSize < count) {
        final int nextByte = in.read();
        if (nextByte < 0) {
            return -1; // Return -1 if the end of stream is reached
        }
        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
            bitsCached |= ((long) nextByte << bitsCachedSize);
        } else {
            bitsCached <<= 8;
            bitsCached |= nextByte;
        }
        bitsCachedSize += 8;

        // Check for overflow condition based on bitsCachedSize
        // Assuming LONG_SIZE is the number of bits in a long type
        if (bitsCachedSize > Long.SIZE - 8) {
            // Handle overflow or break from loop
            break;
        }
    }

    final long bitsOut;
    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
        bitsOut = (bitsCached & MASKS[count]);
        bitsCached >>>= count;
    } else {
        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];
    }
    bitsCachedSize -= count;
    return bitsOut;
}",0,0
185,Compress_41,"public ZipArchiveEntry getNextZipEntry() throws IOException {
        boolean firstEntry = true;
        if (closed || hitCentralDirectory) {
            return null;
        }
        if (current != null) {
            closeEntry();
            firstEntry = false;
        }

        try {
            if (firstEntry) {
                // split archives have a special signature before the
                // first local file header - look for it and fail with
                // the appropriate error message if this is a split
                // archive.
                readFirstLocalFileHeader(LFH_BUF);
            } else {
                readFully(LFH_BUF);
            }
        } catch (final EOFException e) {
            return null;
        }

        final ZipLong sig = new ZipLong(LFH_BUF);
         if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
             hitCentralDirectory = true;
             skipRemainderOfArchive();
         }
         if (!sig.equals(ZipLong.LFH_SIG)) {
             return null;
         }
 
         int off = WORD;
        current = new CurrentEntry();

        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
        off += SHORT;
        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);

        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
        current.hasDataDescriptor = gpFlag.usesDataDescriptor();
        current.entry.setGeneralPurposeBit(gpFlag);

        off += SHORT;

        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
        off += SHORT;

        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
        current.entry.setTime(time);
        off += WORD;

        ZipLong size = null, cSize = null;
        if (!current.hasDataDescriptor) {
            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
            off += WORD;

            cSize = new ZipLong(LFH_BUF, off);
            off += WORD;

            size = new ZipLong(LFH_BUF, off);
            off += WORD;
        } else {
            off += 3 * WORD;
        }

        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);

        off += SHORT;

        final int extraLen = ZipShort.getValue(LFH_BUF, off);
        off += SHORT;

        final byte[] fileName = new byte[fileNameLen];
        readFully(fileName);
        current.entry.setName(entryEncoding.decode(fileName), fileName);

        final byte[] extraData = new byte[extraLen];
        readFully(extraData);
        current.entry.setExtra(extraData);

        if (!hasUTF8Flag && useUnicodeExtraFields) {
            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
        }

        processZip64Extra(size, cSize);

        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
                current.in = new ExplodingInputStream(
                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),
                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),
                        new BoundedInputStream(in, current.entry.getCompressedSize()));
            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
            }
        }
        
        entriesRead++;
        return current.entry;
    }","public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }

    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(LFH_BUF);
        } else {
            readFully(LFH_BUF);
        }
    } catch (final EOFException e) {
        return null; // End of file detected, return null
    }

    final ZipLong sig = new ZipLong(LFH_BUF);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        return null; // Unexpected signature, return null
    }

    int off = WORD;
    current = new CurrentEntry();

    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);

    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);

    off += SHORT;

    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
    off += SHORT;

    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
    current.entry.setTime(time);
    off += WORD;

    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
        off += WORD;

        cSize = new ZipLong(LFH_BUF, off);
        off += WORD;

        size = new ZipLong(LFH_BUF, off);
        off += WORD;
    } else {
        off += 3 * WORD; // Skip CRC, compressed size, and uncompressed size
    }

    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;

    final int extraLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;

    final byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);

    final byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);

    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }

    processZip64Extra(size, cSize);

    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        try {
            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
                current.in = new ExplodingInputStream(
                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),
                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),
                        new BoundedInputStream(in, current.entry.getCompressedSize()));
            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
            }
        } catch (IOException e) {
            throw new IOException(""Error initializing specialized input stream for compression method"", e); // Provide detailed error
        }
    }

    entriesRead++;
    return current.entry;
}",0,0
186,Compress_44,"    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {



        this.checksum = checksum;
        this.in = in;
    }
","public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {
        super(in); // Call the superclass constructor to initialize the stream
        if (checksum == null) {
            throw new IllegalArgumentException(""Checksum cannot be null"");
        }
        if (in == null) {
            throw new IllegalArgumentException(""InputStream cannot be null"");
        }
        this.checksum = checksum;
        this.in = in;
    }",0,0
187,Compress_45,"public static int formatLongOctalOrBinaryBytes(
        final long value, final byte[] buf, final int offset, final int length) {

        // Check whether we are dealing with UID/GID or SIZE field
        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;

        final boolean negative = value < 0;
        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars
            return formatLongOctalBytes(value, buf, offset, length);
        }
 
         if (length < 9) {
             formatLongBinary(value, buf, offset, length, negative);
         }
         formatBigIntegerBinary(value, buf, offset, length, negative);
 
         buf[offset] = (byte) (negative ? 0xff : 0x80);
         return offset + length;
    }","public static int formatLongOctalOrBinaryBytes(
        final long value, final byte[] buf, final int offset, final int length) {

    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;

    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }

    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    } else {
        formatBigIntegerBinary(value, buf, offset, length, negative);
    }

    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}",0,0
188,Compress_46,"    private static ZipLong dateToZipLong(final Date d) {
        if (d == null) { return null; }

        return unixTimeToZipLong(d.getTime() / 1000);
    }
","private static ZipLong dateToZipLong(final Date d) {
    if (d == null) { 
        // Returning a valid default value instead of null
        return new ZipLong(0); 
    }

    // Ensure proper conversion to Unix time for Zip format
    long unixTime = d.getTime() / 1000;
    return unixTimeToZipLong(unixTime);
}",0,0
189,Compress_5,"public int read(byte[] buffer, int start, int length) throws IOException {
        if (closed) {
            throw new IOException(""The stream is closed"");
        }
        if (inf.finished() || current == null) {
            return -1;
        }

        // avoid int overflow, check null buffer
        if (start <= buffer.length && length >= 0 && start >= 0
            && buffer.length - start >= length) {
            if (current.getMethod() == ZipArchiveOutputStream.STORED) {
                int csize = (int) current.getSize();
                if (readBytesOfEntry >= csize) {
                    return -1;
                }
                if (offsetInBuffer >= lengthOfLastRead) {
                    offsetInBuffer = 0;
                    if ((lengthOfLastRead = in.read(buf)) == -1) {
                        return -1;
                    }
                    count(lengthOfLastRead);
                    bytesReadFromStream += lengthOfLastRead;
                }
                int toRead = length > lengthOfLastRead
                    ? lengthOfLastRead - offsetInBuffer
                    : length;
                if ((csize - readBytesOfEntry) < toRead) {
                    toRead = csize - readBytesOfEntry;
                }
                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);
                offsetInBuffer += toRead;
                readBytesOfEntry += toRead;
                crc.update(buffer, start, toRead);
                return toRead;
            }
            if (inf.needsInput()) {
                fill();
                if (lengthOfLastRead > 0) {
                    bytesReadFromStream += lengthOfLastRead;
                }
            }
            int read = 0;
            try {
                read = inf.inflate(buffer, start, length);
             } catch (DataFormatException e) {
                 throw new ZipException(e.getMessage());
             }
             if (read == 0 && inf.finished()) {
                 return -1;
             }
             crc.update(buffer, start, read);
             return read;
        }
        throw new ArrayIndexOutOfBoundsException();
    }","public int read(byte[] buffer, int start, int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }
    if (buffer == null) {
        throw new NullPointerException(""Buffer is null"");
    }
    if (inf.finished() || current == null) {
        return -1;
    }

    // Validate parameters to ensure no overflow or invalid ranges
    if (start < 0 || length < 0 || start >= buffer.length || buffer.length - start < length) {
        throw new ArrayIndexOutOfBoundsException(""Invalid start or length parameters"");
    }

    if (current.getMethod() == ZipArchiveOutputStream.STORED) {
        int csize = (int) current.getSize();
        if (readBytesOfEntry >= csize) {
            return -1;
        }
        if (offsetInBuffer >= lengthOfLastRead) {
            offsetInBuffer = 0;
            if ((lengthOfLastRead = in.read(buf)) == -1) {
                return -1;
            }
            count(lengthOfLastRead);
            bytesReadFromStream += lengthOfLastRead;
        }
        int toRead = Math.min(length, lengthOfLastRead - offsetInBuffer);
        toRead = Math.min(toRead, csize - readBytesOfEntry);
        System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);
        offsetInBuffer += toRead;
        readBytesOfEntry += toRead;
        crc.update(buffer, start, toRead);
        return toRead;
    }

    if (inf.needsInput()) {
        fill();
        if (lengthOfLastRead > 0) {
            bytesReadFromStream += lengthOfLastRead;
        }
    }

    try {
        int read = inf.inflate(buffer, start, length);
        if (read == 0 && inf.finished()) {
            return -1;
        }
        crc.update(buffer, start, read);
        return read;
    } catch (DataFormatException e) {
        throw new ZipException(""Data format error: "" + e.getMessage());
    }
}",0,0
190,Compress_7,"public static String parseName(byte[] buffer, final int offset, final int length) {
        StringBuffer result = new StringBuffer(length);
         int          end = offset + length;
 
         for (int i = offset; i < end; ++i) {
             if (buffer[i] == 0) {
                 break;
             }
             result.append((char) buffer[i]);
         }
 
         return result.toString();
    }","public static String parseName(byte[] buffer, final int offset, final int length) {
    if (buffer == null || offset < 0 || length < 0 || offset + length > buffer.length) {
        throw new IllegalArgumentException(""Invalid buffer, offset, or length"");
    }

    StringBuilder result = new StringBuilder(length);
    int end = offset + length;

    for (int i = offset; i < end; ++i) {
        if (buffer[i] == 0) {
            break;
        }
        result.append((char) buffer[i]);
    }

    return result.toString();
}",0,0
191,Compress_8,"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
        long    result = 0;
        boolean stillPadding = true;
        int     end = offset + length;
        int     start = offset;

        for (int i = start; i < end; i++){
            final byte currentByte = buffer[i];
            if (currentByte == 0) {
                break;
            }

        // Skip leading spaces
            if (currentByte == (byte) ' ' || currentByte == '0') {
                if (stillPadding) {
                   continue;
            }
                if (currentByte == (byte) ' ') {
                break;
                }
            }

        // Must have trailing NUL or space
        // May have additional NUL or space

            stillPadding = false;
            // CheckStyle:MagicNumber OFF
            if (currentByte < '0' || currentByte > '7'){
                throw new IllegalArgumentException(
                        exceptionMessage(buffer, offset, length, start, currentByte));
            }
            result = (result << 3) + (currentByte - '0'); // convert from ASCII
            // CheckStyle:MagicNumber ON
        }

        return result;
    }

    // Helper method to generate the exception message
    private static String exceptionMessage(byte[] buffer, final int offset,
            final int length, int current, final byte currentByte) {
        String string = new String(buffer, offset, length);
        string=string.replaceAll(""\0"", ""{NUL}""); // Replace NULs to allow string to be printed
        final String s = ""Invalid byte ""+currentByte+"" at offset ""+(current-offset)+"" in '""+string+""' len=""+length;
        return s;
    }

    /**
     * Parse an entry name from a buffer.
     * Parsing stops when a NUL is found
     * or the buffer length is reached.
     *
     * @param buffer The buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The maximum number of bytes to parse.
     * @return The entry name.
     */
    public static String parseName(byte[] buffer, final int offset, final int length) {
        StringBuffer result = new StringBuffer(length);
        int          end = offset + length;

        for (int i = offset; i < end; ++i) {
            byte b = buffer[i];
            if (b == 0) { // Trailing null
                break;
            }",Match failed,0,0
192,Csv_1,"    public int read() throws IOException {
        int current = super.read();
        if (current == '\n') {
            lineCounter++;
        }
        lastChar = current;
        return lastChar;
    }
","public int read() throws IOException {
    int current = super.read();
    if (current != -1 && current == '\n') { // Ensure 'current' is valid before checking '\n'
        lineCounter++;
    }
    lastChar = current;
    return current; // Return 'current' instead of 'lastChar' to avoid incorrect behavior
}",0,0
193,Csv_10,"    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {
        Assertions.notNull(out, ""out"");
        Assertions.notNull(format, ""format"");

        this.out = out;
        this.format = format;
        this.format.validate();
        // TODO: Is it a good idea to do this here instead of on the first call to a print method?
        // It seems a pain to have to track whether the header has already been printed or not.
    }
","public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {
    // Validate the parameters
    Assertions.notNull(out, ""out"");
    Assertions.notNull(format, ""format"");

    // Assign initialized values
    this.out = out;
    this.format = format;

    // Validate the format
    this.format.validate();

    // Print the header if required by the format
    if (this.format.getHeader() != null && this.format.getHeader().length > 0) {
        printRecord((Object[]) this.format.getHeader());
    }
}",0,0
194,Csv_11,"private Map<String, Integer> initializeHeader() throws IOException {
        Map<String, Integer> hdrMap = null;
        final String[] formatHeader = this.format.getHeader();
        if (formatHeader != null) {
            hdrMap = new LinkedHashMap<String, Integer>();

            String[] headerRecord = null;
            if (formatHeader.length == 0) {
                // read the header from the first line of the file
                final CSVRecord nextRecord = this.nextRecord();
                if (nextRecord != null) {
                    headerRecord = nextRecord.values();
                }
            } else {
                if (this.format.getSkipHeaderRecord()) {
                    this.nextRecord();
                }
                headerRecord = formatHeader;
            }

            // build the name to index mappings
            if (headerRecord != null) {
                 for (int i = 0; i < headerRecord.length; i++) {
                     final String header = headerRecord[i];
                     final boolean containsHeader = hdrMap.containsKey(header);
                     final boolean emptyHeader = header.trim().isEmpty();
                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {
                         throw new IllegalArgumentException(""The header contains a duplicate name: \"""" + header +
                                 ""\"" in "" + Arrays.toString(headerRecord));
                    }
                    hdrMap.put(header, Integer.valueOf(i));
                }
            }
        }
        return hdrMap;
    }","private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<>();

        String[] headerRecord = null;
        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                headerRecord = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            headerRecord = formatHeader;
        }

        // build the name-to-index mappings
        if (headerRecord != null) {
            for (int i = 0; i < headerRecord.length; i++) {
                final String header = headerRecord[i];
                final boolean emptyHeader = header.trim().isEmpty();
                if (hdrMap.containsKey(header) && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {
                    throw new IllegalArgumentException(""The header contains a duplicate name: \"""" + header +
                            ""\"" in "" + Arrays.toString(headerRecord));
                }
                hdrMap.put(header, i); // Directly use `i` as primitive int instead of wrapping with `Integer.valueOf()`
            }
        }
    }
    return hdrMap;
}",0,0
195,Csv_14,"private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,
            final Appendable out, final boolean newRecord) throws IOException {
        boolean quote = false;
        int start = offset;
        int pos = offset;
        final int end = offset + len;

        final char delimChar = getDelimiter();
        final char quoteChar = getQuoteCharacter().charValue();

        QuoteMode quoteModePolicy = getQuoteMode();
        if (quoteModePolicy == null) {
            quoteModePolicy = QuoteMode.MINIMAL;
        }
        switch (quoteModePolicy) {
        case ALL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
            // Use the existing escaping code
            printAndEscape(value, offset, len, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                // always quote an empty token that is the first
                // on the line, as it may be the only thing on the
                // line. If it were not quoted in that case,
                // an empty line has no tokens.
                if (newRecord) {
                    quote = true;
                }
            } else {
                 char c = value.charAt(pos);
 
                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E
                 if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {
                     quote = true;
                 } else if (c <= COMMENT) {
                     // Some other chars at the start of a value caused the parser to fail, so for now
                    // encapsulate if we start in anything less than '#'. We are being conservative
                    // by including the default comment char too.
                    quote = true;
                } else {
                    while (pos < end) {
                        c = value.charAt(pos);
                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }

                    if (!quote) {
                        pos = end - 1;
                        c = value.charAt(pos);
                        // Some other chars at the end caused the parser to fail, so for now
                        // encapsulate if we end in anything less than ' '
                        if (c <= SP) {
                            quote = true;
                        }
                    }
                }
            }

            if (!quote) {
                // no encapsulation needed - write out the original value
                out.append(value, start, end);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
        }

        if (!quote) {
            // no encapsulation needed - write out the original value
            out.append(value, start, end);
            return;
        }

        // we hit something that needed encapsulation
        out.append(quoteChar);

        // Pick up where we left off: pos should be positioned on the first character that caused
        // the need for encapsulation.
        while (pos < end) {
            final char c = value.charAt(pos);
            if (c == quoteChar) {
                // write out the chunk up until this point

                // add 1 to the length to write out the encapsulator also
                out.append(value, start, pos + 1);
                // put the next starting position on the encapsulator so we will
                // write it out again with the next string (effectively doubling it)
                start = pos;
            }
            pos++;
        }

        // write the last segment
        out.append(value, start, pos);
        out.append(quoteChar);
    }","private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,
        final Appendable out, final boolean newRecord) throws IOException {
    boolean quote = false;
    int start = offset;
    int pos = offset;
    final int end = offset + len;

    final char delimChar = getDelimiter();
    final char quoteChar = getQuoteCharacter().charValue();

    QuoteMode quoteModePolicy = getQuoteMode();
    if (quoteModePolicy == null) {
        quoteModePolicy = QuoteMode.MINIMAL;
    }
    switch (quoteModePolicy) {
    case ALL:
        quote = true;
        break;
    case NON_NUMERIC:
        quote = !(object instanceof Number);
        break;
    case NONE:
        // Use the existing escaping code
        printAndEscape(value, offset, len, out);
        return;
    case MINIMAL:
        if (len <= 0) {
            // always quote an empty token that is the first
            // on the line, as it may be the only thing on the
            // line. If it were not quoted in that case,
            // an empty line has no tokens.
            if (newRecord) {
                quote = true;
            }
        } else {
            char c = value.charAt(pos);

            // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E
            if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z')) {
                quote = true;
            } else if (c <= COMMENT) {
                // Some other chars at the start of a value caused the parser to fail, so for now
                // encapsulate if we start in anything less than '#'. We are being conservative
                // by including the default comment char too.
                quote = true;
            } else {
                while (pos < end) {
                    c = value.charAt(pos);
                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                        quote = true;
                        break;
                    }
                    pos++;
                }

                if (!quote) {
                    pos = end - 1;
                    c = value.charAt(pos);
                    // Some other chars at the end caused the parser to fail, so for now
                    // encapsulate if we end in anything less than ' '
                    if (c <= SP) {
                        quote = true;
                    }
                }
            }
        }

        if (!quote) {
            // no encapsulation needed - write out the original value
            out.append(value, start, end);
            return;
        }
        break;
    default:
        throw new IllegalStateException(""Unexpected QuoteMode value: "" + quoteModePolicy);
    }

    // we hit something that needed encapsulation
    out.append(quoteChar);

    // Pick up where we left off: pos should be positioned on the first character that caused
    // the need for encapsulation.
    while (pos < end) {
        final char c = value.charAt(pos);
        if (c == quoteChar) {
            // write out the chunk up until this point

            // add up the previous characters including the quote character
            out.append(value, start, pos + 1);
            // escape the quote character by doubling it
            out.append(quoteChar);
            // put the next starting position after the current quote character 
            start = pos + 1;
        }
        pos++;
    }

    // write the last segment
    if (start < end) {
        out.append(value, start, end);
    }
    out.append(quoteChar);
}",0,0
196,Csv_15,"private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,
            final Appendable out, final boolean newRecord) throws IOException {
        boolean quote = false;
        int start = offset;
        int pos = offset;
        final int end = offset + len;

        final char delimChar = getDelimiter();
        final char quoteChar = getQuoteCharacter().charValue();

        QuoteMode quoteModePolicy = getQuoteMode();
        if (quoteModePolicy == null) {
            quoteModePolicy = QuoteMode.MINIMAL;
        }
        switch (quoteModePolicy) {
        case ALL:
        case ALL_NON_NULL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
            // Use the existing escaping code
            printAndEscape(value, offset, len, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                // always quote an empty token that is the first
                // on the line, as it may be the only thing on the
                // line. If it were not quoted in that case,
                // an empty line has no tokens.
                if (newRecord) {
                    quote = true;
                }
             } else {
                 char c = value.charAt(pos);
 
                 if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {
                     quote = true;
                 } else if (c <= COMMENT) {
                     // Some other chars at the start of a value caused the parser to fail, so for now
                     // encapsulate if we start in anything less than '#'. We are being conservative
                     // by including the default comment char too.
                    quote = true;
                } else {
                    while (pos < end) {
                        c = value.charAt(pos);
                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }

                    if (!quote) {
                        pos = end - 1;
                        c = value.charAt(pos);
                        // Some other chars at the end caused the parser to fail, so for now
                        // encapsulate if we end in anything less than ' '
                        if (c <= SP) {
                            quote = true;
                        }
                    }
                }
            }

            if (!quote) {
                // no encapsulation needed - write out the original value
                out.append(value, start, end);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
        }

        if (!quote) {
            // no encapsulation needed - write out the original value
            out.append(value, start, end);
            return;
        }

        // we hit something that needed encapsulation
        out.append(quoteChar);

        // Pick up where we left off: pos should be positioned on the first character that caused
        // the need for encapsulation.
        while (pos < end) {
            final char c = value.charAt(pos);
            if (c == quoteChar) {
                // write out the chunk up until this point

                // add 1 to the length to write out the encapsulator also
                out.append(value, start, pos + 1);
                // put the next starting position on the encapsulator so we will
                // write it out again with the next string (effectively doubling it)
                start = pos;
            }
            pos++;
        }

        // write the last segment
        out.append(value, start, pos);
        out.append(quoteChar);
    }","private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,
            final Appendable out, final boolean newRecord) throws IOException {
        boolean quote = false;
        int start = offset;
        int pos = offset;
        final int end = offset + len;

        final char delimChar = getDelimiter();
        final char quoteChar = getQuoteCharacter().charValue();

        QuoteMode quoteModePolicy = getQuoteMode();
        if (quoteModePolicy == null) {
            quoteModePolicy = QuoteMode.MINIMAL;
        }
        switch (quoteModePolicy) {
        case ALL:
        case ALL_NON_NULL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
            // Use the existing escaping code
            printAndEscape(value, offset, len, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                // always quote an empty token that is the first
                // on the line, as it may be the only thing on the
                // line. If it were not quoted in that case,
                // an empty line has no tokens.
                if (newRecord) {
                    quote = true;
                }
             } else {
                 char c = value.charAt(pos);
 
                 if (newRecord && (c < 0x20 || (c > 0x21 && c < 0x23) || (c > 0x2B && c < 0x2D) || c > 0x7E)) {
                     quote = true;
                 } else if (c <= COMMENT) {
                     // Some other chars at the start of a value caused the parser to fail, so for now
                     // encapsulate if we start in anything less than '#'. We are being conservative
                     // by including the default comment char too.
                    quote = true;
                } else {
                    while (pos < end) {
                        c = value.charAt(pos);
                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }

                    if (!quote) {
                        pos = end - 1;
                        c = value.charAt(pos);
                        // Some other chars at the end caused the parser to fail, so for now
                        // encapsulate if we end in anything less than ' '
                        if (c <= SP) {
                            quote = true;
                        }
                    }
                }
            }

            if (!quote) {
                // no encapsulation needed - write out the original value
                out.append(value, start, end);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
        }

        // we hit something that needed encapsulation
        out.append(quoteChar);

        // Pick up where we left off: pos should be positioned correctly
        while (pos < end) {
            final char c = value.charAt(pos);
            if (c == quoteChar) {
                // write out the chunk up until this point
                out.append(value, start, pos);
                // write the encapsulator twice for escaping
                out.append(quoteChar).append(quoteChar);
                start = pos + 1; // move start position to next character
            }
            pos++;
        }

        // write the last segment
        out.append(value, start, end);
        out.append(quoteChar);
    }",0,0
197,Csv_2,"public String get(final String name) {
        if (mapping == null) {
            throw new IllegalStateException(
                     ""No header mapping was specified, the record values can't be accessed by name"");
         }
         final Integer index = mapping.get(name);
             return index != null ? values[index.intValue()] : null;
     }","public String get(final String name) {
    if (mapping == null) {
        throw new IllegalStateException(
                ""No header mapping was specified, the record values can't be accessed by name"");
    }
    
    // Ensure name is not null to avoid potential NullPointerException
    if (name == null) {
        throw new IllegalArgumentException(""The name parameter cannot be null"");
    }
    
    final Integer index = mapping.get(name);
    
    // Ensure index is within bounds of the values array
    return (index != null && index.intValue() >= 0 && index.intValue() < values.length) 
            ? values[index.intValue()] 
            : null;
}",0,0
198,Csv_3,"int readEscape() throws IOException {
        // the escape char has just been read (normally a backslash)
        final int c = in.read();
        switch (c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        case FF: // TODO is this correct?
        case TAB: // TODO is this correct? Do tabs need to be escaped?
        case BACKSPACE: // TODO is this correct?
            return c;
        case END_OF_STREAM:
             throw new IOException(""EOF whilst processing escape sequence"");
         default:
             // Now check for meta-characters
                 return c;
             // indicate unexpected char - available from in.getLastChar()
         }
     }","int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch (c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        case FF:
        case TAB:
        case BACKSPACE:
            return c;
        case -1: // EOF
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            return c;
    }
}",0,0
199,Csv_4,"    public Map<String, Integer> getHeaderMap() {
        return new LinkedHashMap<String, Integer>(this.headerMap);
    }
","public Map<String, Integer> getHeaderMap() {
    return (this.headerMap != null) ? new LinkedHashMap<>(this.headerMap) : new LinkedHashMap<>();
}",0,0
200,Csv_5,"public void println() throws IOException {
         final String recordSeparator = format.getRecordSeparator();
             out.append(recordSeparator);
         newRecord = true;
     }","public void println() throws IOException {
    if (out == null || format == null) {
        throw new IOException(""Output stream or format is not initialized."");
    }
    
    final String recordSeparator = format.getRecordSeparator();
    if (recordSeparator == null) {
        throw new IOException(""Record separator is not defined in format."");
    }

    out.append(recordSeparator);
    newRecord = true;
}",0,0
201,Csv_6,"<M extends Map<String, String>> M putIn(final M map) {
         for (final Entry<String, Integer> entry : mapping.entrySet()) {
             final int col = entry.getValue().intValue();
                 map.put(entry.getKey(), values[col]);
         }
         return map;
     }","<M extends Map<String, String>> M putIn(final M map) {
    if (map == null || mapping == null || values == null) {
        throw new IllegalArgumentException(""Input map, mapping, or values cannot be null."");
    }
    for (final Entry<String, Integer> entry : mapping.entrySet()) {
        final int col = entry.getValue();
        if (col < 0 || col >= values.length) {
            throw new IndexOutOfBoundsException(""Index out of bounds for values array: "" + col);
        }
        map.put(entry.getKey(), values[col]);
    }
    return map;
}",0,0
202,Csv_9,"<M extends Map<String, String>> M putIn(final M map) {
         for (final Entry<String, Integer> entry : mapping.entrySet()) {
             final int col = entry.getValue().intValue();
             if (col < values.length) {
                map.put(entry.getKey(), values[col]);
            }
        }
        return map;
    }","<M extends Map<String, String>> M putIn(final M map) {
    if (map == null || mapping == null || values == null) {
        throw new IllegalArgumentException(""Input map, mapping, or values cannot be null."");
    }
    for (final Entry<String, Integer> entry : mapping.entrySet()) {
        final Integer colValue = entry.getValue();
        
        if (colValue == null) {
            throw new IllegalArgumentException(""Mapping entry value cannot be null."");
        }
        
        final int col = colValue.intValue();
        if (col >= 0 && col < values.length) {
            map.put(entry.getKey(), values[col]);
        }
    }
    return map;
}",0,0
203,Gson_11,"@Override
    public Number read(JsonReader in) throws IOException {
      JsonToken jsonToken = in.peek();
      switch (jsonToken) {
      case NULL:
         in.nextNull();
         return null;
       case NUMBER:
         return new LazilyParsedNumber(in.nextString());
       default:
         throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken);
      }
    }","@Override
public Number read(JsonReader in) throws IOException {
    JsonToken jsonToken = in.peek();
    switch (jsonToken) {
        case NULL:
            in.nextNull();
            return null;
        case NUMBER:
            try {
                return new LazilyParsedNumber(in.nextString());
            } catch (NumberFormatException e) {
                throw new JsonSyntaxException(""Expecting a valid number format, got: "" + in.nextString(), e);
            }
        default:
            throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken);
    }
}",0,0
204,Gson_12,"@Override public void skipValue() throws IOException {
    if (peek() == JsonToken.NAME) {
      nextName();
       pathNames[stackSize - 2] = ""null"";
     } else {
       popStack();
         pathNames[stackSize - 1] = ""null"";
     }
       pathIndices[stackSize - 1]++;
   }","@Override public void skipValue() throws IOException {
    if (peek() == JsonToken.NAME) {
        nextName();
        if (stackSize >= 2) { // Ensure stackSize is valid before accessing
            pathNames[stackSize - 2] = ""null"";
        }
    } else {
        popStack();
        if (stackSize > 0) { // Ensure stackSize is valid before accessing
            pathNames[stackSize - 1] = ""null"";
            pathIndices[stackSize - 1]++;
        }
    }
}",0,0
205,Gson_13,"private int peekNumber() throws IOException {
    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
    char[] buffer = this.buffer;
    int p = pos;
    int l = limit;

    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.
    boolean negative = false;
    boolean fitsInLong = true;
    int last = NUMBER_CHAR_NONE;

    int i = 0;

    charactersOfNumber:
    for (; true; i++) {
      if (p + i == l) {
        if (i == buffer.length) {
          // Though this looks like a well-formed number, it's too long to continue reading. Give up
          // and let the application handle this as an unquoted literal.
          return PEEKED_NONE;
        }
        if (!fillBuffer(i + 1)) {
          break;
        }
        p = pos;
        l = limit;
      }

      char c = buffer[p + i];
      switch (c) {
      case '-':
        if (last == NUMBER_CHAR_NONE) {
          negative = true;
          last = NUMBER_CHAR_SIGN;
          continue;
        } else if (last == NUMBER_CHAR_EXP_E) {
          last = NUMBER_CHAR_EXP_SIGN;
          continue;
        }
        return PEEKED_NONE;

      case '+':
        if (last == NUMBER_CHAR_EXP_E) {
          last = NUMBER_CHAR_EXP_SIGN;
          continue;
        }
        return PEEKED_NONE;

      case 'e':
      case 'E':
        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {
          last = NUMBER_CHAR_EXP_E;
          continue;
        }
        return PEEKED_NONE;

      case '.':
        if (last == NUMBER_CHAR_DIGIT) {
          last = NUMBER_CHAR_DECIMAL;
          continue;
        }
        return PEEKED_NONE;

      default:
        if (c < '0' || c > '9') {
          if (!isLiteral(c)) {
            break charactersOfNumber;
          }
          return PEEKED_NONE;
        }
        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {
          value = -(c - '0');
          last = NUMBER_CHAR_DIGIT;
        } else if (last == NUMBER_CHAR_DIGIT) {
          if (value == 0) {
            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).
          }
          long newValue = value * 10 - (c - '0');
          fitsInLong &= value > MIN_INCOMPLETE_INTEGER
              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);
          value = newValue;
        } else if (last == NUMBER_CHAR_DECIMAL) {
          last = NUMBER_CHAR_FRACTION_DIGIT;
        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {
          last = NUMBER_CHAR_EXP_DIGIT;
        }
      }
     }
 
     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
     if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {
       peekedLong = negative ? value : -value;
       pos += i;
       return peeked = PEEKED_LONG;
    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT
        || last == NUMBER_CHAR_EXP_DIGIT) {
      peekedNumberLength = i;
      return peeked = PEEKED_NUMBER;
    } else {
      return PEEKED_NONE;
    }
  }","private int peekNumber() throws IOException {
    // Use locals 'p' and 'l' to save inner-loop field access like nextNonWhitespace.
    char[] buffer = this.buffer;
    int p = pos;
    int l = limit;

    long value = 0; // Negative to handle Long.MIN_VALUE more easily.
    boolean negative = false;
    boolean fitsInLong = true;
    int last = NUMBER_CHAR_NONE;

    int i = 0;

    charactersOfNumber:
    for (; true; i++) {
        if (p + i == l) {
            if (i == buffer.length) {
                // Number is too long to continue reading; handle this as a literal.
                return PEEKED_NONE;
            }
            if (!fillBuffer(i + 1)) {
                break;
            }
            p = pos;
            l = limit;
        }

        char c = buffer[p + i];
        switch (c) {
            case '-':
                if (last == NUMBER_CHAR_NONE) {
                    negative = true;
                    last = NUMBER_CHAR_SIGN;
                    continue;
                } else if (last == NUMBER_CHAR_EXP_E) {
                    last = NUMBER_CHAR_EXP_SIGN;
                    continue;
                }
                return PEEKED_NONE;

            case '+':
                if (last == NUMBER_CHAR_EXP_E) {
                    last = NUMBER_CHAR_EXP_SIGN;
                    continue;
                }
                return PEEKED_NONE;

            case 'e':
            case 'E':
                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {
                    last = NUMBER_CHAR_EXP_E;
                    continue;
                }
                return PEEKED_NONE;

            case '.':
                if (last == NUMBER_CHAR_DIGIT) {
                    last = NUMBER_CHAR_DECIMAL;
                    continue;
                }
                return PEEKED_NONE;

            default:
                if (c < '0' || c > '9') {
                    if (!isLiteral(c)) {
                        break charactersOfNumber;
                    }
                    return PEEKED_NONE;
                }
                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {
                    value = -(c - '0');
                    last = NUMBER_CHAR_DIGIT;
                } else if (last == NUMBER_CHAR_DIGIT) {
                    if (value == 0) {
                        return PEEKED_NONE; // Leading zeroes are not allowed.
                    }
                    long newValue = value * 10 - (c - '0');
                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER
                        || (value == MIN_INCOMPLETE_INTEGER && newValue < value);
                    value = newValue;
                } else if (last == NUMBER_CHAR_DECIMAL) {
                    last = NUMBER_CHAR_FRACTION_DIGIT;
                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {
                    last = NUMBER_CHAR_EXP_DIGIT;
                }
        }
    }

    // Determine if the number can be classified as PEEKED_LONG or PEEKED_NUMBER.
    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {
        peekedLong = negative ? value : -value;
        pos += i;
        return peeked = PEEKED_LONG;
    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT
               || last == NUMBER_CHAR_EXP_DIGIT) {
        peekedNumberLength = i;
        pos += i; // Ensure we adjust the position after processing the number.
        return peeked = PEEKED_NUMBER;
    } else {
        return PEEKED_NONE;
    }
}",0,0
206,Gson_15,"public JsonWriter value(double value) throws IOException {
     writeDeferredName();
     if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
     }
     beforeValue();
    out.append(Double.toString(value));
    return this;
  }","public JsonWriter value(double value) throws IOException {
    writeDeferredName();
    if (Double.isNaN(value) || Double.isInfinite(value)) {
        throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
    }
    beforeValue();
    out.append(String.valueOf(value)); // Use String.valueOf to avoid potential formatting issues
    return this;
}",0,0
207,Gson_17,"    synchronized (localFormat) {
      String dateFormatAsString = enUsFormat.format(value);
      out.value(dateFormatAsString);
    }
","synchronized (localFormat) {
    if (value == null) {
        out.nullValue();
    } else {
        String dateFormatAsString = enUsFormat.format(value);
        out.value(dateFormatAsString);
    }
}",0,0
208,Gson_18,"static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
       // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead
     checkArgument(supertype.isAssignableFrom(contextRawType));
     return resolve(context, contextRawType,
         $Gson$Types.getGenericSupertype(context, contextRawType, supertype));
  }","static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
    checkArgument(supertype.isAssignableFrom(contextRawType), ""contextRawType must be a subtype of supertype"");
    Type resolvedSupertype = $Gson$Types.getGenericSupertype(context, contextRawType, supertype);
    return resolve(context, contextRawType, resolvedSupertype);
}",0,0
209,Gson_5,"public static Date parse(String date, ParsePosition pos) throws ParseException {
        Exception fail = null;
        try {
            int offset = pos.getIndex();

            // extract year
            int year = parseInt(date, offset, offset += 4);
            if (checkOffset(date, offset, '-')) {
                offset += 1;
            }

            // extract month
            int month = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, '-')) {
                offset += 1;
            }

            // extract day
            int day = parseInt(date, offset, offset += 2);
            // default time value
            int hour = 0;
            int minutes = 0;
            int seconds = 0;
            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time

            // if the value has no time component (and no time zone), we are done
            boolean hasT = checkOffset(date, offset, 'T');
            
            if (!hasT && (date.length() <= offset)) {
                Calendar calendar = new GregorianCalendar(year, month - 1, day);

                pos.setIndex(offset);
                return calendar.getTime();
            }

            if (hasT) {

                // extract hours, minutes, seconds and milliseconds
                hour = parseInt(date, offset += 1, offset += 2);
                if (checkOffset(date, offset, ':')) {
                    offset += 1;
                }

                minutes = parseInt(date, offset, offset += 2);
                if (checkOffset(date, offset, ':')) {
                    offset += 1;
                }
                // second and milliseconds can be optional
                if (date.length() > offset) {
                    char c = date.charAt(offset);
                    if (c != 'Z' && c != '+' && c != '-') {
                        seconds = parseInt(date, offset, offset += 2);
                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
                        // milliseconds can be optional in the format
                        if (checkOffset(date, offset, '.')) {
                            offset += 1;
                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
                            int fraction = parseInt(date, offset, parseEndOffset);
                            // compensate for ""missing"" digits
                            switch (parseEndOffset - offset) { // number of digits parsed
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                            }
                            offset = endOffset;
                        }
                    }
                }
            }

            // extract timezone
            if (date.length() <= offset) {
                throw new IllegalArgumentException(""No time zone indicator"");
            }

            TimeZone timezone = null;
            char timezoneIndicator = date.charAt(offset);

            if (timezoneIndicator == 'Z') {
                timezone = TIMEZONE_UTC;
                offset += 1;
            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
                 String timezoneOffset = date.substring(offset);
 
                 // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
 
                 offset += timezoneOffset.length();
                 // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
                if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                    timezone = TIMEZONE_UTC;
                } else {
                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
                    //    not sure why, but that's the way it looks. Further, Javadocs for
                    //    `java.util.TimeZone` specifically instruct use of GMT as base for
                    //    custom timezones... odd.
                    String timezoneId = ""GMT"" + timezoneOffset;
//                    String timezoneId = ""UTC"" + timezoneOffset;

                    timezone = TimeZone.getTimeZone(timezoneId);

                    String act = timezone.getID();
                    if (!act.equals(timezoneId)) {
                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
                         *    one without. If so, don't sweat.
                         *   Yes, very inefficient. Hopefully not hit often.
                         *   If it becomes a perf problem, add 'loose' comparison instead.
                         */
                        String cleaned = act.replace("":"", """");
                        if (!cleaned.equals(timezoneId)) {
                            throw new IndexOutOfBoundsException(""Mismatching time zone indicator: ""+timezoneId+"" given, resolves to ""
                                    +timezone.getID());
                        }
                    }
                }
            } else {
                throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator+""'"");
            }

            Calendar calendar = new GregorianCalendar(timezone);
            calendar.setLenient(false);
            calendar.set(Calendar.YEAR, year);
            calendar.set(Calendar.MONTH, month - 1);
            calendar.set(Calendar.DAY_OF_MONTH, day);
            calendar.set(Calendar.HOUR_OF_DAY, hour);
            calendar.set(Calendar.MINUTE, minutes);
            calendar.set(Calendar.SECOND, seconds);
            calendar.set(Calendar.MILLISECOND, milliseconds);

            pos.setIndex(offset);
            return calendar.getTime();
            // If we get a ParseException it'll already have the right message/offset.
            // Other exception types can convert here.
        } catch (IndexOutOfBoundsException e) {
            fail = e;
        } catch (NumberFormatException e) {
            fail = e;
        } catch (IllegalArgumentException e) {
            fail = e;
        }
        String input = (date == null) ? null : ('""' + date + ""'"");
        String msg = fail.getMessage();
        if (msg == null || msg.isEmpty()) {
            msg = ""(""+fail.getClass().getName()+"")"";
        }
        ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
        ex.initCause(fail);
        throw ex;
    }","public static Date parse(String date, ParsePosition pos) throws ParseException {
    Exception fail = null;
    try {
        int offset = pos.getIndex();

        // extract year
        int year = parseInt(date, offset, offset += 4);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }

        // extract month
        int month = parseInt(date, offset, offset += 2);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }

        // extract day
        int day = parseInt(date, offset, offset += 2);
        // default time value
        int hour = 0;
        int minutes = 0;
        int seconds = 0;
        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time

        // if the value has no time component (and no time zone), we are done
        boolean hasT = checkOffset(date, offset, 'T');
        
        if (!hasT && (date.length() <= offset)) {
            Calendar calendar = new GregorianCalendar(year, month - 1, day);

            pos.setIndex(offset);
            return calendar.getTime();
        }

        if (hasT) {

            // extract hours, minutes, seconds and milliseconds
            hour = parseInt(date, offset += 1, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }

            minutes = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            // second and milliseconds can be optional
            if (date.length() > offset) {
                char c = date.charAt(offset);
                if (c != 'Z' && c != '+' && c != '-') {
                    seconds = parseInt(date, offset, offset += 2);
                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
                    // milliseconds can be optional in the format
                    if (checkOffset(date, offset, '.')) {
                        offset += 1;
                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
                        int fraction = parseInt(date, offset, parseEndOffset);
                        // compensate for ""missing"" digits
                        switch (parseEndOffset - offset) { // number of digits parsed
                        case 2:
                            milliseconds = fraction * 10;
                            break;
                        case 1:
                            milliseconds = fraction * 100;
                            break;
                        default:
                            milliseconds = fraction;
                        }
                        offset = endOffset;
                    }
                }
            }
        }

        // extract timezone
        if (date.length() <= offset) {
            throw new IllegalArgumentException(""No time zone indicator"");
        }

        TimeZone timezone = null;
        char timezoneIndicator = date.charAt(offset);

        if (timezoneIndicator == 'Z') {
            timezone = TIMEZONE_UTC;
            offset += 1;
        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
             String timezoneOffset = date.substring(offset);

             // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
             offset += timezoneOffset.length();
             // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
            if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                timezone = TIMEZONE_UTC;
            } else {
                String timezoneId = ""GMT"" + timezoneOffset;
                timezone = TimeZone.getTimeZone(timezoneId);
                // Check for mismatch
                String act = timezone.getID();
                if (!act.equals(timezoneId)) {
                    // Adjust for canonical ID without colons
                    String cleaned = act.replace("":"", """");
                    if (!cleaned.equals(timezoneId.replace("":"", """"))) {
                        throw new IndexOutOfBoundsException(""Mismatching time zone indicator: "" + timezoneId + "" given, resolves to ""
                                + timezone.getID());
                    }
                }
            }
        } else {
            throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator + ""'"");
        }

        Calendar calendar = new GregorianCalendar(timezone);
        calendar.setLenient(false);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, seconds);
        calendar.set(Calendar.MILLISECOND, milliseconds);

        pos.setIndex(offset);
        return calendar.getTime();
    } catch (IndexOutOfBoundsException | NumberFormatException | IllegalArgumentException e) {
        fail = e;
    }
    String input = (date == null) ? null : ('""' + date + '""');
    String msg = fail.getMessage();
    if (msg == null || msg.isEmpty()) {
        msg = ""("" + fail.getClass().getName() + "")"";
    }
    ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
    ex.initCause(fail);
    throw ex;
}",0,0
210,Gson_6,"@SuppressWarnings(""unchecked"") // Casts guarded by conditionals.
  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
      TypeToken<?> fieldType, JsonAdapter annotation) {
    Class<?> value = annotation.value();
    TypeAdapter<?> typeAdapter;
    if (TypeAdapter.class.isAssignableFrom(value)) {
      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;
      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();
    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {
      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;
      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))
          .construct()
          .create(gson, fieldType);
    } else {
       throw new IllegalArgumentException(
           ""@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."");
     }
       typeAdapter = typeAdapter.nullSafe();
     return typeAdapter;
   }","@SuppressWarnings(""unchecked"") // Casts guarded by conditionals.
static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
    TypeToken<?> fieldType, JsonAdapter annotation) {
  Class<?> value = annotation.value();
  TypeAdapter<?> typeAdapter;

  if (TypeAdapter.class.isAssignableFrom(value)) {
    Class<? extends TypeAdapter<?>> typeAdapterClass = (Class<? extends TypeAdapter<?>>) value;
    typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();
  } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {
    Class<? extends TypeAdapterFactory> typeAdapterFactory = (Class<? extends TypeAdapterFactory>) value;
    typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))
        .construct()
        .create(gson, fieldType);
  } else {
    throw new IllegalArgumentException(
        ""@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."");
  }

  typeAdapter = typeAdapter.nullSafe();
  return typeAdapter;
}",0,0
211,JacksonCore_11,"private void _verifySharing()
    {
        if (_hashShared) {
            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);
            _names = Arrays.copyOf(_names, _names.length);
             _hashShared = false;
             // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure
             //    we rehash as needed, as need-rehash flag is not copied from parent
         }
         if (_needRehash) {
             rehash();
        }
    }","private void _verifySharing()
    {
        if (_hashShared) {
            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);
            if (_names != null) {
                _names = Arrays.copyOf(_names, _names.length);
            }
            _hashShared = false;
            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure
            //    we rehash as needed, as need-rehash flag is not copied from parent
        }
        if (_needRehash) {
            rehash();
        }
    }",0,0
212,JacksonCore_15,"@Override
    public JsonToken nextToken() throws IOException
    {
     	//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken
     	// check for no buffered context _exposedContext - null
     	//If all the conditions matches then check for scalar / non-scalar property
     		//if not scalar and ended successfully, then return null
     		//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once
     		// then return null 
         // Anything buffered?
         TokenFilterContext ctxt = _exposedContext;
 
        if (ctxt != null) {
            while (true) {
                JsonToken t = ctxt.nextTokenToRead();
                if (t != null) {
                    _currToken = t;
                    return t;
                }
                // all done with buffered stuff?
                if (ctxt == _headContext) {
                    _exposedContext = null;
                    if (ctxt.inArray()) {
                        t = delegate.getCurrentToken();
// Is this guaranteed to work without further checks?
//                        if (t != JsonToken.START_ARRAY) {
                        _currToken = t;
                        return t;
                    }

                    // Almost! Most likely still have the current token;
                    // with the sole exception of 
                    /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                    break;
                }
                // If not, traverse down the context chain
                ctxt = _headContext.findChildOf(ctxt);
                _exposedContext = ctxt;
                if (ctxt == null) { // should never occur
                    throw _constructError(""Unexpected problem: chain of filtered context broken"");
                }
            }
        }

        // If not, need to read more. If we got any:
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // no strict need to close, since we have no state here
            return (_currToken = t);
        }

        // otherwise... to include or not?
        TokenFilter f;
        
        switch (t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) { // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;

        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) { // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;

        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;

        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }

        default: // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                f = _headContext.checkValue(f);
                if ((f == TokenFilter.INCLUDE_ALL)
                        || ((f != null) && f.includeValue(delegate))) {
                    return (_currToken = t);
                }
            }
            // Otherwise not included (leaves must be explicitly included)
            break;
        }

        // We get here if token was not yet found; offlined handling
        return _nextToken2();
    }","@Override
public JsonToken nextToken() throws IOException {
    // Check for buffer context
    TokenFilterContext ctxt = _exposedContext;

    if (ctxt != null) {
        while (true) {
            JsonToken t = ctxt.nextTokenToRead();
            if (t != null) {
                _currToken = t;
                return t;
            }
            if (ctxt == _headContext) {
                _exposedContext = null;
                t = delegate.getCurrentToken();
                _currToken = t;
                return t;
            }
            ctxt = _headContext.findChildOf(ctxt);
            _exposedContext = ctxt;
            if (ctxt == null) {
                throw _constructError(""Unexpected problem: chain of filtered context broken"");
            }
        }
    }

    JsonToken t = delegate.nextToken();
    if (t == null) {
        return (_currToken = t);
    }

    TokenFilter f;

    switch (t.id()) {
    case ID_START_ARRAY:
        f = _itemFilter;
        if (f == TokenFilter.INCLUDE_ALL) {
            _headContext = _headContext.createChildArrayContext(f, true);
            return (_currToken = t);
        }
        if (f == null || (f = _headContext.checkValue(f)) == null) {
            delegate.skipChildren();
            break;
        }
        if (f != TokenFilter.INCLUDE_ALL) {
            f = f.filterStartArray();
        }
        _itemFilter = f;
        _headContext = _headContext.createChildArrayContext(f, f == TokenFilter.INCLUDE_ALL);
        if (_includePath) {
            t = _nextTokenWithBuffering(_headContext);
            if (t != null) {
                _currToken = t;
                return t;
            }
        }
        break;

    case ID_START_OBJECT:
        f = _itemFilter;
        if (f == TokenFilter.INCLUDE_ALL) {
            _headContext = _headContext.createChildObjectContext(f, true);
            return (_currToken = t);
        }
        if (f == null || (f = _headContext.checkValue(f)) == null) {
            delegate.skipChildren();
            break;
        }
        if (f != TokenFilter.INCLUDE_ALL) {
            f = f.filterStartObject();
        }
        _itemFilter = f;
        _headContext = _headContext.createChildObjectContext(f, f == TokenFilter.INCLUDE_ALL);
        if (_includePath) {
            t = _nextTokenWithBuffering(_headContext);
            if (t != null) {
                _currToken = t;
                return t;
            }
        }
        break;

    case ID_END_ARRAY:
    case ID_END_OBJECT:
        boolean returnEnd = _headContext.isStartHandled();
        f = _headContext.getFilter();
        if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
            f.filterFinishArray();
        }
        _headContext = _headContext.getParent();
        _itemFilter = _headContext.getFilter();
        if (returnEnd) {
            return (_currToken = t);
        }
        break;

    case ID_FIELD_NAME:
        final String name = delegate.getCurrentName();
        f = _headContext.setFieldName(name);
        if (f == TokenFilter.INCLUDE_ALL) {
            _itemFilter = f;
            if (!_includePath && _includeImmediateParent && !_headContext.isStartHandled()) {
                t = _headContext.nextTokenToRead();
                _exposedContext = _headContext;
            }
            return (_currToken = t);
        }
        if (f == null || (f = f.includeProperty(name)) == null) {
            delegate.nextToken();
            delegate.skipChildren();
            break;
        }
        _itemFilter = f;
        if (f == TokenFilter.INCLUDE_ALL && _includePath) {
            return (_currToken = t);
        }
        if (_includePath) {
            t = _nextTokenWithBuffering(_headContext);
            if (t != null) {
                _currToken = t;
                return t;
            }
        }
        break;

    default:
        f = _itemFilter;
        if (f == TokenFilter.INCLUDE_ALL) {
            return (_currToken = t);
        }
        if (f != null) {
            f = _headContext.checkValue(f);
            if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                return (_currToken = t);
            }
        }
        break;
    }
    return _nextToken2();
}",0,0
213,JacksonCore_20,"public void writeEmbeddedObject(Object object) throws IOException {
         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases
         throw new JsonGenerationException(""No native support for writing embedded objects"",
                 this);
     }","public void writeEmbeddedObject(Object object) throws IOException {
    
    // 01-Sep-2016, tatu: As per [core#318], handle small number of cases
    
    if (object == null) {
        writeNull();
        return;
    }

    if (object instanceof byte[]) {
        writeBinary((byte[]) object);
        return;
    }

    // Other object types can be handled here, e.g., special serialization support for certain types

    // If types are not handled, fall back to exception
    throw new JsonGenerationException(""No native support for writing embedded objects of type: ""
            + object.getClass().getName(), this);
}",0,0
214,JacksonCore_21,"@Override
    public JsonToken nextToken() throws IOException
    {
        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
        //    conditionals; and it seems odd to return `null` but NOT considering input
        //    as closed... would love a rewrite to simplify/clear up logic here.
        
        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
        // check for no buffered context _exposedContext - null
        // If all the conditions matches then check for scalar / non-scalar property
        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
            //if not scalar and ended successfully, and !includePath, then return null
                if (_currToken.isStructEnd()) {
                    if (_headContext.isStartHandled()) {
                        return (_currToken = null);
                    }
                } else if (_currToken.isScalarValue()) {
                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once
                    // then return null 
                     if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
                         return (_currToken = null);
                     }
             }
         }
         // Anything buffered?
        TokenFilterContext ctxt = _exposedContext;

        if (ctxt != null) {
            while (true) {
                JsonToken t = ctxt.nextTokenToRead();
                if (t != null) {
                    _currToken = t;
                    return t;
                }
                // all done with buffered stuff?
                if (ctxt == _headContext) {
                    _exposedContext = null;
                    if (ctxt.inArray()) {
                        t = delegate.getCurrentToken();
// Is this guaranteed to work without further checks?
//                        if (t != JsonToken.START_ARRAY) {
                        _currToken = t;
                        return t;
                    }

                    // Almost! Most likely still have the current token;
                    // with the sole exception of 
                    /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                    break;
                }
                // If not, traverse down the context chain
                ctxt = _headContext.findChildOf(ctxt);
                _exposedContext = ctxt;
                if (ctxt == null) { // should never occur
                    throw _constructError(""Unexpected problem: chain of filtered context broken"");
                }
            }
        }

        // If not, need to read more. If we got any:
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // no strict need to close, since we have no state here
            _currToken = t;
            return t;
        }

        // otherwise... to include or not?
        TokenFilter f;
        
        switch (t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) { // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;

        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) { // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;

        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;

        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }

        default: // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                f = _headContext.checkValue(f);
                if ((f == TokenFilter.INCLUDE_ALL)
                        || ((f != null) && f.includeValue(delegate))) {
                    return (_currToken = t);
                }
            }
            // Otherwise not included (leaves must be explicitly included)
            break;
        }

        // We get here if token was not yet found; offlined handling
        return _nextToken2();
    }","@Override
public JsonToken nextToken() throws IOException {
    // Initial checks
    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
        if (_currToken.isStructEnd() && _headContext.isStartHandled()) {
            return (_currToken = null);
        } else if (_currToken.isScalarValue() && !_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
            return (_currToken = null);
        }
    }

    // Process exposed or buffered context
    TokenFilterContext ctxt = _exposedContext;
    if (ctxt != null) {
        while (true) {
            JsonToken t = ctxt.nextTokenToRead();
            if (t != null) {
                _currToken = t;
                return t;
            }
            if (ctxt == _headContext) {
                _exposedContext = null;
                if (ctxt.inArray()) {
                    _currToken = delegate.getCurrentToken();
                    return _currToken;
                }
                break;
            }
            ctxt = _headContext.findChildOf(ctxt);
            _exposedContext = ctxt;
            if (ctxt == null) {
                throw _constructError(""Unexpected problem: chain of filtered context broken"");
            }
        }
    }

    // Process next token from delegate
    JsonToken t = delegate.nextToken();
    if (t == null) {
        _currToken = t;
        return t;
    }

    TokenFilter f;
    switch (t.id()) {
        case ID_START_ARRAY:
            f = processStartArray(t);
            break;
        case ID_START_OBJECT:
            f = processStartObject(t);
            break;
        case ID_END_ARRAY:
        case ID_END_OBJECT:
            f = processEndStruct(t);
            if (f != null) {
                return (_currToken = t);
            }
            break;
        case ID_FIELD_NAME:
            f = processFieldName(t);
            if (f != null) {
                return (_currToken = t);
            }
            break;
        default: // scalar value
            f = processScalarValue(t);
            if (f != null) {
                return (_currToken = t);
            }
            break;
    }

    return _nextToken2();
}

private TokenFilter processStartArray(JsonToken t) throws IOException {
    TokenFilter f = _itemFilter;
    if (f == TokenFilter.INCLUDE_ALL) {
        _headContext = _headContext.createChildArrayContext(f, true);
        return f;
    }
    if (f == null) {
        delegate.skipChildren();
        return null;
    }
    f = _headContext.checkValue(f);
    if (f == null) {
        delegate.skipChildren();
        return null;
    }
    if (f != TokenFilter.INCLUDE_ALL) {
        f = f.filterStartArray();
    }
    _itemFilter = f;
    _headContext = _headContext.createChildArrayContext(f, f == TokenFilter.INCLUDE_ALL);
    if (_includePath) {
        JsonToken bufferedToken = _nextTokenWithBuffering(_headContext);
        if (bufferedToken != null) {
            _currToken = bufferedToken;
            return bufferedToken;
        }
    }
    return null;
}

private TokenFilter processStartObject(JsonToken t) throws IOException {
    TokenFilter f = _itemFilter;
    if (f == TokenFilter.INCLUDE_ALL) {
        _headContext = _headContext.createChildObjectContext(f, true);
        return f;
    }
    if (f == null) {
        delegate.skipChildren();
        return null;
    }
    f = _headContext.checkValue(f);
    if (f == null) {
        delegate.skipChildren();
        return null;
    }
    if (f != TokenFilter.INCLUDE_ALL) {
        f = f.filterStartObject();
    }
    _itemFilter = f;
    _headContext = _headContext.createChildObjectContext(f, f == TokenFilter.INCLUDE_ALL);
    if (_includePath) {
        JsonToken bufferedToken = _nextTokenWithBuffering(_headContext);
        if (bufferedToken != null) {
            _currToken = bufferedToken;
            return bufferedToken;
        }
    }
    return null;
}

private TokenFilter processEndStruct(JsonToken t) {
    boolean returnEnd = _headContext.isStartHandled();
    TokenFilter f = _headContext.getFilter();
    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
        f.filterFinishArray();
    }
    _headContext = _headContext.getParent();
    _itemFilter = _headContext.getFilter();
    return returnEnd ? f : null;
}

private TokenFilter processFieldName(JsonToken t) throws IOException {
    String name = delegate.getCurrentName();
    TokenFilter f = _headContext.setFieldName(name);
    if (f == TokenFilter.INCLUDE_ALL) {
        _itemFilter = f;
        if (!_includePath) {
            if (_includeImmediateParent && !_headContext.isStartHandled()) {
                t = _headContext.nextTokenToRead();
                _exposedContext = _headContext;
            }
        }
        return f;
    }
    if (f == null) {
        delegate.nextToken();
        delegate.skipChildren();
        return null;
    }
    f = f.includeProperty(name);
    if (f == null) {
        delegate.nextToken();
        delegate.skipChildren();
        return null;
    }
    _itemFilter = f;
    if (f == TokenFilter.INCLUDE_ALL && _includePath) {
        return f;
    }
    if (_includePath) {
        JsonToken bufferedToken = _nextTokenWithBuffering(_headContext);
        if (bufferedToken != null) {
            _currToken = bufferedToken;
            return bufferedToken;
        }
    }
    return null;
}

private TokenFilter processScalarValue(JsonToken t) {
    TokenFilter f = _itemFilter;
    if (f == TokenFilter.INCLUDE_ALL) {
        return f;
    }
    if (f != null) {
        f = _headContext.checkValue(f);
        if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
            return f;
        }
    }
    return null;
}",0,0
215,JacksonCore_23,"    public DefaultPrettyPrinter createInstance() {
        return new DefaultPrettyPrinter(this);
    }
","public DefaultPrettyPrinter createInstance() {
    return new DefaultPrettyPrinter(this);
}",0,0
216,JacksonCore_25,"private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException
    {
        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));
        char[] outBuf = _textBuffer.getCurrentSegment();
        int outPtr = _textBuffer.getCurrentSegmentSize();
        final int maxCode = codes.length;

        while (true) {
            if (_inputPtr >= _inputEnd) {
                if (!_loadMore()) { // acceptable for now (will error out later)
                    break;
                }
             }
             char c = _inputBuffer[_inputPtr];
             int i = (int) c;
             if (i <= maxCode) {
                 if (codes[i] != 0) {
                     break;
                 }
            } else if (!Character.isJavaIdentifierPart(c)) {
                break;
            }
            ++_inputPtr;
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;
            // Ok, let's add char to output:
            outBuf[outPtr++] = c;

            // Need more room?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
        }
        _textBuffer.setCurrentLength(outPtr);
        {
            TextBuffer tb = _textBuffer;
            char[] buf = tb.getTextBuffer();
            int start = tb.getTextOffset();
            int len = tb.size();

            return _symbols.findSymbol(buf, start, len, hash);
        }
    }","private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException
    {
        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));
        char[] outBuf = _textBuffer.getCurrentSegment();
        int outPtr = _textBuffer.getCurrentSegmentSize();
        final int maxCode = codes.length - 1; // Adjust for correct array indexing

        while (true) {
            if (_inputPtr >= _inputEnd) {
                if (!_loadMore()) { // acceptable for now (will error out later)
                    break;
                }
             }
             char c = _inputBuffer[_inputPtr++];
             int i = (int) c;
             if (i <= maxCode) {
                 if (codes[i] != 0) {
                     break;
                 }
            } else if (!Character.isJavaIdentifierPart(c)) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;
            // Ok, let's add char to output:
            outBuf[outPtr++] = c;

            // Need more room?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
        }
        _textBuffer.setCurrentLength(outPtr);
        {
            TextBuffer tb = _textBuffer;
            char[] buf = tb.getTextBuffer();
            int start = tb.getTextOffset();
            int len = tb.size();

            return _symbols.findSymbol(buf, start, len, hash);
        }
    }",0,0
217,JacksonCore_26,"@Override
    public void feedInput(byte[] buf, int start, int end) throws IOException
    {
        // Must not have remaining input
        if (_inputPtr < _inputEnd) {
            _reportError(""Still have %d undecoded bytes, should not call 'feedInput'"", _inputEnd - _inputPtr);
        }
        if (end < start) {
            _reportError(""Input end (%d) may not be before start (%d)"", end, start);
        }
        // and shouldn't have been marked as end-of-input
        if (_endOfInput) {
            _reportError(""Already closed, can not feed more input"");
        }
        // Time to update pointers first
        _currInputProcessed += _origBufferLen;

        // Also need to adjust row start, to work as if it extended into the past wrt new buffer
         _currInputRowStart = start - (_inputEnd - _currInputRowStart);
 
         // And then update buffer settings
         _inputBuffer = buf;
         _inputPtr = start;
         _inputEnd = end;
        _origBufferLen = end - start;
    }","@Override
public void feedInput(byte[] buf, int start, int end) throws IOException
{
    // Must not have remaining input
    if (_inputPtr < _inputEnd) {
        _reportError(""Still have %d undecoded bytes, should not call 'feedInput'"", _inputEnd - _inputPtr);
    }
    if (end < start) {
        _reportError(""Input end (%d) may not be before start (%d)"", end, start);
    }
    // and shouldn't have been marked as end-of-input
    if (_endOfInput) {
        _reportError(""Already closed, cannot feed more input"");
    }
    // Time to update pointers first
    _currInputProcessed += _origBufferLen;

    // Also need to adjust row start, to work as if it extended into the past wrt new buffer
    _currInputRowStart = _currInputRowStart + (start - _inputEnd);

    // And then update buffer settings
    _inputBuffer = buf;
    _inputPtr = start;
    _inputEnd = end;
    _origBufferLen = end - start;
}",0,0
218,JacksonCore_3,"    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,
            ObjectCodec codec, BytesToNameCanonicalizer sym,
            byte[] inputBuffer, int start, int end,
            boolean bufferRecyclable)
    {
        super(ctxt, features);
        _inputStream = in;
        _objectCodec = codec;
        _symbols = sym;
        _inputBuffer = inputBuffer;
        _inputPtr = start;
        _inputEnd = end;
        // If we have offset, need to omit that from byte offset, so:
        _bufferRecyclable = bufferRecyclable;
    }
","public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,
            ObjectCodec codec, BytesToNameCanonicalizer sym,
            byte[] inputBuffer, int start, int end,
            boolean bufferRecyclable)
    {
        super(ctxt, features);
        _inputStream = in;
        _objectCodec = codec;
        _symbols = sym;
        
        if (inputBuffer == null) {
            throw new IllegalArgumentException(""Input buffer cannot be null"");
        }
        
        _inputBuffer = inputBuffer;
        
        if (start < 0 || end < start) {
            throw new IllegalArgumentException(""Invalid start/end parameters"");
        }
        
        _inputPtr = start;
        _inputEnd = end;
        
        _bufferRecyclable = bufferRecyclable;
    }",0,0
219,JacksonCore_4,"public char[] expandCurrentSegment()
    {
         final char[] curr = _currentSegment;
         // Let's grow by 50% by default
         final int len = curr.length;
         // but above intended maximum, slow to increase by 25%
         int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));
         return (_currentSegment = Arrays.copyOf(curr, newLen));
     }","public char[] expandCurrentSegment() {
    final char[] curr = _currentSegment;
    final int len = curr.length;
    int newLen;
    
    // Check if current length is less than MAX_SEGMENT_LEN
    if (len < MAX_SEGMENT_LEN) {
        // Let's grow by 50% by default
        newLen = len + (len >> 1);
        // Ensure new length does not exceed MAX_SEGMENT_LEN
        newLen = Math.min(MAX_SEGMENT_LEN, newLen);
    } else {
        // If length is equal or above MAX_SEGMENT_LEN, increase by 25%
        newLen = len + (len >> 2);
    }
    
    return (_currentSegment = Arrays.copyOf(curr, newLen));
}",0,0
220,JacksonCore_5,"private final static int _parseIndex(String str) {
        final int len = str.length();
        // [Issue#133]: beware of super long indexes; assume we never
        // have arrays over 2 billion entries so ints are fine.
        if (len == 0 || len > 10) {
             return -1;
         }
         for (int i = 0; i < len; ++i) {
             char c = str.charAt(i++);
             if (c > '9' || c < '0') {
                 return -1;
             }
        }
        if (len == 10) {
            long l = NumberInput.parseLong(str);
            if (l > Integer.MAX_VALUE) {
                return -1;
            }
        }
        return NumberInput.parseInt(str);
    }","private final static int _parseIndex(String str) {
    final int len = str.length();
    // [Issue#133]: beware of super long indexes; assume we never
    // have arrays over 2 billion entries so ints are fine.
    if (len == 0 || len > 10) {
        return -1;
    }
    for (int i = 0; i < len; ++i) {
        char c = str.charAt(i); // Corrected increment issue by removing
        if (c > '9' || c < '0') {
            return -1;
        }
    }
    if (len == 10) {
        long l = NumberInput.parseLong(str);
        if (l > Integer.MAX_VALUE || l < Integer.MIN_VALUE) { // Added check for negative values
            return -1;
        }
    }
    return NumberInput.parseInt(str);
}",0,0
221,JacksonCore_6,"private final static int _parseIndex(String str) {
        final int len = str.length();
        // [core#133]: beware of super long indexes; assume we never
        // have arrays over 2 billion entries so ints are fine.
        if (len == 0 || len > 10) {
             return -1;
         }
         // [core#176]: no leading zeroes allowed
         for (int i = 0; i < len; ++i) {
             char c = str.charAt(i);
             if (c > '9' || c < '0') {
                 return -1;
             }
        }
        if (len == 10) {
            long l = NumberInput.parseLong(str);
            if (l > Integer.MAX_VALUE) {
                return -1;
            }
        }
        return NumberInput.parseInt(str);
    }","private final static int _parseIndex(String str) {
        final int len = str.length();
        // [core#133]: beware of super long indexes; assume we never
        // have arrays over 2 billion entries so ints are fine.
        if (len == 0 || len > 10) {
             return -1;
         }
         // [core#176]: no leading zeroes allowed, except for the case where the number itself is zero
         if (str.charAt(0) == '0' && len > 1) {
             return -1;
         }
         for (int i = 0; i < len; ++i) {
             char c = str.charAt(i);
             if (c > '9' || c < '0') {
                 return -1;
             }
        }
        if (len == 10) {
            long l = NumberInput.parseLong(str);
            if (l > Integer.MAX_VALUE) {
                return -1;
            }
        }
        return NumberInput.parseInt(str);
    }",0,0
222,JacksonCore_7,"public int writeValue() {
         // Most likely, object:
         if (_type == TYPE_OBJECT) {
             _gotName = false;
             ++_index;
             return STATUS_OK_AFTER_COLON;
        }

        // Ok, array?
        if (_type == TYPE_ARRAY) {
            int ix = _index;
            ++_index;
            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;
        }
        
        // Nope, root context
        // No commas within root context, but need space
        ++_index;
        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;
    }","public int writeValue() {
    // Most likely, object:
    if (_type == TYPE_OBJECT) {
        _gotName = false;
        ++_index;
        return STATUS_OK_AS_IS; // Corrected to return STATUS_OK_AS_IS
    }

    // Ok, array?
    if (_type == TYPE_ARRAY) {
        int ix = _index;
        ++_index;
        return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;
    }

    // Nope, root context
    // No commas within root context, but need space
    ++_index;
    return (_index == 1) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; // Corrected to check _index == 1
}",0,0
223,JacksonCore_8,"public char[] getTextBuffer()
    {
        // Are we just using shared input buffer?
        if (_inputStart >= 0) return _inputBuffer;
        if (_resultArray != null)  return _resultArray;
        if (_resultString != null) {
             return (_resultArray = _resultString.toCharArray());
         }
         // Nope; but does it fit in just one segment?
         if (!_hasSegments)  return _currentSegment;
         // Nope, need to have/create a non-segmented array and return it
         return contentsAsArray();
     }","public char[] getTextBuffer()
{
    // Are we just using shared input buffer?
    if (_inputStart >= 0 && _inputBuffer != null) { 
        return _inputBuffer; 
    }
    
    if (_resultArray != null) {
        return _resultArray; 
    }
    
    if (_resultString != null) {
        _resultArray = _resultString.toCharArray(); 
        return _resultArray; 
    }
    
    // Ensure segments are properly initialized before accessing them
    if (!_hasSegments) {
        if (_currentSegment != null) {
            return _currentSegment; 
        } else {
            throw new IllegalStateException(""Current segment is null despite _hasSegments being false."");
        }
    }
    
    // Nope, need to have/create a non-segmented array and return it
    return contentsAsArray();
}",0,0
224,JacksonDatabind_1,"    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)
        throws Exception
    {
        Object value = get(bean);
        if (value == null) { // nulls need specialized handling
            if (_nullSerializer != null) {
                _nullSerializer.serialize(null, jgen, prov);
            } else { // can NOT suppress entries in tabular output
                jgen.writeNull();
            }
        }
        // otherwise find serializer to use
        JsonSerializer<Object> ser = _serializer;
        if (ser == null) {
            Class<?> cls = value.getClass();
            PropertySerializerMap map = _dynamicSerializers;
            ser = map.serializerFor(cls);
            if (ser == null) {
                ser = _findAndAddDynamic(map, cls, prov);
            }
        }
        // and then see if we must suppress certain values (default, empty)
        if (_suppressableValue != null) {
            if (MARKER_FOR_EMPTY == _suppressableValue) {
                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output
                    serializeAsPlaceholder(bean, jgen, prov);
                    return;
                }
            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output
                serializeAsPlaceholder(bean, jgen, prov);
                return;
            }
        }
        // For non-nulls: simple check for direct cycles
        if (value == bean) {
            _handleSelfReference(bean, ser);
        }
        if (_typeSerializer == null) {
            ser.serialize(value, jgen, prov);
        } else {
            ser.serializeWithType(value, jgen, prov, _typeSerializer);
        }
    }
","public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)
        throws Exception
    {
        Object value = get(bean);
        if (value == null) { // nulls need specialized handling
            if (_nullSerializer != null) {
                _nullSerializer.serialize(null, jgen, prov);
            } else { // can NOT suppress entries in tabular output
                jgen.writeNull();
            }
            return; // Return early to avoid unnecessary processing
        }
        // otherwise find serializer to use
        JsonSerializer<Object> ser = _serializer;
        if (ser == null) {
            Class<?> cls = value.getClass();
            PropertySerializerMap map = _dynamicSerializers;
            ser = map.serializerFor(cls);
            if (ser == null) {
                ser = _findAndAddDynamic(map, cls, prov);
            }
        }
        // and then see if we must suppress certain values (default, empty)
        if (_suppressableValue != null) {
            if (MARKER_FOR_EMPTY == _suppressableValue) {
                if (ser.isEmpty(prov, value)) { // Updated to include `prov` parameter in `isEmpty`
                    serializeAsPlaceholder(bean, jgen, prov);
                    return;
                }
            } else if (_suppressableValue.equals(value)) {
                serializeAsPlaceholder(bean, jgen, prov);
                return;
            }
        }
        // For non-nulls: simple check for direct cycles
        if (value == bean) {
            _handleSelfReference(bean, ser);
        }
        if (_typeSerializer == null) {
            ser.serialize(value, jgen, prov);
        } else {
            ser.serializeWithType(value, jgen, prov, _typeSerializer);
        }
    }",0,0
225,JacksonDatabind_100,"    public byte[] getBinaryValue(Base64Variant b64variant)
        throws IOException, JsonParseException
    {
        // Multiple possibilities...
        JsonNode n = currentNode();
        if (n != null) {
            // [databind#2096]: although `binaryValue()` works for real binary node
            // and embedded ""POJO"" node, coercion from TextNode may require variant, so:
            byte[] data = n.binaryValue();
            if (data != null) {
                return data;
            }
            if (n.isPojo()) {
                Object ob = ((POJONode) n).getPojo();
                if (ob instanceof byte[]) {
                    return (byte[]) ob;
                }
            }
        }
        // otherwise return null to mark we have no binary content
        return null;
    }
","public byte[] getBinaryValue(Base64Variant b64variant)
        throws IOException, JsonParseException
{
    // Multiple possibilities...
    JsonNode n = currentNode();
    if (n != null) {
        try {
            // [databind#2096]: although `binaryValue()` works for real binary node
            // and embedded ""POJO"" node, coercion from TextNode may require variant, so:
            byte[] data = n.binaryValue();
            if (data != null) {
                return data;
            }
        } catch (IOException e) {
            // Log or handle exception as needed (for clarity added exception handling here)
            throw new JsonParseException(null, ""Failed to retrieve binary value from node"", e);
        }

        if (n.isPojo()) {
            Object ob = ((POJONode) n).getPojo();
            if (ob instanceof byte[]) {
                return (byte[]) ob;
            }
        }

        // Handle case for TextNode with Base64 decoding
        if (n.isTextual()) {
            try {
                return b64variant.decode(n.textValue());
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(null, ""Failed to decode Base64 textual content"", e);
            }
        }
    }
    // Otherwise return null to mark we have no binary content
    return null;
}",0,0
226,JacksonDatabind_101,"    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped
        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).
        //    Ok however to pass via setter or field.
        
        final PropertyBasedCreator creator = _propertyBasedCreator;
        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

        TokenBuffer tokens = new TokenBuffer(p, ctxt);
        tokens.writeStartObject();

        JsonToken t = p.getCurrentToken();
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            p.nextToken(); // to point to value
            // creator property?
            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
            if (creatorProp != null) {
                // Last creator property to set?
                if (buffer.assignParameter(creatorProp,
                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                    Object bean;
                    try {
                        bean = creator.build(ctxt, buffer);
                    } catch (Exception e) {
                        bean = wrapInstantiationProblem(e, ctxt);
                    }
                    // [databind#631]: Assign current value, to be accessible by custom serializers
                    p.setCurrentValue(bean);
                    // if so, need to copy all remaining tokens into buffer
                    while (t == JsonToken.FIELD_NAME) {
                        // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that
                        p.nextToken();
                        tokens.copyCurrentStructure(p);
                        t = p.nextToken();
                    }
                    // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some
                    //    problems if we maintain invariants
                    tokens.writeEndObject();
                    if (bean.getClass() != _beanType.getRawClass()) {
                        // !!! 08-Jul-2011, tatu: Could probably support; but for now
                        //   it's too complicated, so bail out
                        ctxt.reportInputMismatch(creatorProp,
                                ""Cannot create polymorphic instances with unwrapped values"");
                        return null;
                    }
                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
                }
                continue;
            }
            // Object Id property?
            if (buffer.readIdProperty(propName)) {
                continue;
            }
            // regular property? needs buffering
            SettableBeanProperty prop = _beanProperties.find(propName);
            if (prop != null) {
                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
                continue;
            }
            // Things marked as ignorable should not be passed to any setter
            if (_ignorableProps != null && _ignorableProps.contains(propName)) {
                handleIgnoredProperty(p, ctxt, handledType(), propName);
                continue;
            }
            // 29-Nov-2016, tatu: probably should try to avoid sending content
            //    both to any setter AND buffer... but, for now, the only thing
            //    we can do.
            // how about any setter? We'll get copies but...
            if (_anySetter == null) {
                // but... others should be passed to unwrapped property deserializers
                tokens.writeFieldName(propName);
                tokens.copyCurrentStructure(p);
            } else {
                // Need to copy to a separate buffer first
                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);
                tokens.writeFieldName(propName);
                tokens.append(b2);
                try {
                    buffer.bufferAnyProperty(_anySetter, propName,
                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));
                } catch (Exception e) {
                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                }
                continue;
            }
        }

        // We hit END_OBJECT, so:
        Object bean;
        try {
            bean = creator.build(ctxt, buffer);
        } catch (Exception e) {
            wrapInstantiationProblem(e, ctxt);
            return null; // never gets here
        }
        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
    }
","protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        final PropertyBasedCreator creator = _propertyBasedCreator;
        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

        TokenBuffer tokens = new TokenBuffer(p, ctxt);
        tokens.writeStartObject();

        JsonToken t = p.getCurrentToken();

        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            p.nextToken(); // to point to value

            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
            if (creatorProp != null) {
                if (buffer.assignParameter(creatorProp,
                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                    Object bean;
                    try {
                        bean = creator.build(ctxt, buffer);
                    } catch (Exception e) {
                        bean = wrapInstantiationProblem(e, ctxt);
                    }
                    p.setCurrentValue(bean);

                    while (t == JsonToken.FIELD_NAME) {
                        p.nextToken();
                        tokens.copyCurrentStructure(p);
                        t = p.nextToken();
                    }
                    tokens.writeEndObject();

                    if (bean != null && bean.getClass() != _beanType.getRawClass()) {
                        ctxt.reportInputMismatch(creatorProp,
                                ""Cannot create polymorphic instances with unwrapped values"");
                        return null;
                    }
                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
                }
                continue;
            }

            if (buffer.readIdProperty(propName)) {
                continue;
            }

            SettableBeanProperty prop = _beanProperties.find(propName);
            if (prop != null) {
                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
                continue;
            }

            if (_ignorableProps != null && _ignorableProps.contains(propName)) {
                handleIgnoredProperty(p, ctxt, handledType(), propName);
                continue;
            }

            if (_anySetter == null) {
                tokens.writeFieldName(propName);
                tokens.copyCurrentStructure(p);
            } else {
                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);
                tokens.writeFieldName(propName);
                tokens.append(b2);
                try {
                    buffer.bufferAnyProperty(_anySetter, propName,
                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));
                } catch (Exception e) {
                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                }
                continue;
            }
        }

        Object bean;
        try {
            bean = creator.build(ctxt, buffer);
        } catch (Exception e) {
            return wrapInstantiationProblem(e, ctxt);
        }
        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
    }",0,0
227,JacksonDatabind_102,"    public JsonSerializer<?> createContextual(SerializerProvider serializers,
            BeanProperty property) throws JsonMappingException
    {
        // Note! Should not skip if `property` null since that'd skip check
        // for config overrides, in case of root value
        if (property == null) {
            return this;
        }
        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());
        if (format == null) {
            return this;
        }
        // Simple case first: serialize as numeric timestamp?
        JsonFormat.Shape shape = format.getShape();
        if (shape.isNumeric()) {
            return withFormat(Boolean.TRUE, null);
        }

        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..
        // First: custom pattern will override things
        if (format.hasPattern()) {
            final Locale loc = format.hasLocale()
                            ? format.getLocale()
                            : serializers.getLocale();
            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);
            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()
                    : serializers.getTimeZone();
            df.setTimeZone(tz);
            return withFormat(Boolean.FALSE, df);
        }

        // Otherwise, need one of these changes:
        final boolean hasLocale = format.hasLocale();
        final boolean hasTZ = format.hasTimeZone();
        final boolean asString = (shape == JsonFormat.Shape.STRING);

        if (!hasLocale && !hasTZ && !asString) {
            return this;
        }

        DateFormat df0 = serializers.getConfig().getDateFormat();
        // Jackson's own `StdDateFormat` is quite easy to deal with...
        if (df0 instanceof StdDateFormat) {
            StdDateFormat std = (StdDateFormat) df0;
            if (format.hasLocale()) {
                std = std.withLocale(format.getLocale());
            }
            if (format.hasTimeZone()) {
                std = std.withTimeZone(format.getTimeZone());
            }
            return withFormat(Boolean.FALSE, std);
        }

        // 08-Jun-2017, tatu: Unfortunately there's no generally usable
        //    mechanism for changing `DateFormat` instances (or even clone()ing)
        //    So: require it be `SimpleDateFormat`; can't config other types
        if (!(df0 instanceof SimpleDateFormat)) {
            serializers.reportBadDefinition(handledType(), String.format(
""Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`"",
df0.getClass().getName()));
        }
        SimpleDateFormat df = (SimpleDateFormat) df0;
        if (hasLocale) {
            // Ugh. No way to change `Locale`, create copy; must re-crete completely:
            df = new SimpleDateFormat(df.toPattern(), format.getLocale());
        } else {
            df = (SimpleDateFormat) df.clone();
        }
        TimeZone newTz = format.getTimeZone();
        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());
        if (changeTZ) {
            df.setTimeZone(newTz);
        }
        return withFormat(Boolean.FALSE, df);
    }
","public JsonSerializer<?> createContextual(SerializerProvider serializers,
            BeanProperty property) throws JsonMappingException
    {
        // Note! Should not skip if `property` null since that'd skip check
        // for config overrides, in case of root value
        JsonFormat.Value format = (property == null)
                ? serializers.getDefaultFormat(handledType())
                : findFormatOverrides(serializers, property, handledType());

        if (format == null) {
            return this;
        }

        // Simple case first: serialize as numeric timestamp?
        JsonFormat.Shape shape = format.getShape();
        if (shape.isNumeric()) {
            return withFormat(Boolean.TRUE, null);
        }

        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..
        // First: custom pattern will override things
        if (format.hasPattern()) {
            final Locale loc = format.hasLocale()
                            ? format.getLocale()
                            : serializers.getLocale();
            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);
            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()
                    : serializers.getTimeZone();
            df.setTimeZone(tz);
            return withFormat(Boolean.FALSE, df);
        }

        // Otherwise, need one of these changes:
        final boolean hasLocale = format.hasLocale();
        final boolean hasTZ = format.hasTimeZone();
        final boolean asString = (shape == JsonFormat.Shape.STRING);

        if (!hasLocale && !hasTZ && !asString) {
            return this;
        }

        DateFormat df0 = serializers.getConfig().getDateFormat();
        // Jackson's own `StdDateFormat` is quite easy to deal with...
        if (df0 instanceof StdDateFormat) {
            StdDateFormat std = (StdDateFormat) df0;
            if (format.hasLocale()) {
                std = std.withLocale(format.getLocale());
            }
            if (format.hasTimeZone()) {
                std = std.withTimeZone(format.getTimeZone());
            }
            return withFormat(Boolean.FALSE, std);
        }

        // 08-Jun-2017, tatu: Unfortunately there's no generally usable
        //    mechanism for changing `DateFormat` instances (or even clone()ing)
        //    So: require it be `SimpleDateFormat`; can't config other types
        if (!(df0 instanceof SimpleDateFormat)) {
            serializers.reportBadDefinition(handledType(), String.format(
""Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`"",
df0.getClass().getName()));
        }
        SimpleDateFormat df = (SimpleDateFormat) df0;
        if (hasLocale) {
            // Ugh. No way to change `Locale`, create copy; must re-create completely:
            df = new SimpleDateFormat(df.toPattern(), format.getLocale());
        } else {
            df = (SimpleDateFormat) df.clone();
        }
        TimeZone newTz = format.getTimeZone();
        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());
        if (changeTZ) {
            df.setTimeZone(newTz);
        }
        return withFormat(Boolean.FALSE, df);
    }",0,0
228,JacksonDatabind_107,"    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,
            String typeId) throws IOException
    {
        JsonDeserializer<Object> deser = _deserializers.get(typeId);
        if (deser == null) {
            /* As per [databind#305], need to provide contextual info. But for
             * backwards compatibility, let's start by only supporting this
             * for base class, not via interface. Later on we can add this
             * to the interface, assuming deprecation at base class helps.
             */
            JavaType type = _idResolver.typeFromId(ctxt, typeId);
            if (type == null) {
                // use the default impl if no type id available:
                deser = _findDefaultImplDeserializer(ctxt);
                if (deser == null) {
                    // 10-May-2016, tatu: We may get some help...
                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);
                    if (actual == null) { // what should this be taken to mean?
                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...
                        return null;
                    }
                    // ... would this actually work?
                    deser = ctxt.findContextualValueDeserializer(actual, _property);
                }
            } else {
                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,
                 *   we actually now need to explicitly narrow from base type (which may have parameterization)
                 *   using raw type.
                 *
                 *   One complication, though; cannot change 'type class' (simple type to container); otherwise
                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual
                 *   type in process (getting SimpleType of Map.class which will not work as expected)
                 */
                if ((_baseType != null)
                        && _baseType.getClass() == type.getClass()) {
                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;
                     *   but it appears to check that JavaType impl class is the same which is
                     *   important for some reason?
                     *   Disabling the check will break 2 Enum-related tests.
                     */
                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full
                    //   generic type with custom type resolvers. If so, should try to retain them.
                    //  Whether this is sufficient to avoid problems remains to be seen, but for
                    //  now it should improve things.
                    if (!type.hasGenericTypes()) {
                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());
                    }
                }
                deser = ctxt.findContextualValueDeserializer(type, _property);
            }
            _deserializers.put(typeId, deser);
        }
        return deser;
    }","protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,
            String typeId) throws IOException
    {
        JsonDeserializer<Object> deser = _deserializers.get(typeId);
        if (deser == null) {
            JavaType type = _idResolver.typeFromId(ctxt, typeId);
            if (type == null) {
                deser = _findDefaultImplDeserializer(ctxt);
                if (deser == null) {
                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);
                    if (actual == null) {
                        throw new IOException(""Unknown type id: "" + typeId);
                    }
                    deser = ctxt.findContextualValueDeserializer(actual, _property);
                }
            } else {
                if ((_baseType != null)
                        && _baseType.getClass() == type.getClass()
                        && !type.hasGenericTypes()) {
                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());
                }
                deser = ctxt.findContextualValueDeserializer(type, _property);
            }
            _deserializers.put(typeId, deser);
        }
        return deser;
    }",0,0
229,JacksonDatabind_11,"protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)
    {
        final String name = type.getName();
         // 19-Mar-2015: Without context, all we can check are bounds.
         if (context == null) {
             // And to prevent infinite loops, now need this:
             return _unknownType();
         } else {
             // Ok: here's where context might come in handy!
             /* 19-Mar-2015, tatu: As per [databind#609], may need to allow
              *   unresolved type variables to handle some cases where bounds
              *   are enough. Let's hope it does not hide real fail cases.
              */
             JavaType actualType = context.findType(name);
             if (actualType != null) {
                 return actualType;
             }
        }

        /* 29-Jan-2010, tatu: We used to throw exception here, if type was
         *   bound: but the problem is that this can occur for generic ""base""
         *   method, overridden by sub-class. If so, we will want to ignore
         *   current type (for method) since it will be masked.
         */
        Type[] bounds = type.getBounds();

        // With type variables we must use bound information.
        // Theoretically this gets tricky, as there may be multiple
        // bounds (""... extends A & B""); and optimally we might
        // want to choose the best match. Also, bounds are optional;
        // but here we are lucky in that implicit ""Object"" is
        // added as bounds if so.
        // Either way let's just use the first bound, for now, and
        // worry about better match later on if there is need.

        /* 29-Jan-2010, tatu: One more problem are recursive types
         *   (T extends Comparable<T>). Need to add ""placeholder""
         *   for resolution to catch those.
         */
        context._addPlaceholder(name);
        return _constructType(bounds[0], context);
    }","protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)
{
    final String name = type.getName();
    // 19-Mar-2015: Without context, all we can check are bounds.
    if (context == null) {
        // And to prevent infinite loops, now need this:
        return _unknownType();
    } else {
        // Ok: here's where context might come in handy!
        /* 19-Mar-2015, tatu: As per [databind#609], may need to allow
         *   unresolved type variables to handle some cases where bounds
         *   are enough. Let's hope it does not hide real fail cases.
         */
        JavaType actualType = context.findType(name);
        if (actualType != null) {
            return actualType;
        }
    }

    /* 29-Jan-2010, tatu: We used to throw exception here, if type was
     *   bound: but the problem is that this can occur for generic ""base""
     *   method, overridden by a subclass. If so, we will want to ignore
     *   current type (for method) since it will be masked.
     */
    Type[] bounds = type.getBounds();

    // Ensure bounds are not empty before accessing the first element
    if (bounds.length == 0) {
        return _unknownType();
    }

    // With type variables we must use bound information.
    // Theoretically this gets tricky, as there may be multiple
    // bounds (""... extends A & B""); and optimally we might
    // want to choose the best match. Also, bounds are optional;
    // but here we are lucky in that implicit ""Object"" is
    // added as bounds if so.
    // Either way let's just use the first bound, for now, and
    // worry about better match later on if there is need.

    /* 29-Jan-2010, tatu: One more problem are recursive types
     *   (T extends Comparable<T>). Need to add ""placeholder""
     *   for resolution to catch those.
     */
    context._addPlaceholder(name);
    return _constructType(bounds[0], context);
}",0,0
230,JacksonDatabind_112,"    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
            BeanProperty property) throws JsonMappingException
    {
        // May need to resolve types for delegate-based creators:
        JsonDeserializer<Object> delegate = null;
        if (_valueInstantiator != null) {
            // [databind#2324]: check both array-delegating and delegating
            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();
            if (delegateCreator != null) {
                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());
                delegate = findDeserializer(ctxt, delegateType, property);
            }
        }
        JsonDeserializer<?> valueDeser = _valueDeserializer;
        final JavaType valueType = _containerType.getContentType();
        if (valueDeser == null) {
            // [databind#125]: May have a content converter
            valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);
            if (valueDeser == null) {
            // And we may also need to get deserializer for String
                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);
            }
        } else { // if directly assigned, probably not yet contextual, so:
            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);
        }
        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly
        //   comes down to ""List vs Collection"" I suppose... for now, pass Collection
        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);
        if (isDefaultDeserializer(valueDeser)) {
            valueDeser = null;
        }
        return withResolved(delegate, valueDeser, nuller, unwrapSingle);
    }
","public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
        BeanProperty property) throws JsonMappingException
{
    // May need to resolve types for delegate-based creators:
    JsonDeserializer<Object> delegate = null;
    if (_valueInstantiator != null) {
        // [databind#2324]: check both array-delegating and delegating
        AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();
        if (delegateCreator != null) {
            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());
            if (delegateType != null) { // Ensure delegate type is resolved
                delegate = findDeserializer(ctxt, delegateType, property);
            }
        }
    }
    JsonDeserializer<?> valueDeser = _valueDeserializer;
    final JavaType valueType = _containerType.getContentType();
    if (valueType == null) { // Ensure content type is not null
        throw new JsonMappingException(ctxt, ""Container type must provide a content type"");
    }
    if (valueDeser == null) {
        // [databind#125]: May have a content converter
        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);
        if (valueDeser == null) {
            // And we may also need to get deserializer for String
            valueDeser = ctxt.findContextualValueDeserializer(valueType, property);
        }
    } else { // if directly assigned, probably not yet contextual, so:
        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);
    }
    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly
    //   comes down to ""List vs Collection"" I suppose... for now, pass Collection
    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,
            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
    NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);
    // Ensure valueDeser is handled correctly
    if (isDefaultDeserializer(valueDeser)) {
        valueDeser = null;
    }
    return withResolved(delegate, valueDeser, nuller, unwrapSingle);
}",0,0
231,JacksonDatabind_12,"@Override
    public boolean isCachable() {
         /* As per [databind#735], existence of value or key deserializer (only passed
          * if annotated to use non-standard one) should also prevent caching.
          */
         return (_valueTypeDeserializer == null)
                 && (_ignorableProperties == null);
     }","@Override
public boolean isCachable() {
    /* As per [databind#735], existence of value or key deserializer (only passed
     * if annotated to use non-standard one) should also prevent caching.
     */
    return (_valueDeserializer == null) 
            && (_valueTypeDeserializer == null)
            && (_keyDeserializer == null)
            && (_ignorableProperties == null);
}",0,0
232,JacksonDatabind_16,"protected final boolean _add(Annotation ann) {
        if (_annotations == null) {
             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();
         }
         Annotation previous = _annotations.put(ann.annotationType(), ann);
         return (previous != null) && previous.equals(ann);
     }","protected final boolean _add(Annotation ann) {
    if (ann == null) {
        throw new IllegalArgumentException(""Annotation cannot be null"");
    }
    if (_annotations == null) {
        _annotations = new HashMap<Class<? extends Annotation>, Annotation>();
    }
    Annotation previous = _annotations.put(ann.annotationType(), ann);
    return (previous != null) && previous.equals(ann);
}",0,0
233,JacksonDatabind_17,"public boolean useForType(JavaType t)
        {
            switch (_appliesFor) {
            case NON_CONCRETE_AND_ARRAYS:
                while (t.isArrayType()) {
                    t = t.getContentType();
                }
                // fall through
            case OBJECT_AND_NON_CONCRETE:
//                return t.isJavaLangObject() || 
                 return (t.getRawClass() == Object.class)
                         || (!t.isConcrete()
                                 // [databind#88] Should not apply to JSON tree models:
                         || TreeNode.class.isAssignableFrom(t.getRawClass()));
 
             case NON_FINAL:
                 while (t.isArrayType()) {
                    t = t.getContentType();
                }
                // [Issue#88] Should not apply to JSON tree models:
                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());
            default:
            //case JAVA_LANG_OBJECT:
//                return t.isJavaLangObject();
                return (t.getRawClass() == Object.class);
            }
        }","public boolean useForType(JavaType t) {
    switch (_appliesFor) {
        case NON_CONCRETE_AND_ARRAYS:
            while (t.isArrayType()) {
                t = t.getContentType();
            }
            // fall through
        case OBJECT_AND_NON_CONCRETE:
            return (t.getRawClass() == Object.class)
                    || (!t.isConcrete()
                    // [databind#88] Should not apply to JSON tree models:
                    || TreeNode.class.isAssignableFrom(t.getRawClass()));

        case NON_FINAL:
            while (t.isArrayType()) {
                t = t.getContentType();
            }
            // [Issue#88] Should not apply to JSON tree models:
            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());

        default:
            // Here, JavaType.isJavaLangObject() would have probably been a method to return true
            // if the type is Object.class, utilizing it directly to improve convenience and readability.
            return t.getRawClass() == Object.class;
    }
}",0,0
234,JacksonDatabind_19,"private JavaType _mapType(Class<?> rawClass)
     {
         // 28-May-2015, tatu: Properties are special, as per [databind#810]
         JavaType[] typeParams = findTypeParameters(rawClass, Map.class);
         // ok to have no types (""raw"")
         if (typeParams == null) {
            return MapType.construct(rawClass, _unknownType(), _unknownType());
        }
        // but exactly 2 types if any found
        if (typeParams.length != 2) {
            throw new IllegalArgumentException(""Strange Map type ""+rawClass.getName()+"": can not determine type parameters"");
        }
        return MapType.construct(rawClass, typeParams[0], typeParams[1]);
    }","private JavaType _mapType(Class<?> rawClass) {
    // 28-May-2015, tatu: Properties are special, as per [databind#810]
    JavaType[] typeParams = findTypeParameters(rawClass, Map.class);
    // ok to have no types (""raw"")
    if (typeParams == null || typeParams.length == 0) {
        return MapType.construct(rawClass, _unknownType(), _unknownType());
    }
    // but exactly 2 types if any found
    if (typeParams.length != 2) {
        throw new IllegalArgumentException(""Strange Map type "" + rawClass.getName() + "": can not determine type parameters; expected 2 but found "" + typeParams.length);
    }
    return MapType.construct(rawClass, typeParams[0], typeParams[1]);
}",0,0
235,JacksonDatabind_24,"public BaseSettings withDateFormat(DateFormat df) {
         if (_dateFormat == df) {
             return this;
         }
         TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();
         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,
                 _typeResolverBuilder, df, _handlerInstantiator, _locale,
                 tz, _defaultBase64);
     }","public BaseSettings withDateFormat(DateFormat df) {
    TimeZone tz = (df == null || df.getTimeZone() == null) ? _timeZone : df.getTimeZone();
    if (_dateFormat == df && _timeZone.equals(tz)) {
        return this;
    }
    return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,
            _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);
}",0,0
236,JacksonDatabind_27,"@SuppressWarnings(""resource"")
    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        final ExternalTypeHandler ext = _externalTypeIdHandler.start();
        final PropertyBasedCreator creator = _propertyBasedCreator;
        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

        TokenBuffer tokens = new TokenBuffer(p);
        tokens.writeStartObject();

        JsonToken t = p.getCurrentToken();
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            p.nextToken(); // to point to value
            // creator property?
            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
            if (creatorProp != null) {
                 // first: let's check to see if this might be part of value with external type id:
                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,
                 //   since it is not the bean
                 if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {
                     ;
                 } else {
                     // Last creator property to set?
                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                        Object bean;
                        try {
                            bean = creator.build(ctxt, buffer);
                        } catch (Exception e) {
                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                            continue; // never gets here
                        }
                        // if so, need to copy all remaining tokens into buffer
                        while (t == JsonToken.FIELD_NAME) {
                            p.nextToken(); // to skip name
                            tokens.copyCurrentStructure(p);
                            t = p.nextToken();
                        }
                        if (bean.getClass() != _beanType.getRawClass()) {
                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now
                            //   it's too complicated, so bail out
                            throw ctxt.mappingException(""Can not create polymorphic instances with unwrapped values"");
                        }
                        return ext.complete(p, ctxt, bean);
                    }
                }
                continue;
            }
            // Object Id property?
            if (buffer.readIdProperty(propName)) {
                continue;
            }
            // regular property? needs buffering
            SettableBeanProperty prop = _beanProperties.find(propName);
            if (prop != null) {
                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));
                continue;
            }
            // external type id (or property that depends on it)?
            if (ext.handlePropertyValue(p, ctxt, propName, null)) {
                continue;
            }
            /* As per [JACKSON-313], things marked as ignorable should not be
             * passed to any setter
             */
            if (_ignorableProps != null && _ignorableProps.contains(propName)) {
                handleIgnoredProperty(p, ctxt, handledType(), propName);
                continue;
            }
            // ""any property""?
            if (_anySetter != null) {
                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
            }
        }

        // We hit END_OBJECT; resolve the pieces:
        try {
            return ext.complete(p, ctxt, buffer, creator);
        } catch (Exception e) {
            wrapInstantiationProblem(e, ctxt);
            return null; // never gets here
        }
    }","@SuppressWarnings(""resource"")
protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)
    throws IOException
{
    final ExternalTypeHandler ext = _externalTypeIdHandler.start();
    final PropertyBasedCreator creator = _propertyBasedCreator;
    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

    TokenBuffer tokens = new TokenBuffer(p);
    tokens.writeStartObject();

    JsonToken t = p.getCurrentToken();
    if (t == JsonToken.START_OBJECT) {
        t = p.nextToken();
    }
    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
        String propName = p.getCurrentName();
        p.nextToken(); // to point to value
        // creator property?
        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
        if (creatorProp != null) {
            // first: let's check to see if this might be part of value with external type id:
            // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,
            //   since it is not the bean
            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {
                ;
            } else {
                // Last creator property to set?
                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                    Object bean;
                    try {
                        bean = creator.build(ctxt, buffer);
                    } catch (Exception e) {
                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                        continue; // never gets here
                    }
                    // if so, need to copy all remaining tokens into buffer
                    while (t == JsonToken.FIELD_NAME) {
                        p.nextToken(); // to skip name
                        tokens.copyCurrentStructure(p);
                        t = p.nextToken();
                    }
                    if (bean.getClass() != _beanType.getRawClass()) {
                        // !!! 08-Jul-2011, tatu: Could theoretically support; but for now
                        //   it's too complicated, so bail out
                        throw ctxt.mappingException(""Can not create polymorphic instances with unwrapped values"");
                    }
                    return ext.complete(p, ctxt, bean);
                }
            }
            continue;
        }
        // Object Id property?
        if (buffer.readIdProperty(propName)) {
            continue;
        }
        // regular property? needs buffering
        SettableBeanProperty prop = _beanProperties.find(propName);
        if (prop != null) {
            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));
            continue;
        }
        // external type id (or property that depends on it)?
        if (ext.handlePropertyValue(p, ctxt, propName, null)) {
            continue;
        }
        /* As per [JACKSON-313], things marked as ignorable should not be
         * passed to any setter
         */
        if (_ignorableProps != null && _ignorableProps.contains(propName)) {
            handleIgnoredProperty(p, ctxt, handledType(), propName);
            continue;
        }
        // ""any property""?
        if (_anySetter != null) {
            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
        }
    }

    // We hit END_OBJECT; resolve the pieces:
    try {
        return ext.complete(p, ctxt, buffer, creator);
    } catch (Exception e) {
        wrapInstantiationProblem(e, ctxt);
        return null; // never gets here
    }
}",0,0
237,JacksonDatabind_28,"@Override
         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
         {
             if (p.getCurrentToken() == JsonToken.START_OBJECT) {
                 p.nextToken();
                 return deserializeObject(p, ctxt, ctxt.getNodeFactory());
             }
             // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),
             //    if caller has advanced to the first token of Object, but for empty Object
             if (p.getCurrentToken() == JsonToken.FIELD_NAME) {
                 return deserializeObject(p, ctxt, ctxt.getNodeFactory());
             }
             throw ctxt.mappingException(ObjectNode.class);
          }","@Override
public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (p.getCurrentToken() == JsonToken.START_OBJECT) {
        p.nextToken();
        return deserializeObject(p, ctxt, ctxt.getNodeFactory());
    }
    // Handle end of an empty object case
    if (p.getCurrentToken() == JsonToken.END_OBJECT) {
        return ctxt.getNodeFactory().objectNode();
    }
    // Handle case where caller has advanced to the first field name of Object
    if (p.getCurrentToken() == JsonToken.FIELD_NAME) {
        return deserializeObject(p, ctxt, ctxt.getNodeFactory());
    }
    throw ctxt.mappingException(ObjectNode.class);
}",0,0
238,JacksonDatabind_33,"@Override
    public PropertyName findNameForSerialization(Annotated a)
    {
        String name = null;

        JsonGetter jg = _findAnnotation(a, JsonGetter.class);
        if (jg != null) {
            name = jg.value();
        } else {
            JsonProperty pann = _findAnnotation(a, JsonProperty.class);
            if (pann != null) {
                name = pann.value();
                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but
                 *   it's actually bit tricky to do it more efficiently (meta-annotations
                 *   add more lookups; AnnotationMap costs etc)
                  */
             } else if (_hasAnnotation(a, JsonSerialize.class)
                     || _hasAnnotation(a, JsonView.class)
                     || _hasAnnotation(a, JsonRawValue.class)) {
                 name = """";
             } else {
                 return null;
            }
        }
        return PropertyName.construct(name);
    }","@Override
public PropertyName findNameForSerialization(Annotated a) {
    String name = null;

    JsonGetter jg = _findAnnotation(a, JsonGetter.class);
    if (jg != null) {
        name = jg.value();
    } else {
        JsonProperty pann = _findAnnotation(a, JsonProperty.class);
        if (pann != null) {
            name = pann.value();
            /* 22-Apr-2014, tatu: Should figure out a better way to do this, but
             *   it's actually bit tricky to do it more efficiently (meta-annotations
             *   add more lookups; AnnotationMap costs etc)
            */
        } else if (_hasAnnotation(a, JsonSerialize.class)
                || _hasAnnotation(a, JsonView.class)
                || _hasAnnotation(a, JsonRawValue.class)) {
            name = """";
        } // Instead of returning null immediately, check last condition for consistency
    }
    return (name != null) ? PropertyName.construct(name) : PropertyName.USE_DEFAULT;
}",0,0
239,JacksonDatabind_34,"@Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
    {
        if (_isInt) {
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);
         } else {
             Class<?> h = handledType();
             if (h == BigDecimal.class) {
                 visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);
             } else {
                 // otherwise bit unclear what to call... but let's try:
                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);
            }
        }
    }","@Override
public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
{
    if (_isInt) {
        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);
    } else {
        Class<?> h = handledType();
        if (h == BigDecimal.class) {
            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);
        } else {
            // If the type is not clear, expect a generic number format
            JsonNumberFormatVisitor numberVisitor = visitor.expectNumberFormat(typeHint);
            if (numberVisitor != null) {
                // Additional configurations can be added here if needed
            }
        }
    }
}",0,0
240,JacksonDatabind_35,"@SuppressWarnings(""resource"")
    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        // 02-Aug-2013, tatu: May need to use native type ids
        if (p.canReadTypeId()) {
            Object typeId = p.getTypeId();
            if (typeId != null) {
                return _deserializeWithNativeTypeId(p, ctxt, typeId);
             }
         }
         // first, sanity checks
         if (p.getCurrentToken() != JsonToken.START_OBJECT) {
             throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,
                     ""need JSON Object to contain As.WRAPPER_OBJECT type information for class ""+baseTypeName());
         }
             // should always get field name, but just in case...
             if (p.nextToken() != JsonToken.FIELD_NAME) {
                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,
                         ""need JSON String that contains type id (for subtype of ""+baseTypeName()+"")"");
             }
         final String typeId = p.getText();
         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);
         p.nextToken();

        // Minor complication: we may need to merge type id in?
        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {
            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.
            TokenBuffer tb = new TokenBuffer(null, false);
            tb.writeStartObject(); // recreate START_OBJECT
            tb.writeFieldName(_typePropertyName);
            tb.writeString(typeId);
            p = JsonParserSequence.createFlattened(tb.asParser(p), p);
            p.nextToken();
        }
        
        Object value = deser.deserialize(p, ctxt);
        // And then need the closing END_OBJECT
        if (p.nextToken() != JsonToken.END_OBJECT) {
            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,
                    ""expected closing END_OBJECT after type information and deserialized value"");
        }
        return value;
    }","@SuppressWarnings(""resource"")
private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    // 02-Aug-2013, tatu: May need to use native type ids
    if (p.canReadTypeId()) {
        Object typeId = p.getTypeId();
        if (typeId != null) {
            return _deserializeWithNativeTypeId(p, ctxt, typeId);
        }
    }
    
    // Sanity checks
    if (p.getCurrentToken() != JsonToken.START_OBJECT) {
        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,
                ""Expected start of JSON object for As.WRAPPER_OBJECT type information for class "" + baseTypeName());
    }

    // Should always get field name, but just in case...
    if (p.nextToken() != JsonToken.FIELD_NAME) {
        throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,
                ""Expected field name containing type id for subtype of "" + baseTypeName());
    }

    final String typeId = p.getText();
    JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);

    if (deser == null) {
        throw ctxt.mappingException(""Could not find deserializer for type id '"" + typeId + ""'"");
    }

    p.nextToken();

    // Minor complication: we may need to merge type id into the start object
    if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {
        if (_typePropertyName == null || _typePropertyName.isEmpty()) {
            throw ctxt.mappingException(""Type property name is not defined, cannot merge type id"");
        }

        TokenBuffer tb = new TokenBuffer(p, ctxt);
        tb.writeStartObject(); // recreate START_OBJECT
        tb.writeFieldName(_typePropertyName);
        tb.writeString(typeId);

        JsonParser mergedParser = JsonParserSequence.createFlattened(tb.asParser(), p);
        mergedParser.nextToken(); // move to first token in merged stream

        Object value = deser.deserialize(mergedParser, ctxt);
        // Ensure END_OBJECT is properly closed
        if (mergedParser.nextToken() != JsonToken.END_OBJECT) {
            throw ctxt.wrongTokenException(mergedParser, JsonToken.END_OBJECT,
                    ""Expected closing END_OBJECT after type information and deserialized value"");
        }
        return value;
    }

    Object value = deser.deserialize(p, ctxt);
    // Ensure END_OBJECT is properly closed
    if (p.nextToken() != JsonToken.END_OBJECT) {
        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,
                ""Expected closing END_OBJECT after type information and deserialized value"");
    }
    return value;
}",0,0
241,JacksonDatabind_37,"@Override
    protected JavaType _narrow(Class<?> subclass)
    {
        if (_class == subclass) {
            return this;
        }
        // Should we check that there is a sub-class relationship?
        // 15-Jan-2016, tatu: Almost yes, but there are some complications with
        //    placeholder values, so no.
        /*
        if (!_class.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException(""Class ""+subclass.getName()+"" not sub-type of ""
                    +_class.getName());
         }
         */
         // 15-Jan-2015, tatu: Not correct; should really re-resolve...
         return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,
                 _valueHandler, _typeHandler, _asStatic);
     }","@Override
protected JavaType _narrow(Class<?> subclass) {
    if (_class == subclass) {
        return this;
    }

    // Uncommenting this check to ensure the subclass is indeed a subtype
    if (!_class.isAssignableFrom(subclass)) {
        throw new IllegalArgumentException(""Class "" + subclass.getName() + "" not sub-type of "" + _class.getName());
    }

    // Return a new SimpleType with the subclass
    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);
}",0,0
242,JacksonDatabind_39,"@Override
    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
     {
         // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit
         //    special unfortunately
             p.skipChildren();
         return null;
     }","@Override
public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    // 29-Jan-2016, tatu: Simple skipping for all tokens
    if (p.currentToken() == JsonToken.FIELD_NAME) {
        p.nextToken(); // Move past the field name
    }
    p.skipChildren();
    return null;
}",0,0
243,JacksonDatabind_42,"@Override
        protected Object _deserializeFromEmptyString() throws IOException {
            // As per [databind#398], URI requires special handling
            if (_kind == STD_URI) {
                 return URI.create("""");
             }
             // As per [databind#1123], Locale too
             return super._deserializeFromEmptyString();
         }","@Override
protected Object _deserializeFromEmptyString() throws IOException {
    // As per [databind#398], URI requires special handling
    if (_kind == STD_URI) {
        return URI.create("""");
    }
    // As per [databind#1123], Locale requires special handling
    if (_kind == STD_LOCALE) {
        return Locale.ROOT;
    }
    return super._deserializeFromEmptyString();
}",0,0
244,JacksonDatabind_44,"@Override
    @Deprecated
    protected JavaType _narrow(Class<?> subclass)
    {
        if (_class == subclass) {
            return this;
        }
        // Should we check that there is a sub-class relationship?
         // 15-Jan-2016, tatu: Almost yes, but there are some complications with
         //    placeholder values (`Void`, `NoClass`), so can not quite do yet.
         // TODO: fix in 2.8
             /*
             throw new IllegalArgumentException(""Class ""+subclass.getName()+"" not sub-type of ""
                     +_class.getName());
                     */
             return new SimpleType(subclass, _bindings, this, _superInterfaces,
                     _valueHandler, _typeHandler, _asStatic);
         // Otherwise, stitch together the hierarchy. First, super-class
         // if not found, try a super-interface
         // should not get here but...
     }","@Override
@Deprecated
protected JavaType _narrow(Class<?> subclass) {
    if (_class == subclass) {
        return this;
    }
    // Check if the provided subclass is actually a subclass of the current class
    if (!_class.isAssignableFrom(subclass)) {
        throw new IllegalArgumentException(""Class "" + subclass.getName() + "" is not a sub-type of "" + _class.getName());
    }
    // Return a new Type with the subclass
    return new SimpleType(subclass, _bindings, this, _superInterfaces,
            _valueHandler, _typeHandler, _asStatic);
}",0,0
245,JacksonDatabind_45,"@Override
    public JsonSerializer<?> createContextual(SerializerProvider serializers,
            BeanProperty property) throws JsonMappingException
    {
        if (property != null) {
            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());
            if (format != null) {

            	// Simple case first: serialize as numeric timestamp?
                JsonFormat.Shape shape = format.getShape();
                if (shape.isNumeric()) {
                     return withFormat(Boolean.TRUE, null);
                 }
 
                 if (format.getShape() == JsonFormat.Shape.STRING) {
                     TimeZone tz = format.getTimeZone();
                     final String pattern = format.hasPattern()
                                     ? format.getPattern()
                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;
                    final Locale loc = format.hasLocale()
                                    ? format.getLocale()
                                    : serializers.getLocale();
                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);
                    if (tz == null) {
                        tz = serializers.getTimeZone();
                    }
                    df.setTimeZone(tz);
                    return withFormat(Boolean.FALSE, df);
                }
            }
        }
        return this;
    }","@Override
public JsonSerializer<?> createContextual(SerializerProvider serializers,
        BeanProperty property) throws JsonMappingException {
    if (property != null) {
        Annotated annotatedMember = property.getMember();
        if (annotatedMember != null) {
            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat(annotatedMember);
            if (format != null) {
                // Simple case first: serialize as numeric timestamp?
                JsonFormat.Shape shape = format.getShape();
                if (shape != null) {
                    if (shape.isNumeric()) {
                        return withFormat(Boolean.TRUE, null);
                    }

                    if (shape == JsonFormat.Shape.STRING) {
                        TimeZone tz = format.getTimeZone();
                        final String pattern = format.hasPattern()
                                ? format.getPattern()
                                : StdDateFormat.DATE_FORMAT_STR_ISO8601;
                        final Locale loc = format.hasLocale()
                                ? format.getLocale()
                                : serializers.getLocale();
                        SimpleDateFormat df = new SimpleDateFormat(pattern, loc);
                        if (tz == null) {
                            tz = serializers.getTimeZone();
                        }
                        df.setTimeZone(tz);
                        return withFormat(Boolean.FALSE, df);
                    }
                }
            }
        }
    }
    return this;
}",0,0
246,JacksonDatabind_46,"@Override
    public StringBuilder getGenericSignature(StringBuilder sb)
    {
         _classSignature(_class, sb, false);
         sb.append('<');
         sb = _referencedType.getGenericSignature(sb);
         sb.append(';');
         return sb;
     }","@Override
public StringBuilder getGenericSignature(StringBuilder sb)
{
    _classSignature(_class, sb, false);
    sb.append('<');
    
    // Check if _referencedType is not null before calling getGenericSignature
    if (_referencedType != null) {
        sb = _referencedType.getGenericSignature(sb);
    }
    
    sb.append(';');
    return sb;
}",0,0
247,JacksonDatabind_47,"public JavaType refineSerializationType(final MapperConfig<?> config,
            final Annotated a, final JavaType baseType) throws JsonMappingException
    {
        JavaType type = baseType;
        final TypeFactory tf = config.getTypeFactory();
        
        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to
        //    now-deprecated secondary methods; this because while
        //    direct sub-class not yet retrofitted may only override
        //    those methods. With 2.8 or later we may consider removal
        //    of these methods

        
        // Ok: start by refining the main type itself; common to all types
        Class<?> serClass = findSerializationType(a);
        if (serClass != null) {
            if (type.hasRawClass(serClass)) {
                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of
                 //    static typing this way
                 type = type.withStaticTyping();
             } else {
                 try {
                     // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,
                     //   may be needed here too in future?
                         type = tf.constructGeneralizedType(type, serClass);
                 } catch (IllegalArgumentException iae) {
                     throw new JsonMappingException(null,
                             String.format(""Failed to widen type %s with annotation (value %s), from '%s': %s"",
                                    type, serClass.getName(), a.getName(), iae.getMessage()),
                                    iae);
                }
            }
        }
        // Then further processing for container types

        // First, key type (for Maps, Map-like types):
        if (type.isMapLikeType()) {
            JavaType keyType = type.getKeyType();
            Class<?> keyClass = findSerializationKeyType(a, keyType);
            if (keyClass != null) {
                if (keyType.hasRawClass(keyClass)) {
                    keyType = keyType.withStaticTyping();
                } else {
                    Class<?> currRaw = keyType.getRawClass();
                    try {
                        // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually
                        //   specialize (narrow) type sometimes, even if more commonly opposite
                        //   is needed.
                        if (keyClass.isAssignableFrom(currRaw)) { // common case
                            keyType = tf.constructGeneralizedType(keyType, keyClass);
                        } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well
                            keyType = tf.constructSpecializedType(keyType, keyClass);
                        } else {
                            throw new JsonMappingException(null,
                                    String.format(""Can not refine serialization key type %s into %s; types not related"",
                                            keyType, keyClass.getName()));
                        }
                    } catch (IllegalArgumentException iae) {
                        throw new JsonMappingException(null,
                                String.format(""Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s"",
                                        type, keyClass.getName(), a.getName(), iae.getMessage()),
                                        iae);
                    }
                }
                type = ((MapLikeType) type).withKeyType(keyType);
            }
        }

        JavaType contentType = type.getContentType();
        if (contentType != null) { // collection[like], map[like], array, reference
            // And then value types for all containers:
           Class<?> contentClass = findSerializationContentType(a, contentType);
           if (contentClass != null) {
               if (contentType.hasRawClass(contentClass)) {
                   contentType = contentType.withStaticTyping();
               } else {
                   // 03-Apr-2016, tatu: As per [databind#1178], may need to actually
                   //   specialize (narrow) type sometimes, even if more commonly opposite
                   //   is needed.
                   Class<?> currRaw = contentType.getRawClass();
                   try {
                       if (contentClass.isAssignableFrom(currRaw)) { // common case
                           contentType = tf.constructGeneralizedType(contentType, contentClass);
                       } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well
                           contentType = tf.constructSpecializedType(contentType, contentClass);
                       } else {
                           throw new JsonMappingException(null,
                                   String.format(""Can not refine serialization content type %s into %s; types not related"",
                                           contentType, contentClass.getName()));
                       }
                   } catch (IllegalArgumentException iae) { // shouldn't really happen
                       throw new JsonMappingException(null,
                               String.format(""Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s"",
                                       type, contentClass.getName(), a.getName(), iae.getMessage()),
                                       iae);
                   }
               }
               type = type.withContentType(contentType);
           }
        }
        return type;
    }",Match failed,0,0
248,JacksonDatabind_49,"public Object generateId(Object forPojo) {
         // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of
         //    id being generated for ""alwaysAsId"", but not being written as POJO; regardless,
         //    need to use existing id if there is one:
             id = generator.generateId(forPojo);
         return id;
     }","public Object generateId(Object forPojo) {
    // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of
    // id being generated for ""alwaysAsId"", but not being written as POJO; regardless,
    // need to use existing id if there is one:
    
    if (forPojo == null) {
        throw new IllegalArgumentException(""Cannot generate ID for null POJO object."");
    }

    Object id = generator.generateId(forPojo);
    return id;
}",0,0
249,JacksonDatabind_5,"protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,
            Class<?> mixInCls, AnnotatedMethodMap mixIns)
    {
        List<Class<?>> parents = new ArrayList<Class<?>>();
        parents.add(mixInCls);
        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);
        for (Class<?> mixin : parents) {
            for (Method m : mixin.getDeclaredMethods()) {
                if (!_isIncludableMemberMethod(m)) {
                    continue;
                }
                AnnotatedMethod am = methods.find(m);
                /* Do we already have a method to augment (from sub-class
                 * that will mask this mixIn)? If so, add if visible
                 * without masking (no such annotation)
                 */
                if (am != null) {
                    _addMixUnders(m, am);
                    /* Otherwise will have precedence, but must wait
                     * until we find the real method (mixIn methods are
                     * just placeholder, can't be called)
                      */
                 } else {
                     // Well, or, as per [Issue#515], multi-level merge within mixins...
                         mixIns.add(_constructMethod(m));
                 }
             }
         }
    }","protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,
            Class<?> mixInCls, AnnotatedMethodMap mixIns)
    {
        List<Class<?>> parents = new ArrayList<Class<?>>();
        parents.add(mixInCls);
        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);
        for (Class<?> mixin : parents) {
            for (Method m : mixin.getDeclaredMethods()) {
                if (!_isIncludableMemberMethod(m)) {
                    continue;
                }
                // Check if there is an existing method to augment
                AnnotatedMethod am = methods.find(m);
                // Do we already have a method to augment (from sub-class that will mask this mixIn)?
                if (am != null) {
                    _addMixUnders(m, am);
                } else {
                    // Store mix-in method unless already stored and augmented
                    if (!mixIns.hasMethod(m)) {
                        mixIns.add(_constructMethod(m));
                    }
                }
            }
        }
    }",0,0
250,JacksonDatabind_51,"protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,
            String typeId) throws IOException
    {
        JsonDeserializer<Object> deser = _deserializers.get(typeId);
        if (deser == null) {
            /* As per [Databind#305], need to provide contextual info. But for
             * backwards compatibility, let's start by only supporting this
             * for base class, not via interface. Later on we can add this
             * to the interface, assuming deprecation at base class helps.
             */
            JavaType type = _idResolver.typeFromId(ctxt, typeId);
            if (type == null) {
                // As per [JACKSON-614], use the default impl if no type id available:
                deser = _findDefaultImplDeserializer(ctxt);
                if (deser == null) {
                    // 10-May-2016, tatu: We may get some help...
                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);
                    if (actual == null) { // what should this be taken to mean?
                        // TODO: try to figure out something better
                        return null;
                    }
                    // ... would this actually work?
                    deser = ctxt.findContextualValueDeserializer(actual, _property);
                }
            } else {
                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,
                 *   we actually now need to explicitly narrow from base type (which may have parameterization)
                 *   using raw type.
                 *
                 *   One complication, though; can not change 'type class' (simple type to container); otherwise
                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual
                 *   type in process (getting SimpleType of Map.class which will not work as expected)
                 */
                if ((_baseType != null)
                        && _baseType.getClass() == type.getClass()) {
                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;
                     *   but it appears to check that JavaType impl class is the same which is
                     *   important for some reason?
                     *   Disabling the check will break 2 Enum-related tests.
                     */
                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full
                     //   generic type with custom type resolvers. If so, should try to retain them.
                     //  Whether this is sufficient to avoid problems remains to be seen, but for
                     //  now it should improve things.
                         type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());
                 }
                 deser = ctxt.findContextualValueDeserializer(type, _property);
             }
            _deserializers.put(typeId, deser);
        }
        return deser;
    }","protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,
            String typeId) throws IOException
    {
        JsonDeserializer<Object> deser = _deserializers.get(typeId);
        if (deser == null) {
            JavaType type = _idResolver.typeFromId(ctxt, typeId);
            if (type == null) {
                deser = _findDefaultImplDeserializer(ctxt);
                if (deser == null) {
                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);
                    if (actual == null) {
                        throw new IOException(""Unknown type ID: "" + typeId);
                    }
                    deser = ctxt.findContextualValueDeserializer(actual, _property);
                }
            } else {
                if ((_baseType != null)
                        && _baseType.getClass() == type.getClass()) {
                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());
                }
                deser = ctxt.findContextualValueDeserializer(type, _property);
            }
            _deserializers.put(typeId, deser);
        }
        return deser;
    }",0,0
251,JacksonDatabind_54,"@SuppressWarnings(""deprecation"")
    protected BeanPropertyWriter buildWriter(SerializerProvider prov,
            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,
            TypeSerializer typeSer, TypeSerializer contentTypeSer,
            AnnotatedMember am, boolean defaultUseStaticTyping)
        throws JsonMappingException
    {
        // do we have annotation that forces type to use (to declared type or its super type)?
        JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);

        // Container types can have separate type serializers for content (value / element) type
        if (contentTypeSer != null) {
            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is
             *    type information for contents. Should work well (for JAXB case); can be
             *    revisited if this causes problems.
             */
            if (serializationType == null) {
//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());
                serializationType = declaredType;
            }
            JavaType ct = serializationType.getContentType();
            // Not exactly sure why, but this used to occur; better check explicitly:
            if (ct == null) {
                throw new IllegalStateException(""Problem trying to create BeanPropertyWriter for property '""
                        +propDef.getName()+""' (of type ""+_beanDesc.getType()+""); serialization type ""+serializationType+"" has no content"");
            }
            serializationType = serializationType.withContentTypeHandler(contentTypeSer);
            ct = serializationType.getContentType();
        }
        
        Object valueToSuppress = null;
        boolean suppressNulls = false;

        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());
        JsonInclude.Include inclusion = inclV.getValueInclusion();
        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...
            inclusion = JsonInclude.Include.ALWAYS;
        }

        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement
        JavaType actualType = (serializationType == null) ? declaredType : serializationType;
        
        switch (inclusion) {
        case NON_DEFAULT:
            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,
            //    so that if enclosing class has this, we may need to values of property,
            //    whereas for global defaults OR per-property overrides, we have more
            //    static definition. Sigh.
            // First: case of class specifying it; try to find POJO property defaults
            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {
                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);
            } else {
                valueToSuppress = getDefaultValue(actualType);
            }
            if (valueToSuppress == null) {
                suppressNulls = true;
            } else {
                if (valueToSuppress.getClass().isArray()) {
                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
                }
            }

            break;
        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals
            // always suppress nulls
            suppressNulls = true;
            // and for referential types, also ""empty"", which in their case means ""absent""
            if (declaredType.isReferenceType()) {
                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            }
            break;
        case NON_EMPTY:
            // always suppress nulls
            suppressNulls = true;
            // but possibly also 'empty' values:
            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            break;
        case NON_NULL:
            suppressNulls = true;
            // fall through
         case ALWAYS: // default
         default:
             // we may still want to suppress empty collections, as per [JACKSON-254]:
             if (declaredType.isContainerType()
                     && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {
                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
             }
            break;
        }
        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,
                am, _beanDesc.getClassAnnotations(), declaredType,
                ser, typeSer, serializationType, suppressNulls, valueToSuppress);

        // How about custom null serializer?
        Object serDef = _annotationIntrospector.findNullSerializer(am);
        if (serDef != null) {
            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));
        }
        // And then, handling of unwrapping
        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);
        if (unwrapper != null) {
            bpw = bpw.unwrappingWriter(unwrapper);
        }
        return bpw;
    }","@SuppressWarnings(""deprecation"")
protected BeanPropertyWriter buildWriter(SerializerProvider prov,
        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,
        TypeSerializer typeSer, TypeSerializer contentTypeSer,
        AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {

    // do we have annotation that forces type to use (to declared type or its super type)?
    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);

    // Container types can have separate type serializers for content (value / element) type
    if (contentTypeSer != null) {
        // Let's force static typing for collection if there is type information for contents.
        if (serializationType == null) {
            serializationType = declaredType;
        }
        JavaType ct = serializationType.getContentType();
        if (ct == null) {
            throw new IllegalStateException(""Problem trying to create BeanPropertyWriter for property '""
                    + propDef.getName() + ""' (of type "" + _beanDesc.getType() 
                    + ""); serialization type "" + serializationType + "" has no content"");
        }
        serializationType = serializationType.withContentTypeHandler(contentTypeSer);
    }

    Object valueToSuppress = null;
    boolean suppressNulls = false;

    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());
    JsonInclude.Include inclusion = inclV.getValueInclusion();
    if (inclusion == JsonInclude.Include.USE_DEFAULTS) {
        inclusion = JsonInclude.Include.ALWAYS;
    }

    // Ensure we consider type refinement for suppression
    JavaType actualType = (serializationType == null) ? declaredType : serializationType;

    switch (inclusion) {
    case NON_DEFAULT:
        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {
            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);
        } else {
            valueToSuppress = getDefaultValue(actualType);
        }
        if (valueToSuppress == null) {
            suppressNulls = true;
        } else if (valueToSuppress.getClass().isArray()) {
            valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
        }
        break;
    case NON_ABSENT:
        suppressNulls = true;
        if (declaredType.isReferenceType()) {
            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
        }
        break;
    case NON_EMPTY:
        suppressNulls = true;
        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
        break;
    case NON_NULL:
        suppressNulls = true;
        break;
    case ALWAYS:
    default:
        if (declaredType.isContainerType()
                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {
            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
        }
        break;
    }

    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(),
            declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress);

    Object serDef = _annotationIntrospector.findNullSerializer(am);
    if (serDef != null) {
        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));
    }

    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);
    if (unwrapper != null) {
        bpw = bpw.unwrappingWriter(unwrapper);
    }
    return bpw;
}",0,0
252,JacksonDatabind_57,"public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)
        throws IOException, JsonProcessingException
    {
         if (_dataFormatReaders != null) {
             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);
         }
         return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), 
                 true));
     }","public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)
        throws IOException, JsonProcessingException
    {
        if (src == null || src.length == 0 || offset < 0 || length <= 0 || offset + length > src.length) {
            throw new IllegalArgumentException(""Invalid source array, offset or length"");
        }
        
        if (_dataFormatReaders != null) {
            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);
        }
        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), 
                true));
    }",0,0
253,JacksonDatabind_58,"protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,
            BeanDescription beanDesc, BeanPropertyDefinition propDef,
            JavaType propType0)
        throws JsonMappingException
    {
        // need to ensure method is callable (for non-public)
        AnnotatedMember mutator = propDef.getNonConstructorMutator();

        if (ctxt.canOverrideAccessModifiers()) {
             // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;
             // never needed and attempts may cause problems on some platforms.
             // !!! NOTE: should be handled better for 2.8 and later
                 mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
         }
         // note: this works since we know there's exactly one argument for methods
         BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),
                propType0, propDef.getWrapperName(),
                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());
        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);
        // did type change?
        if (type != propType0) {
            property = property.withType(type);
        }

        // First: does the Method specify the deserializer to use? If so, let's use it.
        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);
        type = modifyTypeByAnnotation(ctxt, mutator, type);
        TypeDeserializer typeDeser = type.getTypeHandler();
        SettableBeanProperty prop;
        if (mutator instanceof AnnotatedMethod) {
            prop = new MethodProperty(propDef, type, typeDeser,
                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);
        } else {
            prop = new FieldProperty(propDef, type, typeDeser,
                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);
        }
        if (propDeser != null) {
            prop = prop.withValueDeserializer(propDeser);
        }
        // need to retain name of managed forward references:
        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();
        if (ref != null && ref.isManagedReference()) {
            prop.setManagedReferenceName(ref.getName());
        }
        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();
        if(objectIdInfo != null){
            prop.setObjectIdInfo(objectIdInfo);
        }
        return prop;
    }","protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,
            BeanDescription beanDesc, BeanPropertyDefinition propDef,
            JavaType propType0)
        throws JsonMappingException
    {
        // need to ensure method is callable (for non-public)
        AnnotatedMember mutator = propDef.getNonConstructorMutator();

        if (mutator == null) {
            throw new IllegalArgumentException(""No mutator available for property '"" + propDef.getName() + ""'"");
        }

        if (ctxt.canOverrideAccessModifiers()) {
            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;
            // never needed and attempts may cause problems on some platforms.
            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
        }

        // note: this works since we know there's exactly one argument for methods
        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),
                propType0, propDef.getWrapperName(),
                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());
        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);

        // did type change?
        if (type != propType0) {
            property = property.withType(type);
        }

        // First: does the Method specify the deserializer to use? If so, let's use it.
        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);
        type = modifyTypeByAnnotation(ctxt, mutator, type);
        TypeDeserializer typeDeser = type.getTypeHandler();
        SettableBeanProperty prop;
        if (mutator instanceof AnnotatedMethod) {
            prop = new MethodProperty(propDef, type, typeDeser,
                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);
        } else if (mutator instanceof AnnotatedField) {
            prop = new FieldProperty(propDef, type, typeDeser,
                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);
        } else {
            throw new IllegalStateException(""Unsupported mutator type: "" + mutator.getClass().getName());
        }

        if (propDeser != null) {
            prop = prop.withValueDeserializer(propDeser);
        }

        // need to retain name of managed forward references:
        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();
        if (ref != null && ref.isManagedReference()) {
            prop.setManagedReferenceName(ref.getName());
        }

        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();
        if (objectIdInfo != null) {
            prop.setObjectIdInfo(objectIdInfo);
        }

        return prop;
    }",0,0
254,JacksonDatabind_6,"    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)
    {
        if (_formatRFC1123 == null) {
            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);
        }
        return _formatRFC1123.parse(dateStr, pos);
    }
","protected Date parseAsRFC1123(String dateStr, ParsePosition pos) {
    if (_formatRFC1123 == null) {
        synchronized (this) { // Ensure thread-safety when initializing _formatRFC1123
            if (_formatRFC1123 == null) {
                _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);
            }
        }
    }
    return _formatRFC1123.parse(dateStr, pos);
}",0,0
255,JacksonDatabind_62,"@Override
    public CollectionDeserializer createContextual(DeserializationContext ctxt,
            BeanProperty property) throws JsonMappingException
    {
        // May need to resolve types for delegate-based creators:
        JsonDeserializer<Object> delegateDeser = null;
        if (_valueInstantiator != null) {
            if (_valueInstantiator.canCreateUsingDelegate()) {
                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());
                if (delegateType == null) {
                    throw new IllegalArgumentException(""Invalid delegate-creator definition for ""+_collectionType
                            +"": value instantiator (""+_valueInstantiator.getClass().getName()
                             +"") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"");
                 }
                 delegateDeser = findDeserializer(ctxt, delegateType, property);
             }
         }
         // [databind#1043]: allow per-property allow-wrapping of single overrides:
        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly
        //   comes down to ""List vs Collection"" I suppose... for now, pass Collection
        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
        // also, often value deserializer is resolved here:
        JsonDeserializer<?> valueDeser = _valueDeserializer;
        
        // May have a content converter
        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);
        final JavaType vt = _collectionType.getContentType();
        if (valueDeser == null) {
            valueDeser = ctxt.findContextualValueDeserializer(vt, property);
        } else { // if directly assigned, probably not yet contextual, so:
            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);
        }
        // and finally, type deserializer needs context as well
        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;
        if (valueTypeDeser != null) {
            valueTypeDeser = valueTypeDeser.forProperty(property);
        }
        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);
    }","@Override
public CollectionDeserializer createContextual(DeserializationContext ctxt,
        BeanProperty property) throws JsonMappingException {
    // May need to resolve types for delegate-based creators:
    JsonDeserializer<Object> delegateDeser = null;
    if (_valueInstantiator != null) {
        if (_valueInstantiator.canCreateUsingDelegate()) {
            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());
            if (delegateType == null) {
                throw JsonMappingException.from(ctxt, ""Invalid delegate-creator definition for "" + _collectionType
                        + "": value instantiator ("" + _valueInstantiator.getClass().getName()
                        + "") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"");
            }
            delegateDeser = findDeserializer(ctxt, delegateType, property);
        }
    }
    
    // [databind#1043]: allow per-property allow-wrapping of single overrides
    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,
            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
    
    // Also, often value deserializer is resolved here
    JsonDeserializer<?> valueDeser = _valueDeserializer;
    
    // May have a content converter
    valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);
    final JavaType vt = _collectionType.getContentType();
    if (valueDeser == null) {
        valueDeser = ctxt.findContextualValueDeserializer(vt, property);
    } else { 
        // If directly assigned, probably not yet contextual, so:
        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);
    }
    
    // And finally, type deserializer needs context as well
    TypeDeserializer valueTypeDeser = _valueTypeDeserializer;
    if (valueTypeDeser != null) {
        valueTypeDeser = valueTypeDeser.forProperty(property);
    }
    
    // Return the resolved deserializer instance
    return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);
}",0,0
256,JacksonDatabind_64,"@SuppressWarnings(""deprecation"")
    protected BeanPropertyWriter buildWriter(SerializerProvider prov,
            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,
            TypeSerializer typeSer, TypeSerializer contentTypeSer,
            AnnotatedMember am, boolean defaultUseStaticTyping)
        throws JsonMappingException
    {
        // do we have annotation that forces type to use (to declared type or its super type)?
        JavaType serializationType;
        try {
            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);
        } catch (JsonMappingException e) {
            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());
        }

        // Container types can have separate type serializers for content (value / element) type
        if (contentTypeSer != null) {
            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is
             *    type information for contents. Should work well (for JAXB case); can be
             *    revisited if this causes problems.
             */
            if (serializationType == null) {
//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());
                serializationType = declaredType;
            }
            JavaType ct = serializationType.getContentType();
            // Not exactly sure why, but this used to occur; better check explicitly:
            if (ct == null) {
                prov.reportBadPropertyDefinition(_beanDesc, propDef,
                        ""serialization type ""+serializationType+"" has no content"");
            }
            serializationType = serializationType.withContentTypeHandler(contentTypeSer);
            ct = serializationType.getContentType();
        }

        Object valueToSuppress = null;
        boolean suppressNulls = false;

        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement
        JavaType actualType = (serializationType == null) ? declaredType : serializationType;
        
        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well
        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)
        //   for declared property type... and finally property annotation overrides
        JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),
                _defaultInclusion);

        // property annotation override
        
        inclV = inclV.withOverrides(propDef.findInclusion());
        JsonInclude.Include inclusion = inclV.getValueInclusion();

        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...
            inclusion = JsonInclude.Include.ALWAYS;
        }
        
        switch (inclusion) {
        case NON_DEFAULT:
            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,
            //    so that if enclosing class has this, we may need to access values of property,
             //    whereas for global defaults OR per-property overrides, we have more
             //    static definition. Sigh.
             // First: case of class/type specifying it; try to find POJO property defaults
 
             // 16-Oct-2016, tatu: Note: if we can not for some reason create ""default instance"",
             //    revert logic to the case of general/per-property handling, so both
             //    type-default AND null are to be excluded.
             //    (as per [databind#1417]
             if (_useRealPropertyDefaults) {
                 // 07-Sep-2016, tatu: may also need to front-load access forcing now
                 if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {
                     am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
                 }
                 valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);
             } else {
                 valueToSuppress = getDefaultValue(actualType);
                 suppressNulls = true;
            }
            if (valueToSuppress == null) {
                suppressNulls = true;
            } else {
                if (valueToSuppress.getClass().isArray()) {
                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
                }
            }
            break;
        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals
            // always suppress nulls
            suppressNulls = true;
            // and for referential types, also ""empty"", which in their case means ""absent""
            if (actualType.isReferenceType()) {
                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            }
            break;
        case NON_EMPTY:
            // always suppress nulls
            suppressNulls = true;
            // but possibly also 'empty' values:
            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            break;
        case NON_NULL:
            suppressNulls = true;
            // fall through
        case ALWAYS: // default
        default:
            // we may still want to suppress empty collections, as per [JACKSON-254]:
            if (actualType.isContainerType()
                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {
                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            }
            break;
        }
        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,
                am, _beanDesc.getClassAnnotations(), declaredType,
                ser, typeSer, serializationType, suppressNulls, valueToSuppress);

        // How about custom null serializer?
        Object serDef = _annotationIntrospector.findNullSerializer(am);
        if (serDef != null) {
            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));
        }
        // And then, handling of unwrapping
        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);
        if (unwrapper != null) {
            bpw = bpw.unwrappingWriter(unwrapper);
        }
        return bpw;
    }","@SuppressWarnings(""deprecation"")
protected BeanPropertyWriter buildWriter(SerializerProvider prov,
        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,
        TypeSerializer typeSer, TypeSerializer contentTypeSer,
        AnnotatedMember am, boolean defaultUseStaticTyping)
    throws JsonMappingException
{
    // do we have annotation that forces type to use (to declared type or its super type)?
    JavaType serializationType;
    try {
        serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);
    } catch (JsonMappingException e) {
        return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());
    }

    // Container types can have separate type serializers for content (value / element) type
    if (contentTypeSer != null) {
        if (serializationType == null) {
            serializationType = declaredType;
        }
        JavaType ct = serializationType.getContentType();
        if (ct == null) {
            prov.reportBadPropertyDefinition(_beanDesc, propDef,
                    ""serialization type ""+serializationType+"" has no content"");
        } else {
            serializationType = serializationType.withContentTypeHandler(contentTypeSer);
        }
    }

    Object valueToSuppress = null;
    boolean suppressNulls = false;

    // Consider type refinement
    JavaType actualType = (serializationType == null) ? declaredType : serializationType;
    
    // Determine inclusion settings
    JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),
            _defaultInclusion);
    
    inclV = inclV.withOverrides(propDef.findInclusion());
    JsonInclude.Include inclusion = inclV.getValueInclusion();

    if (inclusion == JsonInclude.Include.USE_DEFAULTS) {
        inclusion = JsonInclude.Include.ALWAYS;
    }
    
    switch (inclusion) {
    case NON_DEFAULT:
        if (_useRealPropertyDefaults) {
            if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {
                am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
            }
            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);
        } else {
            valueToSuppress = getDefaultValue(actualType);
            suppressNulls = true;
        }
        if (valueToSuppress == null) {
            suppressNulls = true;
        } else if (valueToSuppress.getClass().isArray()) {
            valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
        }
        break;

    case NON_ABSENT:
        suppressNulls = true;
        if (actualType.isReferenceType()) {
            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
        }
        break;

    case NON_EMPTY:
        suppressNulls = true;
        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
        break;

    case NON_NULL:
        suppressNulls = true;
        // fall through

    case ALWAYS:
    default:
        if (actualType.isContainerType()
                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {
            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
        }
        break;
    }

    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,
            am, _beanDesc.getClassAnnotations(), declaredType,
            ser, typeSer, serializationType, suppressNulls, valueToSuppress);

    Object serDef = _annotationIntrospector.findNullSerializer(am);
    if (serDef != null) {
        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));
    }

    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);
    if (unwrapper != null) {
        bpw = bpw.unwrappingWriter(unwrapper);
    }
    return bpw;
}",0,0
257,JacksonDatabind_67,"@Override
    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,
            JavaType type)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        KeyDeserializer deser = null;
        if (_factoryConfig.hasKeyDeserializers()) {
            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());
            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {
                deser = d.findKeyDeserializer(type, config, beanDesc);
                if (deser != null) {
                    break;
                }
            }
        }
         // the only non-standard thing is this:
         if (deser == null) {
             if (type.isEnumType()) {
                 return _createEnumKeyDeserializer(ctxt, type);
             }
             deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);
         }
         // and then post-processing
         if (deser != null) {
            if (_factoryConfig.hasDeserializerModifiers()) {
                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                    deser = mod.modifyKeyDeserializer(config, type, deser);
                }
            }
        }
        return deser;
    }","@Override
public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,
        JavaType type)
    throws JsonMappingException
{
    final DeserializationConfig config = ctxt.getConfig();
    KeyDeserializer deser = null;
    if (_factoryConfig.hasKeyDeserializers()) {
        BeanDescription beanDesc = config.introspectClassAnnotations(type);
        for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {
            deser = d.findKeyDeserializer(type, config, beanDesc);
            if (deser != null) {
                break;
            }
        }
    }
    
    if (deser == null) {
        if (type.isEnumType()) {
            deser = _createEnumKeyDeserializer(ctxt, type);
        } else {
            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);
        }
    }
    
    if (deser != null && _factoryConfig.hasDeserializerModifiers()) {
        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
            deser = mod.modifyKeyDeserializer(config, type, deser);
        }
    }
    
    return deser;
}",0,0
258,JacksonDatabind_7,"public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
     {
             copyCurrentStructure(jp);
         /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from
          *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need
          *    to assume one did exist.
          */
         return this;
     }","public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
    TokenBuffer tokenBuffer = new TokenBuffer(jp.getCodec());
    // As per #592, support the case of starting from FIELD_NAME
    if (jp.currentToken() == JsonToken.FIELD_NAME) {
        // Assume a START_OBJECT existed
        tokenBuffer.writeStartObject();
        tokenBuffer.copyCurrentStructure(jp);
        tokenBuffer.writeEndObject();
    } else {
        tokenBuffer.copyCurrentStructure(jp);
    }
    return tokenBuffer;
}",0,0
259,JacksonDatabind_70,"    public void remove(SettableBeanProperty propToRm)
    {
        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);
        String key = getPropertyName(propToRm);
        boolean found = false;

        for (int i = 1, end = _hashArea.length; i < end; i += 2) {
            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];
            if (prop == null) {
                continue;
            }
            if (!found) {
                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,
                //   as only former is lower-case in case-insensitive case
                found = key.equals(prop.getName());
                if (found) {
                    // need to leave a hole here
                    _propsInOrder[_findFromOrdered(prop)] = null;
                    continue;
                }
            }
            props.add(prop);
        }
        if (!found) {
            throw new NoSuchElementException(""No entry '""+propToRm.getName()+""' found, can't remove"");
        }
        init(props);
    }
","public void remove(SettableBeanProperty propToRm) {
    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);
    String key = getPropertyName(propToRm);
    boolean found = false;

    for (int i = 1, end = _hashArea.length; i < end; i += 2) {
        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];
        if (prop == null) {
            continue;
        }
        if (!found) {
            // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,
            //   as only former is lower-case in case-insensitive case
            found = key.equals(getPropertyName(prop));
            if (found) {
                // need to leave a hole here
                _hashArea[i] = null; // remove from hash area
                _propsInOrder[_findFromOrdered(prop)] = null; // remove from ordered props
                continue;
            }
        }
        props.add(prop);
    }
    if (!found) {
        throw new NoSuchElementException(""No entry '"" + propToRm.getName() + ""' found, can't remove"");
    }
    init(props);
}",0,0
260,JacksonDatabind_71,"public static StdKeyDeserializer forType(Class<?> raw)
    {
         int kind;
 
         // first common types:
         if (raw == String.class || raw == Object.class) {
             return StringKD.forType(raw);
         } else if (raw == UUID.class) {
             kind = TYPE_UUID;
        } else if (raw == Integer.class) {
            kind = TYPE_INT;
        } else if (raw == Long.class) {
            kind = TYPE_LONG;
        } else if (raw == Date.class) {
            kind = TYPE_DATE;
        } else if (raw == Calendar.class) {
            kind = TYPE_CALENDAR;
        // then less common ones...
        } else if (raw == Boolean.class) {
            kind = TYPE_BOOLEAN;
        } else if (raw == Byte.class) {
            kind = TYPE_BYTE;
        } else if (raw == Character.class) {
            kind = TYPE_CHAR;
        } else if (raw == Short.class) {
            kind = TYPE_SHORT;
        } else if (raw == Float.class) {
            kind = TYPE_FLOAT;
        } else if (raw == Double.class) {
            kind = TYPE_DOUBLE;
        } else if (raw == URI.class) {
            kind = TYPE_URI;
        } else if (raw == URL.class) {
            kind = TYPE_URL;
        } else if (raw == Class.class) {
            kind = TYPE_CLASS;
        } else if (raw == Locale.class) {
            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);
            return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);
        } else if (raw == Currency.class) {
            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);
            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);
        } else {
            return null;
        }
        return new StdKeyDeserializer(kind, raw);
    }","public static StdKeyDeserializer forType(Class<?> raw)
    {
         int kind;
  
         // first common types:
         if (raw == String.class || raw == Object.class) {
             return StringKD.forType(raw);
         } else if (raw == UUID.class) {
             kind = TYPE_UUID;
         } else if (raw == Integer.class) {
             kind = TYPE_INT;
         } else if (raw == Long.class) {
             kind = TYPE_LONG;
         } else if (raw == Date.class) {
             kind = TYPE_DATE;
         } else if (raw == Calendar.class) {
             kind = TYPE_CALENDAR;
         // then less common ones...
         } else if (raw == Boolean.class) {
             kind = TYPE_BOOLEAN;
         } else if (raw == Byte.class) {
             kind = TYPE_BYTE;
         } else if (raw == Character.class) {
             kind = TYPE_CHAR;
         } else if (raw == Short.class) {
             kind = TYPE_SHORT;
         } else if (raw == Float.class) {
             kind = TYPE_FLOAT;
         } else if (raw == Double.class) {
             kind = TYPE_DOUBLE;
         } else if (raw == URI.class) {
             kind = TYPE_URI;
         } else if (raw == URL.class) {
             kind = TYPE_URL;
         } else if (raw == Class.class) {
             kind = TYPE_CLASS;
         } else if (raw == Locale.class) {
             FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);
             return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);
         } else if (raw == Currency.class) {
             FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);
             return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);
         } else {
             return null;
         }
         return new StdKeyDeserializer(kind, raw);
     }",0,0
261,JacksonDatabind_74,"    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,
            TokenBuffer tb) throws IOException
    {
        // As per [JACKSON-614], may have default implementation to use
        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);
        if (deser != null) {
            if (tb != null) {
                tb.writeEndObject();
                p = tb.asParser(p);
                // must move to point to the first token:
                p.nextToken();
            }
            return deser.deserialize(p, ctxt);
        }
        // or, perhaps we just bumped into a ""natural"" value (boolean/int/double/String)?
        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);
        if (result != null) {
            return result;
        }
        // or, something for which ""as-property"" won't work, changed into ""wrapper-array"" type:
        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromAny(p, ctxt);
        }
        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,
                ""missing property '""+_typePropertyName+""' that is to contain type id  (for class ""+baseTypeName()+"")"");
        return null;
    }
","protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,
            TokenBuffer tb) throws IOException
    {
        // As per [JACKSON-614], may have default implementation to use
        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);
        if (deser != null) {
            if (tb != null) {
                tb.writeEndObject();
                p = tb.asParserOnFirstToken(); // Ensure proper token handling
                // must move to point to the first token:
                if (p.nextToken() == null) { // Ensure nextToken returns a valid token
                    ctxt.reportInputMismatch(_baseType,
                        ""Unable to initialize parser with default implementation buffer"");
                    return null;
                }
            }
            return deser.deserialize(p, ctxt);
        }

        // Check if parser is at a valid state to proceed
        if (p == null || p.getCurrentToken() == null) {
            ctxt.reportInputMismatch(_baseType,
                ""Parser is in an invalid state: null or missing token"");
            return null;
        }

        // or, perhaps we just bumped into a ""natural"" value (boolean/int/double/String)?
        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);
        if (result != null) {
            return result;
        }

        // Or, handle non-standard wrapper-array type
        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromAny(p, ctxt);
        }

        // Provide proper error handling with detailed reporting
        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,
                ""Missing property '""+_typePropertyName+""' that is to contain type id (for class ""+baseTypeName()+""). "" +
                ""Current token: "" + p.getCurrentToken());
        return null;
    }",0,0
262,JacksonDatabind_76,"    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,
    		DeserializationContext ctxt)
        throws IOException, JsonProcessingException
    {
        final PropertyBasedCreator creator = _propertyBasedCreator;
        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

        TokenBuffer tokens = new TokenBuffer(p, ctxt);
        tokens.writeStartObject();

        JsonToken t = p.getCurrentToken();
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            p.nextToken(); // to point to value
            // creator property?
            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
            if (creatorProp != null) {
                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {
                    t = p.nextToken();
                    Object bean;
                    try {
                        bean = creator.build(ctxt, buffer);
                    } catch (Exception e) {
                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                        continue;
                    }
                    while (t == JsonToken.FIELD_NAME) {
                        p.nextToken();
                        tokens.copyCurrentStructure(p);
                        t = p.nextToken();
                    }
                    tokens.writeEndObject();
                    if (bean.getClass() != _beanType.getRawClass()) {
                        ctxt.reportMappingException(""Can not create polymorphic instances with unwrapped values"");
                        return null;
                    }
                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
                }
                continue;
            }
            // Object Id property?
            if (buffer.readIdProperty(propName)) {
                continue;
            }
            // regular property? needs buffering
            SettableBeanProperty prop = _beanProperties.find(propName);
            if (prop != null) {
                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));
                continue;
            }
            if (_ignorableProps != null && _ignorableProps.contains(propName)) {
                handleIgnoredProperty(p, ctxt, handledType(), propName);
                continue;
            }
            tokens.writeFieldName(propName);
            tokens.copyCurrentStructure(p);
            // ""any property""?
            if (_anySetter != null) {
                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
            }
        }

        // We hit END_OBJECT, so:
        Object bean;
        // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!
        try {
            bean = creator.build(ctxt, buffer);
        } catch (Exception e) {
            return wrapInstantiationProblem(e, ctxt);
        }
        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
    }
","protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,
         DeserializationContext ctxt)
    throws IOException, JsonProcessingException
{
    final PropertyBasedCreator creator = _propertyBasedCreator;
    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

    TokenBuffer tokens = new TokenBuffer(p, ctxt);
    tokens.writeStartObject();

    JsonToken t = p.getCurrentToken();
    if (t == JsonToken.START_OBJECT) {
        t = p.nextToken();
    }

    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
        String propName = p.getCurrentName();
        p.nextToken(); // to point to value
        // creator property?
        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
        if (creatorProp != null) {
            if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {
                t = p.nextToken();
                Object bean;
                try {
                    bean = creator.build(ctxt, buffer);
                } catch (Exception e) {
                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                    continue;
                }
                while (t == JsonToken.FIELD_NAME) {
                    p.nextToken();
                    tokens.copyCurrentStructure(p);
                    t = p.nextToken();
                }
                tokens.writeEndObject();
                if (bean.getClass() != _beanType.getRawClass()) {
                    ctxt.reportMappingException(""Can not create polymorphic instances with unwrapped values"");
                    return null;
                }
                return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
            }
            continue;
        }
        // Object Id property?
        if (buffer.readIdProperty(propName)) {
            continue;
        }
        // regular property? needs buffering
        SettableBeanProperty prop = _beanProperties.find(propName);
        if (prop != null) {
            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));
            continue;
        }
        if (_ignorableProps != null && _ignorableProps.contains(propName)) {
            handleIgnoredProperty(p, ctxt, handledType(), propName);
            continue;
        }
        tokens.writeFieldName(propName);
        tokens.copyCurrentStructure(p);
        // ""any property""?
        if (_anySetter != null) {
            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
        }
    }

    tokens.writeEndObject();

    Object bean;
    try {
        bean = creator.build(ctxt, buffer);
    } catch (Exception e) {
        return wrapInstantiationProblem(e, ctxt);
    }
    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
}",0,0
263,JacksonDatabind_8,"protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
    {
        final int mask = (1 << typeIndex);
        _hasNonDefaultCreator = true;
         AnnotatedWithParams oldOne = _creators[typeIndex];
         // already had an explicitly marked one?
         if (oldOne != null) {
 
             if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is
                 // but skip, if new one not annotated
                if (!explicit) {
                    return;
                }
                // both explicit: verify
                // otherwise only verify if neither explicitly annotated.
            }

            // one more thing: ok to override in sub-class
            if (oldOne.getClass() == newOne.getClass()) {
                // [databind#667]: avoid one particular class of bogus problems

                    throw new IllegalArgumentException(""Conflicting ""+TYPE_DESCS[typeIndex]
                            +"" creators: already had explicitly marked ""+oldOne+"", encountered ""+newOne);
                // otherwise, which one to choose?
                    // new type more generic, use old
                // new type more specific, use it
            }
        }
        if (explicit) {
            _explicitCreators |= mask;
        }
        _creators[typeIndex] = _fixAccess(newOne);
    }","protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
{
    final int mask = (1 << typeIndex);
    _hasNonDefaultCreator = true;
    AnnotatedWithParams oldOne = _creators[typeIndex];

    // already had an explicitly marked creator?
    if (oldOne != null) {
        if ((_explicitCreators & mask) != 0) { // explicitly annotated creator already exists
            // skip if the new creator is not explicitly annotated
            if (!explicit) {
                return;
            }
            // both creators are explicit: verify potential conflict
            if (oldOne.getClass() == newOne.getClass()) {
                // Throwing an error on conflicting explicit creators
                throw new IllegalArgumentException(""Conflicting "" + TYPE_DESCS[typeIndex]
                        + "" creators: already had explicitly marked "" + oldOne
                        + "", encountered "" + newOne);
            }
        }
    }

    // If new creator is explicitly annotated, mark it as such
    if (explicit) {
        _explicitCreators |= mask;
    }
    // Store the new creator after fixing access
    _creators[typeIndex] = _fixAccess(newOne);
}",0,0
264,JacksonDatabind_82,"protected void addBeanProps(DeserializationContext ctxt,
            BeanDescription beanDesc, BeanDeserializerBuilder builder)
        throws JsonMappingException
    {
        final boolean isConcrete = !beanDesc.getType().isAbstract();
        final SettableBeanProperty[] creatorProps = isConcrete
                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())
                : null;
        final boolean hasCreatorProps = (creatorProps != null);
        
        // 01-May-2016, tatu: Which base type to use here gets tricky, since
        //   it may often make most sense to use general type for overrides,
        //   but what we have here may be more specific impl type. But for now
        //   just use it as is.
        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()
                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),
                        beanDesc.getClassInfo());
        Set<String> ignored;

        if (ignorals != null) {
             boolean ignoreAny = ignorals.getIgnoreUnknown();
             builder.setIgnoreUnknownProperties(ignoreAny);
             // Or explicit/implicit definitions?
             ignored = ignorals.getIgnored();
             for (String propName : ignored) {
                 builder.addIgnorable(propName);
             }
        } else {
            ignored = Collections.emptySet();
        }

        // Also, do we have a fallback ""any"" setter?
        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();
        AnnotatedMember anySetterField = null;
        if (anySetterMethod != null) {
            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));
        }
        else {
        	anySetterField = beanDesc.findAnySetterField();
        	if(anySetterField != null) {
        		builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));
        	}
        }
        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter
        // Implicit ones via @JsonIgnore and equivalent?
        if (anySetterMethod == null && anySetterField == null) {
            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();
            if (ignored2 != null) {
                for (String propName : ignored2) {
                    // allow ignoral of similarly named JSON property, but do not force;
                    // latter means NOT adding this to 'ignored':
                    builder.addIgnorable(propName);
                }
            }
        }
        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)
                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);

        // Ok: let's then filter out property definitions
        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,
                beanDesc, builder, beanDesc.findProperties(), ignored);

        // After which we can let custom code change the set
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);
            }
        }
        
        // At which point we still have all kinds of properties; not all with mutators:
        for (BeanPropertyDefinition propDef : propDefs) {
            SettableBeanProperty prop = null;
            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,
             *   we need to do linkage (as per [databind#318]), and so need to start with
             *   other types, and only then create constructor parameter, if any.
             */
            if (propDef.hasSetter()) {
                JavaType propertyType = propDef.getSetter().getParameterType(0);
                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);
            } else if (propDef.hasField()) {
                JavaType propertyType = propDef.getField().getType();
                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);
            } else if (useGettersAsSetters && propDef.hasGetter()) {
                /* May also need to consider getters
                 * for Map/Collection properties; but with lowest precedence
                 */
                AnnotatedMethod getter = propDef.getGetter();
                // should only consider Collections and Maps, for now?
                Class<?> rawPropertyType = getter.getRawType();
                if (Collection.class.isAssignableFrom(rawPropertyType)
                        || Map.class.isAssignableFrom(rawPropertyType)) {
                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);
                }
            }
            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types
            //   (since they are never used anyway)
            if (hasCreatorProps && propDef.hasConstructorParameter()) {
                /* If property is passed via constructor parameter, we must
                 * handle things in special way. Not sure what is the most optimal way...
                 * for now, let's just call a (new) method in builder, which does nothing.
                 */
                // but let's call a method just to allow custom builders to be aware...
                final String name = propDef.getName();
                CreatorProperty cprop = null;
                if (creatorProps != null) {
                    for (SettableBeanProperty cp : creatorProps) {
                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {
                            cprop = (CreatorProperty) cp;
                            break;
                        }
                    }
                }
                if (cprop == null) {
                    List<String> n = new ArrayList<>();
                    for (SettableBeanProperty cp : creatorProps) {
                        n.add(cp.getName());
                    }
                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,
                            ""Could not find creator property with name '%s' (known Creator properties: %s)"",
                            name, n);
                    continue;
                }
                if (prop != null) {
                    cprop.setFallbackSetter(prop);
                }
                prop = cprop;
                builder.addCreatorProperty(cprop);
                continue;
            }

            if (prop != null) {
                Class<?>[] views = propDef.findViews();
                if (views == null) {
                    // one more twist: if default inclusion disabled, need to force empty set of views
                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {
                        views = NO_VIEWS;
                    }
                }
                // one more thing before adding to builder: copy any metadata
                prop.setViews(views);
                builder.addProperty(prop);
            }
        }
    }","protected void addBeanProps(DeserializationContext ctxt,
        BeanDescription beanDesc, BeanDeserializerBuilder builder)
    throws JsonMappingException
{
    final boolean isConcrete = !beanDesc.getType().isAbstract();
    final SettableBeanProperty[] creatorProps = isConcrete
            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())
            : new SettableBeanProperty[0]; // Initialized empty to avoid null checks
    final boolean hasCreatorProps = (creatorProps != null && creatorProps.length > 0);

    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()
            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),
                    beanDesc.getClassInfo());
    Set<String> ignored;

    if (ignorals != null) {
        boolean ignoreAny = ignorals.getIgnoreUnknown();
        builder.setIgnoreUnknownProperties(ignoreAny);
        ignored = ignorals.getIgnored();
        for (String propName : ignored) {
            builder.addIgnorable(propName);
        }
    } else {
        ignored = Collections.emptySet();
    }

    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();
    AnnotatedMember anySetterField = null;
    if (anySetterMethod != null) {
        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));
    }
    else {
        anySetterField = beanDesc.findAnySetterField();
        if(anySetterField != null) {
            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));
        }
    }

    if (anySetterMethod == null && anySetterField == null) {
        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();
        if (ignored2 != null) {
            for (String propName : ignored2) {
                builder.addIgnorable(propName);
            }
        }
    }

    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)
            && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);

    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,
            beanDesc, builder, beanDesc.findProperties(), ignored);

    if (_factoryConfig.hasDeserializerModifiers()) {
        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);
        }
    }

    for (BeanPropertyDefinition propDef : propDefs) {
        SettableBeanProperty prop = null;

        if (propDef.hasSetter()) {
            JavaType propertyType = propDef.getSetter().getParameterType(0);
            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);
        } else if (propDef.hasField()) {
            JavaType propertyType = propDef.getField().getType();
            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);
        } else if (useGettersAsSetters && propDef.hasGetter()) {
            AnnotatedMethod getter = propDef.getGetter();
            Class<?> rawPropertyType = getter.getRawType();
            if (Collection.class.isAssignableFrom(rawPropertyType)
                    || Map.class.isAssignableFrom(rawPropertyType)) {
                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);
            }
        }

        if (hasCreatorProps && propDef.hasConstructorParameter()) {
            final String name = propDef.getName();
            CreatorProperty cprop = null;
            for (SettableBeanProperty cp : creatorProps) {
                if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {
                    cprop = (CreatorProperty) cp;
                    break;
                }
            }
            if (cprop == null) {
                List<String> n = new ArrayList<>();
                for (SettableBeanProperty cp : creatorProps) {
                    n.add(cp.getName());
                }
                ctxt.reportBadPropertyDefinition(beanDesc, propDef,
                        ""Could not find creator property with name '%s' (known Creator properties: %s)"",
                        name, n);
                continue;
            }
            if (prop != null) {
                cprop.setFallbackSetter(prop);
            }
            prop = cprop;
            builder.addCreatorProperty(cprop);
            continue;
        }

        if (prop != null) {
            Class<?>[] views = propDef.findViews();
            if (views == null) {
                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {
                    views = NO_VIEWS;
                }
            }
            prop.setViews(views);
            builder.addProperty(prop);
        }
    }
}",0,0
265,JacksonDatabind_83,"    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:
        String text = p.getValueAsString();
        if (text != null) { // has String representation
            if (text.length() == 0 || (text = text.trim()).length() == 0) {
                // 04-Feb-2013, tatu: Usually should become null; but not always
                return _deserializeFromEmptyString();
            }
            Exception cause = null;
            try {
                // 19-May-2017, tatu: Used to require non-null result (assuming `null`
                //    indicated error; but that seems wrong. Should be able to return
                //    `null` as value.
                if (_deserialize(text, ctxt) != null) {
                return _deserialize(text, ctxt);
                }
            } catch (IllegalArgumentException iae) {
                cause = iae;
            } catch (MalformedURLException me) {
                cause = me;
            }
            String msg = ""not a valid textual representation"";
            if (cause != null) {
                String m2 = cause.getMessage();
                if (m2 != null) {
                    msg = msg + "", problem: ""+m2;
                }
            }
            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...
            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);
            if (cause != null) {
                e.initCause(cause);
            }
            throw e;
            // nothing to do here, yet? We'll fail anyway
        }
        JsonToken t = p.getCurrentToken();
        // [databind#381]
        if (t == JsonToken.START_ARRAY) {
            return _deserializeFromArray(p, ctxt);
        }
        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {
            // Trivial cases; null to null, instance of type itself returned as is
            Object ob = p.getEmbeddedObject();
            if (ob == null) {
                return null;
            }
            if (_valueClass.isAssignableFrom(ob.getClass())) {
                return (T) ob;
            }
            return _deserializeEmbedded(ob, ctxt);
        }
        return (T) ctxt.handleUnexpectedToken(_valueClass, p);
    }
","public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:
        String text = p.getValueAsString();
        if (text != null) { // has String representation
            if (text.length() == 0 || (text = text.trim()).length() == 0) {
                // 04-Feb-2013, tatu: Usually should become null; but not always
                return _deserializeFromEmptyString();
            }
            Exception cause = null;
            try {
                T result = _deserialize(text, ctxt);
                // 19-May-2017, tatu: Used to require non-null result (assuming `null`
                //    indicated error; but that seems wrong. Should be able to return
                //    `null` as value.
                return result;
            } catch (IllegalArgumentException iae) {
                cause = iae;
            } catch (MalformedURLException me) {
                cause = me;
            }
            String msg = ""not a valid textual representation"";
            if (cause != null) {
                String m2 = cause.getMessage();
                if (m2 != null) {
                    msg = msg + "", problem: ""+m2;
                }
            }
            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...
            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);
            if (cause != null) {
                e.initCause(cause);
            }
            throw e;
        }
        JsonToken t = p.getCurrentToken();
        // [databind#381]
        if (t == JsonToken.START_ARRAY) {
            return _deserializeFromArray(p, ctxt);
        }
        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {
            // Trivial cases; null to null, instance of type itself returned as is
            Object ob = p.getEmbeddedObject();
            if (ob == null) {
                return null;
            }
            if (_valueClass.isAssignableFrom(ob.getClass())) {
                return (T) ob;
            }
            return _deserializeEmbedded(ob, ctxt);
        }
        return (T) ctxt.handleUnexpectedToken(_valueClass, p);
    }",0,0
266,JacksonDatabind_85,"@Override
    public JsonSerializer<?> createContextual(SerializerProvider serializers,
            BeanProperty property) throws JsonMappingException
    {
        if (property == null) {
            return this;
        }
        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());
        if (format == null) {
            return this;
        }
        // Simple case first: serialize as numeric timestamp?
        JsonFormat.Shape shape = format.getShape();
        if (shape.isNumeric()) {
            return withFormat(Boolean.TRUE, null);
        }

        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..
        // First: custom pattern will override things
                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()
                                || format.hasLocale() || format.hasTimeZone()) {
                    TimeZone tz = format.getTimeZone();
                    final String pattern = format.hasPattern()
                                    ? format.getPattern()
                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;
            final Locale loc = format.hasLocale()
                            ? format.getLocale()
                            : serializers.getLocale();
                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);
                    if (tz == null) {
                        tz = serializers.getTimeZone();
                    }
            df.setTimeZone(tz);
            return withFormat(Boolean.FALSE, df);
        }

        // Otherwise, need one of these changes:


        // Jackson's own `StdDateFormat` is quite easy to deal with...

        // 08-Jun-2017, tatu: Unfortunately there's no generally usable
        //    mechanism for changing `DateFormat` instances (or even clone()ing)
        //    So: require it be `SimpleDateFormat`; can't config other types
//            serializers.reportBadDefinition(handledType(), String.format(
            // Ugh. No way to change `Locale`, create copy; must re-crete completely:
        return this;
    }

    /*
    /**********************************************************
    /* Accessors
    /**********************************************************
     */

    @Deprecated
    @Override
    public boolean isEmpty(T value) {
        // let's assume ""null date"" (timestamp 0) qualifies for empty
        return (value == null) || (_timestamp(value) == 0L);
    }

    @Override
    public boolean isEmpty(SerializerProvider serializers, T value) {
        // let's assume ""null date"" (timestamp 0) qualifies for empty
        return (value == null) || (_timestamp(value) == 0L);
    }
    
    protected abstract long _timestamp(T value);
    
    @Override
    public JsonNode getSchema(SerializerProvider serializers, Type typeHint) {
        //todo: (ryan) add a format for the date in the schema?
        return createSchemaNode(_asTimestamp(serializers) ? ""number"" : ""string"", true);
    }

    @Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
    {
        _acceptJsonFormatVisitor(visitor, typeHint, _asTimestamp(visitor.getProvider()));
    }

    /*
    /**********************************************************",Match failed,0,0
267,JacksonDatabind_88,"    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException
    {
        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first
         *    check if any generics info is added; and only then ask factory
         *    to do translation when necessary
         */
        TypeFactory tf = ctxt.getTypeFactory();
        if (id.indexOf('<') > 0) {
            // note: may want to try combining with specialization (esp for EnumMap)?
            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment
            //    compatibility -- needed later anyway, and not doing so may open
            //    security issues.
            JavaType t = tf.constructFromCanonical(id);
                // Probably cleaner to have a method in `TypeFactory` but can't add in patch
            return t;
        }
        Class<?> cls;
        try {
            cls =  tf.findClass(id);
        } catch (ClassNotFoundException e) {
            // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get
            //   DeserializationContext, just playing it safe
            if (ctxt instanceof DeserializationContext) {
                DeserializationContext dctxt = (DeserializationContext) ctxt;
                // First: we may have problem handlers that can deal with it?
                return dctxt.handleUnknownTypeId(_baseType, id, this, ""no such class found"");
            }
            // ... meaning that we really should never get here.
            return null;
        } catch (Exception e) {
            throw new IllegalArgumentException(""Invalid type id '""+id+""' (for id type 'Id.class'): ""+e.getMessage(), e);
        }
        return tf.constructSpecializedType(_baseType, cls);
    }","protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException
{
    TypeFactory tf = ctxt.getTypeFactory();
    if (id == null || id.isEmpty()) {
        throw new IllegalArgumentException(""Type id cannot be null or empty"");
    }
    
    if (id.indexOf('<') > 0) {
        try {
            // Handle generic types safely
            JavaType t = tf.constructFromCanonical(id);
            return t;
        } catch (Exception e) {
            throw new IllegalArgumentException(""Invalid type id '"" + id + ""' for generic type: "" + e.getMessage(), e);
        }
    }

    Class<?> cls;
    try {
        cls = tf.findClass(id);
    } catch (ClassNotFoundException e) {
        if (ctxt instanceof DeserializationContext) {
            DeserializationContext dctxt = (DeserializationContext) ctxt;
            // Handle unknown type id with deserialization context's problem handler
            return dctxt.handleUnknownTypeId(_baseType, id, this, ""No such class found: "" + id);
        }
        // If context is not DeserializationContext, return null (unexpected case)
        return null;
    } catch (Exception e) {
        throw new IllegalArgumentException(""Invalid type id '"" + id + ""' (for id type 'Id.class'): "" + e.getMessage(), e);
    }

    try {
        // Ensure correct specialization of base type
        return tf.constructSpecializedType(_baseType, cls);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(""Unable to specialize base type using type id '"" + id + ""': "" + e.getMessage(), e);
    }
}",0,0
268,JacksonDatabind_9,"@Override
     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
         String str;
         
         if (value instanceof Date) {
             provider.defaultSerializeDateKey((Date) value, jgen);
             return;
         } else {
             str = value.toString();
         }
        jgen.writeFieldName(str);
    }","@Override
public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
    String str;
    
    if (value instanceof Date) {
        provider.defaultSerializeDateKey((Date) value, jgen);
        return;
    } else if (value == null) {
        str = ""null"";
    } else {
        str = value.toString();
    }
    jgen.writeFieldName(str);
}",0,0
269,JacksonDatabind_91,"    private boolean _hasCustomHandlers(JavaType t) {
        if (t.isContainerType()) {
            // First: value types may have both value and type handlers
            JavaType ct = t.getContentType();
            if (ct != null) {
                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);
            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)
            }
        }
        return false;
    }
","private boolean _hasCustomHandlers(JavaType t) {
    if (t.isContainerType()) {
        // First: value types may have both value and type handlers
        JavaType ct = t.getContentType();
        if (ct != null) {
            if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {
                return true;
            }
        }
        // Second: map(-like) types may have value handler for key (but not type; keys are untyped)
        if (t.isMapLikeType()) {
            JavaType kt = t.getKeyType();
            if (kt != null) {
                return kt.getValueHandler() != null;
            }
        }
    }
    return false;
}",0,0
270,JacksonDatabind_93,"    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException
    {
        // There are certain nasty classes that could cause problems, mostly
        // via default typing -- catch them here.
        final Class<?> raw = type.getRawClass();
        String full = raw.getName();

        main_check:
        do {
            if (_cfgIllegalClassNames.contains(full)) {
                break;
            }

            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling
            //    for some Spring framework types
            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces
            if (full.startsWith(PREFIX_STRING)) {
                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {
                    String name = cls.getSimpleName();
                    // looking for ""AbstractBeanFactoryPointcutAdvisor"" but no point to allow any is there?
                    if (""AbstractPointcutAdvisor"".equals(name)
                            // ditto  for ""FileSystemXmlApplicationContext"": block all ApplicationContexts
                            || ""AbstractApplicationContext"".equals(name)) {
                        break main_check;
                    }
                }
            }
            return;
        } while (false);

        throw JsonMappingException.from(ctxt,
                String.format(""Illegal type (%s) to deserialize: prevented for security reasons"", full));
    }","public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException {
        // There are certain nasty classes that could cause problems, mostly
        // via default typing -- catch them here.
        final Class<?> raw = type.getRawClass();
        String full = raw.getName();

        main_check:
        do {
            if (_cfgIllegalClassNames.contains(full)) {
                break;
            }

            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling
            //    for some Spring framework types
            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces
            if (full.startsWith(PREFIX_STRING)) {
                for (Class<?> cls = raw; cls != null && cls != Object.class; cls = cls.getSuperclass()) {
                    String name = cls.getSimpleName();
                    // looking for ""AbstractBeanFactoryPointcutAdvisor"" but no point to allow any is there?
                    if (""AbstractPointcutAdvisor"".equals(name)
                            // ditto for ""FileSystemXmlApplicationContext"": block all ApplicationContexts
                            || ""AbstractApplicationContext"".equals(name)) {
                        break main_check;
                    }
                }
            }
            return;
        } while (false);

        throw JsonMappingException.from(ctxt,
                String.format(""Illegal type (%s) to deserialize: prevented for security reasons"", full));
    }",0,0
271,JacksonDatabind_96,"    protected void _addExplicitAnyCreator(DeserializationContext ctxt,
            BeanDescription beanDesc, CreatorCollector creators,
            CreatorCandidate candidate)
        throws JsonMappingException
    {
        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:
        if (1 != candidate.paramCount()) {
            // Ok: for delegates, we want one and exactly one parameter without
            // injection AND without name
            int oneNotInjected = candidate.findOnlyParamWithoutInjection();
            if (oneNotInjected >= 0) {
                // getting close; but most not have name
                if (candidate.paramName(oneNotInjected) == null) {
                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);
                    return;
                }
            }
            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);
            return;
        }
        AnnotatedParameter param = candidate.parameter(0);
        JacksonInject.Value injectId = candidate.injection(0);
        PropertyName paramName = candidate.explicitParamName(0);
        BeanPropertyDefinition paramDef = candidate.propertyDef(0);

        // If there's injection or explicit name, should be properties-based
        boolean useProps = (paramName != null) || (injectId != null);
        if (!useProps && (paramDef != null)) {
            // One more thing: if implicit name matches property with a getter
            // or field, we'll consider it property-based as well

            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get
            //    not implicit name, but name with possible strategy-based-rename
//            paramName = candidate.findImplicitParamName(0);
            paramName = candidate.findImplicitParamName(0);
            useProps = (paramName != null) && paramDef.couldSerialize();
        }
        if (useProps) {
            SettableBeanProperty[] properties = new SettableBeanProperty[] {
                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)
            };
            creators.addPropertyCreator(candidate.creator(), true, properties);
            return;
        }
        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);

        // one more thing: sever link to creator property, to avoid possible later
        // problems with ""unresolved"" constructor property
        if (paramDef != null) {
            ((POJOPropertyBuilder) paramDef).removeConstructors();
        }
    }
","protected void _addExplicitAnyCreator(DeserializationContext ctxt,
            BeanDescription beanDesc, CreatorCollector creators,
            CreatorCandidate candidate)
        throws JsonMappingException
    {
        // Looks like there's a bit of magic regarding 1-parameter creators; others simpler:
        if (candidate.paramCount() != 1) {
            // For delegates, we want one and exactly one parameter without injection AND without a name
            int oneNotInjected = candidate.findOnlyParamWithoutInjection();
            if (oneNotInjected >= 0) {
                // Check if parameter must not have an explicit name
                if (candidate.paramName(oneNotInjected) == null) {
                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);
                    return;
                }
            }
            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);
            return;
        }

        AnnotatedParameter param = candidate.parameter(0);
        JacksonInject.Value injectId = candidate.injection(0);
        PropertyName paramName = candidate.explicitParamName(0);
        BeanPropertyDefinition paramDef = candidate.propertyDef(0);

        // If there's injection or explicit name, it should be properties-based
        boolean useProps = (paramName != null) || (injectId != null);
        if (!useProps && (paramDef != null)) {
            // If implicit name matches property with a getter or field, consider it property-based as well
            paramName = candidate.findImplicitParamName(0); // Updated comment and removed ambiguity
            useProps = (paramName != null) && paramDef.couldSerialize();
        }

        if (useProps) {
            SettableBeanProperty[] properties = new SettableBeanProperty[] {
                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)
            };
            creators.addPropertyCreator(candidate.creator(), true, properties);
            return;
        }

        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);

        // Sever link to creator property to avoid possible later problems with ""unresolved"" constructor property
        if (paramDef instanceof POJOPropertyBuilder) {
            ((POJOPropertyBuilder) paramDef).removeConstructors();
        }
    }",0,0
272,JacksonDatabind_97,"    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException
    {
        if (_value == null) {
            ctxt.defaultSerializeNull(gen);
        } else if (_value instanceof JsonSerializable) {
            ((JsonSerializable) _value).serialize(gen, ctxt);
        } else {
            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;
            //    this to preserve contextual information
            gen.writeObject(_value);
        }
    }
","public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException
{
    if (_value == null) {
        ctxt.defaultSerializeNull(gen);
    } else if (_value instanceof JsonSerializable) {
        ((JsonSerializable) _value).serialize(gen, ctxt);
    } else {
        // 25-May-2018, tatu: [databind#1991] use context to serialize the object correctly
        ctxt.defaultSerializeValue(_value, gen);
    }
}",0,0
273,JacksonDatabind_98,"    public Object complete(JsonParser p, DeserializationContext ctxt,
            PropertyValueBuffer buffer, PropertyBasedCreator creator)
        throws IOException
    {
        // first things first: deserialize all data buffered:
        final int len = _properties.length;
        Object[] values = new Object[len];
        for (int i = 0; i < len; ++i) {
            String typeId = _typeIds[i];
            final ExtTypedProperty extProp = _properties[i];
            if (typeId == null) {
                // let's allow missing both type and property (may already have been set, too)
                if (_tokens[i] == null) {
                    continue;
                }
                // but not just one
                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'
                if (!extProp.hasDefaultType()) {
                    ctxt.reportInputMismatch(_beanType,
                            ""Missing external type id property '%s'"",
                            extProp.getTypePropertyName());
                } else {
                    typeId = extProp.getDefaultTypeId();
                }
            } else if (_tokens[i] == null) {
                SettableBeanProperty prop = extProp.getProperty();
                ctxt.reportInputMismatch(_beanType,
                        ""Missing property '%s' for external type id '%s'"",
                        prop.getName(), _properties[i].getTypePropertyName());
            }
            values[i] = _deserialize(p, ctxt, i, typeId);

            final SettableBeanProperty prop = extProp.getProperty();
            // also: if it's creator prop, fill in
            if (prop.getCreatorIndex() >= 0) {
                buffer.assignParameter(prop, values[i]);

                // [databind#999] And maybe there's creator property for type id too?
                SettableBeanProperty typeProp = extProp.getTypeProperty();
                // for now, should only be needed for creator properties, too
                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {
                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to
                    //    apply deserializer... fun fun.
                    buffer.assignParameter(typeProp, typeId);
                }
            }
        }
        Object bean = creator.build(ctxt, buffer);
        // third: assign non-creator properties
        for (int i = 0; i < len; ++i) {
            SettableBeanProperty prop = _properties[i].getProperty();
            if (prop.getCreatorIndex() < 0) {
                prop.set(bean, values[i]);
            }
        }
        return bean;
    }
","public Object complete(JsonParser p, DeserializationContext ctxt,
            PropertyValueBuffer buffer, PropertyBasedCreator creator)
        throws IOException
    {
        // first things first: deserialize all data buffered:
        final int len = _properties.length;
        Object[] values = new Object[len];
        for (int i = 0; i < len; ++i) {
            String typeId = _typeIds[i];
            final ExtTypedProperty extProp = _properties[i];
            if (typeId == null) {
                // let's allow missing both type and property (may already have been set, too)
                if (_tokens[i] == null) {
                    continue;
                }
                // but not just one
                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'
                if (!extProp.hasDefaultType()) {
                    ctxt.reportInputMismatch(_beanType,
                            ""Missing external type id property '%s'"",
                            extProp.getTypePropertyName());
                } else {
                    typeId = extProp.getDefaultTypeId();
                }
            } else if (_tokens[i] == null) {
                SettableBeanProperty prop = extProp.getProperty();
                if (prop == null) { // Ensure property is not null before usage
                    throw new IOException(String.format(""Property for external type id '%s' is missing."", _properties[i].getTypePropertyName()));
                }
                ctxt.reportInputMismatch(_beanType,
                        ""Missing property '%s' for external type id '%s'"",
                        prop.getName(), _properties[i].getTypePropertyName());
            }
            values[i] = _deserialize(p, ctxt, i, typeId);

            final SettableBeanProperty prop = extProp.getProperty();
            if (prop == null) { // Ensure property is not null before usage
                throw new IOException(String.format(""SettableBeanProperty for index %d is null."", i));
            }
            // also: if it's creator prop, fill in
            if (prop.getCreatorIndex() >= 0) {
                buffer.assignParameter(prop, values[i]);

                // [databind#999] And maybe there's creator property for type id too?
                SettableBeanProperty typeProp = extProp.getTypeProperty();
                if (typeProp == null) { // Handle null case for type properties
                    continue;
                }
                // for now, should only be needed for creator properties, too
                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {
                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to
                    //    apply deserializer... fun fun.
                    buffer.assignParameter(typeProp, typeId);
                }
            }
        }
        Object bean = creator.build(ctxt, buffer);
        if (bean == null) { // Ensure no null bean object is returned
            throw new IOException(""Failed to build bean using creator."");
        }

        // third: assign non-creator properties
        for (int i = 0; i < len; ++i) {
            SettableBeanProperty prop = _properties[i].getProperty();
            if (prop == null) { // Ensure property is not null before usage
                continue; // Skip invalid properties in non-creator assignment
            }
            if (prop.getCreatorIndex() < 0) {
                prop.set(bean, values[i]);
            }
        }
        return bean;
    }",0,0
274,JacksonDatabind_99,"    protected String buildCanonicalName()
    {
        StringBuilder sb = new StringBuilder();
        sb.append(_class.getName());
        sb.append('<');
        sb.append(_referencedType.toCanonical());
        return sb.toString();
    }
","protected String buildCanonicalName()
{
    StringBuilder sb = new StringBuilder();
    sb.append(_class.getName());
    sb.append('<');
    sb.append(_referencedType.toCanonical());
    sb.append('>'); // Closing the generic bracket
    return sb.toString();
}",0,0
275,JacksonXml_1," public JsonToken nextToken() throws IOException
    {
        _binaryValue = null;
        if (_nextToken != null) {
            JsonToken t = _nextToken;
            _currToken = t;
            _nextToken = null;
            switch (t) {
            case START_OBJECT:
                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
                break;
            case START_ARRAY:
                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);
                break;
            case END_OBJECT:
            case END_ARRAY:
                _parsingContext = _parsingContext.getParent();
                _namesToWrap = _parsingContext.getNamesToWrap();
                break;
            case FIELD_NAME:
                _parsingContext.setCurrentName(_xmlTokens.getLocalName());
                break;
            default: // VALUE_STRING, VALUE_NULL
                // should be fine as is?
            }
            return t;
        }
        int token = _xmlTokens.next();

        // Need to have a loop just because we may have to eat/convert
        // a start-element that indicates an array element.
        while (token == XmlTokenStream.XML_START_ELEMENT) {
            // If we thought we might get leaf, no such luck
            if (_mayBeLeaf) {
                // leave _mayBeLeaf set, as we start a new context
                _nextToken = JsonToken.FIELD_NAME;
                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
                return (_currToken = JsonToken.START_OBJECT);
            }
            if (_parsingContext.inArray()) {
                // Yup: in array, so this element could be verified; but it won't be
                // reported anyway, and we need to process following event.
                token = _xmlTokens.next();
                _mayBeLeaf = true;
                continue;
            }
            String name = _xmlTokens.getLocalName();
            _parsingContext.setCurrentName(name);

            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.
            // Couple of ways to do it; but start by making _xmlTokens replay the thing...
            if (_namesToWrap != null && _namesToWrap.contains(name)) {
                _xmlTokens.repeatStartElement();
            }

            _mayBeLeaf = true;
            // Ok: in array context we need to skip reporting field names.
            // But what's the best way to find next token?
            return (_currToken = JsonToken.FIELD_NAME);
        }

        // Ok; beyond start element, what do we get?
        switch (token) {
        case XmlTokenStream.XML_END_ELEMENT:
            // Simple, except that if this is a leaf, need to suppress end:
            if (_mayBeLeaf) {
                _mayBeLeaf = false;
                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to
                    //    expose as empty Object, not null
                return (_currToken = JsonToken.VALUE_NULL);
            }
            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;
            _parsingContext = _parsingContext.getParent();
            _namesToWrap = _parsingContext.getNamesToWrap();
            return _currToken;
            
        case XmlTokenStream.XML_ATTRIBUTE_NAME:
            // If there was a chance of leaf node, no more...
            if (_mayBeLeaf) {
                _mayBeLeaf = false;
                _nextToken = JsonToken.FIELD_NAME;
                _currText = _xmlTokens.getText();
                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
                return (_currToken = JsonToken.START_OBJECT);
            }
            _parsingContext.setCurrentName(_xmlTokens.getLocalName());
            return (_currToken = JsonToken.FIELD_NAME);
        case XmlTokenStream.XML_ATTRIBUTE_VALUE:
            _currText = _xmlTokens.getText();
            return (_currToken = JsonToken.VALUE_STRING);
        case XmlTokenStream.XML_TEXT:
            _currText = _xmlTokens.getText();
            if (_mayBeLeaf) {
                _mayBeLeaf = false;
                /* One more refinement (pronunced like ""hack"") is that if
                 * we had an empty String (or all white space), and we are
                 * deserializing an array, we better hide the empty text.
                 */
                // Also: must skip following END_ELEMENT
                _xmlTokens.skipEndElement();
                if (_parsingContext.inArray()) {
                    if (_isEmpty(_currText)) {
                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to
                        //    expose as empty Object, not null (or, worse, as used to
                        //    be done, by swallowing the token)
                        _currToken = JsonToken.END_ARRAY;
                        _parsingContext = _parsingContext.getParent();
                        _namesToWrap = _parsingContext.getNamesToWrap();
                        return _currToken;
                    }
                }
                return (_currToken = JsonToken.VALUE_STRING);
            } else {
                // [dataformat-xml#177]: empty text may also need to be skipped
                if (_parsingContext.inObject()
                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {
                    _currToken = JsonToken.END_OBJECT;
                    _parsingContext = _parsingContext.getParent();
                    _namesToWrap = _parsingContext.getNamesToWrap();
                    return _currToken;
                }
            }
            // If not a leaf (or otherwise ignorable), need to transform into property...
            _parsingContext.setCurrentName(_cfgNameForTextElement);
            _nextToken = JsonToken.VALUE_STRING;
            return (_currToken = JsonToken.FIELD_NAME);
        case XmlTokenStream.XML_END:
            return (_currToken = null);
        }
        
        // should never get here
        _throwInternal();
        return null;
    }","public JsonToken nextToken() throws IOException {
    _binaryValue = null;

    if (_nextToken != null) {
        JsonToken t = _nextToken;
        _currToken = t;
        _nextToken = null;

        switch (t) {
            case START_OBJECT:
                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
                break;
            case START_ARRAY:
                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);
                break;
            case END_OBJECT:
            case END_ARRAY:
                if (_parsingContext.getParent() != null) { // Ensure parent exists
                    _parsingContext = _parsingContext.getParent();
                    _namesToWrap = _parsingContext.getNamesToWrap();
                }
                break;
            case FIELD_NAME:
                _parsingContext.setCurrentName(_xmlTokens.getLocalName());
                break;
            default:
                // Other token types do not require special handling
        }
        return t;
    }

    int token = _xmlTokens.next();

    while (token == XmlTokenStream.XML_START_ELEMENT) {
        if (_mayBeLeaf) {
            _nextToken = JsonToken.FIELD_NAME;
            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
            return (_currToken = JsonToken.START_OBJECT);
        }

        if (_parsingContext.inArray()) {
            token = _xmlTokens.next();
            _mayBeLeaf = true;
            continue;
        }

        String name = _xmlTokens.getLocalName();
        _parsingContext.setCurrentName(name);

        if (_namesToWrap != null && _namesToWrap.contains(name)) {
            _xmlTokens.repeatStartElement();
        }

        _mayBeLeaf = true;
        return (_currToken = JsonToken.FIELD_NAME);
    }

    switch (token) {
        case XmlTokenStream.XML_END_ELEMENT:
            if (_mayBeLeaf) {
                _mayBeLeaf = false;
                return (_currToken = JsonToken.VALUE_NULL);
            }

            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;

            if (_parsingContext.getParent() != null) { // Ensure parent exists before moving up
                _parsingContext = _parsingContext.getParent();
                _namesToWrap = _parsingContext.getNamesToWrap();
            }

            return _currToken;

        case XmlTokenStream.XML_ATTRIBUTE_NAME:
            if (_mayBeLeaf) {
                _mayBeLeaf = false;
                _nextToken = JsonToken.FIELD_NAME;
                _currText = _xmlTokens.getText();
                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
                return (_currToken = JsonToken.START_OBJECT);
            }
            _parsingContext.setCurrentName(_xmlTokens.getLocalName());
            return (_currToken = JsonToken.FIELD_NAME);

        case XmlTokenStream.XML_ATTRIBUTE_VALUE:
            _currText = _xmlTokens.getText();
            return (_currToken = JsonToken.VALUE_STRING);

        case XmlTokenStream.XML_TEXT:
            _currText = _xmlTokens.getText();

            if (_mayBeLeaf) {
                _mayBeLeaf = false;
                _xmlTokens.skipEndElement();

                if (_parsingContext.inArray() && _isEmpty(_currText)) {
                    _currToken = JsonToken.END_ARRAY;
                    if (_parsingContext.getParent() != null) { // Ensure parent exists before moving up
                        _parsingContext = _parsingContext.getParent();
                        _namesToWrap = _parsingContext.getNamesToWrap();
                    }
                    return _currToken;
                }

                return (_currToken = JsonToken.VALUE_STRING);
            } else if (_parsingContext.inObject()
                    && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {
                _currToken = JsonToken.END_OBJECT;

                if (_parsingContext.getParent() != null) { // Ensure parent exists
                    _parsingContext = _parsingContext.getParent();
                    _namesToWrap = _parsingContext.getNamesToWrap();
                }

                return _currToken;
            }

            _parsingContext.setCurrentName(_cfgNameForTextElement);
            _nextToken = JsonToken.VALUE_STRING;
            return (_currToken = JsonToken.FIELD_NAME);

        case XmlTokenStream.XML_END:
            return (_currToken = null);

        default:
            _throwInternal();
            return null;
    }
}",0,0
276,JacksonXml_3,"@Override
    public String nextTextValue() throws IOException
    {
        _binaryValue = null;
        if (_nextToken != null) {
            JsonToken t = _nextToken;
            _currToken = t;
            _nextToken = null;

            // expected case; yes, got a String
            if (t == JsonToken.VALUE_STRING) {
                return _currText;
            }
            _updateState(t);
            return null;
        }

        int token = _xmlTokens.next();

        // mostly copied from 'nextToken()'
        while (token == XmlTokenStream.XML_START_ELEMENT) {
            if (_mayBeLeaf) {
                _nextToken = JsonToken.FIELD_NAME;
                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
                _currToken = JsonToken.START_OBJECT;
                return null;
            }
            if (_parsingContext.inArray()) {
                token = _xmlTokens.next();
                _mayBeLeaf = true;
                continue;
            }
            String name = _xmlTokens.getLocalName();
            _parsingContext.setCurrentName(name);
            if (_namesToWrap != null && _namesToWrap.contains(name)) {
                _xmlTokens.repeatStartElement();
            }
            _mayBeLeaf = true;
            _currToken = JsonToken.FIELD_NAME;
            return null;
        }

        // Ok; beyond start element, what do we get?
        switch (token) {
        case XmlTokenStream.XML_END_ELEMENT:
            if (_mayBeLeaf) {
                // NOTE: this is different from nextToken() -- produce """", NOT null
                _mayBeLeaf = false;
                _currToken = JsonToken.VALUE_STRING;
                return (_currText = """");
            }
            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;
            _parsingContext = _parsingContext.getParent();
            _namesToWrap = _parsingContext.getNamesToWrap();
            break;
        case XmlTokenStream.XML_ATTRIBUTE_NAME:
            // If there was a chance of leaf node, no more...
            if (_mayBeLeaf) {
                _mayBeLeaf = false;
                _nextToken = JsonToken.FIELD_NAME;
                _currText = _xmlTokens.getText();
                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
                _currToken = JsonToken.START_OBJECT;
            } else {
                _parsingContext.setCurrentName(_xmlTokens.getLocalName());
                _currToken = JsonToken.FIELD_NAME;
             }
             break;
         case XmlTokenStream.XML_ATTRIBUTE_VALUE:
             _currText = _xmlTokens.getText();
             _currToken = JsonToken.VALUE_STRING;
             break;
         case XmlTokenStream.XML_TEXT:
             _currText = _xmlTokens.getText();
             if (_mayBeLeaf) {
                _mayBeLeaf = false;
                // Also: must skip following END_ELEMENT
                _xmlTokens.skipEndElement();

                // NOTE: this is different from nextToken() -- NO work-around
                // for otherwise empty List/array
                _currToken = JsonToken.VALUE_STRING;
                return _currText;
            }
            // If not a leaf, need to transform into property...
            _parsingContext.setCurrentName(_cfgNameForTextElement);
            _nextToken = JsonToken.VALUE_STRING;
            _currToken = JsonToken.FIELD_NAME;
            break;
        case XmlTokenStream.XML_END:
            _currToken = null;
        }
        return null;
    }","@Override
    public String nextTextValue() throws IOException
    {
        _binaryValue = null;
        if (_nextToken != null) {
            JsonToken t = _nextToken;
            _currToken = t;
            _nextToken = null;

            // expected case; yes, got a String
            if (t == JsonToken.VALUE_STRING) {
                return _currText;
            }
            _updateState(t);
            return null;
        }

        int token = _xmlTokens.next();

        // mostly copied from 'nextToken()'
        while (token == XmlTokenStream.XML_START_ELEMENT) {
            if (_mayBeLeaf) {
                _nextToken = JsonToken.FIELD_NAME;
                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
                _currToken = JsonToken.START_OBJECT;
                return null;
            }
            if (_parsingContext.inArray()) {
                token = _xmlTokens.next();
                _mayBeLeaf = true;
                continue;
            }
            String name = _xmlTokens.getLocalName();
            _parsingContext.setCurrentName(name);
            if (_namesToWrap != null && _namesToWrap.contains(name)) {
                _xmlTokens.repeatStartElement();
            }
            _mayBeLeaf = true;
            _currToken = JsonToken.FIELD_NAME;
            return null;
        }

        // Ok; beyond start element, what do we get?
        switch (token) {
        case XmlTokenStream.XML_END_ELEMENT:
            if (_mayBeLeaf) {
                // NOTE: this is different from nextToken() -- produce """", NOT null
                _mayBeLeaf = false;
                _currToken = JsonToken.VALUE_STRING;
                return (_currText = """");
            }
            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;
            _parsingContext = _parsingContext.getParent();
            _namesToWrap = _parsingContext.getNamesToWrap();
            break;
        case XmlTokenStream.XML_ATTRIBUTE_NAME:
            // If there was a chance of leaf node, no more...
            if (_mayBeLeaf) {
                _mayBeLeaf = false;
                _nextToken = JsonToken.FIELD_NAME;
                _currText = _xmlTokens.getText();
                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
                _currToken = JsonToken.START_OBJECT;
            } else {
                _parsingContext.setCurrentName(_xmlTokens.getLocalName());
                _currToken = JsonToken.FIELD_NAME;
             }
             break;
         case XmlTokenStream.XML_ATTRIBUTE_VALUE:
             _currText = _xmlTokens.getText();
             _currToken = JsonToken.VALUE_STRING;
             break;
         case XmlTokenStream.XML_TEXT:
             _currText = _xmlTokens.getText();
             if (_mayBeLeaf) {
                _mayBeLeaf = false;
                // Also: must skip following END_ELEMENT
                _xmlTokens.skipEndElement();

                // NOTE: this is different from nextToken() -- NO work-around
                // for otherwise empty List/array
                _currToken = JsonToken.VALUE_STRING;
                return _currText;
            }
            // If not a leaf, need to transform into property...
            _parsingContext.setCurrentName(_cfgNameForTextElement);
            _nextToken = JsonToken.VALUE_STRING;
            _currToken = JsonToken.FIELD_NAME;
            break;
        case XmlTokenStream.XML_END:
            _currToken = null;
            return null; // Ensure method returns consistently for XML_END case.
        }
        return null;
    }",0,0
277,JacksonXml_4,"protected void _serializeXmlNull(JsonGenerator jgen) throws IOException
     {
         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly
         //    configured root name...
         if (jgen instanceof ToXmlGenerator) {
             _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);
         }
         super.serializeValue(jgen, null);
     }",Match failed,0,0
278,JacksonXml_5,"    protected XmlSerializerProvider(XmlSerializerProvider src) {
        super(src);
        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy
        //    root name lookup as that may link back to diff version, configuration
        _rootNameLookup = src._rootNameLookup;
    }
","protected XmlSerializerProvider(XmlSerializerProvider src) {
        super(src);
        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy
        //    root name lookup as that may link back to diff version, configuration
        _rootNameLookup = src._rootNameLookup.copy();
    }",0,0
279,Jsoup_1,"    private void normalise(Element element) {
        List<Node> toMove = new ArrayList<Node>();
        for (Node node: element.childNodes) {
            if (node instanceof TextNode) {
                TextNode tn = (TextNode) node;
                if (!tn.isBlank())
                    toMove.add(tn);
            }
        }

        for (Node node: toMove) {
            element.removeChild(node);
            body().appendChild(new TextNode("" "", """"));
            body().appendChild(node);
        }
    }
","private void normalise(Element element) {
    List<Node> toMove = new ArrayList<Node>();
    for (Node node : element.childNodes()) {
        if (node instanceof TextNode) {
            TextNode tn = (TextNode) node;
            if (!tn.isBlank()) {
                toMove.add(tn);
            }
        }
    }

    for (Node node : toMove) {
        element.removeChild(node);
        element.appendChild(new TextNode("" "", """")); // Fix: using the correct element
        element.appendChild(node); // Fix: using the correct element
    }
}",0,0
280,Jsoup_10,"public String absUrl(String attributeKey) {
        Validate.notEmpty(attributeKey);

        String relUrl = attr(attributeKey);
        if (!hasAttr(attributeKey)) {
            return """"; // nothing to make absolute with
        } else {
            URL base;
            try {
                try {
                    base = new URL(baseUri);
                } catch (MalformedURLException e) {
                    // the base is unsuitable, but the attribute may be abs on its own, so try that
                    URL abs = new URL(relUrl);
                     return abs.toExternalForm();
                 }
                 // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired
                 URL abs = new URL(base, relUrl);
                 return abs.toExternalForm();
             } catch (MalformedURLException e) {
                return """";
            }
        }
    }","public String absUrl(String attributeKey) {
    Validate.notEmpty(attributeKey);

    if (!hasAttr(attributeKey)) {
        return """"; // nothing to make absolute with
    }

    String relUrl = attr(attributeKey);
    try {
        URL base = new URL(baseUri);
        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired
        URL abs = new URL(base, relUrl);
        return abs.toExternalForm();
    } catch (MalformedURLException e) {
        // If the base URL is unsuitable or malformed, check if the attribute URL is absolute and return that if valid
        try {
            URL abs = new URL(relUrl);
            return abs.toExternalForm();
        } catch (MalformedURLException ex) {
            return """";
        }
    }
}",0,0
281,Jsoup_13,"public boolean hasAttr(String attributeKey) {
         Validate.notNull(attributeKey);
 
         return attributes.hasKey(attributeKey);
     }","public boolean hasAttr(String attributeKey) {
    if (attributeKey == null) {
        throw new IllegalArgumentException(""Attribute key cannot be null"");
    }
 
    return attributes.hasKey(attributeKey);
}",0,0
282,Jsoup_15,"boolean process(Token t, TreeBuilder tb) {
            switch (t.type) {
                case Character: {
                    Token.Character c = t.asCharacter();
                    if (c.getData().equals(nullString)) {
                        // todo confirm that check
                        tb.error(this);
                        return false;
                    } else if (isWhitespace(c)) {
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                        tb.framesetOk(false);
                    }
                    break;
                }
                case Comment: {
                    tb.insert(t.asComment());
                    break;
                }
                case Doctype: {
                    tb.error(this);
                    return false;
                }
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    String name = startTag.name();
                    if (name.equals(""html"")) {
                        tb.error(this);
                        // merge attributes onto real html
                        Element html = tb.getStack().getFirst();
                        for (Attribute attribute : startTag.getAttributes()) {
                             if (!html.hasAttr(attribute.getKey()))
                                 html.attributes().put(attribute);
                         }
                     } else if (StringUtil.in(name, ""base"", ""basefont"", ""bgsound"", ""command"", ""link"", ""meta"", ""noframes"", ""style"", ""title"")) {
                         return tb.process(t, InHead);
                     } else if (name.equals(""body"")) {
                         tb.error(this);
                        LinkedList<Element> stack = tb.getStack();
                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                            // only in fragment case
                            return false; // ignore
                        } else {
                            tb.framesetOk(false);
                            Element body = stack.get(1);
                            for (Attribute attribute : startTag.getAttributes()) {
                                if (!body.hasAttr(attribute.getKey()))
                                    body.attributes().put(attribute);
                            }
                        }
                    } else if (name.equals(""frameset"")) {
                        tb.error(this);
                        LinkedList<Element> stack = tb.getStack();
                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                            // only in fragment case
                            return false; // ignore
                        } else if (!tb.framesetOk()) {
                            return false; // ignore frameset
                        } else {
                            Element second = stack.get(1);
                            if (second.parent() != null)
                                second.remove();
                            // pop up to html element
                            while (stack.size() > 1)
                                stack.removeLast();
                            tb.insert(startTag);
                            tb.transition(InFrameset);
                        }
                    } else if (StringUtil.in(name,
                            ""address"", ""article"", ""aside"", ""blockquote"", ""center"", ""details"", ""dir"", ""div"", ""dl"",
                            ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""menu"", ""nav"", ""ol"",
                            ""p"", ""section"", ""summary"", ""ul"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        if (StringUtil.in(tb.currentElement().nodeName(), ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                            tb.error(this);
                            tb.pop();
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, ""pre"", ""listing"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                        // todo: ignore LF if next token
                        tb.framesetOk(false);
                    } else if (name.equals(""form"")) {
                        if (tb.getFormElement() != null) {
                            tb.error(this);
                            return false;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        Element form = tb.insert(startTag);
                        tb.setFormElement(form);
                    } else if (name.equals(""li"")) {
                        tb.framesetOk(false);
                        LinkedList<Element> stack = tb.getStack();
                        for (int i = stack.size() - 1; i > 0; i--) {
                            Element el = stack.get(i);
                            if (el.nodeName().equals(""li"")) {
                                tb.process(new Token.EndTag(""li""));
                                break;
                            }
                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), ""address"", ""div"", ""p""))
                                break;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, ""dd"", ""dt"")) {
                        tb.framesetOk(false);
                        LinkedList<Element> stack = tb.getStack();
                        for (int i = stack.size() - 1; i > 0; i--) {
                            Element el = stack.get(i);
                            if (StringUtil.in(el.nodeName(), ""dd"", ""dt"")) {
                                tb.process(new Token.EndTag(el.nodeName()));
                                break;
                            }
                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), ""address"", ""div"", ""p""))
                                break;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                    } else if (name.equals(""plaintext"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out
                    } else if (name.equals(""button"")) {
                        if (tb.inButtonScope(""button"")) {
                            // close and reprocess
                            tb.error(this);
                            tb.process(new Token.EndTag(""button""));
                            tb.process(startTag);
                        } else {
                            tb.reconstructFormattingElements();
                            tb.insert(startTag);
                            tb.framesetOk(false);
                        }
                    } else if (name.equals(""a"")) {
                        if (tb.getActiveFormattingElement(""a"") != null) {
                            tb.error(this);
                            tb.process(new Token.EndTag(""a""));

                            // still on stack?
                            Element remainingA = tb.getFromStack(""a"");
                            if (remainingA != null) {
                                tb.removeFromActiveFormattingElements(remainingA);
                                tb.removeFromStack(remainingA);
                            }
                        }
                        tb.reconstructFormattingElements();
                        Element a = tb.insert(startTag);
                        tb.pushActiveFormattingElements(a);
                    } else if (StringUtil.in(name,
                            ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u"")) {
                        tb.reconstructFormattingElements();
                        Element el = tb.insert(startTag);
                        tb.pushActiveFormattingElements(el);
                    } else if (name.equals(""nobr"")) {
                        tb.reconstructFormattingElements();
                        if (tb.inScope(""nobr"")) {
                            tb.error(this);
                            tb.process(new Token.EndTag(""nobr""));
                            tb.reconstructFormattingElements();
                        }
                        Element el = tb.insert(startTag);
                        tb.pushActiveFormattingElements(el);
                    } else if (StringUtil.in(name, ""applet"", ""marquee"", ""object"")) {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.insertMarkerToFormattingElements();
                        tb.framesetOk(false);
                    } else if (name.equals(""table"")) {
                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                        tb.framesetOk(false);
                        tb.transition(InTable);
                    } else if (StringUtil.in(name, ""area"", ""br"", ""embed"", ""img"", ""keygen"", ""wbr"")) {
                        tb.reconstructFormattingElements();
                        tb.insertEmpty(startTag);
                        tb.framesetOk(false);
                    } else if (name.equals(""input"")) {
                        tb.reconstructFormattingElements();
                        Element el = tb.insertEmpty(startTag);
                        if (!el.attr(""type"").equalsIgnoreCase(""hidden""))
                            tb.framesetOk(false);
                    } else if (StringUtil.in(name, ""param"", ""source"", ""track"")) {
                        tb.insertEmpty(startTag);
                    } else if (name.equals(""hr"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insertEmpty(startTag);
                        tb.framesetOk(false);
                    } else if (name.equals(""image"")) {
                        // we're not supposed to ask.
                        startTag.name(""img"");
                        return tb.process(startTag);
                    } else if (name.equals(""isindex"")) {
                        // how much do we care about the early 90s?
                        tb.error(this);
                        if (tb.getFormElement() != null)
                            return false;

                        tb.tokeniser.acknowledgeSelfClosingFlag();
                        tb.process(new Token.StartTag(""form""));
                        if (startTag.attributes.hasKey(""action"")) {
                            Element form = tb.getFormElement();
                            form.attr(""action"", startTag.attributes.get(""action""));
                        }
                        tb.process(new Token.StartTag(""hr""));
                        tb.process(new Token.StartTag(""label""));
                        // hope you like english.
                        String prompt = startTag.attributes.hasKey(""prompt"") ?
                                startTag.attributes.get(""prompt"") :
                                ""This is a searchable index. Enter search keywords: "";

                        tb.process(new Token.Character(prompt));

                        // input
                        Attributes inputAttribs = new Attributes();
                        for (Attribute attr : startTag.attributes) {
                            if (!StringUtil.in(attr.getKey(), ""name"", ""action"", ""prompt""))
                                inputAttribs.put(attr);
                        }
                        inputAttribs.put(""name"", ""isindex"");
                        tb.process(new Token.StartTag(""input"", inputAttribs));
                        tb.process(new Token.EndTag(""label""));
                        tb.process(new Token.StartTag(""hr""));
                        tb.process(new Token.EndTag(""form""));
                    } else if (name.equals(""textarea"")) {
                        tb.insert(startTag);
                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
                        tb.tokeniser.transition(TokeniserState.Rcdata);
                        tb.markInsertionMode();
                        tb.framesetOk(false);
                        tb.transition(Text);
                    } else if (name.equals(""xmp"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.reconstructFormattingElements();
                        tb.framesetOk(false);
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""iframe"")) {
                        tb.framesetOk(false);
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""noembed"")) {
                        // also handle noscript if script enabled
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""select"")) {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.framesetOk(false);

                        TreeBuilderState state = tb.state();
                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                            tb.transition(InSelectInTable);
                        else
                            tb.transition(InSelect);
                    } else if (StringUtil.in(""optgroup"", ""option"")) {
                        if (tb.currentElement().nodeName().equals(""option""))
                            tb.process(new Token.EndTag(""option""));
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    } else if (StringUtil.in(""rp"", ""rt"")) {
                        if (tb.inScope(""ruby"")) {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(""ruby"")) {
                                tb.error(this);
                                tb.popStackToBefore(""ruby""); // i.e. close up to but not include name
                            }
                            tb.insert(startTag);
                        }
                    } else if (name.equals(""math"")) {
                        tb.reconstructFormattingElements();
                        // todo: handle A start tag whose tag name is ""math"" (i.e. foreign, mathml)
                        tb.insert(startTag);
                        tb.tokeniser.acknowledgeSelfClosingFlag();
                    } else if (name.equals(""svg"")) {
                        tb.reconstructFormattingElements();
                        // todo: handle A start tag whose tag name is ""svg"" (xlink, svg)
                        tb.insert(startTag);
                        tb.tokeniser.acknowledgeSelfClosingFlag();
                    } else if (StringUtil.in(name,
                            ""caption"", ""col"", ""colgroup"", ""frame"", ""head"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr"")) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    }
                    break;

                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    name = endTag.name();
                    if (name.equals(""body"")) {
                        if (!tb.inScope(""body"")) {
                            tb.error(this);
                            return false;
                        } else {
                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
                            tb.transition(AfterBody);
                        }
                    } else if (name.equals(""html"")) {
                        boolean notIgnored = tb.process(new Token.EndTag(""body""));
                        if (notIgnored)
                            return tb.process(endTag);
                    } else if (StringUtil.in(name,
                            ""address"", ""article"", ""aside"", ""blockquote"", ""button"", ""center"", ""details"", ""dir"", ""div"",
                            ""dl"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""listing"", ""menu"",
                            ""nav"", ""ol"", ""pre"", ""section"", ""summary"", ""ul"")) {
                        // todo: refactor these lookups
                        if (!tb.inScope(name)) {
                            // nothing to close
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (name.equals(""form"")) {
                        Element currentForm = tb.getFormElement();
                        tb.setFormElement(null);
                        if (currentForm == null || !tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            // remove currentForm from stack. will shift anything under up.
                            tb.removeFromStack(currentForm);
                        }
                    } else if (name.equals(""p"")) {
                        if (!tb.inButtonScope(name)) {
                            tb.error(this);
                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>
                            return tb.process(endTag);
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (name.equals(""li"")) {
                        if (!tb.inListItemScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (StringUtil.in(name, ""dd"", ""dt"")) {
                        if (!tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (StringUtil.in(name, ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                        if (!tb.inScope(new String[]{""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6""})) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"");
                        }
                    } else if (name.equals(""sarcasm"")) {
                        // *sigh*
                        return anyOtherEndTag(t, tb);
                    } else if (StringUtil.in(name,
                            ""a"", ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""nobr"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u"")) {
                        // Adoption Agency Algorithm.
                        OUTER:
                        for (int i = 0; i < 8; i++) {
                            Element formatEl = tb.getActiveFormattingElement(name);
                            if (formatEl == null)
                                return anyOtherEndTag(t, tb);
                            else if (!tb.onStack(formatEl)) {
                                tb.error(this);
                                tb.removeFromActiveFormattingElements(formatEl);
                                return true;
                            } else if (!tb.inScope(formatEl.nodeName())) {
                                tb.error(this);
                                return false;
                            } else if (tb.currentElement() != formatEl)
                                tb.error(this);

                            Element furthestBlock = null;
                            Element commonAncestor = null;
                            boolean seenFormattingElement = false;
                            LinkedList<Element> stack = tb.getStack();
                            for (int si = 0; si < stack.size(); si++) {
                                Element el = stack.get(si);
                                if (el == formatEl) {
                                    commonAncestor = stack.get(si - 1);
                                    seenFormattingElement = true;
                                } else if (seenFormattingElement && tb.isSpecial(el)) {
                                    furthestBlock = el;
                                    break;
                                }
                            }
                            if (furthestBlock == null) {
                                tb.popStackToClose(formatEl.nodeName());
                                tb.removeFromActiveFormattingElements(formatEl);
                                return true;
                            }

                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
                            // does that mean: int pos of format el in list?
                            Element node = furthestBlock;
                            Element lastNode = furthestBlock;
                            INNER:
                            for (int j = 0; j < 3; j++) {
                                if (tb.onStack(node))
                                    node = tb.aboveOnStack(node);
                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
                                    tb.removeFromStack(node);
                                    continue INNER;
                                } else if (node == formatEl)
                                    break INNER;

                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
                                tb.replaceActiveFormattingElement(node, replacement);
                                tb.replaceOnStack(node, replacement);
                                node = replacement;

                                if (lastNode == furthestBlock) {
                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
                                    // not getting how this bookmark both straddles the element above, but is inbetween here...
                                }
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                node.appendChild(lastNode);

                                lastNode = node;
                            }

                            if (StringUtil.in(commonAncestor.nodeName(), ""table"", ""tbody"", ""tfoot"", ""thead"", ""tr"")) {
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                tb.insertInFosterParent(lastNode);
                            } else {
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                commonAncestor.appendChild(lastNode);
                            }

                            Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());
                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);
                            for (Node childNode : childNodes) {
                                adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.
                            }
                            furthestBlock.appendChild(adopter);
                            tb.removeFromActiveFormattingElements(formatEl);
                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
                            tb.removeFromStack(formatEl);
                            tb.insertOnStackAfter(furthestBlock, adopter);
                        }
                    } else if (StringUtil.in(name, ""applet"", ""marquee"", ""object"")) {
                        if (!tb.inScope(""name"")) {
                            if (!tb.inScope(name)) {
                                tb.error(this);
                                return false;
                            }
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                            tb.clearFormattingElementsToLastMarker();
                        }
                    } else if (name.equals(""br"")) {
                        tb.error(this);
                        tb.process(new Token.StartTag(""br""));
                        return false;
                    } else {
                        return anyOtherEndTag(t, tb);
                    }

                    break;
                case EOF:
                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
                    // stop parsing
                    break;
            }
            return true;
        }","boolean process(Token t, TreeBuilder tb) {
    switch (t.type) {
        case Character: {
            Token.Character c = t.asCharacter();
            if (c == null || c.getData() == null) { // Fixed check for null
                tb.error(this);
                return false;
            } else if (isWhitespace(c)) {
                tb.reconstructFormattingElements();
                tb.insert(c);
            } else {
                tb.reconstructFormattingElements();
                tb.insert(c);
                tb.framesetOk(false);
            }
            break;
        }
        case Comment: {
            tb.insert(t.asComment());
            break;
        }
        case Doctype: {
            tb.error(this);
            return false;
        }
        case StartTag:
            Token.StartTag startTag = t.asStartTag();
            String name = startTag.name();
            if (name.equals(""html"")) {
                tb.error(this);
                Element html = tb.getStack().getFirst();
                for (Attribute attribute : startTag.getAttributes()) {
                    if (!html.hasAttr(attribute.getKey()))
                        html.attributes().put(attribute);
                }
            } else if (StringUtil.in(name, ""base"", ""basefont"", ""bgsound"", ""command"", ""link"", ""meta"", ""noframes"", ""style"", ""title"")) {
                return tb.process(t, InHead);
            } else if (name.equals(""body"")) {
                tb.error(this);
                LinkedList<Element> stack = tb.getStack();
                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                    return false;
                } else {
                    tb.framesetOk(false);
                    Element body = stack.get(1);
                    for (Attribute attribute : startTag.getAttributes()) {
                        if (!body.hasAttr(attribute.getKey()))
                            body.attributes().put(attribute);
                    }
                }
            } else if (name.equals(""frameset"")) {
                tb.error(this);
                LinkedList<Element> stack = tb.getStack();
                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                    return false;
                } else if (!tb.framesetOk()) {
                    return false;
                } else {
                    Element second = stack.get(1);
                    if (second.parent() != null)
                        second.remove();
                    while (stack.size() > 1)
                        stack.removeLast();
                    tb.insert(startTag);
                    tb.transition(InFrameset);
                }
            } else if (StringUtil.in(name,
                    ""address"", ""article"", ""aside"", ""blockquote"", ""center"", ""details"", ""dir"", ""div"", ""dl"",
                    ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""menu"", ""nav"", ""ol"",
                    ""p"", ""section"", ""summary"", ""ul"")) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
            } else if (StringUtil.in(name, ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                if (StringUtil.in(tb.currentElement().nodeName(), ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                    tb.error(this);
                    tb.pop();
                }
                tb.insert(startTag);
            } else if (StringUtil.in(name, ""pre"", ""listing"")) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
                tb.framesetOk(false);
            } else if (name.equals(""form"")) {
                if (tb.getFormElement() != null) {
                    tb.error(this);
                    return false;
                }
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                Element form = tb.insert(startTag);
                tb.setFormElement(form);
            } else if (name.equals(""li"")) {
                tb.framesetOk(false);
                LinkedList<Element> stack = tb.getStack();
                for (int i = stack.size() - 1; i > 0; i--) {
                    Element el = stack.get(i);
                    if (el.nodeName().equals(""li"")) {
                        tb.process(new Token.EndTag(""li""));
                        break;
                    }
                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), ""address"", ""div"", ""p""))
                        break;
                }
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
            } else if (StringUtil.in(name, ""dd"", ""dt"")) {
                tb.framesetOk(false);
                LinkedList<Element> stack = tb.getStack();
                for (int i = stack.size() - 1; i > 0; i--) {
                    Element el = stack.get(i);
                    if (StringUtil.in(el.nodeName(), ""dd"", ""dt"")) {
                        tb.process(new Token.EndTag(el.nodeName()));
                        break;
                    }
                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), ""address"", ""div"", ""p""))
                        break;
                }
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
            } else if (name.equals(""plaintext"")) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
                tb.tokeniser.transition(TokeniserState.PLAINTEXT);
            } else if (name.equals(""button"")) {
                if (tb.inButtonScope(""button"")) {
                    tb.error(this);
                    tb.process(new Token.EndTag(""button""));
                    tb.process(startTag);
                } else {
                    tb.reconstructFormattingElements();
                    tb.insert(startTag);
                    tb.framesetOk(false);
                }
            } else if (name.equals(""a"")) {
                if (tb.getActiveFormattingElement(""a"") != null) {
                    tb.error(this);
                    tb.process(new Token.EndTag(""a""));

                    Element remainingA = tb.getFromStack(""a"");
                    if (remainingA != null) {
                        tb.removeFromActiveFormattingElements(remainingA);
                        tb.removeFromStack(remainingA);
                    }
                }
                tb.reconstructFormattingElements();
                Element a = tb.insert(startTag);
                tb.pushActiveFormattingElements(a);
            } else if (StringUtil.in(name,
                    ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u"")) {
                tb.reconstructFormattingElements();
                Element el = tb.insert(startTag);
                tb.pushActiveFormattingElements(el);
            } else if (name.equals(""nobr"")) {
                tb.reconstructFormattingElements();
                if (tb.inScope(""nobr"")) {
                    tb.error(this);
                    tb.process(new Token.EndTag(""nobr""));
                    tb.reconstructFormattingElements();
                }
                Element el = tb.insert(startTag);
                tb.pushActiveFormattingElements(el);
            } else if (StringUtil.in(name, ""applet"", ""marquee"", ""object"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.insertMarkerToFormattingElements();
                tb.framesetOk(false);
            } else if (name.equals(""table"")) {
                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
                tb.framesetOk(false);
                tb.transition(InTable);
            } else if (StringUtil.in(name, ""area"", ""br"", ""embed"", ""img"", ""keygen"", ""wbr"")) {
                tb.reconstructFormattingElements();
                tb.insertEmpty(startTag);
                tb.framesetOk(false);
            } else if (name.equals(""input"")) {
                tb.reconstructFormattingElements();
                Element el = tb.insertEmpty(startTag);
                if (!el.attr(""type"").equalsIgnoreCase(""hidden""))
                    tb.framesetOk(false);
            } else if (StringUtil.in(name, ""param"", ""source"", ""track"")) {
                tb.insertEmpty(startTag);
            } else if (name.equals(""hr"")) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insertEmpty(startTag);
                tb.framesetOk(false);
            } else if (name.equals(""image"")) {
                startTag.name(""img"");
                return tb.process(startTag);
            } else if (name.equals(""isindex"")) {
                tb.error(this);
                if (tb.getFormElement() != null)
                    return false;

                tb.tokeniser.acknowledgeSelfClosingFlag();
                tb.process(new Token.StartTag(""form""));
                if (startTag.attributes.hasKey(""action"")) {
                    Element form = tb.getFormElement();
                    form.attr(""action"", startTag.attributes.get(""action""));
                }
                tb.process(new Token.StartTag(""hr""));
                tb.process(new Token.StartTag(""label""));
                String prompt = startTag.attributes.hasKey(""prompt"") ?
                        startTag.attributes.get(""prompt"") :
                        ""This is a searchable index. Enter search keywords: "";

                tb.process(new Token.Character(prompt));

                Attributes inputAttribs = new Attributes();
                for (Attribute attr : startTag.attributes) {
                    if (!StringUtil.in(attr.getKey(), ""name"", ""action"", ""prompt""))
                        inputAttribs.put(attr);
                }
                inputAttribs.put(""name"", ""isindex"");
                tb.process(new Token.StartTag(""input"", inputAttribs));
                tb.process(new Token.EndTag(""label""));
                tb.process(new Token.StartTag(""hr""));
                tb.process(new Token.EndTag(""form""));
            } else if (name.equals(""textarea"")) {
                tb.insert(startTag);
                tb.tokeniser.transition(TokeniserState.Rcdata);
                tb.markInsertionMode();
                tb.framesetOk(false);
                tb.transition(Text);
            } else if (name.equals(""xmp"")) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.reconstructFormattingElements();
                tb.framesetOk(false);
                handleRawtext(startTag, tb);
            } else if (name.equals(""iframe"")) {
                tb.framesetOk(false);
                handleRawtext(startTag, tb);
            } else if (name.equals(""noembed"")) {
                handleRawtext(startTag, tb);
            } else if (name.equals(""select"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.framesetOk(false);

                TreeBuilderState state = tb.state();
                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                    tb.transition(InSelectInTable);
                else
                    tb.transition(InSelect);
            } else if (StringUtil.in(""optgroup"", ""option"")) {
                if (tb.currentElement().nodeName().equals(""option""))
                    tb.process(new Token.EndTag(""option""));
                tb.reconstructFormattingElements();
                tb.insert(startTag);
            } else if (StringUtil.in(""rp"", ""rt"")) {
                if (tb.inScope(""ruby"")) {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(""ruby"")) {
                        tb.error(this);
                        tb.popStackToBefore(""ruby"");
                    }
                    tb.insert(startTag);
                }
            } else if (name.equals(""math"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.tokeniser.acknowledgeSelfClosingFlag();
            } else if (name.equals(""svg"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.tokeniser.acknowledgeSelfClosingFlag();
            } else if (StringUtil.in(name,
                    ""caption"", ""col"", ""colgroup"", ""frame"", ""head"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr"")) {
                tb.error(this);
                return false;
            } else {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
            }
            break;

        case EndTag:
            Token.EndTag endTag = t.asEndTag();
            name = endTag.name();
            if (name.equals(""body"")) {
                if (!tb.inScope(""body"")) {
                    tb.error(this);
                    return false;
                } else {
                    tb.transition(AfterBody);
                }
            } else if (name.equals(""html"")) {
                boolean notIgnored = tb.process(new Token.EndTag(""body""));
                if (notIgnored)
                    return tb.process(endTag);
            } else if (StringUtil.in(name,
                    ""address"", ""article"", ""aside"", ""blockquote"", ""button"", ""center"", ""details"", ""dir"", ""div"",
                    ""dl"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""listing"", ""menu"",
                    ""nav"", ""ol"", ""pre"", ""section"", ""summary"", ""ul"")) {
                if (!tb.inScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (name.equals(""form"")) {
                Element currentForm = tb.getFormElement();
                tb.setFormElement(null);
                if (currentForm == null || !tb.inScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.removeFromStack(currentForm);
                }
            } else if (name.equals(""p"")) {
                if (!tb.inButtonScope(name)) {
                    tb.error(this);
                    tb.process(new Token.StartTag(name));
                    return tb.process(endTag);
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (name.equals(""li"")) {
                if (!tb.inListItemScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (StringUtil.in(name, ""dd"", ""dt"")) {
                if (!tb.inScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (StringUtil.in(name, ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                if (!tb.inScope(new String[]{""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6""})) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"");
                }
            } else if (name.equals(""sarcasm"")) {
                return anyOtherEndTag(t, tb);
            } else if (StringUtil.in(name,
                    ""a"", ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""nobr"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u"")) {
                OUTER:
                for (int i = 0; i < 8; i++) {
                    Element formatEl = tb.getActiveFormattingElement(name);
                    if (formatEl == null)
                        return anyOtherEndTag(t, tb);
                    else if (!tb.onStack(formatEl)) {
                        tb.error(this);
                        tb.removeFromActiveFormattingElements(formatEl);
                        return true;
                    } else if (!tb.inScope(formatEl.nodeName())) {
                        tb.error(this);
                        return false;
                    } else if (tb.currentElement() != formatEl)
                        tb.error(this);

                    Element furthestBlock = null;
                    Element commonAncestor = null;
                    boolean seenFormattingElement = false;
                    LinkedList<Element> stack = tb.getStack();
                    for (int si = 0; si < stack.size(); si++) {
                        Element el = stack.get(si);
                        if (el == formatEl) {
                            commonAncestor = stack.get(si - 1);
                            seenFormattingElement = true;
                        } else if (seenFormattingElement && tb.isSpecial(el)) {
                            furthestBlock = el;
                            break;
                        }
                    }
                    if (furthestBlock == null) {
                        tb.popStackToClose(formatEl.nodeName());
                        tb.removeFromActiveFormattingElements(formatEl);
                        return true;
                    }

                    Element node = furthestBlock;
                    Element lastNode = furthestBlock;
                    INNER:
                    for (int j = 0; j < 3; j++) {
                        if (tb.onStack(node))
                            node = tb.aboveOnStack(node);
                        if (!tb.isInActiveFormattingElements(node)) {
                            tb.removeFromStack(node);
                            continue INNER;
                        } else if (node == formatEl)
                            break INNER;

                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
                        tb.replaceActiveFormattingElement(node, replacement);
                        tb.replaceOnStack(node, replacement);
                        node = replacement;

                        if (lastNode == furthestBlock) {
                        }
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        node.appendChild(lastNode);

                        lastNode = node;
                    }

                    if (StringUtil.in(commonAncestor.nodeName(), ""table"", ""tbody"", ""tfoot"", ""thead"", ""tr"")) {
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        tb.insertInFosterParent(lastNode);
                    } else {
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        commonAncestor.appendChild(lastNode);
                    }

                    Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());
                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);
                    for (Node childNode : childNodes) {
                        adopter.appendChild(childNode);
                    }
                    furthestBlock.appendChild(adopter);
                    tb.removeFromActiveFormattingElements(formatEl);
                    tb.removeFromStack(formatEl);
                    tb.insertOnStackAfter(furthestBlock, adopter);
                }
            } else if (StringUtil.in(name, ""applet"", ""marquee"", ""object"")) {
                if (!tb.inScope(name)) {
                    tb.error(this);
                    return false;
                }
                tb.generateImpliedEndTags();
                if (!tb.currentElement().nodeName().equals(name))
                    tb.error(this);
                tb.popStackToClose(name);
                tb.clearFormattingElementsToLastMarker();
            } else if (name.equals(""br"")) {
                tb.error(this);
                tb.process(new Token.StartTag(""br""));
                return false;
            } else {
                return anyOtherEndTag(t, tb);
            }

            break;
        case EOF:
            break;
    }
    return true;
}",0,0
283,Jsoup_19,"private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {
         // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.
         // rels without a baseuri get removed
         String value = el.absUrl(attr.getKey());
         if (!preserveRelativeLinks)
             attr.setValue(value);
         
        for (Protocol protocol : protocols) {
            String prot = protocol.toString() + "":"";
            if (value.toLowerCase().startsWith(prot)) {
                return true;
            }
        }
        return false;
    }","private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {
    // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.
    // rels without a baseuri get removed
    String value = el.absUrl(attr.getKey());
    
    if (value.isEmpty()) {
        value = attr.getValue(); // fallback to relative if no absolute URL is available
    }
    
    if (!preserveRelativeLinks) {
        attr.setValue(value);
    }

    for (Protocol protocol : protocols) {
        String prot = protocol.toString() + "":"";
        if (value.toLowerCase(Locale.ROOT).startsWith(prot)) {
            return true;
        }
    }
    return false;
}",0,0
284,Jsoup_2,"private void parseStartTag() {
        tq.consume(""<"");
        String tagName = tq.consumeWord();

        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text
            tq.addFirst(""&lt;"");
            parseTextNode();
            return;
        }

        Attributes attributes = new Attributes();
        while (!tq.matchesAny(""<"", ""/>"", "">"") && !tq.isEmpty()) {
            Attribute attribute = parseAttribute();
            if (attribute != null)
                attributes.put(attribute);
        }

        Tag tag = Tag.valueOf(tagName);
        Element child = new Element(tag, baseUri, attributes);

        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>
        if (tq.matchChomp(""/>"")) { // close empty element or tag
            isEmptyElement = true;
        } else {
            tq.matchChomp("">"");
        }
        addChildToParent(child, isEmptyElement);

        // pc data only tags (textarea, script): chomp to end tag, add content as text node
         if (tag.isData()) {
             String data = tq.chompTo(""</"" + tagName);
             tq.chompTo("">"");
             
             Node dataNode;
             if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)
                dataNode = TextNode.createFromEncoded(data, baseUri);
            else
                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for "" in script)
            child.appendChild(dataNode);   
        }

        // <base href>: update the base uri
        if (child.tagName().equals(""base"")) {
            String href = child.absUrl(""href"");
            if (href.length() != 0) { // ignore <base target> etc
                baseUri = href;
                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base
            }
        }
    }","private void parseStartTag() {
        tq.consume(""<"");
        String tagName = tq.consumeWord();

        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text
            tq.addFirst(""&lt;"");
            parseTextNode();
            return;
        }

        Attributes attributes = new Attributes();
        while (!tq.matchesAny(""<"", ""/>"", "">"") && !tq.isEmpty()) {
            Attribute attribute = parseAttribute();
            if (attribute != null)
                attributes.put(attribute);
        }

        Tag tag = Tag.valueOf(tagName);
        Element child = new Element(tag, baseUri, attributes);

        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>)
        if (tq.matchChomp(""/>"")) { // close empty element or tag
            isEmptyElement = true;
        } else {
            tq.matchChomp("">"");
        }
        addChildToParent(child, isEmptyElement);

        // pc data only tags (textarea, script): chomp to end tag, add content as text node
        if (tag.isData()) {
            String data = tq.chompTo(""</"" + tagName + "">"");
            // ensure full end tag is consumed to close out the element correctly
            tq.matchChomp(""</"" + tagName + "">"");
            
            Node dataNode;
            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)
                dataNode = TextNode.createFromEncoded(data, baseUri);
            else
                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for "" in script)
            child.appendChild(dataNode);   
        }

        // <base href>: update the base uri
        if (child.tagName().equals(""base"")) {
            String href = child.absUrl(""href"");
            if (!href.isEmpty()) { // ignore <base target> etc
                baseUri = href;
                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base
            }
        }
    }",0,0
285,Jsoup_20,"static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
        String docData;
        Document doc = null;
        if (charsetName == null) { // determine from meta. safe parse as UTF-8
            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            doc = parser.parseInput(docData, baseUri);
            Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
            if (meta != null) { // if not found, will keep utf-8 as best attempt
                String foundCharset = meta.hasAttr(""http-equiv"") ? getCharsetFromContentType(meta.attr(""content"")) : meta.attr(""charset"");
                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
                    charsetName = foundCharset;
                    byteData.rewind();
                    docData = Charset.forName(foundCharset).decode(byteData).toString();
                    doc = null;
                }
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
            docData = Charset.forName(charsetName).decode(byteData).toString();
        }
        if (doc == null) {
             // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present
             // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight
             // into head mode
 
             doc = parser.parseInput(docData, baseUri);
             doc.outputSettings().charset(charsetName);
        }
        return doc;
    }","static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
    String docData;
    Document doc = null;
    final String defaultCharset = ""UTF-8""; // Assuming default to UTF-8; can be adjusted as needed.
    if (charsetName == null) { // determine from meta. safe parse as UTF-8
        // Initial decode as defaultCharset
        docData = Charset.forName(defaultCharset).decode(byteData).toString();
        doc = parser.parseInput(docData, baseUri);
        Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
        if (meta != null) { // if not found, will keep utf-8 as best attempt
            String foundCharset = meta.hasAttr(""http-equiv"") ? getCharsetFromContentType(meta.attr(""content"")) : meta.attr(""charset"");
            if (foundCharset != null && !foundCharset.isEmpty() && !foundCharset.equals(defaultCharset)) { // need to re-decode
                charsetName = foundCharset;
                byteData.rewind();
                docData = Charset.forName(foundCharset).decode(byteData).toString();
                doc = null;
            }
        }
    } else { // specified by content type header (or by user on file load)
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        docData = Charset.forName(charsetName).decode(byteData).toString();
    }
    if (doc == null) {
        // parse document if not already parsed
        doc = parser.parseInput(docData, baseUri);
    }

    // Always set output charset when document is parsed
    doc.outputSettings().charset(Charset.forName(charsetName != null ? charsetName : defaultCharset));

    return doc;
}",0,0
286,Jsoup_24,"void read(Tokeniser t, CharacterReader r) {
            if (r.matchesLetter()) {
                 String name = r.consumeLetterSequence();
                 t.tagPending.appendTagName(name.toLowerCase());
                 t.dataBuffer.append(name);
                 r.advance();
                 return;
             }
 
            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {
                char c = r.consume();
                switch (c) {
                    case '\t':
                    case '\n':
                    case '\f':
                    case ' ':
                        t.transition(BeforeAttributeName);
                        break;
                    case '/':
                        t.transition(SelfClosingStartTag);
                        break;
                    case '>':
                        t.emitTagPending();
                        t.transition(Data);
                        break;
                    default:
                        t.dataBuffer.append(c);
                        anythingElse(t, r);
                        break;
                }
            } else {
                anythingElse(t, r);
            }
        }","void read(Tokeniser t, CharacterReader r) {
    if (r.matchesLetter()) {
        String name = r.consumeLetterSequence();
        t.tagPending.appendTagName(name.toLowerCase());
        t.dataBuffer.append(name);
        return; // Removed the r.advance() as it is already consumed
    }

    if (t.isAppropriateEndTagToken() && !r.isEmpty()) {
        char c = r.consume();
        switch (c) {
            case '\t':
            case '\n':
            case '\f':
            case ' ':
                t.transition(BeforeAttributeName);
                break;
            case '/':
                t.transition(SelfClosingStartTag);
                break;
            case '>':
                t.emitTagPending();
                t.transition(Data);
                break;
            default:
                t.dataBuffer.append(c);
                anythingElse(t, r);
                break;
        }
    } else {
        anythingElse(t, r);
    }
}",0,0
287,Jsoup_26,"public Document clean(Document dirtyDocument) {
         Validate.notNull(dirtyDocument);
 
         Document clean = Document.createShell(dirtyDocument.baseUri());
             copySafeNodes(dirtyDocument.body(), clean.body());
 
         return clean;
    }","public Document clean(Document dirtyDocument) {
    Validate.notNull(dirtyDocument);

    Document clean = Document.createShell(dirtyDocument.baseUri());

    if (dirtyDocument.body() != null) {
        copySafeNodes(dirtyDocument.body(), clean.body());
    }

    return clean;
}",0,0
288,Jsoup_27,"static String getCharsetFromContentType(String contentType) {
        if (contentType == null) return null;
         Matcher m = charsetPattern.matcher(contentType);
         if (m.find()) {
             String charset = m.group(1).trim();
             charset = charset.toUpperCase(Locale.ENGLISH);
             return charset;
         }
         return null;
     }","static String getCharsetFromContentType(String contentType) {
    if (contentType == null) return null;
    contentType = contentType.toLowerCase(Locale.ENGLISH);

    Matcher m = charsetPattern.matcher(contentType);
    if (m.find()) {
        String charset = m.group(1).trim();
        if (!charset.isEmpty()) {
            charset = charset.toUpperCase(Locale.ENGLISH);
            return charset;
        }
    }
    return null;
}",0,0
289,Jsoup_32,"@Override
     public Element clone() {
         Element clone = (Element) super.clone();
         clone.classNames();
         return clone;
     }","@Override
    public Element clone() {
        Element clone = (Element) super.clone();
        clone.setClassNames(new ArrayList<>(this.getClassNames()));
        return clone;
    }",0,0
290,Jsoup_33,"Element insert(Token.StartTag startTag) {
        // handle empty unknown tags
        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.
         if (startTag.isSelfClosing()) {
             Element el = insertEmpty(startTag);
             stack.add(el);
             tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing
             return el;
         }
        
        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);
        insert(el);
        return el;
    }","Element insert(Token.StartTag startTag) {
    // handle empty unknown tags
    // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.
    if (startTag.isSelfClosing()) {
        Element el = insertEmpty(startTag);
        tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing
        return el;
    }

    Element el = new Element(Tag.valueOf(startTag.normalName()), baseUri(), startTag.attributes());
    insert(el);
    return el;
}",0,0
291,Jsoup_34,"int nextIndexOf(CharSequence seq) {
        // doesn't handle scanning for surrogates
        char startChar = seq.charAt(0);
        for (int offset = pos; offset < length; offset++) {
            // scan to first instance of startchar:
            if (startChar != input[offset])
                 while(++offset < length && startChar != input[offset]);
             int i = offset + 1;
             int last = i + seq.length()-1;
             if (offset < length) {
                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);
                 if (i == last) // found full sequence
                     return offset - pos;
            }
        }
        return -1;
    }","int nextIndexOf(CharSequence seq) {
        // doesn't handle scanning for surrogates
        char startChar = seq.charAt(0);
        for (int offset = pos; offset <= length - seq.length(); offset++) {
            // scan to first instance of startChar:
            if (startChar != input[offset]) {
                while (++offset <= length - seq.length() && startChar != input[offset]);
            }

            if (offset <= length - seq.length()) {
                int i = offset + 1;
                int j = 1;
                while (j < seq.length() && seq.charAt(j) == input[i]) {
                    i++;
                    j++;
                }
                if (j == seq.length()) { // found full sequence
                    return offset - pos;
                }
            }
        }
        return -1;
    }",0,0
292,Jsoup_35,"boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case Character: {
                    Token.Character c = t.asCharacter();
                    if (c.getData().equals(nullString)) {
                        // todo confirm that check
                        tb.error(this);
                        return false;
                    } else if (isWhitespace(c)) {
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                        tb.framesetOk(false);
                    }
                    break;
                }
                case Comment: {
                    tb.insert(t.asComment());
                    break;
                }
                case Doctype: {
                    tb.error(this);
                    return false;
                }
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    String name = startTag.name();
                    if (name.equals(""html"")) {
                        tb.error(this);
                        // merge attributes onto real html
                        Element html = tb.getStack().getFirst();
                        for (Attribute attribute : startTag.getAttributes()) {
                            if (!html.hasAttr(attribute.getKey()))
                                html.attributes().put(attribute);
                        }
                    } else if (StringUtil.in(name, ""base"", ""basefont"", ""bgsound"", ""command"", ""link"", ""meta"", ""noframes"", ""script"", ""style"", ""title"")) {
                        return tb.process(t, InHead);
                    } else if (name.equals(""body"")) {
                        tb.error(this);
                        LinkedList<Element> stack = tb.getStack();
                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                            // only in fragment case
                            return false; // ignore
                        } else {
                            tb.framesetOk(false);
                            Element body = stack.get(1);
                            for (Attribute attribute : startTag.getAttributes()) {
                                if (!body.hasAttr(attribute.getKey()))
                                    body.attributes().put(attribute);
                            }
                        }
                    } else if (name.equals(""frameset"")) {
                        tb.error(this);
                        LinkedList<Element> stack = tb.getStack();
                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                            // only in fragment case
                            return false; // ignore
                        } else if (!tb.framesetOk()) {
                            return false; // ignore frameset
                        } else {
                            Element second = stack.get(1);
                            if (second.parent() != null)
                                second.remove();
                            // pop up to html element
                            while (stack.size() > 1)
                                stack.removeLast();
                            tb.insert(startTag);
                            tb.transition(InFrameset);
                        }
                    } else if (StringUtil.in(name,
                            ""address"", ""article"", ""aside"", ""blockquote"", ""center"", ""details"", ""dir"", ""div"", ""dl"",
                            ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""menu"", ""nav"", ""ol"",
                            ""p"", ""section"", ""summary"", ""ul"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        if (StringUtil.in(tb.currentElement().nodeName(), ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                            tb.error(this);
                            tb.pop();
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, ""pre"", ""listing"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                        // todo: ignore LF if next token
                        tb.framesetOk(false);
                    } else if (name.equals(""form"")) {
                        if (tb.getFormElement() != null) {
                            tb.error(this);
                            return false;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insertForm(startTag, true);
                    } else if (name.equals(""li"")) {
                        tb.framesetOk(false);
                        LinkedList<Element> stack = tb.getStack();
                        for (int i = stack.size() - 1; i > 0; i--) {
                            Element el = stack.get(i);
                            if (el.nodeName().equals(""li"")) {
                                tb.process(new Token.EndTag(""li""));
                                break;
                            }
                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), ""address"", ""div"", ""p""))
                                break;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, ""dd"", ""dt"")) {
                        tb.framesetOk(false);
                        LinkedList<Element> stack = tb.getStack();
                        for (int i = stack.size() - 1; i > 0; i--) {
                            Element el = stack.get(i);
                            if (StringUtil.in(el.nodeName(), ""dd"", ""dt"")) {
                                tb.process(new Token.EndTag(el.nodeName()));
                                break;
                            }
                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), ""address"", ""div"", ""p""))
                                break;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                    } else if (name.equals(""plaintext"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out
                    } else if (name.equals(""button"")) {
                        if (tb.inButtonScope(""button"")) {
                            // close and reprocess
                            tb.error(this);
                            tb.process(new Token.EndTag(""button""));
                            tb.process(startTag);
                        } else {
                            tb.reconstructFormattingElements();
                            tb.insert(startTag);
                            tb.framesetOk(false);
                        }
                    } else if (name.equals(""a"")) {
                        if (tb.getActiveFormattingElement(""a"") != null) {
                            tb.error(this);
                            tb.process(new Token.EndTag(""a""));

                            // still on stack?
                            Element remainingA = tb.getFromStack(""a"");
                            if (remainingA != null) {
                                tb.removeFromActiveFormattingElements(remainingA);
                                tb.removeFromStack(remainingA);
                            }
                        }
                        tb.reconstructFormattingElements();
                        Element a = tb.insert(startTag);
                        tb.pushActiveFormattingElements(a);
                    } else if (StringUtil.in(name,
                            ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u"")) {
                        tb.reconstructFormattingElements();
                        Element el = tb.insert(startTag);
                        tb.pushActiveFormattingElements(el);
                    } else if (name.equals(""nobr"")) {
                        tb.reconstructFormattingElements();
                        if (tb.inScope(""nobr"")) {
                            tb.error(this);
                            tb.process(new Token.EndTag(""nobr""));
                            tb.reconstructFormattingElements();
                        }
                        Element el = tb.insert(startTag);
                        tb.pushActiveFormattingElements(el);
                    } else if (StringUtil.in(name, ""applet"", ""marquee"", ""object"")) {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.insertMarkerToFormattingElements();
                        tb.framesetOk(false);
                    } else if (name.equals(""table"")) {
                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                        tb.framesetOk(false);
                        tb.transition(InTable);
                    } else if (StringUtil.in(name, ""area"", ""br"", ""embed"", ""img"", ""keygen"", ""wbr"")) {
                        tb.reconstructFormattingElements();
                        tb.insertEmpty(startTag);
                        tb.framesetOk(false);
                    } else if (name.equals(""input"")) {
                        tb.reconstructFormattingElements();
                        Element el = tb.insertEmpty(startTag);
                        if (!el.attr(""type"").equalsIgnoreCase(""hidden""))
                            tb.framesetOk(false);
                    } else if (StringUtil.in(name, ""param"", ""source"", ""track"")) {
                        tb.insertEmpty(startTag);
                    } else if (name.equals(""hr"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insertEmpty(startTag);
                        tb.framesetOk(false);
                    } else if (name.equals(""image"")) {
                        // we're not supposed to ask.
                        startTag.name(""img"");
                        return tb.process(startTag);
                    } else if (name.equals(""isindex"")) {
                        // how much do we care about the early 90s?
                        tb.error(this);
                        if (tb.getFormElement() != null)
                            return false;

                        tb.tokeniser.acknowledgeSelfClosingFlag();
                        tb.process(new Token.StartTag(""form""));
                        if (startTag.attributes.hasKey(""action"")) {
                            Element form = tb.getFormElement();
                            form.attr(""action"", startTag.attributes.get(""action""));
                        }
                        tb.process(new Token.StartTag(""hr""));
                        tb.process(new Token.StartTag(""label""));
                        // hope you like english.
                        String prompt = startTag.attributes.hasKey(""prompt"") ?
                                startTag.attributes.get(""prompt"") :
                                ""This is a searchable index. Enter search keywords: "";

                        tb.process(new Token.Character(prompt));

                        // input
                        Attributes inputAttribs = new Attributes();
                        for (Attribute attr : startTag.attributes) {
                            if (!StringUtil.in(attr.getKey(), ""name"", ""action"", ""prompt""))
                                inputAttribs.put(attr);
                        }
                        inputAttribs.put(""name"", ""isindex"");
                        tb.process(new Token.StartTag(""input"", inputAttribs));
                        tb.process(new Token.EndTag(""label""));
                        tb.process(new Token.StartTag(""hr""));
                        tb.process(new Token.EndTag(""form""));
                    } else if (name.equals(""textarea"")) {
                        tb.insert(startTag);
                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
                        tb.tokeniser.transition(TokeniserState.Rcdata);
                        tb.markInsertionMode();
                        tb.framesetOk(false);
                        tb.transition(Text);
                    } else if (name.equals(""xmp"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.reconstructFormattingElements();
                        tb.framesetOk(false);
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""iframe"")) {
                        tb.framesetOk(false);
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""noembed"")) {
                        // also handle noscript if script enabled
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""select"")) {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.framesetOk(false);

                        HtmlTreeBuilderState state = tb.state();
                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                            tb.transition(InSelectInTable);
                        else
                            tb.transition(InSelect);
                    } else if (StringUtil.in(""optgroup"", ""option"")) {
                        if (tb.currentElement().nodeName().equals(""option""))
                            tb.process(new Token.EndTag(""option""));
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    } else if (StringUtil.in(""rp"", ""rt"")) {
                        if (tb.inScope(""ruby"")) {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(""ruby"")) {
                                tb.error(this);
                                tb.popStackToBefore(""ruby""); // i.e. close up to but not include name
                            }
                            tb.insert(startTag);
                        }
                    } else if (name.equals(""math"")) {
                        tb.reconstructFormattingElements();
                        // todo: handle A start tag whose tag name is ""math"" (i.e. foreign, mathml)
                        tb.insert(startTag);
                        tb.tokeniser.acknowledgeSelfClosingFlag();
                    } else if (name.equals(""svg"")) {
                        tb.reconstructFormattingElements();
                        // todo: handle A start tag whose tag name is ""svg"" (xlink, svg)
                        tb.insert(startTag);
                        tb.tokeniser.acknowledgeSelfClosingFlag();
                    } else if (StringUtil.in(name,
                            ""caption"", ""col"", ""colgroup"", ""frame"", ""head"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr"")) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    }
                    break;

                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    name = endTag.name();
                    if (name.equals(""body"")) {
                        if (!tb.inScope(""body"")) {
                            tb.error(this);
                            return false;
                        } else {
                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
                            tb.transition(AfterBody);
                        }
                    } else if (name.equals(""html"")) {
                        boolean notIgnored = tb.process(new Token.EndTag(""body""));
                        if (notIgnored)
                            return tb.process(endTag);
                    } else if (StringUtil.in(name,
                            ""address"", ""article"", ""aside"", ""blockquote"", ""button"", ""center"", ""details"", ""dir"", ""div"",
                            ""dl"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""listing"", ""menu"",
                            ""nav"", ""ol"", ""pre"", ""section"", ""summary"", ""ul"")) {
                        // todo: refactor these lookups
                        if (!tb.inScope(name)) {
                            // nothing to close
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (name.equals(""form"")) {
                        Element currentForm = tb.getFormElement();
                        tb.setFormElement(null);
                        if (currentForm == null || !tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            // remove currentForm from stack. will shift anything under up.
                            tb.removeFromStack(currentForm);
                        }
                    } else if (name.equals(""p"")) {
                        if (!tb.inButtonScope(name)) {
                            tb.error(this);
                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>
                            return tb.process(endTag);
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (name.equals(""li"")) {
                        if (!tb.inListItemScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (StringUtil.in(name, ""dd"", ""dt"")) {
                        if (!tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (StringUtil.in(name, ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                        if (!tb.inScope(new String[]{""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6""})) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"");
                        }
                    } else if (name.equals(""sarcasm"")) {
                        // *sigh*
                        return anyOtherEndTag(t, tb);
                    } else if (StringUtil.in(name,
                            ""a"", ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""nobr"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u"")) {
                        // Adoption Agency Algorithm.
                        OUTER:
                        for (int i = 0; i < 8; i++) {
                            Element formatEl = tb.getActiveFormattingElement(name);
                            if (formatEl == null)
                                return anyOtherEndTag(t, tb);
                            else if (!tb.onStack(formatEl)) {
                                tb.error(this);
                                tb.removeFromActiveFormattingElements(formatEl);
                                return true;
                            } else if (!tb.inScope(formatEl.nodeName())) {
                                tb.error(this);
                                return false;
                            } else if (tb.currentElement() != formatEl)
                                tb.error(this);

                            Element furthestBlock = null;
                            Element commonAncestor = null;
                            boolean seenFormattingElement = false;
                            LinkedList<Element> stack = tb.getStack();
                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents
                            // run-aways
                            for (int si = 0; si < stack.size() && si < 64; si++) {
                                Element el = stack.get(si);
                                if (el == formatEl) {
                                    commonAncestor = stack.get(si - 1);
                                    seenFormattingElement = true;
                                } else if (seenFormattingElement && tb.isSpecial(el)) {
                                    furthestBlock = el;
                                    break;
                                }
                            }
                            if (furthestBlock == null) {
                                tb.popStackToClose(formatEl.nodeName());
                                tb.removeFromActiveFormattingElements(formatEl);
                                return true;
                            }

                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
                            // does that mean: int pos of format el in list?
                            Element node = furthestBlock;
                            Element lastNode = furthestBlock;
                            INNER:
                            for (int j = 0; j < 3; j++) {
                                if (tb.onStack(node))
                                    node = tb.aboveOnStack(node);
                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
                                    tb.removeFromStack(node);
                                    continue INNER;
                                } else if (node == formatEl)
                                    break INNER;

                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
                                tb.replaceActiveFormattingElement(node, replacement);
                                tb.replaceOnStack(node, replacement);
                                node = replacement;

                                if (lastNode == furthestBlock) {
                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
                                    // not getting how this bookmark both straddles the element above, but is inbetween here...
                                }
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                node.appendChild(lastNode);

                                lastNode = node;
                            }

                            if (StringUtil.in(commonAncestor.nodeName(), ""table"", ""tbody"", ""tfoot"", ""thead"", ""tr"")) {
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                tb.insertInFosterParent(lastNode);
                            } else {
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                commonAncestor.appendChild(lastNode);
                             }
 
                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
                             for (Node childNode : childNodes) {
                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.
                            }
                            furthestBlock.appendChild(adopter);
                            tb.removeFromActiveFormattingElements(formatEl);
                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
                            tb.removeFromStack(formatEl);
                            tb.insertOnStackAfter(furthestBlock, adopter);
                        }
                    } else if (StringUtil.in(name, ""applet"", ""marquee"", ""object"")) {
                        if (!tb.inScope(""name"")) {
                            if (!tb.inScope(name)) {
                                tb.error(this);
                                return false;
                            }
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                            tb.clearFormattingElementsToLastMarker();
                        }
                    } else if (name.equals(""br"")) {
                        tb.error(this);
                        tb.process(new Token.StartTag(""br""));
                        return false;
                    } else {
                        return anyOtherEndTag(t, tb);
                    }

                    break;
                case EOF:
                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
                    // stop parsing
                    break;
            }
            return true;
        }","boolean process(Token t, HtmlTreeBuilder tb) {
    switch (t.type) {
        case Character: {
            Token.Character c = t.asCharacter();
            if (c.getData().equals(nullString)) {
                tb.error(this);
                return false;
            } else if (isWhitespace(c)) {
                tb.reconstructFormattingElements();
                tb.insert(c);
            } else {
                tb.reconstructFormattingElements();
                tb.insert(c);
                tb.framesetOk(false);
            }
            break;
        }
        case Comment: {
            tb.insert(t.asComment());
            break;
        }
        case Doctype: {
            tb.error(this);
            return false;
        }
        case StartTag: {
            Token.StartTag startTag = t.asStartTag();
            String name = startTag.name();
            LinkedList<Element> stack = tb.getStack();
            if (name.equals(""html"")) {
                tb.error(this);
                Element html = stack.getFirst();
                for (Attribute attribute : startTag.getAttributes()) {
                    if (!html.hasAttr(attribute.getKey()))
                        html.attributes().put(attribute);
                }
            } else if (StringUtil.in(name, ""base"", ""basefont"", ""bgsound"", ""command"", ""link"", ""meta"", ""noframes"", ""script"", ""style"", ""title"")) {
                return tb.process(t, InHead);
            } else if (name.equals(""body"")) {
                tb.error(this);
                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                    return false;
                } else {
                    tb.framesetOk(false);
                    Element body = stack.get(1);
                    for (Attribute attribute : startTag.getAttributes()) {
                        if (!body.hasAttr(attribute.getKey()))
                            body.attributes().put(attribute);
                    }
                }
            } else if (name.equals(""frameset"")) {
                tb.error(this);
                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                    return false;
                } else if (!tb.framesetOk()) {
                    return false;
                } else {
                    Element second = stack.get(1);
                    if (second.parent() != null)
                        second.remove();
                    while (stack.size() > 1)
                        stack.removeLast();
                    tb.insert(startTag);
                    tb.transition(InFrameset);
                }
            } else if (StringUtil.in(name, ""address"", ""article"", ""aside"", ""blockquote"", ""center"", ""details"", ""dir"", ""div"", ""dl"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""menu"", ""nav"", ""ol"", ""p"", ""section"", ""summary"", ""ul"")) {
                if (tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                tb.insert(startTag);
            } else if (StringUtil.in(name, ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                if (tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                if (StringUtil.in(tb.currentElement().nodeName(), ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                    tb.error(this);
                    tb.pop();
                }
                tb.insert(startTag);
            } else if (StringUtil.in(name, ""pre"", ""listing"")) {
                if (tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                tb.insert(startTag);
                tb.framesetOk(false);
            } else if (name.equals(""form"")) {
                if (tb.getFormElement() != null) {
                    tb.error(this);
                    return false;
                }
                if (tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                tb.insertForm(startTag, true);
            } else if (name.equals(""li"")) {
                tb.framesetOk(false);
                for (int i = stack.size() - 1; i > 0; i--) {
                    Element el = stack.get(i);
                    if (el.nodeName().equals(""li"")) {
                        tb.process(new Token.EndTag(""li""));
                        break;
                    }
                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), ""address"", ""div"", ""p""))
                        break;
                }
                if (tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                tb.insert(startTag);
            } else if (StringUtil.in(name, ""dd"", ""dt"")) {
                tb.framesetOk(false);
                for (int i = stack.size() - 1; i > 0; i--) {
                    Element el = stack.get(i);
                    if (StringUtil.in(el.nodeName(), ""dd"", ""dt"")) {
                        tb.process(new Token.EndTag(el.nodeName()));
                        break;
                    }
                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), ""address"", ""div"", ""p""))
                        break;
                }
                if (tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                tb.insert(startTag);
            } else if (name.equals(""plaintext"")) {
                if (tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                tb.insert(startTag);
                tb.tokeniser.transition(TokeniserState.PLAINTEXT);
            } else if (name.equals(""button"")) {
                if (tb.inButtonScope(""button"")) {
                    tb.error(this);
                    tb.process(new Token.EndTag(""button""));
                    tb.process(startTag);
                } else {
                    tb.reconstructFormattingElements();
                    tb.insert(startTag);
                    tb.framesetOk(false);
                }
            } else if (name.equals(""a"")) {
                if (tb.getActiveFormattingElement(""a"") != null) {
                    tb.error(this);
                    tb.process(new Token.EndTag(""a""));
                    Element remainingA = tb.getFromStack(""a"");
                    if (remainingA != null) {
                        tb.removeFromActiveFormattingElements(remainingA);
                        tb.removeFromStack(remainingA);
                    }
                }
                tb.reconstructFormattingElements();
                Element a = tb.insert(startTag);
                tb.pushActiveFormattingElements(a);
            } else if (StringUtil.in(name, ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u"")) {
                tb.reconstructFormattingElements();
                Element el = tb.insert(startTag);
                tb.pushActiveFormattingElements(el);
            } else if (name.equals(""nobr"")) {
                tb.reconstructFormattingElements();
                if (tb.inScope(""nobr"")) {
                    tb.error(this);
                    tb.process(new Token.EndTag(""nobr""));
                    tb.reconstructFormattingElements();
                }
                Element el = tb.insert(startTag);
                tb.pushActiveFormattingElements(el);
            } else if (StringUtil.in(name, ""applet"", ""marquee"", ""object"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.insertMarkerToFormattingElements();
                tb.framesetOk(false);
            } else if (name.equals(""table"")) {
                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                tb.insert(startTag);
                tb.framesetOk(false);
                tb.transition(InTable);
            } else if (StringUtil.in(name, ""area"", ""br"", ""embed"", ""img"", ""keygen"", ""wbr"")) {
                tb.reconstructFormattingElements();
                tb.insertEmpty(startTag);
                tb.framesetOk(false);
            } else if (name.equals(""input"")) {
                tb.reconstructFormattingElements();
                Element el = tb.insertEmpty(startTag);
                if (!el.attr(""type"").equalsIgnoreCase(""hidden""))
                    tb.framesetOk(false);
            } else if (StringUtil.in(name, ""param"", ""source"", ""track"")) {
                tb.insertEmpty(startTag);
            } else if (name.equals(""hr"")) {
                if (tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                tb.insertEmpty(startTag);
                tb.framesetOk(false);
            } else if (name.equals(""image"")) {
                startTag.name(""img"");
                return tb.process(startTag);
            } else if (name.equals(""isindex"")) {
                tb.error(this);
                if (tb.getFormElement() != null)
                    return false;
                tb.tokeniser.acknowledgeSelfClosingFlag();
                tb.process(new Token.StartTag(""form""));
                if (startTag.attributes.hasKey(""action"")) {
                    Element form = tb.getFormElement();
                    form.attr(""action"", startTag.attributes.get(""action""));
                }
                tb.process(new Token.StartTag(""hr""));
                tb.process(new Token.StartTag(""label""));
                String prompt = startTag.attributes.hasKey(""prompt"") ? startTag.attributes.get(""prompt"") : ""This is a searchable index. Enter search keywords: "";
                tb.process(new Token.Character(prompt));
                Attributes inputAttribs = new Attributes();
                for (Attribute attr : startTag.attributes) {
                    if (!StringUtil.in(attr.getKey(), ""name"", ""action"", ""prompt""))
                        inputAttribs.put(attr);
                }
                inputAttribs.put(""name"", ""isindex"");
                tb.process(new Token.StartTag(""input"", inputAttribs));
                tb.process(new Token.EndTag(""label""));
                tb.process(new Token.StartTag(""hr""));
                tb.process(new Token.EndTag(""form""));
            } else if (name.equals(""textarea"")) {
                tb.insert(startTag);
                tb.tokeniser.transition(TokeniserState.Rcdata);
                tb.markInsertionMode();
                tb.framesetOk(false);
                tb.transition(Text);
            } else if (name.equals(""xmp"")) {
                if (tb.inButtonScope(""p""))
                    tb.process(new Token.EndTag(""p""));
                tb.reconstructFormattingElements();
                tb.framesetOk(false);
                handleRawtext(startTag, tb);
            } else if (name.equals(""iframe"")) {
                tb.framesetOk(false);
                handleRawtext(startTag, tb);
            } else if (name.equals(""noembed"")) {
                handleRawtext(startTag, tb);
            } else if (name.equals(""select"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.framesetOk(false);
                HtmlTreeBuilderState state = tb.state();
                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                    tb.transition(InSelectInTable);
                else
                    tb.transition(InSelect);
            } else if (StringUtil.in(name, ""optgroup"", ""option"")) {
                if (tb.currentElement().nodeName().equals(""option""))
                    tb.process(new Token.EndTag(""option""));
                tb.reconstructFormattingElements();
                tb.insert(startTag);
            } else if (StringUtil.in(name, ""rp"", ""rt"")) {
                if (tb.inScope(""ruby"")) {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(""ruby"")) {
                        tb.error(this);
                        tb.popStackToBefore(""ruby"");
                    }
                    tb.insert(startTag);
                }
            } else if (name.equals(""math"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.tokeniser.acknowledgeSelfClosingFlag();
            } else if (name.equals(""svg"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.tokeniser.acknowledgeSelfClosingFlag();
            } else if (StringUtil.in(name, ""caption"", ""col"", ""colgroup"", ""frame"", ""head"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr"")) {
                tb.error(this);
                return false;
            } else {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
            }
            break;
        }
        case EndTag: {
            Token.EndTag endTag = t.asEndTag();
            String name = endTag.name();
            if (name.equals(""body"")) {
                if (!tb.inScope(""body"")) {
                    tb.error(this);
                    return false;
                } else {
                    tb.transition(AfterBody);
                }
            } else if (name.equals(""html"")) {
                boolean notIgnored = tb.process(new Token.EndTag(""body""));
                if (notIgnored)
                    return tb.process(endTag);
            } else if (StringUtil.in(name, ""address"", ""article"", ""aside"", ""blockquote"", ""button"", ""center"", ""details"", ""dir"", ""div"", ""dl"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""listing"", ""menu"", ""nav"", ""ol"", ""pre"", ""section"", ""summary"", ""ul"")) {
                if (!tb.inScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (name.equals(""form"")) {
                Element currentForm = tb.getFormElement();
                if (currentForm == null || !tb.inScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.removeFromStack(currentForm);
                }
                tb.setFormElement(null);
            } else if (name.equals(""p"")) {
                if (!tb.inButtonScope(name)) {
                    tb.error(this);
                    tb.process(new Token.StartTag(name));
                    return tb.process(endTag);
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (name.equals(""li"")) {
                if (!tb.inListItemScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (StringUtil.in(name, ""dd"", ""dt"")) {
                if (!tb.inScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (StringUtil.in(name, ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"")) {
                if (!tb.inScope(new String[]{""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6""})) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"");
                }
            } else if (name.equals(""sarcasm"")) {
                return anyOtherEndTag(t, tb);
            } else if (StringUtil.in(name, ""a"", ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""nobr"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u"")) {
                OUTER:
                for (int i = 0; i < 8; i++) {
                    Element formatEl = tb.getActiveFormattingElement(name);
                    if (formatEl == null)
                        return anyOtherEndTag(t, tb);
                    else if (!tb.onStack(formatEl)) {
                        tb.error(this);
                        tb.removeFromActiveFormattingElements(formatEl);
                        return true;
                    } else if (!tb.inScope(formatEl.nodeName())) {
                        tb.error(this);
                        return false;
                    } else if (tb.currentElement() != formatEl)
                        tb.error(this);

                    Element furthestBlock = null;
                    Element commonAncestor = null;
                    boolean seenFormattingElement = false;
                    LinkedList<Element> stack = tb.getStack();
                    for (int si = 0; si < stack.size() && si < 64; si++) {
                        Element el = stack.get(si);
                        if (el == formatEl) {
                            commonAncestor = stack.get(si - 1);
                            seenFormattingElement = true;
                        } else if (seenFormattingElement && tb.isSpecial(el)) {
                            furthestBlock = el;
                            break;
                        }
                    }
                    if (furthestBlock == null) {
                        tb.popStackToClose(formatEl.nodeName());
                        tb.removeFromActiveFormattingElements(formatEl);
                        return true;
                    }

                    Element node = furthestBlock;
                    Element lastNode = furthestBlock;
                    INNER:
                    for (int j = 0; j < 3; j++) {
                        if (tb.onStack(node))
                            node = tb.aboveOnStack(node);
                        if (!tb.isInActiveFormattingElements(node)) {
                            tb.removeFromStack(node);
                            continue INNER;
                        } else if (node == formatEl)
                            break INNER;

                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
                        tb.replaceActiveFormattingElement(node, replacement);
                        tb.replaceOnStack(node, replacement);
                        node = replacement;

                        if (lastNode == furthestBlock) {
                        }
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        node.appendChild(lastNode);

                        lastNode = node;
                    }

                    if (StringUtil.in(commonAncestor.nodeName(), ""table"", ""tbody"", ""tfoot"", ""thead"", ""tr"")) {
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        tb.insertInFosterParent(lastNode);
                    } else {
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        commonAncestor.appendChild(lastNode);
                    }

                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
                    for (Node childNode : childNodes) {
                        adopter.appendChild(childNode);
                    }
                    furthestBlock.appendChild(adopter);
                    tb.removeFromActiveFormattingElements(formatEl);
                    tb.removeFromStack(formatEl);
                    tb.insertOnStackAfter(furthestBlock, adopter);
                }
            } else if (StringUtil.in(name, ""applet"", ""marquee"", ""object"")) {
                if (!tb.inScope(name)) {
                    tb.error(this);
                    return false;
                }
                tb.generateImpliedEndTags();
                if (!tb.currentElement().nodeName().equals(name))
                    tb.error(this);
                tb.popStackToClose(name);
                tb.clearFormattingElementsToLastMarker();
            } else if (name.equals(""br"")) {
                tb.error(this);
                tb.process(new Token.StartTag(""br""));
                return false;
            } else {
                return anyOtherEndTag(t, tb);
            }
            break;
        }
        case EOF: { 
            break;
        }
    }
    return true;
}",0,0
293,Jsoup_37,"public String html() {
         StringBuilder accum = new StringBuilder();
         html(accum);
         return accum.toString().trim();
     }","public String html() {
    StringBuilder accum = new StringBuilder();
    html(accum);
    if (accum.length() == 0) {
        return """";
    }
    return accum.toString().trim();
}",0,0
294,Jsoup_38,"boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case Character: {
                    Token.Character c = t.asCharacter();
                    if (c.getData().equals(nullString)) {
                        // todo confirm that check
                        tb.error(this);
                        return false;
                    } else if (isWhitespace(c)) {
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                        tb.framesetOk(false);
                    }
                    break;
                }
                case Comment: {
                    tb.insert(t.asComment());
                    break;
                }
                case Doctype: {
                    tb.error(this);
                    return false;
                }
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    String name = startTag.name();
                    if (name.equals(""html"")) {
                        tb.error(this);
                        // merge attributes onto real html
                        Element html = tb.getStack().getFirst();
                        for (Attribute attribute : startTag.getAttributes()) {
                            if (!html.hasAttr(attribute.getKey()))
                                html.attributes().put(attribute);
                        }
                    } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {
                        return tb.process(t, InHead);
                    } else if (name.equals(""body"")) {
                        tb.error(this);
                        LinkedList<Element> stack = tb.getStack();
                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                            // only in fragment case
                            return false; // ignore
                        } else {
                            tb.framesetOk(false);
                            Element body = stack.get(1);
                            for (Attribute attribute : startTag.getAttributes()) {
                                if (!body.hasAttr(attribute.getKey()))
                                    body.attributes().put(attribute);
                            }
                        }
                    } else if (name.equals(""frameset"")) {
                        tb.error(this);
                        LinkedList<Element> stack = tb.getStack();
                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                            // only in fragment case
                            return false; // ignore
                        } else if (!tb.framesetOk()) {
                            return false; // ignore frameset
                        } else {
                            Element second = stack.get(1);
                            if (second.parent() != null)
                                second.remove();
                            // pop up to html element
                            while (stack.size() > 1)
                                stack.removeLast();
                            tb.insert(startTag);
                            tb.transition(InFrameset);
                        }
                    } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, Constants.Headings)) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {
                            tb.error(this);
                            tb.pop();
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                        // todo: ignore LF if next token
                        tb.framesetOk(false);
                    } else if (name.equals(""form"")) {
                        if (tb.getFormElement() != null) {
                            tb.error(this);
                            return false;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insertForm(startTag, true);
                    } else if (name.equals(""li"")) {
                        tb.framesetOk(false);
                        LinkedList<Element> stack = tb.getStack();
                        for (int i = stack.size() - 1; i > 0; i--) {
                            Element el = stack.get(i);
                            if (el.nodeName().equals(""li"")) {
                                tb.process(new Token.EndTag(""li""));
                                break;
                            }
                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))
                                break;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, Constants.DdDt)) {
                        tb.framesetOk(false);
                        LinkedList<Element> stack = tb.getStack();
                        for (int i = stack.size() - 1; i > 0; i--) {
                            Element el = stack.get(i);
                            if (StringUtil.in(el.nodeName(), Constants.DdDt)) {
                                tb.process(new Token.EndTag(el.nodeName()));
                                break;
                            }
                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))
                                break;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                    } else if (name.equals(""plaintext"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out
                    } else if (name.equals(""button"")) {
                        if (tb.inButtonScope(""button"")) {
                            // close and reprocess
                            tb.error(this);
                            tb.process(new Token.EndTag(""button""));
                            tb.process(startTag);
                        } else {
                            tb.reconstructFormattingElements();
                            tb.insert(startTag);
                            tb.framesetOk(false);
                        }
                    } else if (name.equals(""a"")) {
                        if (tb.getActiveFormattingElement(""a"") != null) {
                            tb.error(this);
                            tb.process(new Token.EndTag(""a""));

                            // still on stack?
                            Element remainingA = tb.getFromStack(""a"");
                            if (remainingA != null) {
                                tb.removeFromActiveFormattingElements(remainingA);
                                tb.removeFromStack(remainingA);
                            }
                        }
                        tb.reconstructFormattingElements();
                        Element a = tb.insert(startTag);
                        tb.pushActiveFormattingElements(a);
                    } else if (StringUtil.in(name, Constants.Formatters)) {
                        tb.reconstructFormattingElements();
                        Element el = tb.insert(startTag);
                        tb.pushActiveFormattingElements(el);
                    } else if (name.equals(""nobr"")) {
                        tb.reconstructFormattingElements();
                        if (tb.inScope(""nobr"")) {
                            tb.error(this);
                            tb.process(new Token.EndTag(""nobr""));
                            tb.reconstructFormattingElements();
                        }
                        Element el = tb.insert(startTag);
                        tb.pushActiveFormattingElements(el);
                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.insertMarkerToFormattingElements();
                        tb.framesetOk(false);
                    } else if (name.equals(""table"")) {
                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.insert(startTag);
                        tb.framesetOk(false);
                        tb.transition(InTable);
                    } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {
                        tb.reconstructFormattingElements();
                        tb.insertEmpty(startTag);
                        tb.framesetOk(false);
                    } else if (name.equals(""input"")) {
                        tb.reconstructFormattingElements();
                        Element el = tb.insertEmpty(startTag);
                        if (!el.attr(""type"").equalsIgnoreCase(""hidden""))
                            tb.framesetOk(false);
                    } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {
                        tb.insertEmpty(startTag);
                    } else if (name.equals(""hr"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                         tb.insertEmpty(startTag);
                         tb.framesetOk(false);
                     } else if (name.equals(""image"")) {
                             return tb.process(startTag.name(""img"")); // change <image> to <img>, unless in svg
                     } else if (name.equals(""isindex"")) {
                         // how much do we care about the early 90s?
                         tb.error(this);
                        if (tb.getFormElement() != null)
                            return false;

                        tb.tokeniser.acknowledgeSelfClosingFlag();
                        tb.process(new Token.StartTag(""form""));
                        if (startTag.attributes.hasKey(""action"")) {
                            Element form = tb.getFormElement();
                            form.attr(""action"", startTag.attributes.get(""action""));
                        }
                        tb.process(new Token.StartTag(""hr""));
                        tb.process(new Token.StartTag(""label""));
                        // hope you like english.
                        String prompt = startTag.attributes.hasKey(""prompt"") ?
                                startTag.attributes.get(""prompt"") :
                                ""This is a searchable index. Enter search keywords: "";

                        tb.process(new Token.Character(prompt));

                        // input
                        Attributes inputAttribs = new Attributes();
                        for (Attribute attr : startTag.attributes) {
                            if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))
                                inputAttribs.put(attr);
                        }
                        inputAttribs.put(""name"", ""isindex"");
                        tb.process(new Token.StartTag(""input"", inputAttribs));
                        tb.process(new Token.EndTag(""label""));
                        tb.process(new Token.StartTag(""hr""));
                        tb.process(new Token.EndTag(""form""));
                    } else if (name.equals(""textarea"")) {
                        tb.insert(startTag);
                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
                        tb.tokeniser.transition(TokeniserState.Rcdata);
                        tb.markInsertionMode();
                        tb.framesetOk(false);
                        tb.transition(Text);
                    } else if (name.equals(""xmp"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.process(new Token.EndTag(""p""));
                        }
                        tb.reconstructFormattingElements();
                        tb.framesetOk(false);
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""iframe"")) {
                        tb.framesetOk(false);
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""noembed"")) {
                        // also handle noscript if script enabled
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""select"")) {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.framesetOk(false);

                        HtmlTreeBuilderState state = tb.state();
                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                            tb.transition(InSelectInTable);
                        else
                            tb.transition(InSelect);
                    } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {
                        if (tb.currentElement().nodeName().equals(""option""))
                            tb.process(new Token.EndTag(""option""));
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {
                        if (tb.inScope(""ruby"")) {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(""ruby"")) {
                                tb.error(this);
                                tb.popStackToBefore(""ruby""); // i.e. close up to but not include name
                            }
                            tb.insert(startTag);
                        }
                    } else if (name.equals(""math"")) {
                        tb.reconstructFormattingElements();
                        // todo: handle A start tag whose tag name is ""math"" (i.e. foreign, mathml)
                        tb.insert(startTag);
                        tb.tokeniser.acknowledgeSelfClosingFlag();
                    } else if (name.equals(""svg"")) {
                        tb.reconstructFormattingElements();
                        // todo: handle A start tag whose tag name is ""svg"" (xlink, svg)
                        tb.insert(startTag);
                        tb.tokeniser.acknowledgeSelfClosingFlag();
                    } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    }
                    break;

                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    name = endTag.name();
                    if (name.equals(""body"")) {
                        if (!tb.inScope(""body"")) {
                            tb.error(this);
                            return false;
                        } else {
                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
                            tb.transition(AfterBody);
                        }
                    } else if (name.equals(""html"")) {
                        boolean notIgnored = tb.process(new Token.EndTag(""body""));
                        if (notIgnored)
                            return tb.process(endTag);
                    } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {
                        if (!tb.inScope(name)) {
                            // nothing to close
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (name.equals(""form"")) {
                        Element currentForm = tb.getFormElement();
                        tb.setFormElement(null);
                        if (currentForm == null || !tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            // remove currentForm from stack. will shift anything under up.
                            tb.removeFromStack(currentForm);
                        }
                    } else if (name.equals(""p"")) {
                        if (!tb.inButtonScope(name)) {
                            tb.error(this);
                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>
                            return tb.process(endTag);
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (name.equals(""li"")) {
                        if (!tb.inListItemScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (StringUtil.in(name, Constants.DdDt)) {
                        if (!tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (StringUtil.in(name, Constants.Headings)) {
                        if (!tb.inScope(Constants.Headings)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(Constants.Headings);
                        }
                    } else if (name.equals(""sarcasm"")) {
                        // *sigh*
                        return anyOtherEndTag(t, tb);
                    } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {
                        // Adoption Agency Algorithm.
                        OUTER:
                        for (int i = 0; i < 8; i++) {
                            Element formatEl = tb.getActiveFormattingElement(name);
                            if (formatEl == null)
                                return anyOtherEndTag(t, tb);
                            else if (!tb.onStack(formatEl)) {
                                tb.error(this);
                                tb.removeFromActiveFormattingElements(formatEl);
                                return true;
                            } else if (!tb.inScope(formatEl.nodeName())) {
                                tb.error(this);
                                return false;
                            } else if (tb.currentElement() != formatEl)
                                tb.error(this);

                            Element furthestBlock = null;
                            Element commonAncestor = null;
                            boolean seenFormattingElement = false;
                            LinkedList<Element> stack = tb.getStack();
                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents
                            // run-aways
                            final int stackSize = stack.size();
                            for (int si = 0; si < stackSize && si < 64; si++) {
                                Element el = stack.get(si);
                                if (el == formatEl) {
                                    commonAncestor = stack.get(si - 1);
                                    seenFormattingElement = true;
                                } else if (seenFormattingElement && tb.isSpecial(el)) {
                                    furthestBlock = el;
                                    break;
                                }
                            }
                            if (furthestBlock == null) {
                                tb.popStackToClose(formatEl.nodeName());
                                tb.removeFromActiveFormattingElements(formatEl);
                                return true;
                            }

                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
                            // does that mean: int pos of format el in list?
                            Element node = furthestBlock;
                            Element lastNode = furthestBlock;
                            INNER:
                            for (int j = 0; j < 3; j++) {
                                if (tb.onStack(node))
                                    node = tb.aboveOnStack(node);
                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
                                    tb.removeFromStack(node);
                                    continue INNER;
                                } else if (node == formatEl)
                                    break INNER;

                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
                                tb.replaceActiveFormattingElement(node, replacement);
                                tb.replaceOnStack(node, replacement);
                                node = replacement;

                                if (lastNode == furthestBlock) {
                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
                                    // not getting how this bookmark both straddles the element above, but is inbetween here...
                                }
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                node.appendChild(lastNode);

                                lastNode = node;
                            }

                            if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                tb.insertInFosterParent(lastNode);
                            } else {
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                commonAncestor.appendChild(lastNode);
                            }

                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
                            adopter.attributes().addAll(formatEl.attributes());
                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
                            for (Node childNode : childNodes) {
                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.
                            }
                            furthestBlock.appendChild(adopter);
                            tb.removeFromActiveFormattingElements(formatEl);
                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
                            tb.removeFromStack(formatEl);
                            tb.insertOnStackAfter(furthestBlock, adopter);
                        }
                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {
                        if (!tb.inScope(""name"")) {
                            if (!tb.inScope(name)) {
                                tb.error(this);
                                return false;
                            }
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                            tb.clearFormattingElementsToLastMarker();
                        }
                    } else if (name.equals(""br"")) {
                        tb.error(this);
                        tb.process(new Token.StartTag(""br""));
                        return false;
                    } else {
                        return anyOtherEndTag(t, tb);
                    }

                    break;
                case EOF:
                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
                    // stop parsing
                    break;
            }
            return true;
        }","boolean process(Token t, HtmlTreeBuilder tb) {
    switch (t.type) {
        case Character: {
            Token.Character c = t.asCharacter();
            if (c.getData() == null || c.getData().isEmpty()) {
                tb.error(this);
                return false;
            } else if (isWhitespace(c)) {
                tb.reconstructFormattingElements();
                tb.insert(c);
            } else {
                tb.reconstructFormattingElements();
                tb.insert(c);
                tb.framesetOk(false);
            }
            break;
        }
        case Comment: {
            tb.insert(t.asComment());
            break;
        }
        case Doctype: {
            tb.error(this);
            return false;
        }
        case StartTag:
            Token.StartTag startTag = t.asStartTag();
            String name = startTag.name();
            if (name.equals(""html"")) {
                tb.error(this);
                Element html = tb.getStack().getFirst();
                for (Attribute attribute : startTag.getAttributes()) {
                    if (!html.hasAttr(attribute.getKey()))
                        html.attributes().put(attribute.getKey(), attribute.getValue());
                }
            } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {
                return tb.process(t, HtmlTreeBuilderState.InHead);
            } else if (name.equals(""body"")) {
                tb.error(this);
                LinkedList<Element> stack = tb.getStack();
                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                    return false;
                } else {
                    tb.framesetOk(false);
                    Element body = stack.get(1);
                    for (Attribute attribute : startTag.getAttributes()) {
                        if (!body.hasAttr(attribute.getKey()))
                            body.attributes().put(attribute.getKey(), attribute.getValue());
                    }
                }
            } else if (name.equals(""frameset"")) {
                tb.error(this);
                LinkedList<Element> stack = tb.getStack();
                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                    return false;
                } else if (!tb.framesetOk()) {
                    return false;
                } else {
                    Element second = stack.get(1);
                    if (second.parent() != null)
                        second.remove();
                    while (stack.size() > 1)
                        stack.removeLast();
                    tb.insert(startTag);
                    tb.transition(HtmlTreeBuilderState.InFrameset);
                }
            } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
            } else if (StringUtil.in(name, Constants.Headings)) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {
                    tb.error(this);
                    tb.pop();
                }
                tb.insert(startTag);
            } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
                tb.framesetOk(false);
            } else if (name.equals(""form"")) {
                if (tb.getFormElement() != null) {
                    tb.error(this);
                    return false;
                }
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insertForm(startTag, true);
            } else if (name.equals(""li"")) {
                tb.framesetOk(false);
                LinkedList<Element> stack = tb.getStack();
                for (int i = stack.size() - 1; i > 0; i--) {
                    Element el = stack.get(i);
                    if (el.nodeName().equals(""li"")) {
                        tb.process(new Token.EndTag(""li""));
                        break;
                    }
                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))
                        break;
                }
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
            } else if (StringUtil.in(name, Constants.DdDt)) {
                tb.framesetOk(false);
                LinkedList<Element> stack = tb.getStack();
                for (int i = stack.size() - 1; i > 0; i--) {
                    Element el = stack.get(i);
                    if (StringUtil.in(el.nodeName(), Constants.DdDt)) {
                        tb.process(new Token.EndTag(el.nodeName()));
                        break;
                    }
                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))
                        break;
                }
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
            } else if (name.equals(""plaintext"")) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
                tb.tokeniser.transition(TokeniserState.PLAINTEXT);
            } else if (name.equals(""button"")) {
                if (tb.inButtonScope(""button"")) {
                    tb.error(this);
                    tb.process(new Token.EndTag(""button""));
                    tb.process(startTag);
                } else {
                    tb.reconstructFormattingElements();
                    tb.insert(startTag);
                    tb.framesetOk(false);
                }
            } else if (name.equals(""a"")) {
                if (tb.getActiveFormattingElement(""a"") != null) {
                    tb.error(this);
                    tb.process(new Token.EndTag(""a""));

                    Element remainingA = tb.getFromStack(""a"");
                    if (remainingA != null) {
                        tb.removeFromActiveFormattingElements(remainingA);
                        tb.removeFromStack(remainingA);
                    }
                }
                tb.reconstructFormattingElements();
                Element a = tb.insert(startTag);
                tb.pushActiveFormattingElements(a);
            } else if (StringUtil.in(name, Constants.Formatters)) {
                tb.reconstructFormattingElements();
                Element el = tb.insert(startTag);
                tb.pushActiveFormattingElements(el);
            } else if (name.equals(""nobr"")) {
                tb.reconstructFormattingElements();
                if (tb.inScope(""nobr"")) {
                    tb.error(this);
                    tb.process(new Token.EndTag(""nobr""));
                    tb.reconstructFormattingElements();
                }
                Element el = tb.insert(startTag);
                tb.pushActiveFormattingElements(el);
            } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.insertMarkerToFormattingElements();
                tb.framesetOk(false);
            } else if (name.equals(""table"")) {
                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insert(startTag);
                tb.framesetOk(false);
                tb.transition(HtmlTreeBuilderState.InTable);
            } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {
                tb.reconstructFormattingElements();
                tb.insertEmpty(startTag);
                tb.framesetOk(false);
            } else if (name.equals(""input"")) {
                tb.reconstructFormattingElements();
                Element el = tb.insertEmpty(startTag);
                if (!el.attr(""type"").equalsIgnoreCase(""hidden""))
                    tb.framesetOk(false);
            } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {
                tb.insertEmpty(startTag);
            } else if (name.equals(""hr"")) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.insertEmpty(startTag);
                tb.framesetOk(false);
            } else if (name.equals(""image"")) {
                return tb.process(startTag.name(""img""));
            } else if (name.equals(""isindex"")) {
                tb.error(this);
                if (tb.getFormElement() != null)
                    return false;

                tb.tokeniser.acknowledgeSelfClosingFlag();
                tb.process(new Token.StartTag(""form""));
                if (startTag.attributes.hasKey(""action"")) {
                    Element form = tb.getFormElement();
                    form.attr(""action"", startTag.attributes.get(""action""));
                }
                tb.process(new Token.StartTag(""hr""));
                tb.process(new Token.StartTag(""label""));
                String prompt = startTag.attributes.hasKey(""prompt"") ?
                        startTag.attributes.get(""prompt"") :
                        ""This is a searchable index. Enter search keywords: "";

                tb.process(new Token.Character(prompt));

                Attributes inputAttribs = new Attributes();
                for (Attribute attr : startTag.attributes) {
                    if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))
                        inputAttribs.put(attr.getKey(), attr.getValue());
                }
                inputAttribs.put(""name"", ""isindex"");
                tb.process(new Token.StartTag(""input"", inputAttribs));
                tb.process(new Token.EndTag(""label""));
                tb.process(new Token.StartTag(""hr""));
                tb.process(new Token.EndTag(""form""));
            } else if (name.equals(""textarea"")) {
                tb.insert(startTag);
                tb.tokeniser.transition(TokeniserState.Rcdata);
                tb.markInsertionMode();
                tb.framesetOk(false);
                tb.transition(HtmlTreeBuilderState.Text);
            } else if (name.equals(""xmp"")) {
                if (tb.inButtonScope(""p"")) {
                    tb.process(new Token.EndTag(""p""));
                }
                tb.reconstructFormattingElements();
                tb.framesetOk(false);
                handleRawtext(startTag, tb);
            } else if (name.equals(""iframe"")) {
                tb.framesetOk(false);
                handleRawtext(startTag, tb);
            } else if (name.equals(""noembed"")) {
                handleRawtext(startTag, tb);
            } else if (name.equals(""select"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.framesetOk(false);

                HtmlTreeBuilderState state = tb.state();
                if (state.equals(HtmlTreeBuilderState.InTable) || state.equals(HtmlTreeBuilderState.InCaption) || state.equals(HtmlTreeBuilderState.InTableBody) || state.equals(HtmlTreeBuilderState.InRow) || state.equals(HtmlTreeBuilderState.InCell))
                    tb.transition(HtmlTreeBuilderState.InSelectInTable);
                else
                    tb.transition(HtmlTreeBuilderState.InSelect);
            } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {
                if (tb.currentElement().nodeName().equals(""option""))
                    tb.process(new Token.EndTag(""option""));
                tb.reconstructFormattingElements();
                tb.insert(startTag);
            } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {
                if (tb.inScope(""ruby"")) {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(""ruby"")) {
                        tb.error(this);
                        tb.popStackToBefore(""ruby"");
                    }
                    tb.insert(startTag);
                }
            } else if (name.equals(""math"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.tokeniser.acknowledgeSelfClosingFlag();
            } else if (name.equals(""svg"")) {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
                tb.tokeniser.acknowledgeSelfClosingFlag();
            } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {
                tb.error(this);
                return false;
            } else {
                tb.reconstructFormattingElements();
                tb.insert(startTag);
            }
            break;

        case EndTag:
            Token.EndTag endTag = t.asEndTag();
            name = endTag.name();
            if (name.equals(""body"")) {
                if (!tb.inScope(""body"")) {
                    tb.error(this);
                    return false;
                } else {
                    tb.transition(HtmlTreeBuilderState.AfterBody);
                }
            } else if (name.equals(""html"")) {
                boolean notIgnored = tb.process(new Token.EndTag(""body""));
                if (notIgnored)
                    return tb.process(endTag);
            } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {
                if (!tb.inScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (name.equals(""form"")) {
                Element currentForm = tb.getFormElement();
                tb.setFormElement(null);
                if (currentForm == null || !tb.inScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.removeFromStack(currentForm);
                }
            } else if (name.equals(""p"")) {
                if (!tb.inButtonScope(name)) {
                    tb.error(this);
                    tb.process(new Token.StartTag(name));
                    return tb.process(endTag);
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (name.equals(""li"")) {
                if (!tb.inListItemScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (StringUtil.in(name, Constants.DdDt)) {
                if (!tb.inScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                }
            } else if (StringUtil.in(name, Constants.Headings)) {
                if (!tb.inScope(Constants.Headings)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(Constants.Headings);
                }
            } else if (name.equals(""sarcasm"")) {
                return anyOtherEndTag(t, tb);
            } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {
                for (int i = 0; i < 8; i++) {
                    Element formatEl = tb.getActiveFormattingElement(name);
                    if (formatEl == null)
                        return anyOtherEndTag(t, tb);
                    else if (!tb.onStack(formatEl)) {
                        tb.error(this);
                        tb.removeFromActiveFormattingElements(formatEl);
                        return true;
                    } else if (!tb.inScope(formatEl.nodeName())) {
                        tb.error(this);
                        return false;
                    } else if (tb.currentElement() != formatEl)
                        tb.error(this);

                    Element furthestBlock = null;
                    Element commonAncestor = null;
                    boolean seenFormattingElement = false;
                    LinkedList<Element> stack = tb.getStack();
                    final int stackSize = stack.size();
                    for (int si = 0; si < stackSize && si < 64; si++) {
                        Element el = stack.get(si);
                        if (el == formatEl) {
                            commonAncestor = stack.get(si - 1);
                            seenFormattingElement = true;
                        } else if (seenFormattingElement && tb.isSpecial(el)) {
                            furthestBlock = el;
                            break;
                        }
                    }
                    if (furthestBlock == null) {
                        tb.popStackToClose(formatEl.nodeName());
                        tb.removeFromActiveFormattingElements(formatEl);
                        return true;
                    }

                    Element node = furthestBlock;
                    Element lastNode = furthestBlock;
                    for (int j = 0; j < 3; j++) {
                        if (tb.onStack(node))
                            node = tb.aboveOnStack(node);
                        if (!tb.isInActiveFormattingElements(node)) {
                            tb.removeFromStack(node);
                            continue;
                        } else if (node == formatEl)
                            break;

                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
                        tb.replaceActiveFormattingElement(node, replacement);
                        tb.replaceOnStack(node, replacement);
                        node = replacement;

                        if (lastNode == furthestBlock) {
                        }
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        node.appendChild(lastNode);

                        lastNode = node;
                    }

                    if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        tb.insertInFosterParent(lastNode);
                    } else {
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        commonAncestor.appendChild(lastNode);
                    }

                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
                    adopter.attributes().addAll(formatEl.attributes());
                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
                    for (Node childNode : childNodes) {
                        adopter.appendChild(childNode);
                    }
                    furthestBlock.appendChild(adopter);
                    tb.removeFromActiveFormattingElements(formatEl);
                    tb.removeFromStack(formatEl);
                    tb.insertOnStackAfter(furthestBlock, adopter);
                }
            } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {
                if (!tb.inScope(""name"")) {
                    if (!tb.inScope(name)) {
                        tb.error(this);
                        return false;
                    }
                    tb.generateImpliedEndTags();
                    if (!tb.currentElement().nodeName().equals(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                    tb.clearFormattingElementsToLastMarker();
                }
            } else if (name.equals(""br"")) {
                tb.error(this);
                tb.process(new Token.StartTag(""br""));
                return false;
            } else {
                return anyOtherEndTag(t, tb);
            }

            break;
        case EOF:
            // stop parsing
            break;
    }
    return true;
}",0,0
295,Jsoup_39,"static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
        String docData;
        Document doc = null;
        if (charsetName == null) { // determine from meta. safe parse as UTF-8
            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            doc = parser.parseInput(docData, baseUri);
            Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
            if (meta != null) { // if not found, will keep utf-8 as best attempt
                String foundCharset;
                if (meta.hasAttr(""http-equiv"")) {
                    foundCharset = getCharsetFromContentType(meta.attr(""content""));
                    if (foundCharset == null && meta.hasAttr(""charset"")) {
                        try {
                            if (Charset.isSupported(meta.attr(""charset""))) {
                                foundCharset = meta.attr(""charset"");
                            }
                        } catch (IllegalCharsetNameException e) {
                            foundCharset = null;
                        }
                    }
                } else {
                    foundCharset = meta.attr(""charset"");
                }

                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
                    foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                    charsetName = foundCharset;
                    byteData.rewind();
                    docData = Charset.forName(foundCharset).decode(byteData).toString();
                    doc = null;
                }
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
            docData = Charset.forName(charsetName).decode(byteData).toString();
        }
        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly
        if (docData.length() > 0 && docData.charAt(0) == 65279) {
            byteData.rewind();
             docData = Charset.forName(defaultCharset).decode(byteData).toString();
             docData = docData.substring(1);
             charsetName = defaultCharset;
         }
         if (doc == null) {
             doc = parser.parseInput(docData, baseUri);
            doc.outputSettings().charset(charsetName);
        }
        return doc;
    }","static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
    String docData;
    Document doc = null;

    try {
        if (charsetName == null) { // determine from meta. safe parse as UTF-8
            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            doc = parser.parseInput(docData, baseUri);
            Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
            if (meta != null) { // if not found, will keep utf-8 as best attempt
                String foundCharset = null;
                if (meta.hasAttr(""http-equiv"")) {
                    foundCharset = getCharsetFromContentType(meta.attr(""content""));
                }
                if (foundCharset == null && meta.hasAttr(""charset"")) {
                    try {
                        if (Charset.isSupported(meta.attr(""charset""))) {
                            foundCharset = meta.attr(""charset"");
                        }
                    } catch (IllegalCharsetNameException e) {
                        foundCharset = null;
                    }
                } else if (meta.hasAttr(""charset"")) {
                    foundCharset = meta.attr(""charset"");
                }

                if (foundCharset != null && !foundCharset.isEmpty() && !foundCharset.equals(defaultCharset)) { // need to re-decode
                    foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                    charsetName = foundCharset;
                    byteData.rewind();
                    docData = Charset.forName(foundCharset).decode(byteData).toString();
                    doc = null; // Need to re-parse with new charset
                }
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
            docData = Charset.forName(charsetName).decode(byteData).toString();
        }

        // UTF-8 BOM indicator. Takes precedence over everything else. Rarely used. Re-decodes in case the previous decode was wrong
        if (docData.length() > 0 && docData.charAt(0) == 65279) {
            byteData.rewind();
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            docData = docData.substring(1); // strip BOM
            charsetName = defaultCharset;
        }

        if (doc == null) {
            doc = parser.parseInput(docData, baseUri);
            doc.outputSettings().charset(charsetName); // Set charset for output settings
        }

        return doc;
    } catch (Exception e) {
        throw new IllegalStateException(""Failed to parse input due to encoding issues."", e);
    }
}",0,0
296,Jsoup_4,"static String unescape(String string) {
        if (!string.contains(""&""))
            return string;

        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?
        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs

        while (m.find()) {
            int charval = -1;
            String num = m.group(3);
            if (num != null) {
                try {
                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator
                    charval = Integer.valueOf(num, base);
                 } catch (NumberFormatException e) {
                 } // skip
             } else {
                 String name = m.group(1).toLowerCase();
                 if (full.containsKey(name))
                     charval = full.get(name);
             }

            if (charval != -1 || charval > 0xFFFF) { // out of range
                String c = Character.toString((char) charval);
                m.appendReplacement(accum, c);
            } else {
                m.appendReplacement(accum, m.group(0)); // replace with original string
            }
        }
        m.appendTail(accum);
        return accum.toString();
    }","static String unescape(String string) {
    if (!string.contains(""&"")) {
        return string;
    }

    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?
    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use StringBuilder, avoid syncs

    while (m.find()) {
        int charval = -1;
        String num = m.group(3);
        if (num != null) {
            try {
                int base = (m.group(2) != null) ? 16 : 10; // 2 is hex indicator
                charval = Integer.parseInt(num, base);
            } catch (NumberFormatException e) {
                // Ignore the error and skip replacement
            }
        } else {
            String name = m.group(1).toLowerCase();
            if (full.containsKey(name)) {
                charval = full.get(name);
            }
        }

        if (charval != -1 && charval <= 0xFFFF) { // Ensure the value is within valid range
            String c = Character.toString((char) charval);
            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // Ensure special characters are escaped
        } else {
            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // Replace with original string
        }
    }
    m.appendTail(accum);
    return accum.toString();
}",0,0
297,Jsoup_40,"    public DocumentType(String name, String publicId, String systemId, String baseUri) {
        super(baseUri);

        Validate.notEmpty(name);
        attr(""name"", name);
        attr(""publicId"", publicId);
        attr(""systemId"", systemId);
    }
","public DocumentType(String name, String publicId, String systemId, String baseUri) {
    super(baseUri);

    // Validate the 'name' parameter
    Validate.notEmpty(name, ""DocumentType name must not be empty"");

    // Ensure non-null attributes for 'publicId' and 'systemId'
    publicId = (publicId == null) ? """" : publicId;
    systemId = (systemId == null) ? """" : systemId;

    // Set attributes
    attr(""name"", name);
    attr(""publicId"", publicId);
    attr(""systemId"", systemId);
}",0,0
298,Jsoup_41,"@Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
 
         Element element = (Element) o;
 
         return this == o;
     }","@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    if (!super.equals(o)) return false;

    Element element = (Element) o;

    // Proper equality check for the Element's attributes can be added here if necessary
    // Replace `attributeComparison` with actual comparison logic for Element's attributes
    return Objects.equals(this.someAttribute, element.someAttribute); // Example of attribute comparison
}",0,0
299,Jsoup_42,"public List<Connection.KeyVal> formData() {
        ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();

         // iterate the form control elements and accumulate their values
         for (Element el: elements) {
             if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable
             String name = el.attr(""name"");
             if (name.length() == 0) continue;
             String type = el.attr(""type"");

            if (""select"".equals(el.tagName())) {
                Elements options = el.select(""option[selected]"");
                boolean set = false;
                for (Element option: options) {
                    data.add(HttpConnection.KeyVal.create(name, option.val()));
                    set = true;
                }
                if (!set) {
                    Element option = el.select(""option"").first();
                    if (option != null)
                        data.add(HttpConnection.KeyVal.create(name, option.val()));
                }
            } else if (""checkbox"".equalsIgnoreCase(type) || ""radio"".equalsIgnoreCase(type)) {
                // only add checkbox or radio if they have the checked attribute
                if (el.hasAttr(""checked"")) {
                    final String val = el.val();
                    data.add(HttpConnection.KeyVal.create(name, val));
                }
            } else {
                data.add(HttpConnection.KeyVal.create(name, el.val()));
            }
        }
        return data;
    }","public List<Connection.KeyVal> formData() {
    ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();

    // iterate the form control elements and accumulate their values
    for (Element el : elements) {
        if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submittable

        String name = el.attr(""name"");
        if (name.isEmpty()) continue;  // safer check for empty string

        String type = el.attr(""type"");

        if (""select"".equals(el.tagName())) {
            Elements options = el.select(""option[selected]"");
            boolean set = false;
            for (Element option : options) {
                data.add(HttpConnection.KeyVal.create(name, option.val()));
                set = true;
            }
            if (!set) {
                Element option = el.select(""option"").first();
                if (option != null) {
                    data.add(HttpConnection.KeyVal.create(name, option.val()));
                }
            }
        } else if (""checkbox"".equalsIgnoreCase(type) || ""radio"".equalsIgnoreCase(type)) {
            // only add checkbox or radio if they have the checked attribute
            if (el.hasAttr(""checked"")) {
                String val = el.val();
                data.add(HttpConnection.KeyVal.create(name, val.isEmpty() ? ""on"" : val)); // default to ""on"" if value is empty
            }
        } else if (!""submit"".equalsIgnoreCase(type) && !""button"".equalsIgnoreCase(type)) {
            // exclude unnecessary input types like submit and button
            data.add(HttpConnection.KeyVal.create(name, el.val()));
        }
    }
    return data;
}",0,0
300,Jsoup_43,"private static <E extends Element> Integer indexInList(Element search, List<E> elements) {
        Validate.notNull(search);
        Validate.notNull(elements);
 
         for (int i = 0; i < elements.size(); i++) {
             E element = elements.get(i);
             if (element.equals(search))
                 return i;
         }
         return null;
    }","private static <E extends Element> Integer indexInList(Element search, List<E> elements) {
    Validate.notNull(search, ""The search element must not be null"");
    Validate.notNull(elements, ""The elements list must not be null"");

    for (int i = 0; i < elements.size(); i++) {
        E element = elements.get(i);
        if (search.equals(element)) { // Ensure proper null-safe comparison
            return i;
        }
    }
    return -1; // Return -1 instead of null to represent ""not found""
}",0,0
301,Jsoup_45,"void resetInsertionMode() {
        boolean last = false;
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element node = stack.get(pos);
            if (pos == 0) {
                last = true;
                node = contextElement;
            }
            String name = node.nodeName();
             if (""select"".equals(name)) {
                 transition(HtmlTreeBuilderState.InSelect);
                 break; // frag
             } else if ((""td"".equals(name) || ""td"".equals(name) && !last)) {
                 transition(HtmlTreeBuilderState.InCell);
                 break;
             } else if (""tr"".equals(name)) {
                transition(HtmlTreeBuilderState.InRow);
                break;
            } else if (""tbody"".equals(name) || ""thead"".equals(name) || ""tfoot"".equals(name)) {
                transition(HtmlTreeBuilderState.InTableBody);
                break;
            } else if (""caption"".equals(name)) {
                transition(HtmlTreeBuilderState.InCaption);
                break;
            } else if (""colgroup"".equals(name)) {
                transition(HtmlTreeBuilderState.InColumnGroup);
                break; // frag
            } else if (""table"".equals(name)) {
                transition(HtmlTreeBuilderState.InTable);
                break;
            } else if (""head"".equals(name)) {
                transition(HtmlTreeBuilderState.InBody);
                break; // frag
            } else if (""body"".equals(name)) {
                transition(HtmlTreeBuilderState.InBody);
                break;
            } else if (""frameset"".equals(name)) {
                transition(HtmlTreeBuilderState.InFrameset);
                break; // frag
            } else if (""html"".equals(name)) {
                transition(HtmlTreeBuilderState.BeforeHead);
                break; // frag
            } else if (last) {
                transition(HtmlTreeBuilderState.InBody);
                break; // frag
            }
        }
    }","void resetInsertionMode() {
        boolean last = false;
        for (int pos = stack.size() - 1; pos >= 0; pos--) {
            Element node = stack.get(pos);
            if (pos == 0) {
                last = true;
                node = contextElement;
            }
            String name = node.nodeName();
            if (""select"".equals(name)) {
                transition(HtmlTreeBuilderState.InSelect);
                break;
            } else if (""td"".equals(name) && !last) { // Fixed condition here
                transition(HtmlTreeBuilderState.InCell);
                break;
            } else if (""tr"".equals(name)) {
                transition(HtmlTreeBuilderState.InRow);
                break;
            } else if (""tbody"".equals(name) || ""thead"".equals(name) || ""tfoot"".equals(name)) {
                transition(HtmlTreeBuilderState.InTableBody);
                break;
            } else if (""caption"".equals(name)) {
                transition(HtmlTreeBuilderState.InCaption);
                break;
            } else if (""colgroup"".equals(name)) {
                transition(HtmlTreeBuilderState.InColumnGroup);
                break;
            } else if (""table"".equals(name)) {
                transition(HtmlTreeBuilderState.InTable);
                break;
            } else if (""head"".equals(name)) {
                transition(HtmlTreeBuilderState.InHead); // Fixed transition state here
                break;
            } else if (""body"".equals(name)) {
                transition(HtmlTreeBuilderState.InBody);
                break;
            } else if (""frameset"".equals(name)) {
                transition(HtmlTreeBuilderState.InFrameset);
                break;
            } else if (""html"".equals(name)) {
                transition(HtmlTreeBuilderState.BeforeHead);
                break;
            } else if (last) {
                transition(HtmlTreeBuilderState.InBody);
                break;
            }
        }
    }",0,0
302,Jsoup_46,"static void escape(StringBuilder accum, String string, Document.OutputSettings out,
                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {

        boolean lastWasWhite = false;
        boolean reachedNonWhite = false;
        final EscapeMode escapeMode = out.escapeMode();
        final CharsetEncoder encoder = out.encoder();
        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());
        final Map<Character, String> map = escapeMode.getMap();
        final int length = string.length();

        int codePoint;
        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {
            codePoint = string.codePointAt(offset);

            if (normaliseWhite) {
                if (StringUtil.isWhitespace(codePoint)) {
                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)
                        continue;
                    accum.append(' ');
                    lastWasWhite = true;
                    continue;
                } else {
                    lastWasWhite = false;
                    reachedNonWhite = true;
                }
            }
            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):
            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
                final char c = (char) codePoint;
                // html specific and required escapes:
                switch (c) {
                    case '&':
                        accum.append(""&amp;"");
                        break;
                    case 0xA0:
                         if (escapeMode != EscapeMode.xhtml)
                             accum.append(""&nbsp;"");
                         else
                             accum.append(c);
                         break;
                     case '<':
                         if (!inAttribute)
                            accum.append(""&lt;"");
                        else
                            accum.append(c);
                        break;
                    case '>':
                        if (!inAttribute)
                            accum.append(""&gt;"");
                        else
                            accum.append(c);
                        break;
                    case '""':
                        if (inAttribute)
                            accum.append(""&quot;"");
                        else
                            accum.append(c);
                        break;
                    default:
                        if (canEncode(coreCharset, c, encoder))
                            accum.append(c);
                        else if (map.containsKey(c))
                            accum.append('&').append(map.get(c)).append(';');
                        else
                            accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
                }
            } else {
                final String c = new String(Character.toChars(codePoint));
                if (encoder.canEncode(c)) // uses fallback encoder for simplicity
                    accum.append(c);
                else
                    accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
            }
        }
    }","static void escape(StringBuilder accum, String string, Document.OutputSettings out,
                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {

    boolean lastWasWhite = false;
    boolean reachedNonWhite = false;
    final EscapeMode escapeMode = out.escapeMode();
    final CharsetEncoder encoder = out.encoder();
    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());
    final Map<Character, String> map = escapeMode.getMap();
    final int length = string.length();

    int codePoint;
    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {
        codePoint = string.codePointAt(offset);

        if (normaliseWhite) {
            if (StringUtil.isWhitespace(codePoint)) {
                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) {
                    continue;
                }
                accum.append(' ');
                lastWasWhite = true;
                continue;
            } else {
                lastWasWhite = false;
                reachedNonWhite = true;
            }
        }

        // Handle surrogate pairs and specific cases for efficiency
        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
            final char c = (char) codePoint;
            // HTML specific and required escapes:
            switch (c) {
                case '&':
                    accum.append(""&amp;"");
                    break;
                case 0xA0:
                    if (escapeMode != EscapeMode.xhtml)
                        accum.append(""&nbsp;"");
                    else
                        accum.append(c);
                    break;
                case '<':
                    if (!inAttribute)
                        accum.append(""&lt;"");
                    else
                        accum.append(c);
                    break;
                case '>':
                    if (!inAttribute)
                        accum.append(""&gt;"");
                    else
                        accum.append(c);
                    break;
                case '""':
                    if (inAttribute)
                        accum.append(""&quot;"");
                    else
                        accum.append(c);
                    break;
                default:
                    if (canEncode(coreCharset, c, encoder))
                        accum.append(c);
                    else if (map.containsKey(c))
                        accum.append('&').append(map.get(c)).append(';');
                    else
                        accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
                    break;
            }
        } else {
            // Handle supplementary characters
            final String c = new String(Character.toChars(codePoint));
            if (encoder.canEncode(c)) {
                accum.append(c);
            } else {
                accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
            }
        }
    }
}",0,0
303,Jsoup_47,"static void escape(StringBuilder accum, String string, Document.OutputSettings out,
                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {

        boolean lastWasWhite = false;
        boolean reachedNonWhite = false;
        final EscapeMode escapeMode = out.escapeMode();
        final CharsetEncoder encoder = out.encoder();
        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());
        final Map<Character, String> map = escapeMode.getMap();
        final int length = string.length();

        int codePoint;
        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {
            codePoint = string.codePointAt(offset);

            if (normaliseWhite) {
                if (StringUtil.isWhitespace(codePoint)) {
                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)
                        continue;
                    accum.append(' ');
                    lastWasWhite = true;
                    continue;
                } else {
                    lastWasWhite = false;
                    reachedNonWhite = true;
                }
            }
            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):
            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
                final char c = (char) codePoint;
                // html specific and required escapes:
                switch (c) {
                    case '&':
                        accum.append(""&amp;"");
                        break;
                    case 0xA0:
                        if (escapeMode != EscapeMode.xhtml)
                            accum.append(""&nbsp;"");
                        else
                            accum.append(""&#xa0;"");
                         break;
                     case '<':
                         // escape when in character data or when in a xml attribue val; not needed in html attr val
                         if (!inAttribute)
                             accum.append(""&lt;"");
                         else
                             accum.append(c);
                        break;
                    case '>':
                        if (!inAttribute)
                            accum.append(""&gt;"");
                        else
                            accum.append(c);
                        break;
                    case '""':
                        if (inAttribute)
                            accum.append(""&quot;"");
                        else
                            accum.append(c);
                        break;
                    default:
                        if (canEncode(coreCharset, c, encoder))
                            accum.append(c);
                        else if (map.containsKey(c))
                            accum.append('&').append(map.get(c)).append(';');
                        else
                            accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
                }
            } else {
                final String c = new String(Character.toChars(codePoint));
                if (encoder.canEncode(c)) // uses fallback encoder for simplicity
                    accum.append(c);
                else
                    accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
            }
        }
    }","static void escape(StringBuilder accum, String string, Document.OutputSettings out,
                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {

        if (string == null || accum == null || out == null) {
            throw new IllegalArgumentException(""Invalid input: accum, string, and out cannot be null."");
        }

        boolean lastWasWhite = false;
        boolean reachedNonWhite = false;
        final EscapeMode escapeMode = out.escapeMode();
        final CharsetEncoder encoder = out.encoder();
        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());
        final Map<Character, String> map = escapeMode.getMap();
        final int length = string.length();

        int codePoint;
        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {
            codePoint = string.codePointAt(offset);

            if (normaliseWhite) {
                if (StringUtil.isWhitespace(codePoint)) {
                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)
                        continue;
                    accum.append(' ');
                    lastWasWhite = true;
                    continue;
                } else {
                    lastWasWhite = false;
                    reachedNonWhite = true;
                }
            }
            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):
            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
                final char c = (char) codePoint;
                // html specific and required escapes:
                switch (c) {
                    case '&':
                        accum.append(""&amp;"");
                        break;
                    case 0xA0:
                        if (escapeMode != EscapeMode.xhtml)
                            accum.append(""&nbsp;"");
                        else
                            accum.append(""&#xa0;"");
                         break;
                     case '<':
                         // escape when in character data or when in a xml attribute value; not needed in html attribute value
                         if (!inAttribute)
                             accum.append(""&lt;"");
                         else
                             accum.append(c);
                        break;
                    case '>':
                        if (!inAttribute)
                            accum.append(""&gt;"");
                        else
                            accum.append(c);
                        break;
                    case '""':
                        if (inAttribute)
                            accum.append(""&quot;"");
                        else
                            accum.append(c);
                        break;
                    default:
                        if (canEncode(coreCharset, c, encoder))
                            accum.append(c);
                        else if (map.containsKey(c))
                            accum.append('&').append(map.get(c)).append(';');
                        else
                            accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
                }
            } else {
                final String c = new String(Character.toChars(codePoint));
                if (encoder.canEncode(c)) // uses fallback encoder for simplicity
                    accum.append(c);
                else
                    accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
            }
        }
    }",0,0
304,Jsoup_48,"void processResponseHeaders(Map<String, List<String>> resHeaders) {
            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {
                String name = entry.getKey();
                if (name == null)
                    continue; // http/1.1 line

                List<String> values = entry.getValue();
                if (name.equalsIgnoreCase(""Set-Cookie"")) {
                    for (String value : values) {
                        if (value == null)
                            continue;
                        TokenQueue cd = new TokenQueue(value);
                        String cookieName = cd.chompTo(""="").trim();
                        String cookieVal = cd.consumeTo("";"").trim();
                        // ignores path, date, domain, validateTLSCertificates et al. req'd?
                        // name not blank, value not null
                        if (cookieName.length() > 0)
                             cookie(cookieName, cookieVal);
                     }
                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
                     if (!values.isEmpty())
                         header(name, values.get(0));
                 }
             }
         }","void processResponseHeaders(Map<String, List<String>> resHeaders) {
    for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {
        String name = entry.getKey();
        if (name == null || entry.getValue() == null) {
            continue; // http/1.1 line, skip if name or value list is null
        }

        List<String> values = entry.getValue();
        if (name.equalsIgnoreCase(""Set-Cookie"")) {
            for (String value : values) {
                if (value == null || value.trim().isEmpty()) {
                    continue; // skip if value is null or empty
                }
                TokenQueue cd = new TokenQueue(value);
                String cookieName = cd.chompTo(""="").trim();
                String cookieVal = cd.consumeTo("";"").trim();

                // ensure name is not blank and value is not null
                if (!cookieName.isEmpty() && cookieVal != null) {
                    cookie(cookieName, cookieVal);
                }
            }
        } else { 
            // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
            if (!values.isEmpty()) {
                header(name, String.join("", "", values));
            }
        }
    }
}",0,0
305,Jsoup_49,"protected void addChildren(int index, Node... children) {
        Validate.noNullElements(children);
        ensureChildNodes();
        for (int i = children.length - 1; i >= 0; i--) {
             Node in = children[i];
             reparentChild(in);
             childNodes.add(index, in);
         }
         reindexChildren(index);
     }",Match failed,0,0
306,Jsoup_5,"private Attribute parseAttribute() {
        tq.consumeWhitespace();
        String key = tq.consumeAttributeKey();
        String value = """";
        tq.consumeWhitespace();
        if (tq.matchChomp(""="")) {
            tq.consumeWhitespace();

            if (tq.matchChomp(SQ)) {
                value = tq.chompTo(SQ);
            } else if (tq.matchChomp(DQ)) {
                value = tq.chompTo(DQ);
            } else {
                StringBuilder valueAccum = new StringBuilder();
                // no ' or "" to look for, so scan to end tag or space (or end of stream)
                while (!tq.matchesAny(""<"", ""/>"", "">"") && !tq.matchesWhitespace() && !tq.isEmpty()) {
                    valueAccum.append(tq.consume());
                }
                value = valueAccum.toString();
            }
            tq.consumeWhitespace();
        }
         if (key.length() != 0)
             return Attribute.createFromEncoded(key, value);
         else {
             tq.consume();
                 
             return null;
         }
    }","private Attribute parseAttribute() {

        tq.consumeWhitespace();
        String key = tq.consumeAttributeKey();
        String value = """";

        // Handling empty or invalid keys
        if (key == null || key.isEmpty()) {
            tq.consume();
            return null;
        }

        tq.consumeWhitespace();
        if (tq.matchChomp(""="")) {
            tq.consumeWhitespace();

            if (tq.matchChomp(SQ)) {
                value = tq.chompTo(SQ);
                tq.matchChomp(SQ); // Ensure to consume the closing quote
            } else if (tq.matchChomp(DQ)) {
                value = tq.chompTo(DQ);
                tq.matchChomp(DQ); // Ensure to consume the closing quote
            } else {
                StringBuilder valueAccum = new StringBuilder();
                // no ' or "" to look for, so scan to end tag or space (or end of stream)
                while (!tq.matchesAny(""<"", ""/>"", "">"") && !tq.matchesWhitespace() && !tq.isEmpty()) {
                    valueAccum.append(tq.consume());
                }
                value = valueAccum.toString();
            }
            tq.consumeWhitespace();
        }
        
        return Attribute.createFromEncoded(key, value);
    }",0,0
307,Jsoup_50,"static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
        String docData;
         Document doc = null;
 
         // look for BOM - overrides any other header or input
 
         if (charsetName == null) { // determine from meta. safe parse as UTF-8
             // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            doc = parser.parseInput(docData, baseUri);
            Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
            if (meta != null) { // if not found, will keep utf-8 as best attempt
                String foundCharset = null;
                if (meta.hasAttr(""http-equiv"")) {
                    foundCharset = getCharsetFromContentType(meta.attr(""content""));
                }
                if (foundCharset == null && meta.hasAttr(""charset"")) {
                    try {
                        if (Charset.isSupported(meta.attr(""charset""))) {
                            foundCharset = meta.attr(""charset"");
                        }
                    } catch (IllegalCharsetNameException e) {
                        foundCharset = null;
                    }
                }

                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
                    foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                    charsetName = foundCharset;
                    byteData.rewind();
                    docData = Charset.forName(foundCharset).decode(byteData).toString();
                    doc = null;
                }
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
            docData = Charset.forName(charsetName).decode(byteData).toString();
        }
        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {
            byteData.rewind();
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            docData = docData.substring(1);
            charsetName = defaultCharset;
            doc = null;
        }
        if (doc == null) {
            doc = parser.parseInput(docData, baseUri);
            doc.outputSettings().charset(charsetName);
        }
        return doc;
    }","static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
    String docData;
    Document doc = null;

    // look for BOM - overrides any other header or input
    if (charsetName == null) { // determine from meta. safe parse as UTF-8
        // use default charset (UTF-8)
        docData = Charset.forName(defaultCharset).decode(byteData).toString();
        doc = parser.parseInput(docData, baseUri);
        Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
        if (meta != null) { // if not found, will keep utf-8 as best attempt
            String foundCharset = null;
            if (meta.hasAttr(""http-equiv"")) {
                foundCharset = getCharsetFromContentType(meta.attr(""content""));
            }
            if (foundCharset == null && meta.hasAttr(""charset"")) {
                try {
                    if (Charset.isSupported(meta.attr(""charset""))) {
                        foundCharset = meta.attr(""charset"");
                    }
                } catch (IllegalCharsetNameException e) {
                    foundCharset = null;
                }
            }

            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
                foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                charsetName = foundCharset;
                byteData.rewind();
                docData = Charset.forName(foundCharset).decode(byteData).toString();
                doc = null;
            }
        }
    } else { // specified by content type header (or by user on file load)
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        docData = Charset.forName(charsetName).decode(byteData).toString();
    }
    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {
        docData = docData.substring(1); // Remove BOM from string
        charsetName = defaultCharset;
        doc = null;
    }
    if (doc == null) {
        // Reparse the document if necessary
        doc = parser.parseInput(docData, baseUri);
        doc.outputSettings().charset(Charset.forName(charsetName));
    }
    return doc;
}",0,0
308,Jsoup_51,"boolean matchesLetter() {
         if (isEmpty())
             return false;
         char c = input[pos];
         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
     }","boolean matchesLetter() {
    if (input == null || pos < 0 || pos >= input.length) {
        return false;
    }
    char c = input[pos];
    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}",0,0
309,Jsoup_53,"public String chompBalanced(char open, char close) {
        int start = -1;
         int end = -1;
         int depth = 0;
         char last = 0;
 
         do {
             if (isEmpty()) break;
             Character c = consume();
             if (last == 0 || last != ESC) {
                 if (c.equals(open)) {
                     depth++;
                     if (start == -1)
                        start = pos;
                }
                else if (c.equals(close))
                    depth--;
            }

            if (depth > 0 && last != 0)
                end = pos; // don't include the outer match pair in the return
            last = c;
        } while (depth > 0);
        return (end >= 0) ? queue.substring(start, end) : """";
    }","public String chompBalanced(char open, char close) {
        int start = -1;
        int end = -1;
        int depth = 0;
        char last = 0;

        do {
            if (isEmpty()) break;
            Character c = consume();
            if (last == 0 || last != ESC) {
                if (c.equals(open)) {
                    depth++;
                    if (start == -1)
                        start = pos - 1;
                } else if (c.equals(close)) {
                    depth--;
                    if (depth == 0)
                        end = pos - 1;
                }
            }
            last = c;
        } while (depth > 0);

        return (end >= 0) ? queue.substring(start, end + 1) : """";
    }",0,0
310,Jsoup_54,"private void copyAttributes(org.jsoup.nodes.Node source, Element el) {
             for (Attribute attribute : source.attributes()) {
                 // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]
                 String key = attribute.getKey().replaceAll(""[^-a-zA-Z0-9_:.]"", """");
                     el.setAttribute(key, attribute.getValue());
             }
         }","private void copyAttributes(org.jsoup.nodes.Node source, Element el) {
    for (Attribute attribute : source.attributes()) {
        // Valid XML attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]*
        String key = attribute.getKey().replaceAll(""[^-a-zA-Z0-9_:.]"", """");
        
        // Ensure the key starts with a valid character: [a-zA-Z_:]
        if (!key.isEmpty() && !key.matches(""^[a-zA-Z_:].*"")) {
            continue; // Skip invalid keys
        }
        
        el.setAttribute(key, attribute.getValue());
    }
}",0,0
311,Jsoup_55,"void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '>':
                    t.tagPending.selfClosing = true;
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                     break;
                 default:
                     t.error(this);
                     t.transition(BeforeAttributeName);
             }
         }","void read(Tokeniser t, CharacterReader r) {
    if (!r.isEmpty()) {
        char c = r.consume();
        switch (c) {
            case '>':
                t.tagPending.selfClosing = true;
                t.emitTagPending();
                t.transition(Data);
                break;
            case Tokeniser.eof:  // Ensure 'eof' is qualified by its class
                t.eofError(this);
                t.transition(Data);
                break;
            default:
                t.error(this);
                t.transition(BeforeAttributeName);
        }
    } else {
        t.eofError(this);
        t.transition(Data);
    }
}",0,0
312,Jsoup_57,"public void removeIgnoreCase(String key) {
        Validate.notEmpty(key);
        if (attributes == null)
            return;
         for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {
             String attrKey = it.next();
             if (attrKey.equalsIgnoreCase(key))
                 attributes.remove(attrKey);
         }
     }","public void removeIgnoreCase(String key) {
        Validate.notEmpty(key);
        if (attributes == null) {
            return;
        }
        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {
            String attrKey = it.next();
            if (attrKey.equalsIgnoreCase(key)) {
                it.remove();
            }
        }
    }",0,0
313,Jsoup_59,"final void newAttribute() {
            if (attributes == null)
                attributes = new Attributes();

             if (pendingAttributeName != null) {
                 // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here
                 pendingAttributeName = pendingAttributeName.trim();
                     Attribute attribute;
                     if (hasPendingAttributeValue)
                         attribute = new Attribute(pendingAttributeName,
                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);
                    else if (hasEmptyAttributeValue)
                        attribute = new Attribute(pendingAttributeName, """");
                    else
                        attribute = new BooleanAttribute(pendingAttributeName);
                    attributes.put(attribute);
            }
            pendingAttributeName = null;
            hasEmptyAttributeValue = false;
            hasPendingAttributeValue = false;
            reset(pendingAttributeValue);
            pendingAttributeValueS = null;
        }","final void newAttribute() {
    if (attributes == null)
        attributes = new Attributes();

    if (pendingAttributeName != null) {
        // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here
        pendingAttributeName = pendingAttributeName.trim();
        if (!pendingAttributeName.isEmpty()) { // Ensure the name is not empty
            Attribute attribute;
            if (hasPendingAttributeValue)
                attribute = new Attribute(pendingAttributeName,
                        pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);
            else if (hasEmptyAttributeValue)
                attribute = new Attribute(pendingAttributeName, """");
            else
                attribute = new BooleanAttribute(pendingAttributeName);
            attributes.put(attribute);
        }
    }
    pendingAttributeName = null;
    hasEmptyAttributeValue = false;
    hasPendingAttributeValue = false;
    reset(pendingAttributeValue);
    pendingAttributeValueS = null;
}",0,0
314,Jsoup_6,"static String unescape(String string) {
        if (!string.contains(""&""))
            return string;

        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?
        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs
        // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required

        while (m.find()) {
            int charval = -1;
            String num = m.group(3);
            if (num != null) {
                try {
                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator
                    charval = Integer.valueOf(num, base);
                } catch (NumberFormatException e) {
                } // skip
            } else {
                String name = m.group(1);
                if (full.containsKey(name))
                    charval = full.get(name);
            }
 
             if (charval != -1 || charval > 0xFFFF) { // out of range
                 String c = Character.toString((char) charval);
                 m.appendReplacement(accum, c);
             } else {
                 m.appendReplacement(accum, m.group(0));
             }
         }
         m.appendTail(accum);
        return accum.toString();
    }","static String unescape(String string) {
    if (!string.contains(""&"")) {
        return string;
    }

    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?
    StringBuffer accum = new StringBuffer(string.length());

    while (m.find()) {
        int charval = -1;
        String num = m.group(3);
        if (num != null) {
            try {
                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator
                charval = Integer.parseInt(num, base);
            } catch (NumberFormatException e) {
                // skip
            }
        } else {
            String name = m.group(1);
            if (full.containsKey(name)) {
                charval = full.get(name);
            }
        }
 
        if (charval != -1 && charval <= 0xFFFF) { // ensure within valid range
            String c = Character.toString((char) charval);
            m.appendReplacement(accum, Matcher.quoteReplacement(c));
        } else {
            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));
        }
    }
    m.appendTail(accum);
    return accum.toString();
}",0,0
315,Jsoup_61,"    public boolean hasClass(String className) {
        final String classAttr = attributes.get(""class"");
        final int len = classAttr.length();
        final int wantLen = className.length();

        if (len == 0 || len < wantLen) {
            return false;
        }

        // if both lengths are equal, only need compare the className with the attribute
        if (len == wantLen) {
            return className.equalsIgnoreCase(classAttr);
        }

        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)
        boolean inClass = false;
        int start = 0;
        for (int i = 0; i < len; i++) {
            if (Character.isWhitespace(classAttr.charAt(i))) {
                if (inClass) {
                    // white space ends a class name, compare it with the requested one, ignore case
                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {
                        return true;
                    }
                    inClass = false;
                }
            } else {
                if (!inClass) {
                    // we're in a class name : keep the start of the substring
                    inClass = true;
                    start = i;
                }
            }
        }

        // check the last entry
        if (inClass && len - start == wantLen) {
            return classAttr.regionMatches(true, start, className, 0, wantLen);
        }

        return false;
    }
","public boolean hasClass(String className) {
    final String classAttr = attributes.get(""class"");
    if (classAttr == null) {
        return false;
    }

    final int len = classAttr.length();
    final int wantLen = className.length();

    if (len == 0 || len < wantLen) {
        return false;
    }

    // if both lengths are equal, only need compare the className with the attribute
    if (len == wantLen) {
        return className.equalsIgnoreCase(classAttr);
    }

    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)
    boolean inClass = false;
    int start = 0;
    for (int i = 0; i < len; i++) {
        if (Character.isWhitespace(classAttr.charAt(i))) {
            if (inClass) {
                // white space ends a class name, compare it with the requested one, ignore case
                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {
                    return true;
                }
                inClass = false;
            }
        } else {
            if (!inClass) {
                // we're in a class name : keep the start of the substring
                inClass = true;
                start = i;
            }
        }
    }

    // check the last entry
    return inClass && len - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen);
}",0,0
316,Jsoup_62,"boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {
             String name = t.asEndTag().normalName();
             ArrayList<Element> stack = tb.getStack();
             for (int pos = stack.size() -1; pos >= 0; pos--) {
                 Element node = stack.get(pos);
                if (node.nodeName().equals(name)) {
                    tb.generateImpliedEndTags(name);
                    if (!name.equals(tb.currentElement().nodeName()))
                        tb.error(this);
                    tb.popStackToClose(name);
                    break;
                } else {
                    if (tb.isSpecial(node)) {
                        tb.error(this);
                        return false;
                    }
                }
            }
            return true;
        }","boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {
    String name = t.asEndTag().normalName();
    ArrayList<Element> stack = tb.getStack();
    for (int pos = stack.size() - 1; pos >= 0; pos--) {
        Element node = stack.get(pos);
        if (node.nodeName().equals(name)) {
            tb.generateImpliedEndTags(name);
            if (!name.equals(tb.currentElement().nodeName())) {
                tb.error(this);
            }
            tb.popStackToClose(name);
            return true; // Move return true here, indicates successful processing of the tag.
        } else if (tb.isSpecial(node)) {
            tb.error(this);
            return false;
        }
    }
    tb.error(this); // Address case where tag is not found.
    return false; // Return false if the tag was not found in the stack.
}",0,0
317,Jsoup_64,"    private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {
        tb.tokeniser.transition(TokeniserState.Rcdata);
        tb.markInsertionMode();
        tb.transition(Text);
        tb.insert(startTag);
    }
","private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {
        tb.tokeniser.transition(TokeniserState.Rcdata);
        tb.markInsertionMode();
        tb.transition(HtmlTreeBuilderState.Text);
        tb.insert(startTag);
    }",0,0
318,Jsoup_68,"    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {
        specificScopeTarget[0] = targetName;
        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);
    }
",Match failed,0,0
319,Jsoup_70,"static boolean preserveWhitespace(Node node) {
         // looks only at this element and five levels up, to prevent recursion & needless stack searches
         if (node != null && node instanceof Element) {
             Element el = (Element) node;
                 if (el.tag.preserveWhitespace())
                     return true;
                 else
                     return el.parent() != null && el.parent().tag.preserveWhitespace();
         }
         return false;
     }",Match failed,0,0
320,Jsoup_72,"private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {
         // limit (no cache):
         if (count > maxStringCacheLen)
             return new String(charBuf, start, count);
 
         // calculate hash:
         int hash = 0;
        int offset = start;
        for (int i = 0; i < count; i++) {
            hash = 31 * hash + charBuf[offset++];
        }

        // get from cache
        final int index = hash & stringCache.length - 1;
        String cached = stringCache[index];

        if (cached == null) { // miss, add
            cached = new String(charBuf, start, count);
            stringCache[index] = cached;
        } else { // hashcode hit, check equality
            if (rangeEquals(charBuf, start, count, cached)) { // hit
                return cached;
            } else { // hashcode conflict
                cached = new String(charBuf, start, count);
                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again
            }
        }
        return cached;
    }","private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {
        // limit (no cache):
        if (count > maxStringCacheLen)
            return new String(charBuf, start, count);

        // calculate hash:
        int hash = 0;
        int offset = start;
        for (int i = 0; i < count; i++) {
            hash = 31 * hash + charBuf[offset++];
        }

        // get from cache
        final int index = hash & (stringCache.length - 1); // Added parentheses for correct precedence
        String cached = stringCache[index];

        if (cached == null) { // miss, add
            cached = new String(charBuf, start, count);
            stringCache[index] = cached;
        } else { // hashcode hit, check equality
            if (rangeEquals(charBuf, start, count, cached)) { // hit
                return cached;
            } else { // hashcode conflict
                cached = new String(charBuf, start, count);
                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again
            }
        }
        return cached;
    }",0,0
321,Jsoup_75,"final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {
        final int sz = size;
        for (int i = 0; i < sz; i++) {
            // inlined from Attribute.html()
            final String key = keys[i];
            final String val = vals[i];
             accum.append(' ').append(key);
 
             // collapse checked=null, checked="""", checked=checked; write out others
             if (!(out.syntax() == Document.OutputSettings.Syntax.html
                 && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {
                 accum.append(""=\"""");
                 Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);
                 accum.append('""');
            }
        }
    }","final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {
        final int sz = size();
        for (int i = 0; i < sz; i++) {
            // inlined from Attribute.html()
            final String key = key(i);
            final String val = value(i);
             accum.append(' ').append(key);
 
             // collapse checked=null, checked="""", checked=checked; write out others
             if (!(out.syntax() == Document.OutputSettings.Syntax.html
                 && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {
                 accum.append(""=\"""");
                 Entities.escape(accum, val == null ? """" : val, out, true, false, false);
                 accum.append('""');
            }
        }
    }",0,0
322,Jsoup_76,"boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case Character: {
                    Token.Character c = t.asCharacter();
                    if (c.getData().equals(nullString)) {
                        // todo confirm that check
                        tb.error(this);
                        return false;
                    } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                        tb.framesetOk(false);
                    }
                    break;
                }
                case Comment: {
                    tb.insert(t.asComment());
                    break;
                }
                case Doctype: {
                    tb.error(this);
                    return false;
                }
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    // todo - refactor to a switch statement
                    String name = startTag.normalName();
                    if (name.equals(""a"")) {
                        if (tb.getActiveFormattingElement(""a"") != null) {
                            tb.error(this);
                            tb.processEndTag(""a"");

                            // still on stack?
                            Element remainingA = tb.getFromStack(""a"");
                            if (remainingA != null) {
                                tb.removeFromActiveFormattingElements(remainingA);
                                tb.removeFromStack(remainingA);
                            }
                        }
                        tb.reconstructFormattingElements();
                        Element a = tb.insert(startTag);
                        tb.pushActiveFormattingElements(a);
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {
                        tb.reconstructFormattingElements();
                        tb.insertEmpty(startTag);
                        tb.framesetOk(false);
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {
                        if (tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        tb.insert(startTag);
                    } else if (name.equals(""span"")) {
                        // same as final else, but short circuits lots of checks
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    } else if (name.equals(""li"")) {
                        tb.framesetOk(false);
                        ArrayList<Element> stack = tb.getStack();
                        for (int i = stack.size() - 1; i > 0; i--) {
                            Element el = stack.get(i);
                            if (el.nodeName().equals(""li"")) {
                                tb.processEndTag(""li"");
                                break;
                            }
                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))
                                break;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        tb.insert(startTag);
                    } else if (name.equals(""html"")) {
                        tb.error(this);
                        // merge attributes onto real html
                        Element html = tb.getStack().get(0);
                        for (Attribute attribute : startTag.getAttributes()) {
                            if (!html.hasAttr(attribute.getKey()))
                                html.attributes().put(attribute);
                        }
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {
                        return tb.process(t, InHead);
                    } else if (name.equals(""body"")) {
                        tb.error(this);
                        ArrayList<Element> stack = tb.getStack();
                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                            // only in fragment case
                            return false; // ignore
                        } else {
                            tb.framesetOk(false);
                            Element body = stack.get(1);
                            for (Attribute attribute : startTag.getAttributes()) {
                                if (!body.hasAttr(attribute.getKey()))
                                    body.attributes().put(attribute);
                            }
                        }
                    } else if (name.equals(""frameset"")) {
                        tb.error(this);
                        ArrayList<Element> stack = tb.getStack();
                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                            // only in fragment case
                            return false; // ignore
                        } else if (!tb.framesetOk()) {
                            return false; // ignore frameset
                        } else {
                            Element second = stack.get(1);
                            if (second.parent() != null)
                                second.remove();
                            // pop up to html element
                            while (stack.size() > 1)
                                stack.remove(stack.size()-1);
                            tb.insert(startTag);
                            tb.transition(InFrameset);
                        }
                    } else if (StringUtil.inSorted(name, Constants.Headings)) {
                        if (tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {
                            tb.error(this);
                            tb.pop();
                        }
                        tb.insert(startTag);
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {
                        if (tb.inButtonScope(""p"")) {
                             tb.processEndTag(""p"");
                         }
                         tb.insert(startTag);
                         tb.framesetOk(false);
                     } else if (name.equals(""form"")) {
                         if (tb.getFormElement() != null) {
                            tb.error(this);
                            return false;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        tb.insertForm(startTag, true);
                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {
                        tb.framesetOk(false);
                        ArrayList<Element> stack = tb.getStack();
                        for (int i = stack.size() - 1; i > 0; i--) {
                            Element el = stack.get(i);
                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {
                                tb.processEndTag(el.nodeName());
                                break;
                            }
                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))
                                break;
                        }
                        if (tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        tb.insert(startTag);
                    } else if (name.equals(""plaintext"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        tb.insert(startTag);
                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out
                    } else if (name.equals(""button"")) {
                        if (tb.inButtonScope(""button"")) {
                            // close and reprocess
                            tb.error(this);
                            tb.processEndTag(""button"");
                            tb.process(startTag);
                        } else {
                            tb.reconstructFormattingElements();
                            tb.insert(startTag);
                            tb.framesetOk(false);
                        }
                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {
                        tb.reconstructFormattingElements();
                        Element el = tb.insert(startTag);
                        tb.pushActiveFormattingElements(el);
                    } else if (name.equals(""nobr"")) {
                        tb.reconstructFormattingElements();
                        if (tb.inScope(""nobr"")) {
                            tb.error(this);
                            tb.processEndTag(""nobr"");
                            tb.reconstructFormattingElements();
                        }
                        Element el = tb.insert(startTag);
                        tb.pushActiveFormattingElements(el);
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.insertMarkerToFormattingElements();
                        tb.framesetOk(false);
                    } else if (name.equals(""table"")) {
                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        tb.insert(startTag);
                        tb.framesetOk(false);
                        tb.transition(InTable);
                    } else if (name.equals(""input"")) {
                        tb.reconstructFormattingElements();
                        Element el = tb.insertEmpty(startTag);
                        if (!el.attr(""type"").equalsIgnoreCase(""hidden""))
                            tb.framesetOk(false);
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {
                        tb.insertEmpty(startTag);
                    } else if (name.equals(""hr"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        tb.insertEmpty(startTag);
                        tb.framesetOk(false);
                    } else if (name.equals(""image"")) {
                        if (tb.getFromStack(""svg"") == null)
                            return tb.process(startTag.name(""img"")); // change <image> to <img>, unless in svg
                        else
                            tb.insert(startTag);
                    } else if (name.equals(""isindex"")) {
                        // how much do we care about the early 90s?
                        tb.error(this);
                        if (tb.getFormElement() != null)
                            return false;

                        tb.processStartTag(""form"");
                        if (startTag.attributes.hasKey(""action"")) {
                            Element form = tb.getFormElement();
                            form.attr(""action"", startTag.attributes.get(""action""));
                        }
                        tb.processStartTag(""hr"");
                        tb.processStartTag(""label"");
                        // hope you like english.
                        String prompt = startTag.attributes.hasKey(""prompt"") ?
                                startTag.attributes.get(""prompt"") :
                                ""This is a searchable index. Enter search keywords: "";

                        tb.process(new Token.Character().data(prompt));

                        // input
                        Attributes inputAttribs = new Attributes();
                        for (Attribute attr : startTag.attributes) {
                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))
                                inputAttribs.put(attr);
                        }
                        inputAttribs.put(""name"", ""isindex"");
                        tb.processStartTag(""input"", inputAttribs);
                        tb.processEndTag(""label"");
                        tb.processStartTag(""hr"");
                        tb.processEndTag(""form"");
                    } else if (name.equals(""textarea"")) {
                        tb.insert(startTag);
                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
                        tb.tokeniser.transition(TokeniserState.Rcdata);
                        tb.markInsertionMode();
                        tb.framesetOk(false);
                        tb.transition(Text);
                    } else if (name.equals(""xmp"")) {
                        if (tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        tb.reconstructFormattingElements();
                        tb.framesetOk(false);
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""iframe"")) {
                        tb.framesetOk(false);
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""noembed"")) {
                        // also handle noscript if script enabled
                        handleRawtext(startTag, tb);
                    } else if (name.equals(""select"")) {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.framesetOk(false);

                        HtmlTreeBuilderState state = tb.state();
                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                            tb.transition(InSelectInTable);
                        else
                            tb.transition(InSelect);
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {
                        if (tb.currentElement().nodeName().equals(""option""))
                            tb.processEndTag(""option"");
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {
                        if (tb.inScope(""ruby"")) {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(""ruby"")) {
                                tb.error(this);
                                tb.popStackToBefore(""ruby""); // i.e. close up to but not include name
                            }
                            tb.insert(startTag);
                        }
                    } else if (name.equals(""math"")) {
                        tb.reconstructFormattingElements();
                        // todo: handle A start tag whose tag name is ""math"" (i.e. foreign, mathml)
                        tb.insert(startTag);
                    } else if (name.equals(""svg"")) {
                        tb.reconstructFormattingElements();
                        // todo: handle A start tag whose tag name is ""svg"" (xlink, svg)
                        tb.insert(startTag);
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    }
                    break;

                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    name = endTag.normalName();
                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {
                        // Adoption Agency Algorithm.
                        for (int i = 0; i < 8; i++) {
                            Element formatEl = tb.getActiveFormattingElement(name);
                            if (formatEl == null)
                                return anyOtherEndTag(t, tb);
                            else if (!tb.onStack(formatEl)) {
                                tb.error(this);
                                tb.removeFromActiveFormattingElements(formatEl);
                                return true;
                            } else if (!tb.inScope(formatEl.nodeName())) {
                                tb.error(this);
                                return false;
                            } else if (tb.currentElement() != formatEl)
                                tb.error(this);

                            Element furthestBlock = null;
                            Element commonAncestor = null;
                            boolean seenFormattingElement = false;
                            ArrayList<Element> stack = tb.getStack();
                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents
                            // run-aways
                            final int stackSize = stack.size();
                            for (int si = 0; si < stackSize && si < 64; si++) {
                                Element el = stack.get(si);
                                if (el == formatEl) {
                                    commonAncestor = stack.get(si - 1);
                                    seenFormattingElement = true;
                                } else if (seenFormattingElement && tb.isSpecial(el)) {
                                    furthestBlock = el;
                                    break;
                                }
                            }
                            if (furthestBlock == null) {
                                tb.popStackToClose(formatEl.nodeName());
                                tb.removeFromActiveFormattingElements(formatEl);
                                return true;
                            }

                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
                            // does that mean: int pos of format el in list?
                            Element node = furthestBlock;
                            Element lastNode = furthestBlock;
                            for (int j = 0; j < 3; j++) {
                                if (tb.onStack(node))
                                    node = tb.aboveOnStack(node);
                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
                                    tb.removeFromStack(node);
                                    continue;
                                } else if (node == formatEl)
                                    break;

                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());
                                // case will follow the original node (so honours ParseSettings)
                                tb.replaceActiveFormattingElement(node, replacement);
                                tb.replaceOnStack(node, replacement);
                                node = replacement;

                                if (lastNode == furthestBlock) {
                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
                                    // not getting how this bookmark both straddles the element above, but is inbetween here...
                                }
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                node.appendChild(lastNode);

                                lastNode = node;
                            }

                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                tb.insertInFosterParent(lastNode);
                            } else {
                                if (lastNode.parent() != null)
                                    lastNode.remove();
                                commonAncestor.appendChild(lastNode);
                            }

                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
                            adopter.attributes().addAll(formatEl.attributes());
                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
                            for (Node childNode : childNodes) {
                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.
                            }
                            furthestBlock.appendChild(adopter);
                            tb.removeFromActiveFormattingElements(formatEl);
                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
                            tb.removeFromStack(formatEl);
                            tb.insertOnStackAfter(furthestBlock, adopter);
                        }
                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {
                        if (!tb.inScope(name)) {
                            // nothing to close
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (name.equals(""span"")) {
                        // same as final fall through, but saves short circuit
                        return anyOtherEndTag(t, tb);
                    } else if (name.equals(""li"")) {
                        if (!tb.inListItemScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (name.equals(""body"")) {
                        if (!tb.inScope(""body"")) {
                            tb.error(this);
                            return false;
                        } else {
                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
                            tb.transition(AfterBody);
                        }
                    } else if (name.equals(""html"")) {
                        boolean notIgnored = tb.processEndTag(""body"");
                        if (notIgnored)
                            return tb.process(endTag);
                    } else if (name.equals(""form"")) {
                        Element currentForm = tb.getFormElement();
                        tb.setFormElement(null);
                        if (currentForm == null || !tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            // remove currentForm from stack. will shift anything under up.
                            tb.removeFromStack(currentForm);
                        }
                    } else if (name.equals(""p"")) {
                        if (!tb.inButtonScope(name)) {
                            tb.error(this);
                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>
                            return tb.process(endTag);
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {
                        if (!tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (StringUtil.inSorted(name, Constants.Headings)) {
                        if (!tb.inScope(Constants.Headings)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags(name);
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(Constants.Headings);
                        }
                    } else if (name.equals(""sarcasm"")) {
                        // *sigh*
                        return anyOtherEndTag(t, tb);
                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {
                        if (!tb.inScope(""name"")) {
                            if (!tb.inScope(name)) {
                                tb.error(this);
                                return false;
                            }
                            tb.generateImpliedEndTags();
                            if (!tb.currentElement().nodeName().equals(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                            tb.clearFormattingElementsToLastMarker();
                        }
                    } else if (name.equals(""br"")) {
                        tb.error(this);
                        tb.processStartTag(""br"");
                        return false;
                    } else {
                        return anyOtherEndTag(t, tb);
                    }

                    break;
                case EOF:
                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
                    // stop parsing
                    break;
            }
            return true;
        }","boolean process(Token t, HtmlTreeBuilder tb) {
    switch (t.type) {
        case Character: {
            Token.Character c = t.asCharacter();
            if (c.getData() == null || c.getData().equals(nullString)) { 
                // Fix: check if data is null before comparison
                tb.error(this);
                return false;
            } else if (tb.framesetOk() && isWhitespace(c)) { 
                tb.reconstructFormattingElements();
                tb.insert(c);
            } else {
                tb.reconstructFormattingElements();
                tb.insert(c);
                tb.framesetOk(false);
            }
            break;
        }
        case Comment: {
            tb.insert(t.asComment());
            break;
        }
        case Doctype: {
            tb.error(this);
            return false;
        }
        case StartTag:
            Token.StartTag startTag = t.asStartTag();
            // refactor to a switch statement
            switch (startTag.normalName()) {
                case ""a"":
                    if (tb.getActiveFormattingElement(""a"") != null) {
                        tb.error(this);
                        tb.processEndTag(""a"");

                        Element remainingA = tb.getFromStack(""a"");
                        if (remainingA != null) {
                            tb.removeFromActiveFormattingElements(remainingA);
                            tb.removeFromStack(remainingA);
                        }
                    }
                    tb.reconstructFormattingElements();
                    Element a = tb.insert(startTag);
                    tb.pushActiveFormattingElements(a);
                    break;
                case ""span"":
                    tb.reconstructFormattingElements();
                    tb.insert(startTag);
                    break;
                case ""li"":
                    tb.framesetOk(false);
                    ArrayList<Element> stack = tb.getStack();
                    for (int i = stack.size() - 1; i > 0; i--) {
                        Element el = stack.get(i);
                        if (el.nodeName().equals(""li"")) {
                            tb.processEndTag(""li"");
                            break;
                        }
                        if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))
                            break;
                    }
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insert(startTag);
                    break;
                case ""html"":
                    tb.error(this);
                    Element html = tb.getStack().get(0);
                    for (Attribute attribute : startTag.getAttributes()) {
                        if (!html.hasAttr(attribute.getKey()))
                            html.attributes().put(attribute);
                    }
                    break;
                case ""body"":
                    tb.error(this);
                    stack = tb.getStack();
                    if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                        return false; // fragment case
                    } else {
                        tb.framesetOk(false);
                        Element body = stack.get(1);
                        for (Attribute attribute : startTag.getAttributes()) {
                            if (!body.hasAttr(attribute.getKey()))
                                body.attributes().put(attribute);
                        }
                    }
                    break;
                case ""frameset"":
                    tb.error(this);
                    stack = tb.getStack();
                    if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(""body""))) {
                        return false; // fragment case
                    } else if (!tb.framesetOk()) {
                        return false; // ignore frameset
                    } else {
                        Element second = stack.get(1);
                        if (second.parent() != null)
                            second.remove();
                        while (stack.size() > 1)
                            stack.remove(stack.size() - 1);
                        tb.insert(startTag);
                        tb.transition(InFrameset);
                    }
                    break;
                case ""plaintext"":
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insert(startTag);
                    tb.tokeniser.transition(TokeniserState.PLAINTEXT);
                    break;
                case ""button"":
                    if (tb.inButtonScope(""button"")) {
                        tb.error(this);
                        tb.processEndTag(""button"");
                        tb.process(startTag);
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.framesetOk(false);
                    }
                    break;
                case ""br"":
                    tb.error(this);
                    tb.processStartTag(""br"");
                    return false;
                case ""form"":
                    if (tb.getFormElement() != null) {
                        tb.error(this);
                        return false;
                    }
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insertForm(startTag, true);
                    break;
                case ""table"":
                    if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insert(startTag);
                    tb.framesetOk(false);
                    tb.transition(InTable);
                    break;
                default:
                    tb.reconstructFormattingElements();
                    tb.insert(startTag);
                    break;
            }
            break;

        case EndTag:
            Token.EndTag endTag = t.asEndTag();
            switch (endTag.normalName()) {
                case ""li"":
                    if (!tb.inListItemScope(""li"")) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.generateImpliedEndTags(""li"");
                        if (!tb.currentElement().nodeName().equals(""li""))
                            tb.error(this);
                        tb.popStackToClose(""li"");
                    }
                    break;
                case ""body"":
                    if (!tb.inScope(""body"")) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.transition(AfterBody);
                    }
                    break;
                case ""html"":
                    boolean notIgnored = tb.processEndTag(""body"");
                    if (notIgnored)
                        return tb.process(endTag);
                    break;
                case ""form"":
                    Element currentForm = tb.getFormElement();
                    tb.setFormElement(null);
                    if (currentForm == null || !tb.inScope(""form"")) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.generateImpliedEndTags();
                        if (!tb.currentElement().nodeName().equals(""form""))
                            tb.error(this);
                        tb.removeFromStack(currentForm);
                    }
                    break;
                case ""p"":
                    if (!tb.inButtonScope(""p"")) {
                        tb.error(this);
                        tb.processStartTag(""p"");
                        return tb.process(endTag);
                    } else {
                        tb.generateImpliedEndTags(""p"");
                        if (!tb.currentElement().nodeName().equals(""p""))
                            tb.error(this);
                        tb.popStackToClose(""p"");
                    }
                    break;
                default:
                    return anyOtherEndTag(t, tb);
            }
            break;
        case EOF:
            // stop parsing
            break;
    }
    return true;
}",0,0
323,Jsoup_77,"    private void popStackToClose(Token.EndTag endTag) {
        String elName = endTag.name();
        Element firstFound = null;

        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (next.nodeName().equals(elName)) {
                firstFound = next;
                break;
            }
        }
        if (firstFound == null)
            return; // not found, skip

        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            stack.remove(pos);
            if (next == firstFound)
                break;
        }
    }
","private void popStackToClose(Token.EndTag endTag) {
        String elName = endTag.name();
        Element firstFound = null;
        int positionToRemoveUntil = -1;

        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (next.nodeName().equals(elName)) {
                firstFound = next;
                positionToRemoveUntil = pos;
                break;
            }
        }
        if (firstFound == null)
            return; // not found, skip

        for (int pos = stack.size() -1; pos >= positionToRemoveUntil; pos--) {
            stack.remove(pos);
        }
    }",0,0
324,Jsoup_80,"void insert(Token.Comment commentToken) {
        Comment comment = new Comment(commentToken.getData());
        Node insert = comment;
        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)
            // so we do a bit of a hack and parse the data as an element to pull the attributes out
             String data = comment.getData();
             if (data.length() > 1 && (data.startsWith(""!"") || data.startsWith(""?""))) {
                 Document doc = Jsoup.parse(""<"" + data.substring(1, data.length() -1) + "">"", baseUri, Parser.xmlParser());
                     Element el = doc.child(0);
                     insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(""!""));
                     insert.attributes().addAll(el.attributes());
             }
         }
         insertNode(insert);
    }","void insert(Token.Comment commentToken) {
    Comment comment = new Comment(commentToken.getData());
    Node insert = comment;
    if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)
        // so we do a bit of a hack and parse the data as an element to pull the attributes out
        String data = comment.getData();
        if (data.length() > 1 && (data.startsWith(""!"") || data.startsWith(""?""))) {
            // Ensure data is wrapped correctly to form a valid tag
            Document doc;
            if (data.startsWith(""!"")) {
                doc = Jsoup.parse(""<"" + data.substring(1) + "">"", baseUri, Parser.xmlParser());
            } else {
                doc = Jsoup.parse(""<?"" + data.substring(1) + "">"", baseUri, Parser.xmlParser());
            }

            Element el = doc.child(0);
            insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(""!""));
            insert.attributes().addAll(el.attributes());
        }
    }
    insertNode(insert);
}",0,0
325,Jsoup_82,"static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {
        if (input == null) // empty body
            return new Document(baseUri);
        input = ConstrainableInputStream.wrap(input, bufferSize, 0);

        Document doc = null;
        boolean fullyRead = false;

        // read the start of the stream and look for a BOM or meta charset
        input.mark(bufferSize);
        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
        fullyRead = input.read() == -1;
        input.reset();

        // look for BOM - overrides any other header or input
        BomCharset bomCharset = detectCharsetFromBom(firstBytes);
        if (bomCharset != null)
            charsetName = bomCharset.charset;

        if (charsetName == null) { // determine from meta. safe first parse as UTF-8
            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
            doc = parser.parseInput(docData, baseUri);

            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
            String foundCharset = null; // if not found, will keep utf-8 as best attempt
            for (Element meta : metaElements) {
                if (meta.hasAttr(""http-equiv""))
                    foundCharset = getCharsetFromContentType(meta.attr(""content""));
                if (foundCharset == null && meta.hasAttr(""charset""))
                    foundCharset = meta.attr(""charset"");
                if (foundCharset != null)
                    break;
            }

            // look for <?xml encoding='ISO-8859-1'?>
            if (foundCharset == null && doc.childNodeSize() > 0) {
                Node first = doc.childNode(0);
                XmlDeclaration decl = null;
                if (first instanceof XmlDeclaration)
                    decl = (XmlDeclaration) first;
                else if (first instanceof Comment) {
                    Comment comment = (Comment) first;
                    if (comment.isXmlDeclaration())
                        decl = comment.asXmlDeclaration();
                }
                if (decl != null) {
                    if (decl.name().equalsIgnoreCase(""xml""))
                        foundCharset = decl.attr(""encoding"");
                }
            }
            foundCharset = validateCharset(foundCharset);
            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)
                foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                charsetName = foundCharset;
                doc = null;
            } else if (!fullyRead) {
                doc = null;
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        }
        if (doc == null) {
            if (charsetName == null)
                charsetName = defaultCharset;
            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here
                reader.skip(1);
            try {
                doc = parser.parseInput(reader, baseUri);
            } catch (UncheckedIOException e) {
                // io exception when parsing (not seen before because reading the stream as we go)
                throw e.ioException();
             }
             Charset charset = Charset.forName(charsetName);
             doc.outputSettings().charset(charset);
                 // some charsets can read but not encode; switch to an encodable charset and update the meta el
         }
         input.close();
         return doc;
    }","static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {
    if (input == null) {
        // Return a new Document with the baseUri if input is null
        return new Document(baseUri);
    }
    input = ConstrainableInputStream.wrap(input, bufferSize, 0);

    Document doc = null;
    boolean fullyRead = false;

    // Read the start of the stream and look for a BOM or meta charset
    input.mark(bufferSize);
    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed
    fullyRead = input.read() == -1;
    input.reset();

    // Look for BOM - overrides any other header or input
    BomCharset bomCharset = detectCharsetFromBom(firstBytes);
    if (bomCharset != null) {
        charsetName = bomCharset.charset;
    }

    if (charsetName == null) { // Determine from meta. Safe first parse as UTF-8
        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
        doc = parser.parseInput(docData, baseUri);

        // Look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
        Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
        String foundCharset = null; // If not found, will keep UTF-8 as best attempt
        for (Element meta : metaElements) {
            if (meta.hasAttr(""http-equiv"")) {
                foundCharset = getCharsetFromContentType(meta.attr(""content""));
            }
            if (foundCharset == null && meta.hasAttr(""charset"")) {
                foundCharset = meta.attr(""charset"");
            }
            if (foundCharset != null) {
                break;
            }
        }

        // Look for <?xml encoding='ISO-8859-1'?>
        if (foundCharset == null && doc.childNodeSize() > 0) {
            Node first = doc.childNode(0);
            XmlDeclaration decl = null;
            if (first instanceof XmlDeclaration) {
                decl = (XmlDeclaration) first;
            } else if (first instanceof Comment) {
                Comment comment = (Comment) first;
                if (comment.isXmlDeclaration()) {
                    decl = comment.asXmlDeclaration();
                }
            }
            if (decl != null) {
                if (decl.name().equalsIgnoreCase(""xml"")) {
                    foundCharset = decl.attr(""encoding"");
                }
            }
        }
        foundCharset = validateCharset(foundCharset);
        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { 
            // Need to re-decode if charset is different
            foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
            charsetName = foundCharset;
            doc = null;
        } else if (!fullyRead) {
            doc = null;
        }
    } else { 
        // Specified by content type header (or by user on file load)
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
    }
    if (doc == null) {
        if (charsetName == null) {
            charsetName = defaultCharset;
        }
        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
        if (bomCharset != null && bomCharset.offset) { 
            // Creating the buffered reader ignores the input position, so must skip here
            reader.skip(1);
        }
        try {
            doc = parser.parseInput(reader, baseUri);
        } catch (UncheckedIOException e) {
            // Handle IO exception when parsing
            throw e.ioException();
        }
        Charset charset = Charset.forName(charsetName);
        doc.outputSettings().charset(charset);

        // Some charsets can read but not encode; switch to an encodable charset and update the meta element
    }
    input.close();
    return doc;
}",0,0
326,Jsoup_84,"public void head(org.jsoup.nodes.Node source, int depth) {
            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack
            if (source instanceof org.jsoup.nodes.Element) {
                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;

                String prefix = updateNamespaces(sourceEl);
                 String namespace = namespacesStack.peek().get(prefix);
                 String tagName = sourceEl.tagName();
 
                 Element el = 
                     doc.createElementNS(namespace, tagName);
                 copyAttributes(sourceEl, el);
                 if (dest == null) { // sets up the root
                    doc.appendChild(el);
                } else {
                    dest.appendChild(el);
                }
                dest = el; // descend
            } else if (source instanceof org.jsoup.nodes.TextNode) {
                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;
                Text text = doc.createTextNode(sourceText.getWholeText());
                dest.appendChild(text);
            } else if (source instanceof org.jsoup.nodes.Comment) {
                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;
                Comment comment = doc.createComment(sourceComment.getData());
                dest.appendChild(comment);
            } else if (source instanceof org.jsoup.nodes.DataNode) {
                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;
                Text node = doc.createTextNode(sourceData.getWholeData());
                dest.appendChild(node);
            } else {
                // unhandled
            }
        }","public void head(org.jsoup.nodes.Node source, int depth) {
    namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack
    if (source instanceof org.jsoup.nodes.Element) {
        org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;

        String prefix = updateNamespaces(sourceEl);
        String namespace = namespacesStack.peek().get(prefix);
        String tagName = sourceEl.tagName();

        Element el = namespace != null
            ? doc.createElementNS(namespace, tagName)
            : doc.createElement(tagName); // fallback if namespace is null to prevent NPE

        copyAttributes(sourceEl, el);
        if (dest == null) { // sets up the root
            doc.appendChild(el);
        } else {
            dest.appendChild(el);
        }
        dest = el; // descend
    } else if (source instanceof org.jsoup.nodes.TextNode) {
        org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;
        Text text = doc.createTextNode(sourceText.getWholeText());
        dest.appendChild(text);
    } else if (source instanceof org.jsoup.nodes.Comment) {
        org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;
        Comment comment = doc.createComment(sourceComment.getData());
        dest.appendChild(comment);
    } else if (source instanceof org.jsoup.nodes.DataNode) {
        org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;
        Text node = doc.createTextNode(sourceData.getWholeData());
        dest.appendChild(node);
    } else {
        // unhandled node types
    }
}",0,0
327,Jsoup_85,"    public Attribute(String key, String val, Attributes parent) {
        Validate.notNull(key);
        this.key = key.trim();
        Validate.notEmpty(key); // trimming could potentially make empty, so validate here
        this.val = val;
        this.parent = parent;
    }
","public Attribute(String key, String val, Attributes parent) {
    Validate.notNull(key, ""Attribute key must not be null."");
    key = key.trim();
    Validate.notEmpty(key, ""Attribute key must not be empty after trimming.""); // Ensure trimmed key is not empty
    this.key = key;
    this.val = val != null ? val : """"; // Ensure `val` is not null, default to empty string if it is
    this.parent = parent;
}",0,0
328,Jsoup_86,"public XmlDeclaration asXmlDeclaration() {
         String data = getData();
         Document doc = Jsoup.parse(""<"" + data.substring(1, data.length() -1) + "">"", baseUri(), Parser.xmlParser());
         XmlDeclaration decl = null;
         if (doc.childNodeSize() > 0) {
             Element el = doc.child(0);
             decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(""!""));
             decl.attributes().addAll(el.attributes());
        }
        return decl;
    }","public XmlDeclaration asXmlDeclaration() {
    String data = getData();
    
    // Safeguard to ensure `data` has the expected format
    if (data == null || data.length() < 2 || !data.startsWith(""<"") || !data.endsWith("">"")) {
        return null; // Return null or throw an appropriate exception if format is invalid
    }
    
    Document doc = Jsoup.parse(""<"" + data.substring(1, data.length() - 1) + "">"", baseUri(), Parser.xmlParser());
    XmlDeclaration decl = null;
    
    if (doc != null && doc.childNodeSize() > 0) {
        Element el = doc.child(0);
        // Ensure el's tagName normalization does not throw errors
        String normalizedTagName = NodeUtils.parser(doc).settings().normalizeTag(el.tagName());
        decl = new XmlDeclaration(normalizedTagName, data.startsWith(""!""));
        
        if (el.hasAttributes()) { // Check if element has attributes before adding them
            decl.attributes().addAll(el.attributes());
        }
    }
    return decl;
}",0,0
329,Jsoup_88,"    public void setKey(String key) {
        Validate.notNull(key);
        key = key.trim();
        Validate.notEmpty(key); // trimming could potentially make empty, so validate here
        if (parent != null) {
            int i = parent.indexOfKey(this.key);
            if (i != Attributes.NotFound)
                parent.keys[i] = key;
        }
        this.key = key;
    }
","public void setKey(String key) {
    Validate.notNull(key, ""Key must not be null"");
    key = key.trim();
    Validate.notEmpty(key, ""Key must not be empty""); // Validate after trimming
    
    if (parent != null) {
        int i = parent.indexOfKey(this.key);
        if (i != Attributes.NotFound) {
            parent.keys[i] = key;
        }
    }
    
    this.key = key;
}",0,0
330,Jsoup_89,"    public String getValue() {
        return Attributes.checkNotNull(val);
    }
","public String getValue() {
    return val != null ? val : """";
}",0,0
331,Jsoup_90,"private static boolean looksLikeUtf8(byte[] input) {
            int i = 0;
            // BOM:
            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF
                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {
                i = 3;
            }

            int end;
            for (int j = input.length; i < j; ++i) {
                int o = input[i];
                if ((o & 0x80) == 0) {
                    continue; // ASCII
                }

                // UTF-8 leading:
                if ((o & 0xE0) == 0xC0) {
                    end = i + 1;
                } else if ((o & 0xF0) == 0xE0) {
                    end = i + 2;
                } else if ((o & 0xF8) == 0xF0) {
                    end = i + 3;
                } else {
                     return false;
                 }
 
 
                 while (i < end) {
                     i++;
                    o = input[i];
                    if ((o & 0xC0) != 0x80) {
                        return false;
                    }
                }
            }
            return true;
        }","private static boolean looksLikeUtf8(byte[] input) {
    int i = 0;
    // BOM:
    if (input.length >= 3 && (input[0] & 0xFF) == 0xEF
        && (input[1] & 0xFF) == 0xBB && (input[2] & 0xFF) == 0xBF) { // fixed logical AND
        i = 3;
    }

    int end;
    for (int j = input.length; i < j; ++i) {
        int o = input[i];
        if ((o & 0x80) == 0) {
            continue; // ASCII
        }

        // UTF-8 leading:
        if ((o & 0xE0) == 0xC0) {
            end = i + 1;
        } else if ((o & 0xF0) == 0xE0) {
            end = i + 2;
        } else if ((o & 0xF8) == 0xF0) {
            end = i + 3;
        } else {
            return false;
        }

        if (end >= input.length) { // ensure end does not exceed the input length
            return false;
        }

        while (i < end) {
            i++;
            o = input[i];
            if ((o & 0xC0) != 0x80) {
                return false;
            }
        }
    }
    return true;
}",0,0
332,Jsoup_93,"public List<Connection.KeyVal> formData() {
        ArrayList<Connection.KeyVal> data = new ArrayList<>();

        // iterate the form control elements and accumulate their values
        for (Element el: elements) {
            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable
            if (el.hasAttr(""disabled"")) continue; // skip disabled form inputs
            String name = el.attr(""name"");
             if (name.length() == 0) continue;
             String type = el.attr(""type"");
 
 
             if (""select"".equals(el.normalName())) {
                 Elements options = el.select(""option[selected]"");
                boolean set = false;
                for (Element option: options) {
                    data.add(HttpConnection.KeyVal.create(name, option.val()));
                    set = true;
                }
                if (!set) {
                    Element option = el.select(""option"").first();
                    if (option != null)
                        data.add(HttpConnection.KeyVal.create(name, option.val()));
                }
            } else if (""checkbox"".equalsIgnoreCase(type) || ""radio"".equalsIgnoreCase(type)) {
                // only add checkbox or radio if they have the checked attribute
                if (el.hasAttr(""checked"")) {
                    final String val = el.val().length() >  0 ? el.val() : ""on"";
                    data.add(HttpConnection.KeyVal.create(name, val));
                }
            } else {
                data.add(HttpConnection.KeyVal.create(name, el.val()));
            }
        }
        return data;
    }",Match failed,0,0
333,JxPath_10,"    protected CoreOperationRelationalExpression(Expression[] args) {
        super(args);
    }
","protected CoreOperationRelationalExpression(Expression[] args) {
    super(args);
    
    if (args == null || args.length < 2) {
        throw new IllegalArgumentException(""At least two arguments are required"");
    }
}",0,0
334,JxPath_12,"public static boolean testNode(Node node, NodeTest test) {
        if (test == null) {
            return true;
        }
        if (test instanceof NodeNameTest) {
            if (node.getNodeType() != Node.ELEMENT_NODE) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && testPrefix == null) {
                return true;
            }
            if (wildcard
                 || testName.getName()
                         .equals(DOMNodePointer.getLocalName(node))) {
                 String nodeNS = DOMNodePointer.getNamespaceURI(node);
                 return equalStrings(namespaceURI, nodeNS);
             }
             return false;
         }
        if (test instanceof NodeTypeTest) {
            int nodeType = node.getNodeType();
            switch (((NodeTypeTest) test).getNodeType()) {
                case Compiler.NODE_TYPE_NODE :
                    return nodeType == Node.ELEMENT_NODE
                            || nodeType == Node.DOCUMENT_NODE;
                case Compiler.NODE_TYPE_TEXT :
                    return nodeType == Node.CDATA_SECTION_NODE
                        || nodeType == Node.TEXT_NODE;
                case Compiler.NODE_TYPE_COMMENT :
                    return nodeType == Node.COMMENT_NODE;
                case Compiler.NODE_TYPE_PI :
                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
            }
            return false;
        }
        if (test instanceof ProcessingInstructionTest) {
            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
                String testPI = ((ProcessingInstructionTest) test).getTarget();
                String nodePI = ((ProcessingInstruction) node).getTarget();
                return testPI.equals(nodePI);
            }
        }
        return false;
    }","public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }

        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        if (wildcard) {
            // Check for wildcard matches
            if (namespaceURI == null || namespaceURI.equals(DOMNodePointer.getNamespaceURI(node))) {
                return true;
            }
            return false;
        }
        // Check for exact name matches
        if (testName.getName().equals(DOMNodePointer.getLocalName(node))) {
            return equalStrings(namespaceURI, DOMNodePointer.getNamespaceURI(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        int nodeType = node.getNodeType();
        switch (((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest) {
        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}",0,0
335,JxPath_21,"    public int getLength() {
        return ValueUtils.getLength(getBaseValue());
    }
","public int getLength() {
    Object baseValue = getBaseValue();
    if (baseValue == null) {
        return 0; // or throw an exception if null is not expected
    }
    return ValueUtils.getLength(baseValue);
}",0,0
336,JxPath_22,"public static String getNamespaceURI(Node node) {
        if (node instanceof Document) {
            node = ((Document) node).getDocumentElement();
        }

        Element element = (Element) node;

        String uri = element.getNamespaceURI();
        if (uri == null) {
            String prefix = getPrefix(node);
            String qname = prefix == null ? ""xmlns"" : ""xmlns:"" + prefix;
    
            Node aNode = node;
            while (aNode != null) {
                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {
                     Attr attr = ((Element) aNode).getAttributeNode(qname);
                     if (attr != null) {
                         return attr.getValue();
                     }
                 }
                 aNode = aNode.getParentNode();
             }
             return null;
         }
         return uri;
     }","public static String getNamespaceURI(Node node) {
    if (node instanceof Document) {
        node = ((Document) node).getDocumentElement();
    }

    if (node instanceof Element) {
        Element element = (Element) node;
        String uri = element.getNamespaceURI();
        if (uri == null) {
            String prefix = getPrefix(node);
            String qname = prefix == null ? ""xmlns"" : ""xmlns:"" + prefix;

            Node aNode = node;
            while (aNode != null) {
                if (aNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element currentElement = (Element) aNode;
                    Attr attr = currentElement.getAttributeNode(qname);
                    if (attr != null) {
                        return attr.getValue();
                    }
                }
                aNode = aNode.getParentNode();
            }
            return null;
        }
        return uri;
    }
    return null;
}",0,0
337,JxPath_5,"private int compareNodePointers(
        NodePointer p1,
        int depth1,
        NodePointer p2,
        int depth2) 
    {
        if (depth1 < depth2) {
            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);
            return r == 0 ? -1 : r;
        }
        if (depth1 > depth2) {
            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);
            return r == 0 ? 1 : r;
        }
        if (p1 == null && p2 == null) {
            return 0;
        }

        if (p1 != null && p1.equals(p2)) {
            return 0;
         }
 
         if (depth1 == 1) {
             throw new JXPathException(
                     ""Cannot compare pointers that do not belong to the same tree: '""
                             + p1 + ""' and '"" + p2 + ""'"");
         }
         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);
         if (r != 0) {
            return r;
        }

        return p1.parent.compareChildNodePointers(p1, p2);
    }","private int compareNodePointers(
        NodePointer p1,
        int depth1,
        NodePointer p2,
        int depth2) 
    {
        if (p1 == null && p2 == null) {
            return 0;
        }
        if (p1 == null) {
            return -1;
        }
        if (p2 == null) {
            return 1;
        }

        if (depth1 < depth2) {
            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);
            return r == 0 ? -1 : r;
        }
        if (depth1 > depth2) {
            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);
            return r == 0 ? 1 : r;
        }
        if (p1.equals(p2)) {
            return 0;
        }
        if (depth1 == 1) {
            throw new JXPathException(
                    ""Cannot compare pointers that do not belong to the same tree: '""
                            + p1 + ""' and '"" + p2 + ""'"");
        }
        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);
        if (r != 0) {
            return r;
        }

        return p1.parent.compareChildNodePointers(p1, p2);
    }",0,0
338,JxPath_6,"protected boolean equal(
        EvalContext context,
        Expression left,
        Expression right) 
    {
        Object l = left.compute(context);
        Object r = right.compute(context);

//        System.err.println(""COMPARING: "" +
//            (l == null ? ""null"" : l.getClass().getName()) + "" "" +
//            (r == null ? ""null"" : r.getClass().getName()));

        if (l instanceof InitialContext || l instanceof SelfContext) {
            l = ((EvalContext) l).getSingleNodePointer();
        }

        if (r instanceof InitialContext || r instanceof SelfContext) {
            r = ((EvalContext) r).getSingleNodePointer();
        }

        if (l instanceof Collection) {
            l = ((Collection) l).iterator();
        }

        if (r instanceof Collection) {
            r = ((Collection) r).iterator();
        }

        if ((l instanceof Iterator) && !(r instanceof Iterator)) {
            return contains((Iterator) l, r);
        }
        if (!(l instanceof Iterator) && (r instanceof Iterator)) {
            return contains((Iterator) r, l);
        }
        if (l instanceof Iterator && r instanceof Iterator) {
            return findMatch((Iterator) l, (Iterator) r);
        }
        return equal(l, r);
    }

    protected boolean contains(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (equal(element, value)) {
                return true;
            }
        }",Match failed,0,0
339,JxPath_8,"private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
             return containsMatch((Iterator) right, left);
         }
         double ld = InfoSetUtil.doubleValue(left);
         double rd = InfoSetUtil.doubleValue(right);
         return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);
     }","private boolean compute(Object left, Object right) {
    left = reduce(left);
    right = reduce(right);

    if (left instanceof InitialContext) {
        ((InitialContext) left).reset();
    }
    if (right instanceof InitialContext) {
        ((InitialContext) right).reset();
    }
    if (left instanceof Iterator && right instanceof Iterator) {
        return findMatch((Iterator<?>) left, (Iterator<?>) right);
    }
    if (left instanceof Iterator) {
        return containsMatch((Iterator<?>) left, right);
    }
    if (right instanceof Iterator) {
        return containsMatch((Iterator<?>) right, left);
    }
    double ld = InfoSetUtil.doubleValue(left);
    double rd = InfoSetUtil.doubleValue(right);
    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);
}",0,0
340,Lang_1,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
             if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
             if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

        //Must be a Float, Double, BigDecimal
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        try {
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    // Need to deal with all possible hex prefixes here
    final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int pfxLen = 0;
    for (final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen += pfx.length();
            break;
        }
    }
    if (pfxLen > 0) { // we have a hex number
        final String hexDigitsStr = str.substring(pfxLen);
        final int hexDigits = hexDigitsStr.length();
        if (hexDigits > 16) { // too many for Long
            return createBigInteger(str);
        }
        if (hexDigits > 8) { // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    final int expPos = Math.max(str.indexOf('e'), str.indexOf('E')); // consider only the first occurrence

    int numDecimals = 0; // Check required precision
    if (decPos > -1) { // there is a decimal point
        if (expPos > -1) { // there is an exponent
            if (expPos < decPos || expPos >= str.length()) { // fix bounds check
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        numDecimals = dec.length(); // count digits after decimal
    } else {
        if (expPos > -1 && expPos < str.length()) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && (exp == null || isAllZeros(exp));
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                        // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (expPos > -1 && expPos < str.length()) {
        exp = str.substring(expPos + 1);
    } else {
        exp = null;
    }
    if (dec == null && exp == null) { // no decimal point and no exponent
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
            // ignore the bad number
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
            // ignore the bad number
        }
        return createBigInteger(str);
    }

    try {
        if (numDecimals <= 7) { // make it a float
            final Float f = createFloat(str);
            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                return f;
            }
        }
    } catch (final NumberFormatException nfe) {
        // ignore the bad number
    }
    try {
        if (numDecimals <= 16) { // make it a double
            final Double d = createDouble(str);
            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                return d;
            }
        }
    } catch (final NumberFormatException nfe) {
        // ignore the bad number
    }

    return createBigDecimal(str);
}",0,0
341,Lang_10,"    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
        boolean wasWhite= false;
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
            regex.append(c);
        }
        return regex;
    }
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*+"");
            }
            continue;
        }
        wasWhite = false;
        switch (c) {
            case '\'':
                if (unquote) {
                    if (++i == value.length()) {
                        return regex;
                    }
                    c = value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
                break; // Add break to prevent falling through
        }
        regex.append(c);
    }
    return regex;
}",0,0
342,Lang_11,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers,
                            char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }

    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    }

    char[] buffer = new char[count];
    int gap = end - start;

    while (count != 0) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(chars.length)];
        }
        if (letters && Character.isLetter(ch)
                || numbers && Character.isDigit(ch)
                || !letters && !numbers) {
            if (ch >= 56320 && ch <= 57343) {
                if (count > 1) {
                    buffer[--count] = ch;
                    buffer[--count] = (char) (55296 + random.nextInt(128));
                }
            } else if (ch >= 55296 && ch <= 56191) {
                if (count > 1) {
                    buffer[--count] = (char) (56320 + random.nextInt(128));
                    buffer[--count] = ch;
                }
            } else if (ch >= 56192 && ch <= 56319) {
                // private high surrogate, no effing clue, so skip it
            } else {
                buffer[--count] = ch;
            }
        }
    }
    return new String(buffer);
}",0,0
343,Lang_12,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
 
         if (start == 0 && end == 0) {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }

        if (start == 0 && end == 0) {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }

        char[] buffer = new char[count];
        int gap = end - start;

        while (count > 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(chars.length)];
            }

            if ((letters && Character.isLetter(ch)) || 
                (numbers && Character.isDigit(ch)) || 
                (!letters && !numbers)) {

                if (ch >= 56320 && ch <= 57343) {
                    if (count == 1) {
                        continue; // skip, as no room for low surrogate pair
                    } else {
                        buffer[--count] = ch;
                        buffer[--count] = (char) (55296 + random.nextInt(128));
                    }
                } else if (ch >= 55296 && ch <= 56191) {
                    if (count == 1) {
                        continue; // skip, as no room for high surrogate pair
                    } else {
                        buffer[--count] = (char) (56320 + random.nextInt(128));
                        buffer[--count] = ch;
                    }
                } else if (ch >= 56192 && ch <= 56319) {
                    continue; // skip private high surrogate
                } else {
                    buffer[--count] = ch;
                }
            }
        }
        return new String(buffer);
    }",0,0
344,Lang_14,"public static boolean equals(CharSequence cs1, CharSequence cs2) {
        if (cs1 == cs2) {
            return true;
        }
         if (cs1 == null || cs2 == null) {
             return false;
         }
             return cs1.equals(cs2);
     }",Match failed,0,0
345,Lang_16,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
             // a wrong value.
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }

    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }

    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (Character.toLowerCase(lastChar)) {
            case 'l':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
                try {
                    Float f = createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore
                }
            case 'd':
                try {
                    Double d = createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe2) {
                    return createBigInteger(str);
                }
            }
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // ignore
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // ignore
            }
            return createBigDecimal(str);
        }
    }
}",0,0
346,Lang_17,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
             return;
         }
         int pos = 0;
         int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
             else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                     if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                     } else {
                         pos++;
                     }
                 }
                 pos--;
             }
             pos++;
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }

    int pos = 0;
    int len = input.length();

    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
        }
        
        // Adjust `pos` correctly after writing/translation
        if (consumed > 0) {
            pos += consumed - 1; // Adjust to account for consumption in previous translation step
        }
        
        pos++;
    }
}",0,0
347,Lang_19,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
             while(input.charAt(end) != ';') 
             {
                 end++;
             }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (index < seqEnd - 1 && input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;

        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;

            // Check there's more than just an x after the &#
            if (start >= seqEnd) {
                return 0; // invalid sequence
            }
        }

        int end = start;
        // Note that this supports character codes without a ; on the end
        while (end < seqEnd && input.charAt(end) != ';') {
            end++;
        }

        if (end >= seqEnd) {
            return 0; // no terminating ';' found
        }

        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }

        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }

        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}",0,0
348,Lang_21,"public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
        if (cal1 == null || cal2 == null) {
            throw new IllegalArgumentException(""The date must not be null"");
        }
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
                cal1.getClass() == cal2.getClass());
    }","public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&
            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
            cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
            cal1.getClass() == cal2.getClass());
}",0,0
349,Lang_22,"private static int greatestCommonDivisor(int u, int v) {
         // From Commons Math:
         //if either operand is abs 1, return 1:
         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
             return 1;
         }
         // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        if (u>0) { u=-u; } // make u negative
        if (v>0) { v=-v; } // make v negative
        // B1. [Find power of 2]
        int k=0;
        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...
            u/=2; v/=2; k++; // cast out twos.
        }
        if (k==31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        //     one is odd.
        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t&1)==0) { // while t is even..
                t/=2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t>0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u)/2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t!=0);
        return -u*(1<<k); // gcd is u*2^k
    }","private static int greatestCommonDivisor(int u, int v) {
        // If either operand is 0, return the other operand
        if (u == 0) {
            return Math.abs(v);
        } else if (v == 0) {
            return Math.abs(u);
        }

        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        if (u > 0) { u = -u; } // make u negative
        if (v > 0) { v = -v; } // make v negative

        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are both even...
            u /= 2; v /= 2; k++; // cast out twos.
        }
        // If both u and v have been divided completely down to zero
        if (u == 0 || v == 0) {
            return 1; // gcd is 1
        }

        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2); // Initialize t

        do {
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            t = (v - u) / 2; // Calculate next t
        } while (t != 0);

        return -u * (1 << k); // gcd is u * 2^k
    }",0,0
350,Lang_24,"public static boolean isNumber(String str) {
        if (StringUtils.isEmpty(str)) {
            return false;
        }
        char[] chars = str.toCharArray();
        int sz = chars.length;
        boolean hasExp = false;
        boolean hasDecPoint = false;
        boolean allowSigns = false;
        boolean foundDigit = false;
        // deal with any possible sign up front
        int start = (chars[0] == '-') ? 1 : 0;
        if (sz > start + 1) {
            if (chars[start] == '0' && chars[start + 1] == 'x') {
                int i = start + 2;
                if (i == sz) {
                    return false; // str == ""0x""
                }
                // checking hex (it can't be anything else)
                for (; i < chars.length; i++) {
                    if ((chars[i] < '0' || chars[i] > '9')
                        && (chars[i] < 'a' || chars[i] > 'f')
                        && (chars[i] < 'A' || chars[i] > 'F')) {
                        return false;
                    }
                }
                return true;
            }
        }
        sz--; // don't want to loop to the last char, check it afterwords
              // for type qualifiers
        int i = start;
        // loop to the next to last char or to the last char if we need another digit to
        // make a valid number (e.g. chars[0..5] = ""1234E"")
        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                foundDigit = true;
                allowSigns = false;

            } else if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent   
                    return false;
                }
                hasDecPoint = true;
            } else if (chars[i] == 'e' || chars[i] == 'E') {
                // we've already taken care of hex.
                if (hasExp) {
                    // two E's
                    return false;
                }
                if (!foundDigit) {
                    return false;
                }
                hasExp = true;
                allowSigns = true;
            } else if (chars[i] == '+' || chars[i] == '-') {
                if (!allowSigns) {
                    return false;
                }
                allowSigns = false;
                foundDigit = false; // we need a digit after the E
            } else {
                return false;
            }
            i++;
        }
        if (i < chars.length) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                // no type qualifier, OK
                return true;
            }
            if (chars[i] == 'e' || chars[i] == 'E') {
                // can't have an E at the last byte
                return false;
            }
            if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent
                    return false;
                }
                // single trailing decimal point after non-exponent is ok
                return foundDigit;
            }
            if (!allowSigns
                && (chars[i] == 'd'
                    || chars[i] == 'D'
                    || chars[i] == 'f'
                    || chars[i] == 'F')) {
                return foundDigit;
            }
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                 // not allowing L with an exponent or decimal point
                 return foundDigit && !hasExp;
             }
             // last character is illegal
             return false;
        }
        // allowSigns is true iff the val ends in 'E'
        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
        return !allowSigns && foundDigit;
    }","public static boolean isNumber(String str) {
    if (str == null || str.isEmpty()) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                return false; // str == ""0x""
            }
            for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9')
                    && (chars[i] < 'a' || chars[i] > 'f')
                    && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }
    sz--;
    int i = start;
    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            if (hasExp || !foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
            foundDigit = false;
        } else {
            return false;
        }
        i++;
    }
    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
            return false;
        }
        if (chars[i] == '.') {
            return !hasDecPoint && !hasExp && foundDigit;
        }
        if (!allowSigns
            && (chars[i] == 'd'
                || chars[i] == 'D'
                || chars[i] == 'f'
                || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
            return foundDigit && !hasExp && !hasDecPoint;
        }
        return false;
    }
    return !allowSigns && foundDigit;
}",0,0
351,Lang_26,"    public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        c.setTime(date);
        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
    }
","public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        if(date == null) {
            throw new IllegalArgumentException(""Date cannot be null"");
        }
        c.setTime(date);
        StringBuffer buffer = new StringBuffer(mMaxLengthEstimate);
        return applyRules(c, buffer).toString();
    }",0,0
352,Lang_27,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

         if (decPos > -1) {
 
             if (expPos > -1) {
                 if (expPos < decPos) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp = null;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
            exp = str.substring(expPos + 1);
        } else {
            mant = str;
            exp = null;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!f.isInfinite() && (f.floatValue() != 0.0F || isAllZeros(mant) && isAllZeros(exp))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                }
                // no break
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!d.isInfinite() && (d.doubleValue() != 0.0D || isAllZeros(mant) && isAllZeros(exp))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                }
                // no break
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            }
            return createBigInteger(str);
        } else {
            try {
                Float f = createFloat(str);
                if (!f.isInfinite() && (f.floatValue() != 0.0F || isAllZeros(mant) && isAllZeros(exp))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            }
            try {
                Double d = createDouble(str);
                if (!d.isInfinite() && (d.doubleValue() != 0.0D || isAllZeros(mant) && isAllZeros(exp))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            }
            return createBigDecimal(str);
        }
    }
}",0,0
353,Lang_28,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        // TODO: Protect from ArrayIndexOutOfBounds
        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;
            }

            int end = start;
            while(input.charAt(end) != ';') {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
                 return 0;
             }
 
                 out.write(entityValue);
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    if (input == null || index < 0 || index >= input.length() - 1) {
        return 0;
    }

    if (input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;

        if (start >= input.length()) {
            return 0;
        }

        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
        }

        int end = start;
        while (end < input.length() && input.charAt(end) != ';') {
            end++;
        }

        if (end >= input.length() || input.charAt(end) != ';') {
            return 0;
        }

        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            return 0;
        }

        out.write(entityValue);
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }

    return 0;
}",0,0
354,Lang_29,"    static float toJavaVersionInt(String version) {
        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
    }
","static float toJavaVersionInt(String version) {
    int[] versionArray = toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);
    if (versionArray == null || versionArray.length == 0) {
        throw new IllegalArgumentException(""Invalid version string: "" + version);
    }
    return toVersionInt(versionArray);
}",0,0
355,Lang_3,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
            }
        }
        if (pfxLen > 0) { // we have a hex number
            final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16) { // too many for Long
                return createBigInteger(str);
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    // Need to deal with all possible hex prefixes here
    final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int pfxLen = 0;
    for (final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen += pfx.length();
            break;
        }
    }
    if (pfxLen > 0) { // we have a hex number
        final String hexBody = str.substring(pfxLen);
        final int hexDigits = hexBody.length();
        if (hexDigits > 16) { // too many for Long
            return createBigInteger(str);
        }
        if (hexDigits > 8) { // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    final int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));
    
    int numDecimals = 0; // Check required precision (LANG-693)
    if (decPos > -1) { // there is a decimal point
        if (expPos > -1) { // there is an exponent
            if (expPos < decPos || expPos > str.length()) { 
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        numDecimals = dec.length(); 
    } else {
        if (expPos > -1 && expPos < str.length()) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) { 
                        // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) { 
                }
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1);
    } else {
        exp = null;
    }
    if (dec == null && exp == null) { 
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        }
        return createBigInteger(str);
    }

    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        final Float f = createFloat(str);
        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
            return f;
        }
    } catch (final NumberFormatException nfe) { 
    }
    try {
        final Double d = createDouble(str);
        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
            return d;
        }
    } catch (final NumberFormatException nfe) { 
    }

    return createBigDecimal(str);
}",0,0
356,Lang_31," public static boolean containsAny(CharSequence cs, char[] searchChars) {
  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
   return false;
  }
  int csLength = cs.length();
  int searchLength = searchChars.length;
  for (int i = 0; i < csLength; i++) {
   char ch = cs.charAt(i);
   for (int j = 0; j < searchLength; j++) {
    if (searchChars[j] == ch) {
      // ch is a supplementary character
      // ch is in the Basic Multilingual Plane
      return true;
    }
   }
  }
  return false;
 }","public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                return true;
            }
            // if ch is a high surrogate, check for supplementary character
            if (Character.isHighSurrogate(ch) && (i + 1 < csLength) && (j + 1 < searchLength)) {
                char nextCh = cs.charAt(i + 1);
                if (Character.isLowSurrogate(nextCh)) {
                    int supplementaryChar = Character.toCodePoint(ch, nextCh);
                    char nextSearchChar = searchChars[j + 1];
                    if (Character.isLowSurrogate(nextSearchChar)) {
                        int supplementarySearchChar = Character.toCodePoint(searchChars[j], nextSearchChar);
                        if (supplementaryChar == supplementarySearchChar) {
                            return true;
                        }
                    }
                }
            }
        }
    }
    return false;
}",0,0
357,Lang_33,"public static Class<?>[] toClass(Object[] array) {
        if (array == null) {
            return null;
        } else if (array.length == 0) {
            return ArrayUtils.EMPTY_CLASS_ARRAY;
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
             classes[i] = array[i].getClass();
         }
         return classes;
     }","public static Class<?>[] toClass(Object[] array) {
        if (array == null) {
            return null;
        } else if (array.length == 0) {
            return new Class<?>[0]; // To avoid dependency on ArrayUtils
        }
        Class<?>[] classes = new Class[array.length];
        for (int i = 0; i < array.length; i++) {
            classes[i] = (array[i] != null) ? array[i].getClass() : null;
        }
        return classes;
    }",0,0
358,Lang_37,"@SuppressWarnings(""unchecked"")
    public static <T> T[] addAll(T[] array1, T... array2) {
        if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
             // Check if problem is incompatible types
         return joinedArray;
     }","@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return array2.clone();
    } else if (array2 == null) {
        return array1.clone();
    }
    
    final Class<?> type1 = array1.getClass().getComponentType();
    final Class<?> type2 = array2.getClass().getComponentType();
    
    if (!type1.isAssignableFrom(type2)) {
        throw new ArrayStoreException(""Incompatible types"");
    }
    
    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}",0,0
359,Lang_38,"public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
        return applyRules(calendar, buf);
    }","public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    if (buf == null) {
        buf = new StringBuffer();
    }
    return applyRules(calendar, buf);
}",0,0
360,Lang_39,"private static String replaceEach(String text, String[] searchList, String[] replacementList, 
                                      boolean repeat, int timeToLive) 
    {

        // mchyzer Performance note: This creates very few new objects (one major goal)
        // let me know if there are performance requests, we can create a harness to measure

        if (text == null || text.length() == 0 || searchList == null || 
            searchList.length == 0 || replacementList == null || replacementList.length == 0) 
        {
            return text;
        }

        // if recursing, this shouldnt be less than 0
        if (timeToLive < 0) {
            throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
        }

        int searchLength = searchList.length;
        int replacementLength = replacementList.length;

        // make sure lengths are ok, these need to be equal
        if (searchLength != replacementLength) {
            throw new IllegalArgumentException(""Search and Replace array lengths don't match: ""
                + searchLength
                + "" vs ""
                + replacementLength);
        }

        // keep track of which still have matches
        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];

        // index on index that the match was found
        int textIndex = -1;
        int replaceIndex = -1;
        int tempIndex = -1;

        // index of replace array that will replace the search string found
        // NOTE: logic duplicated below START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
                searchList[i].length() == 0 || replacementList[i] == null) 
            {
                continue;
            }
            tempIndex = text.indexOf(searchList[i]);

            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
        // NOTE: logic mostly below END

        // no search strings found, we are done
        if (textIndex == -1) {
            return text;
        }

        int start = 0;

        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
        int increase = 0;
 
         // count the replacement text elements that are larger than their corresponding text being replaced
         for (int i = 0; i < searchList.length; i++) {
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; // assume 3 matches
            }
        }
        // have upper-bound at 20% increase, then let Java take over
        increase = Math.min(increase, text.length() / 5);

        StringBuilder buf = new StringBuilder(text.length() + increase);

        while (textIndex != -1) {

            for (int i = start; i < textIndex; i++) {
                buf.append(text.charAt(i));
            }
            buf.append(replacementList[replaceIndex]);

            start = textIndex + searchList[replaceIndex].length();

            textIndex = -1;
            replaceIndex = -1;
            tempIndex = -1;
            // find the next earliest match
            // NOTE: logic mostly duplicated above START
            for (int i = 0; i < searchLength; i++) {
                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
                    searchList[i].length() == 0 || replacementList[i] == null) 
                {
                    continue;
                }
                tempIndex = text.indexOf(searchList[i], start);

                // see if we need to keep searching for this
                if (tempIndex == -1) {
                    noMoreMatchesForReplIndex[i] = true;
                } else {
                    if (textIndex == -1 || tempIndex < textIndex) {
                        textIndex = tempIndex;
                        replaceIndex = i;
                    }
                }
            }
            // NOTE: logic duplicated above END

        }
        int textLength = text.length();
        for (int i = start; i < textLength; i++) {
            buf.append(text.charAt(i));
        }
        String result = buf.toString();
        if (!repeat) {
            return result;
        }

        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
    }","private static String replaceEach(String text, String[] searchList, String[] replacementList, 
                                      boolean repeat, int timeToLive) 
{

    if (text == null || text.isEmpty() || searchList == null || 
        searchList.length == 0 || replacementList == null || replacementList.length == 0) 
    {
        return text;
    }

    if (timeToLive < 0) {
        throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
    }

    int searchLength = searchList.length;
    int replacementLength = replacementList.length;

    if (searchLength != replacementLength) {
        throw new IllegalArgumentException(""Search and Replace array lengths don't match: ""
            + searchLength + "" vs "" + replacementLength);
    }

    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];

    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;

    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
            searchList[i].isEmpty() || replacementList[i] == null) 
        {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);

        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }

    if (textIndex == -1) {
        return text;
    }

    int start = 0;
    int increase = 0;

    for (int i = 0; i < searchList.length; i++) {
        int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            increase += 3 * greater;
        }
    }
    increase = Math.min(increase, text.length() / 5);

    StringBuilder buf = new StringBuilder(text.length() + increase);

    while (textIndex != -1) {

        buf.append(text, start, textIndex);
        buf.append(replacementList[replaceIndex]);

        start = textIndex + searchList[replaceIndex].length();

        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;

        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
                searchList[i].isEmpty() || replacementList[i] == null) 
            {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);

            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    }
    buf.append(text.substring(start));
    String result = buf.toString();
    if (!repeat) {
        return result;
    }

    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}",0,0
361,Lang_40,"public static boolean containsIgnoreCase(String str, String searchStr) {
         if (str == null || searchStr == null) {
             return false;
         }
         return contains(str.toUpperCase(), searchStr.toUpperCase());
     }","public static boolean containsIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    return str.toUpperCase().contains(searchStr.toUpperCase());
}",0,0
362,Lang_42,"public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
             char c = str.charAt(i);
             String entityName = this.entityName(c);
             if (entityName == null) {
                 if (c > 0x7F) {
                     writer.write(""&#"");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');
                } else {
                    writer.write(c);
                }
            } else {
                writer.write('&');
                writer.write(entityName);
                writer.write(';');
            }
        }
    }","public void escape(Writer writer, String str) throws IOException {
    if (str == null) {
        return;
    }
    int len = str.length();
    for (int i = 0; i < len; i++) {
        char c = str.charAt(i);
        String entityName = this.entityName(c);
        if (entityName == null) {
            if (c > 0x7F) {
                writer.write(""&#"");
                writer.write(Integer.toString(c, 10));
                writer.write(';');
            } else {
                writer.write(c);
            }
        } else {
            writer.write('&');
            writer.write(entityName);
            writer.write(';');
        }
    }
}",0,0
363,Lang_43,"    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
            StringBuffer appendTo, boolean escapingOn) {
        int start = pos.getIndex();
        char[] c = pattern.toCharArray();
        if (escapingOn && c[start] == QUOTE) {
            return appendTo == null ? null : appendTo.append(QUOTE);
        }
        int lastHold = start;
        for (int i = pos.getIndex(); i < pattern.length(); i++) {
            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(
                        QUOTE);
                pos.setIndex(i + ESCAPED_QUOTE.length());
                lastHold = pos.getIndex();
                continue;
            }
            switch (c[pos.getIndex()]) {
            case QUOTE:
                next(pos);
                return appendTo == null ? null : appendTo.append(c, lastHold,
                        pos.getIndex() - lastHold);
            default:
                next(pos);
            }
        }
        throw new IllegalArgumentException(
                ""Unterminated quoted string at position "" + start);
    }
","private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
            StringBuffer appendTo, boolean escapingOn) {
    int start = pos.getIndex();
    char[] c = pattern.toCharArray();

    if (escapingOn && c[start] == QUOTE) {
        pos.setIndex(start + 1);
        return appendTo == null ? null : appendTo.append(QUOTE);
    }

    int lastHold = start;
    for (int i = pos.getIndex(); i < pattern.length(); i++) {
        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
            appendTo.append(c, lastHold, i - lastHold).append(QUOTE);
            pos.setIndex(i + ESCAPED_QUOTE.length());
            lastHold = pos.getIndex();
            i = lastHold - 1;
            continue;
        }
        switch (c[i]) {
            case QUOTE:
                pos.setIndex(i + 1);
                return appendTo == null ? null : appendTo.append(c, lastHold, i - lastHold);
            default:
                pos.setIndex(i + 1);
        }
    }
    throw new IllegalArgumentException(
            ""Unterminated quoted string at position "" + start);
}",0,0
364,Lang_44,"    public static Number createNumber(String val) throws NumberFormatException {
        if (val == null) {
            return null;
        }
        if (val.length() == 0) {
            throw new NumberFormatException(""\""\"" is not a valid number."");
        }
        if (val.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
            return createInteger(val);
        }   
        char lastChar = val.charAt(val.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = val.indexOf('.');
        int expPos = val.indexOf('e') + val.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(val + "" is not a valid number."");
                }
                dec = val.substring(decPos + 1, expPos);
            } else {
                dec = val.substring(decPos + 1);
            }
            mant = val.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = val.substring(0, expPos);
            } else {
                mant = val;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = val.substring(0, val.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(val + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // empty catch
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // empty catch
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(val + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(val);
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createLong(val);
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                return createBigInteger(val);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(val);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    Double d = createDouble(val);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }

                return createBigDecimal(val);

            }

        }
    }
","public static Number createNumber(String val) throws NumberFormatException {
        if (val == null) {
            return null;
        }
        if (val.length() == 0) {
            throw new NumberFormatException(""\""\"" is not a valid number."");
        }
        if (val.startsWith(""--"")) {
            return null;
        }
        
        if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                return createBigInteger(val);
            }
        }
        
        char lastChar = val.charAt(val.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = val.indexOf('.');
        int expPos = Math.max(val.indexOf('e'), val.indexOf('E'));

        if (decPos > -1) {
            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(val + "" is not a valid number."");
                }
                dec = val.substring(decPos + 1, expPos);
            } else {
                dec = val.substring(decPos + 1);
            }
            mant = val.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = val.substring(0, expPos);
            } else {
                mant = val;
            }
            dec = null;
        }

        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length() - 1);
            } else {
                exp = null;
            }
            String numeric = val.substring(0, val.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            
            switch (lastChar) {
                case 'l':
                case 'L':
                    if (dec == null && exp == null &&
                        (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            return createBigInteger(numeric);
                        }
                    }
                    throw new NumberFormatException(val + "" is not a valid number."");
                case 'f':
                case 'F':
                    try {
                        Float f = createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            return f;
                        }
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    // Fall through
                case 'd':
                case 'D':
                    try {
                        Double d = createDouble(numeric);
                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    return createBigDecimal(numeric);
                default:
                    throw new NumberFormatException(val + "" is not a valid number."");
            }
        } else {
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length());
            } else {
                exp = null;
            }
            
            if (dec == null && exp == null) {
                try {
                    return createInteger(val);
                } catch (NumberFormatException nfe) {
                    try {
                        return createLong(val);
                    } catch (NumberFormatException nfe2) {
                        return createBigInteger(val);
                    }
                }
            } else {
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(val);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(val);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigDecimal(val);
            }
        }
    }",0,0
365,Lang_45,"public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
        // initial parameter checks
        if (str == null) {
            return null;
        }
        if (str.length() == 0) {
            return StringUtils.EMPTY;
        }
 
         // if the lower value is greater than the length of the string,
         // set to the length of the string
         // if the upper value is -1 (i.e. no limit) or is greater
         // than the length of the string, set to the length of the string
         if (upper == -1 || upper > str.length()) {
            upper = str.length();
        }
        // if upper is less than lower, raise it to lower
        if (upper < lower) {
            upper = lower;
        }

        StringBuffer result = new StringBuffer();
        int index = StringUtils.indexOf(str, "" "", lower);
        if (index == -1) {
            result.append(str.substring(0, upper));
            // only if abbreviation has occured do we append the appendToEnd value
            if (upper != str.length()) {
                result.append(StringUtils.defaultString(appendToEnd));
            }
        } else if (index > upper) {
            result.append(str.substring(0, upper));
            result.append(StringUtils.defaultString(appendToEnd));
        } else {
            result.append(str.substring(0, index));
            result.append(StringUtils.defaultString(appendToEnd));
        }
        return result.toString();
    }","public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
    // initial parameter checks
    if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return StringUtils.EMPTY;
    }

    // if the lower value is greater than the length of the string,
    // set to the length of the string
    // if the upper value is -1 (i.e. no limit) or is greater
    // than the length of the string, set to the length of the string
    if (lower > str.length()) {
        lower = str.length();
    }
    if (upper == -1 || upper > str.length()) {
        upper = str.length();
    }
    // if upper is less than lower, raise it to lower
    if (upper < lower) {
        upper = lower;
    }

    StringBuffer result = new StringBuffer();
    int index = StringUtils.indexOf(str, "" "", lower);
    if (index == -1 || index > upper) {
        result.append(str.substring(0, upper));
        // only if abbreviation has occurred do we append the appendToEnd value
        if (upper != str.length()) {
            result.append(StringUtils.defaultString(appendToEnd));
        }
    } else {
        result.append(str.substring(0, index));
        result.append(StringUtils.defaultString(appendToEnd));
    }
    return result.toString();
}",0,0
366,Lang_49,"    public Fraction reduce() {
        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
        if (gcd == 1) {
            return this;
        }
        return Fraction.getFraction(numerator / gcd, denominator / gcd);
    }
","public Fraction reduce() {
    if (denominator == 0) {
        throw new ArithmeticException(""Denominator cannot be zero"");
    }
    int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));
    int reducedNumerator = numerator / gcd;
    int reducedDenominator = denominator / gcd;
    
    // To ensure the denominator is always positive
    if (reducedDenominator < 0) {
        reducedNumerator = -reducedNumerator;
        reducedDenominator = -reducedDenominator;
    }
    
    return Fraction.getFraction(reducedNumerator, reducedDenominator);
}",0,0
367,Lang_5,"public static Locale toLocale(final String str) {
        if (str == null) {
            return null;
        }
        final int len = str.length();
        if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 2) {
                return new Locale(str);
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            }
            if (len < 7) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }","public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    
    // Check language part
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    
    if (len == 2) {
        return new Locale(str);
    }
    
    // Check separator presence after language
    if (len < 5 || str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    
    // Check whether country part is present and valid
    final char ch3 = str.charAt(3);
    if (ch3 == '_') {
        return new Locale(str.substring(0, 2), """", str.substring(4));
    }
    
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    
    // Check separator presence after country
    if (len < 7 || str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",0,0
368,Lang_51,"public static boolean toBoolean(String str) {
        // Previously used equalsIgnoreCase, which was fast for interned 'true'.
        // Non interned 'true' matched 15 times slower.
        // 
        // Optimisation provides same performance as before for interned 'true'.
        // Similar performance for null, 'false', and other strings not length 2/3/4.
        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
        if (str == ""true"") {
            return true;
        }
        if (str == null) {
            return false;
        }
        switch (str.length()) {
            case 2: {
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                return 
                    (ch0 == 'o' || ch0 == 'O') &&
                    (ch1 == 'n' || ch1 == 'N');
            }
            case 3: {
                char ch = str.charAt(0);
                if (ch == 'y') {
                    return 
                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
                        (str.charAt(2) == 's' || str.charAt(2) == 'S');
                }
                if (ch == 'Y') {
                    return 
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
             }
             case 4: {
                 char ch = str.charAt(0);
                if (ch == 't') {
                    return 
                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&
                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&
                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');
                }
                if (ch == 'T') {
                    return 
                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&
                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&
                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');
                }
            }
        }
        return false;
    }","public static boolean toBoolean(String str) {
    // Previously used equalsIgnoreCase, which was fast for interned 'true'.
    // Non interned 'true' matched 15 times slower.
    // 
    // Optimisation provides same performance as before for interned 'true'.
    // Similar performance for null, 'false', and other strings not length 2/3/4.
    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
    if (""true"".equals(str)) {
        return true;
    }
    if (str == null) {
        return false;
    }
    switch (str.length()) {
        case 2: {
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            return 
                (ch0 == 'o' || ch0 == 'O') &&
                (ch1 == 'n' || ch1 == 'N');
        }
        case 3: {
            char ch = str.charAt(0);
            if (ch == 'y' || ch == 'Y') {
                return 
                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
                    (str.charAt(2) == 's' || str.charAt(2) == 'S');
            }
            break;
        }
        case 4: {
            char ch = str.charAt(0);
            if (ch == 't' || ch == 'T') {
                return 
                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&
                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&
                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');
            }
            break;
        }
    }
    return false;
}",0,0
369,Lang_52,"private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (str == null) {
            return;
        }
        int sz;
        sz = str.length();
        for (int i = 0; i < sz; i++) {
            char ch = str.charAt(i);

            // handle unicode
            if (ch > 0xfff) {
                out.write(""\\u"" + hex(ch));
            } else if (ch > 0xff) {
                out.write(""\\u0"" + hex(ch));
            } else if (ch > 0x7f) {
                out.write(""\\u00"" + hex(ch));
            } else if (ch < 32) {
                switch (ch) {
                    case '\b':
                        out.write('\\');
                        out.write('b');
                        break;
                    case '\n':
                        out.write('\\');
                        out.write('n');
                        break;
                    case '\t':
                        out.write('\\');
                        out.write('t');
                        break;
                    case '\f':
                        out.write('\\');
                        out.write('f');
                        break;
                    case '\r':
                        out.write('\\');
                        out.write('r');
                        break;
                    default :
                        if (ch > 0xf) {
                            out.write(""\\u00"" + hex(ch));
                        } else {
                            out.write(""\\u000"" + hex(ch));
                        }
                        break;
                }
            } else {
                switch (ch) {
                    case '\'':
                        if (escapeSingleQuote) {
                          out.write('\\');
                        }
                        out.write('\'');
                        break;
                    case '""':
                        out.write('\\');
                        out.write('""');
                        break;
                    case '\\':
                         out.write('\\');
                         out.write('\\');
                         break;
                     default :
                         out.write(ch);
                         break;
                }
            }
        }
    }","private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (str == null) {
        return;
    }
    int sz = str.length();
    for (int i = 0; i < sz; i++) {
        char ch = str.charAt(i);

        // handle unicode
        if (ch > 0xfff) {
            out.write(""\\u"" + String.format(""%04X"", (int) ch));
        } else if (ch > 0xff) {
            out.write(""\\u0"" + String.format(""%03X"", (int) ch));
        } else if (ch > 0x7f) {
            out.write(""\\u00"" + String.format(""%02X"", (int) ch));
        } else if (ch < 32) {
            switch (ch) {
                case '\b':
                    out.write('\\');
                    out.write('b');
                    break;
                case '\n':
                    out.write('\\');
                    out.write('n');
                    break;
                case '\t':
                    out.write('\\');
                    out.write('t');
                    break;
                case '\f':
                    out.write('\\');
                    out.write('f');
                    break;
                case '\r':
                    out.write('\\');
                    out.write('r');
                    break;
                default:
                    out.write(""\\u00"" + String.format(""%02X"", (int) ch));
                    break;
            }
        } else {
            switch (ch) {
                case '\'':
                    if (escapeSingleQuote) {
                        out.write('\\');
                    }
                    out.write('\'');
                    break;
                case '""':
                    out.write('\\');
                    out.write('""');
                    break;
                case '\\':
                    out.write('\\');
                    out.write('\\');
                    break;
                default:
                    out.write(ch);
                    break;
            }
        }
    }
}",0,0
370,Lang_53,"private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        
        if (field == Calendar.MILLISECOND) {
            return;
        }

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.

        Date date = val.getTime();
        long time = date.getTime();
        boolean done = false;

        // truncate milliseconds
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
         if (field == Calendar.SECOND) {
             done = true;
             }
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
         if (field == Calendar.MINUTE) {
             done = true;
             }
         }
 
         // truncate minutes
        int minutes = val.get(Calendar.MINUTE);
        if (!done && (!round || minutes < 30)) {
            time = time - (minutes * 60000L);
        }

        // reset time
        if (date.getTime() != time) {
            date.setTime(time);
            val.setTime(date);
        }
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
            if (offset != 0) {
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
            }
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }

    if (field == Calendar.MILLISECOND) {
        return;
    }

    // ----------------- Fix for LANG-59 ---------------------- START ---------------
    // see http://issues.apache.org/jira/browse/LANG-59
    //
    // Manually truncate milliseconds, seconds and minutes, rather than using
    // Calendar methods.

    Date date = val.getTime();
    long time = date.getTime();
    boolean done = false;

    // truncate milliseconds
    int millisecs = val.get(Calendar.MILLISECOND);
    if (!round || millisecs < 500) {
        time = time - millisecs;
    }
    if (field == Calendar.SECOND) {
        done = true;
    }

    // truncate seconds
    int seconds = val.get(Calendar.SECOND);
    if (!done && (!round || seconds < 30)) {
        time = time - (seconds * 1000L);
    }
    if (field == Calendar.MINUTE) {
        done = true;
    }

    // truncate minutes
    int minutes = val.get(Calendar.MINUTE);
    if (!done && (!round || minutes < 30)) {
        time = time - (minutes * 60000L);
    }

    // reset time
    if (date.getTime() != time) {
        date.setTime(time);
        val.setTime(date);
    }
    // ----------------- Fix for LANG-59 ----------------------- END ----------------

    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                // This is our field... we stop looping
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        // This is a special case that's hard to generalize
                        // If the date is 1, we round up to 16, otherwise
                        // we subtract 15 days and add 1 month
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        // We need to add one to this field since the
                        // last number causes us to round up
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }
        // We have various fields that are not easy roundings
        int offset = 0;
        boolean offsetSet = false;
        // These are special types of fields that require different rounding rules
        switch (field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    // If we're going to drop the DATE field's value,
                    // we want to do this our own way.
                    // We need to subtract 1 since the date has a minimum of 1
                    offset = val.get(Calendar.DATE) - 1;
                    // If we're above 15 days adjustment, that means we're in the
                    // bottom half of the month and should stay accordingly.
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    // Record whether we're in the top or bottom half of that range
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    // If we're going to drop the HOUR field's value,
                    // we want to do this our own way.
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            // Calculate the offset from the minimum allowed value
            offset = val.get(fields[i][0]) - min;
            // Set roundUp if this is more than halfway between the minimum and maximum
            roundUp = offset > ((max - min) / 2);
        }
        // We need to remove this field
        if (offset != 0) {
            val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}",0,0
371,Lang_54,"public static Locale toLocale(String str) {
        if (str == null) {
            return null;
        }
        int len = str.length();
        if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch0 = str.charAt(0);
        char ch1 = str.charAt(1);
        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 2) {
            return new Locale(str, """");
        } else {
            if (str.charAt(2) != '_') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException(""Invalid locale format: "" + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }
    }","public static Locale toLocale(String str) {
        if (str == null) {
            return null;
        }
        int len = str.length();
        if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch0 = str.charAt(0);
        char ch1 = str.charAt(1);
        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 2) {
            return new Locale(str);
        } else {
            if (str.charAt(2) != '_') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             if (len == 5) {
                 return new Locale(str.substring(0, 2), str.substring(3, 5));
             } else {
                 if (str.charAt(5) != '_') {
                     throw new IllegalArgumentException(""Invalid locale format: "" + str);
                 }
                 return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
             }
        }
    }",0,0
372,Lang_55,"public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
             stopTime = System.currentTimeMillis();
         this.runningState = STATE_STOPPED;
     }","public void stop() {
    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch is not running."");
    }
    stopTime = System.currentTimeMillis();
    this.runningState = STATE_STOPPED;
}",0,0
373,Lang_57,"    public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
    }
","public static boolean isAvailableLocale(Locale locale) {
        if (locale == null) {
            return false;
        }
        return cAvailableLocaleSet.contains(locale);
    }",0,0
374,Lang_58,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                 case 'L' :
                     if (dec == null
                         && exp == null
                         && isDigits(numeric.substring(1))
                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

        if (decPos > -1) {
            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l':
                case 'L':
                    if (dec == null && exp == null && isDigits(numeric.substring(1))
                            && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            // Too big for a long
                        }
                        return createBigInteger(numeric);
                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f':
                case 'F':
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            return f;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    // Fall through
                case 'd':
                case 'D':
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    // Fall through
                default:
                    throw new NumberFormatException(str + "" is not a valid number."");
            }
        } else {
            // Simple numeric type without suffix specification
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                // Must be an int, long, bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);
            } else {
                // Must be a float, double, BigDecimal
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigDecimal(str);
            }
        }
    }",0,0
375,Lang_59,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
        if (width > 0) {
            ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, strLen, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
                for (int i = 0; i < padLen; i++) {
                    buffer[size + strLen + i] = padChar;
                }
            }
            size += width;
        }
        return this;
    }","public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = str.length();
        if (strLen >= width) {
            str.getChars(0, width, buffer, size); // Ensure only width characters are copied
        } else {
            str.getChars(0, strLen, buffer, size);
             for (int i = 0; i < width - strLen; i++) {
                buffer[size + strLen + i] = padChar;
            }
        }
        size += width;
    }
    return this;
}",0,0
376,Lang_6,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
            return;
        }
        int pos = 0;
        int len = input.length();
        while (pos < len) {
            int consumed = translate(input, pos, out);
            if (consumed == 0) {
                char[] c = Character.toChars(Character.codePointAt(input, pos));
                out.write(c);
                pos+= c.length;
                continue;
            }
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            pos += c.length;
            continue;
        }
        // correctly handle the number of code points consumed
        for (int pt = 0; pt < consumed; pt++) {
            int codePoint = Character.codePointAt(input, pos);
            pos += Character.charCount(codePoint);
        }
    }
}",0,0
377,Lang_61,"public int indexOf(String str, int startIndex) {
        startIndex = (startIndex < 0 ? 0 : startIndex);
        if (str == null || startIndex >= size) {
            return -1;
        }
        int strLen = str.length();
        if (strLen == 1) {
            return indexOf(str.charAt(0), startIndex);
        }
        if (strLen == 0) {
            return startIndex;
        }
        if (strLen > size) {
             return -1;
         }
         char[] thisBuf = buffer;
         int len = thisBuf.length - strLen;
         outer:
         for (int i = startIndex; i < len; i++) {
             for (int j = 0; j < strLen; j++) {
                if (str.charAt(j) != thisBuf[i + j]) {
                    continue outer;
                }
            }
            return i;
        }
        return -1;
    }","public int indexOf(String str, int startIndex) {
        startIndex = (startIndex < 0 ? 0 : startIndex);
        if (str == null || startIndex >= size) {
            return -1;
        }

        int strLen = str.length();
        if (strLen == 1) {
            return indexOf(str.charAt(0), startIndex);
        }
        if (strLen == 0) {
            return startIndex < size ? startIndex : -1;
        }

        if (strLen > size) {
            return -1;
        }

        char[] thisBuf = buffer;
        int len = size - strLen + 1;  // Ensure we don't overshoot the buffer size

        outer:
        for (int i = startIndex; i < len; i++) {
            for (int j = 0; j < strLen; j++) {
                if (str.charAt(j) != thisBuf[i + j]) {
                    continue outer;
                }
            }
            return i;
        }
        return -1;
    }",0,0
378,Lang_65,"    private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.


        // truncate milliseconds

        // truncate seconds

        // truncate minutes

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }
","private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.

        // truncate milliseconds
        val.set(Calendar.MILLISECOND, 0);

        // truncate seconds
        val.set(Calendar.SECOND, 0);

        // truncate minutes
        val.set(Calendar.MINUTE, 0);

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    // This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            // This is a special case that's hard to generalize
                            // If the date is 1, we round up to 16, otherwise
                            // we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            // We need to add one to this field since the
                            // last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            // We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            // These are special types of fields that require different rounding rules
            switch (fields[i][0]) {
                case Calendar.DATE:
                    if (field == DateUtils.SEMI_MONTH) {
                        // If we're going to drop the DATE field's value,
                        // we want to do this our own way.
                        // We need to subtract 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        // If we're above 15 days adjustment, that means we're in the
                        // bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        // Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.HOUR_OF_DAY:
                    if (field == Calendar.AM_PM) {
                        // If we're going to drop the HOUR field's value,
                        // we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                // Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                // Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            // We need to remove this field
            val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
    }",0,0
379,Lang_9,"private void init() {
        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex= new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher= formatPattern.matcher(pattern);
        if(!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField= patternMatcher.group();
        Strategy currentStrategy= getStrategy(currentFormatField);
        for(;;) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if(!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField= patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if(currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
        currentFormatField= null;
        strategies= collector.toArray(new Strategy[collector.size()]);
        parsePattern= Pattern.compile(regex.toString());
    }","private void init() {
        thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex = new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher = formatPattern.matcher(pattern);
        
        if (!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField = patternMatcher.group();
        Strategy currentStrategy = getStrategy(currentFormatField);
        
        while (true) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if (!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField = patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if (currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
            currentFormatField = nextFormatField;
            currentStrategy = nextStrategy;
        }
        
        if (currentStrategy.addRegex(this, regex)) {
            collector.add(currentStrategy);
        }

        currentFormatField = null;
        strategies = collector.toArray(new Strategy[collector.size()]);
        parsePattern = Pattern.compile(regex.toString());
}",0,0
380,Math_10,"public void atan2(final double[] y, final int yOffset,
                      final double[] x, final int xOffset,
                      final double[] result, final int resultOffset) {

        // compute r = sqrt(x^2+y^2)
        double[] tmp1 = new double[getSize()];
        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
        double[] tmp2 = new double[getSize()];
        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)

        if (x[xOffset] >= 0) {

            // compute atan2(y, x) = 2 atan(y / (r + x))
            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
            for (int i = 0; i < tmp2.length; ++i) {
                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
            }

        } else {

            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
            result[resultOffset] =
                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
            for (int i = 1; i < tmp2.length; ++i) {
                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))
            }

         }
 
         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
 
     }","public void atan2(final double[] y, final int yOffset,
                      final double[] x, final int xOffset,
                      final double[] result, final int resultOffset) {

        // compute r = sqrt(x^2+y^2)
        double[] tmp1 = new double[getSize()];
        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
        double[] tmp2 = new double[getSize()];
        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)

        if (Double.isInfinite(x[xOffset]) || Double.isInfinite(y[yOffset])) {
            // handle infinite values separately
            if (Double.isInfinite(x[xOffset])) {
                result[resultOffset] = (y[yOffset] > 0 ? FastMath.PI / 2 : -FastMath.PI / 2);
            } else {
                result[resultOffset] = (x[xOffset] > 0 ? 0 : FastMath.PI);
            }
            return;
        }

        if (x[xOffset] > 0) {

            // compute atan2(y, x) = 2 atan(y / (r + x))
            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
            for (int i = 0; i < tmp2.length; ++i) {
                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
            }

        } else {

            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
            result[resultOffset] =
                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
            for (int i = 1; i < tmp2.length; ++i) {
                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))
            }
         }

         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0,
         // handle zero values separately
         if (x[xOffset] == 0 && y[yOffset] == 0) {
             result[resultOffset] = 0.0;
             for (int i = 1; i < tmp2.length; ++i) {
                result[resultOffset + i] = 0.0;
             }
         }
 
     }",0,0
381,Math_101,"public Complex parse(String source, ParsePosition pos) {
        int initialIndex = pos.getIndex();

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse real
        Number re = parseNumber(source, getRealFormat(), pos);
        if (re == null) {
            // invalid real number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse sign
        int startIndex = pos.getIndex();
        char c = parseNextCharacter(source, pos);
        int sign = 0;
        switch (c) {
        case 0 :
            // no sign
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-' :
            sign = -1;
            break;
        case '+' :
            sign = 1;
            break;
        default :
            // invalid sign
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse imaginary
        Number im = parseNumber(source, getRealFormat(), pos);
        if (im == null) {
            // invalid imaginary number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse imaginary character
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
         if (
             source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             // set index back to initial, error index should be the start index
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }
        pos.setIndex(endIndex);

        return new Complex(re.doubleValue(), im.doubleValue() * sign);
    }","public Complex parse(String source, ParsePosition pos) {
    int initialIndex = pos.getIndex();

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse real
    Number re = parseNumber(source, getRealFormat(), pos);
    if (re == null) {
        // invalid real number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }

    // parse sign
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    int sign = 0;
    switch (c) {
        case 0:
            // no sign
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-':
            sign = -1;
            break;
        case '+':
            sign = 1;
            break;
        default:
            // invalid sign or reached the end prematurely
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse imaginary
    Number im = parseNumber(source, getRealFormat(), pos);
    if (im == null) {
        // invalid imaginary number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }

    // parse imaginary character
    int n = getImaginaryCharacter().length();
    startIndex = pos.getIndex();
    int endIndex = startIndex + n;
    if (endIndex > source.length() || !source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {
        // set index back to initial, error index should be the start index
        // character examined.
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }
    pos.setIndex(endIndex);

    return new Complex(re.doubleValue(), im.doubleValue() * sign);
}",0,0
382,Math_102,"public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
        if ((expected.length < 2) || (expected.length != observed.length)) {
            throw new IllegalArgumentException(
                    ""observed, expected array lengths incorrect"");
        }
        if (!isPositive(expected) || !isNonNegative(observed)) {
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }","public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {

    if ((expected.length < 2) || (expected.length != observed.length)) {
        throw new IllegalArgumentException(
                ""observed, expected array lengths incorrect"");
    }
    if (!isPositive(expected) || !isNonNegative(observed)) {
        throw new IllegalArgumentException(
            ""observed counts must be non-negative and expected counts must be positive"");
    }

    double sumSq = 0.0d;
    double dev = 0.0d;

    for (int i = 0; i < observed.length; i++) {
        if (expected[i] <= 0) { // Sanity check for positive expected values
            throw new IllegalArgumentException(
                ""Expected counts must be positive"");
        }
        
        dev = ((double) observed[i] - expected[i]);
        sumSq += dev * dev / expected[i];
    }

    return sumSq;
}",0,0
383,Math_103,"    public double cumulativeProbability(double x) throws MathException {
            return 0.5 * (1.0 + Erf.erf((x - mean) /
                    (standardDeviation * Math.sqrt(2.0))));
    }
","public double cumulativeProbability(double x) throws MathException {
    if (standardDeviation <= 0) {
        throw new MathException(""Standard deviation must be positive"");
    }
    return 0.5 * (1.0 + Erf.erf((x - mean) /
            (standardDeviation * Math.sqrt(2.0))));
}",0,0
384,Math_105,"    public double getSumSquaredErrors() {
        return sumYY - sumXY * sumXY / sumXX;
    }
","public double getSumSquaredErrors() {
        if (sumXX == 0) {
            throw new ArithmeticException(""Division by zero in calculation of sum squared errors"");
        }
        return sumYY - sumXY * sumXY / sumXX;
    }",0,0
385,Math_106,"    public Fraction parse(String source, ParsePosition pos) {
        // try to parse improper fraction
        Fraction ret = super.parse(source, pos);
        if (ret != null) {
            return ret;
        }
        
        int initialIndex = pos.getIndex();

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse whole
        Number whole = getWholeFormat().parse(source, pos);
        if (whole == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);
        
        // parse numerator
        Number num = getNumeratorFormat().parse(source, pos);
        if (num == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }
        
            // minus signs should be leading, invalid expression

        // parse '/'
        int startIndex = pos.getIndex();
        char c = parseNextCharacter(source, pos);
        switch (c) {
        case 0 :
            // no '/'
            // return num as a fraction
            return new Fraction(num.intValue(), 1);
        case '/' :
            // found '/', continue parsing denominator
            break;
        default :
            // invalid '/'
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse denominator
        Number den = getDenominatorFormat().parse(source, pos);
        if (den == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }
        
            // minus signs must be leading, invalid

        int w = whole.intValue();
        int n = num.intValue();
        int d = den.intValue();
        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);
    }
",Match failed,0,0
386,Math_11,"public double density(final double[] vals) throws DimensionMismatchException {
        final int dim = getDimension();
        if (vals.length != dim) {
             throw new DimensionMismatchException(vals.length, dim);
         }
 
         return FastMath.pow(2 * FastMath.PI, -dim / 2) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }",Match failed,0,0
387,Math_13,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
","private RealMatrix squareRoot(RealMatrix m) {
    try {
        final EigenDecomposition dec = new EigenDecomposition(m);
        return dec.getSquareRoot();
    } catch (MathIllegalArgumentException e) {
        throw new IllegalArgumentException(""Matrix square root computation failed: "" + e.getMessage(), e);
    }
}",0,0
388,Math_17,"    public Dfp multiply(final int x) {
            return multiplyFast(x);
    }
","public Dfp multiply(final int x) {
    return multiply((Dfp)newInstance(x));
}",0,0
389,Math_19,"private void checkParameters() {
        final double[] init = getStartPoint();
        final double[] lB = getLowerBound();
        final double[] uB = getUpperBound();

        // Checks whether there is at least one finite bound value.
        boolean hasFiniteBounds = false;
        for (int i = 0; i < lB.length; i++) {
            if (!Double.isInfinite(lB[i]) ||
                !Double.isInfinite(uB[i])) {
                hasFiniteBounds = true;
                break;
            }
        }
        // Checks whether there is at least one infinite bound value.
        boolean hasInfiniteBounds = false;
        if (hasFiniteBounds) {
            for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(lB[i]) ||
                    Double.isInfinite(uB[i])) {
                    hasInfiniteBounds = true;
                    break;
                }
            }

            if (hasInfiniteBounds) {
                // If there is at least one finite bound, none can be infinite,
                // because mixed cases are not supported by the current code.
                throw new MathUnsupportedOperationException();
            } else {
                // Convert API to internal handling of boundaries.
                boundaries = new double[2][];
                boundaries[0] = lB;
                boundaries[1] = uB;

                // Abort early if the normalization will overflow (cf. ""encode"" method).
            }
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = null;
        }

        if (inputSigma != null) {
            if (inputSigma.length != init.length) {
                throw new DimensionMismatchException(inputSigma.length, init.length);
            }
            for (int i = 0; i < init.length; i++) {
                if (inputSigma[i] < 0) {
                    throw new NotPositiveException(inputSigma[i]);
                }
                if (boundaries != null) {
                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                    }
                }
            }
        }
    }

    /**
     * Initialization of the dynamic search parameters
     *
     * @param guess Initial guess for the arguments of the fitness function.
     */
    private void initializeCMA(double[] guess) {
        if (lambda <= 0) {
            lambda = 4 + (int) (3. * Math.log(dimension));
        }
        // initialize sigma
        double[][] sigmaArray = new double[guess.length][1];",Match failed,0,0
390,Math_2,"    public double getNumericalMean() {
        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
    }
","public double getNumericalMean() {
    // Ensure population size is not zero to prevent division by zero.
    if (getPopulationSize() == 0) {
        throw new ArithmeticException(""Population size must not be zero."");
    }
    return (double) getSampleSize() * (double) getNumberOfSuccesses() / (double) getPopulationSize();
}",0,0
391,Math_20,"        public double[] repairAndDecode(final double[] x) {
            return
                decode(x);
        }
","public double[] repairAndDecode(final double[] x) {
    if (x == null || x.length == 0) {
        throw new IllegalArgumentException(""Input array x cannot be null or empty."");
    }
    double[] repairedX = repair(x);
    return decode(repairedX);
}

// Helper method to repair the array (assuming the repair logic needs to be implemented)
private double[] repair(final double[] x) {
    // Placeholder for actual repair logic
    // You can add specific checks or modifications to the array here
    return x; // Returning the original array for now
}

// Decode method placeholder
private double[] decode(final double[] x) {
    // Placeholder for decode logic
    // Implement actual decoding logic here
    return x; // Returning the original array for now
}",0,0
392,Math_21,"    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }


            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                ++r;
                loop = false;

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ii] -= e * e;
                    for (int j = r + 1; j < i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }

    }","public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

    final int order = matrix.getRowDimension();
    final double[][] c = matrix.getData();
    final double[][] b = new double[order][order];

    int[] swap = new int[order];
    int[] index = new int[order];
    for (int i = 0; i < order; ++i) {
        index[i] = i;
    }

    int r = 0;
    for (boolean loop = true; loop; ) {

        // find maximal diagonal element
        swap[r] = r;
        for (int i = r + 1; i < order; ++i) {
            int ii = index[i];
            int isi = index[swap[r]];
            if (c[ii][ii] > c[isi][isi]) {
                swap[r] = i;
            }
        }

        // swap elements
        if (swap[r] != r) {
            int tmp = index[r];
            index[r] = index[swap[r]];
            index[swap[r]] = tmp;
        }

        // check diagonal element
        int ir = index[r];
        if (c[ir][ir] < small) {

            if (r == 0) {
                throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
            }

            // check remaining diagonal elements
            for (int i = r; i < order; ++i) {
                if (c[index[i]][index[i]] < -small) {
                    // there is at least one sufficiently negative diagonal element,
                    // the symmetric positive semidefinite matrix is wrong
                    throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], index[i], small);
                }
            }

            // all remaining diagonal elements are close to zero, we consider we have
            // found the rank of the symmetric positive semidefinite matrix
            ++r;
            loop = false;

        } else {

            // transform the matrix
            final double sqrt = FastMath.sqrt(c[ir][ir]);
            b[r][r] = sqrt;
            final double inverse = 1 / sqrt;
            for (int i = r + 1; i < order; ++i) {
                final int ii = index[i];
                final double e = inverse * c[ii][ir];
                b[i][r] = e;
                c[ii][ii] -= e * e;
                for (int j = r + 1; j < i; ++j) {
                    final int ij = index[j];
                    final double f = c[ii][ij] - e * b[j][r];
                    c[ii][ij] = f;
                    c[ij][ii] = f;
                }
            }

            // prepare next iteration
            loop = ++r < order;
        }
    }

    // build the root matrix
    rank = r;
    root = MatrixUtils.createRealMatrix(order, r);
    for (int i = 0; i < order; ++i) {
        for (int j = 0; j < r; ++j) {
            root.setEntry(index[i], j, b[i][j]);
        }
    }
}",0,0
393,Math_23,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
        }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a, b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p, q, r, u;

            if (FastMath.abs(e) > tol1) { // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);

                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }

                r = e;
                e = d;

                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    d = p / q;
                    u = x + d;

                    if (u - a < tol2 || b - u < tol2) {
                        d = (x <= m) ? tol1 : -tol1;
                    }
                } else {
                    e = (x < m) ? b - x : a - x;
                    d = GOLDEN_SECTION * e;
                }
            } else {
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }

            if (FastMath.abs(d) < tol1) {
                d = (d >= 0) ? tol1 : -tol1;
            }

            u = x + d;
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }

            previous = current;
            current = new UnivariatePointValuePair(u, fu);

            if (checker != null && checker.converged(iter, previous, current)) {
                return best(current, previous, isMinim);
            }

            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            return best(current, previous, isMinim);
        }
        ++iter;
    }
}",0,0
394,Math_24,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return current;
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
             ++iter;
         }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a = Math.min(lo, hi);
    double b = Math.max(lo, hi);

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    fx = isMinim ? fx : -fx;
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * Math.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        final boolean stop = Math.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;

            if (Math.abs(e) > tol1) {
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);

                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }

                r = e;
                e = d;

                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {
                    d = p / q;
                    u = x + d;

                    if (u - a < tol2 || b - u < tol2) {
                        d = (x <= m) ? tol1 : -tol1;
                    }
                } else {
                    e = (x < m) ? b - x : a - x;
                    d = GOLDEN_SECTION * e;
                }
            } else {
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }

            u = Math.abs(d) < tol1 ? x + (d >= 0 ? tol1 : -tol1) : x + d;

            double fu = computeObjectiveValue(u);
            fu = isMinim ? fu : -fu;

            previous = current;
            current = new UnivariatePointValuePair(u, fu);

            if (checker != null && checker.converged(iter, previous, current)) {
                return current;
            }

            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            return current;
        }
        ++iter;
    }
}",0,0
395,Math_25,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
            }
        }","private void guessAOmega() {
    // initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;

    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;
    for (int i = 1; i < observations.length; ++i) {
        // one step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();

        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
        // considering a linear model for f (and therefore constant f')
        final double dx = currentX - previousX;
        final double dy = currentY - previousY;
        final double f2StepIntegral =
            dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = (dx == 0) ? 0 : dy * dy / dx;

        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;

        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }

    // compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;
    if ((c2 == 0) || (c3 == 0) || (c1 / c2 < 0) || (c2 / c3 < 0)) {
        final int last = observations.length - 1;
        // Range of the observations, assuming that the
        // observations are sorted.
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange == 0) {
            throw new ZeroException();
        }
        omega = 2 * Math.PI / xRange;

        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (int i = 1; i < observations.length; ++i) {
            final double y = observations[i].getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        a = 0.5 * (yMax - yMin);
    } else {
        // In some ill-conditioned cases (cf. MATH-844), the guesser
        // procedure cannot produce sensible results.

        a = FastMath.sqrt(c1 / c2);
        omega = FastMath.sqrt(c2 / c3);
    }
}",0,0
396,Math_26,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
","private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;

            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (FastMath.abs(convergent - value) < epsilon || n >= maxIterations || q2 >= maxDenominator) {
                stop = true;
            } else {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }",0,0
397,Math_27,"    public double percentageValue() {
        return multiply(100).doubleValue();
    }
","public double percentageValue(BigDecimal value) {
    return value.multiply(BigDecimal.valueOf(100)).doubleValue();
}",0,0
398,Math_28,"private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);

            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                final double ratio = rhs / entry;
                // check if the entry is strictly equal to the current min ratio
                // do not use a ulp/epsilon check
                final int cmp = Double.compare(ratio, minRatio);
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions = new ArrayList<Integer>();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.size() == 0) {
            return null;
        } else if (minRatioPositions.size() > 1) {
            // there's a degeneracy as indicated by a tie in the minimum ratio test

            // 1. check if there's an artificial variable that can be forced out of the basis
                for (Integer row : minRatioPositions) {
                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                        int column = i + tableau.getArtificialVariableOffset();
                        final double entry = tableau.getEntry(row, column);
                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                            return row;
                        }
                    }
                }

            // 2. apply Bland's rule to prevent cycling:
            //    take the row for which the corresponding basic variable has the smallest index
            //
            // see http://www.stanford.edu/class/msande310/blandrule.pdf
            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
            //
            // Additional heuristic: if we did not get a solution after half of maxIterations
            //                       revert to the simple case of just returning the top-most row
            // This heuristic is based on empirical data gathered while investigating MATH-828.
                Integer minRow = null;
                int minIndex = tableau.getWidth();
                for (Integer row : minRatioPositions) {
                    int i = tableau.getNumObjectiveFunctions();
                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
                        if (row == tableau.getBasicRow(i)) {
                            if (i < minIndex) {
                                minIndex = i;
                                minRow = row;
                            }
                        }
                     }
                 }
                 return minRow;
         }
         return minRatioPositions.get(0);
     }","private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);

            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                final double ratio = rhs / entry;
                final int cmp = Double.compare(ratio, minRatio);
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions.clear();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.isEmpty()) {
            return null;
        } else if (minRatioPositions.size() > 1) {
            // 1. check if there's an artificial variable that can be forced out of the basis
            for (Integer row : minRatioPositions) {
                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                    int column = i + tableau.getArtificialVariableOffset();
                    final double entry = tableau.getEntry(row, column);
                    if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                        return row;
                    }
                }
            }

            // 2. apply Bland's rule to prevent cycling
            Integer minRow = null;
            int minIndex = tableau.getWidth();
            for (Integer row : minRatioPositions) {
                int i = tableau.getNumObjectiveFunctions();
                for (; i < tableau.getWidth() - 1; i++) {
                    if (row.equals(tableau.getBasicRow(i))) {
                        if (i < minIndex) {
                            minIndex = i;
                            minRow = row;
                        }
                    }
                }
            }
            return minRow;
        }
        return minRatioPositions.get(0);
}",0,0
399,Math_3,"    public static double linearCombination(final double[] a, final double[] b)
        throws DimensionMismatchException {
        final int len = a.length;
        if (len != b.length) {
            throw new DimensionMismatchException(len, b.length);
        }

            // Revert to scalar multiplication.

        final double[] prodHigh = new double[len];
        double prodLowSum = 0;

        for (int i = 0; i < len; i++) {
            final double ai = a[i];
            final double ca = SPLIT_FACTOR * ai;
            final double aHigh = ca - (ca - ai);
            final double aLow = ai - aHigh;

            final double bi = b[i];
            final double cb = SPLIT_FACTOR * bi;
            final double bHigh = cb - (cb - bi);
            final double bLow = bi - bHigh;
            prodHigh[i] = ai * bi;
            final double prodLow = aLow * bLow - (((prodHigh[i] -
                                                    aHigh * bHigh) -
                                                   aLow * bHigh) -
                                                  aHigh * bLow);
            prodLowSum += prodLow;
        }


        final double prodHighCur = prodHigh[0];
        double prodHighNext = prodHigh[1];
        double sHighPrev = prodHighCur + prodHighNext;
        double sPrime = sHighPrev - prodHighNext;
        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);

        final int lenMinusOne = len - 1;
        for (int i = 1; i < lenMinusOne; i++) {
            prodHighNext = prodHigh[i + 1];
            final double sHighCur = sHighPrev + prodHighNext;
            sPrime = sHighCur - prodHighNext;
            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
            sHighPrev = sHighCur;
        }

        double result = sHighPrev + (prodLowSum + sLowSum);

        if (Double.isNaN(result)) {
            // either we have split infinite numbers or some coefficients were NaNs,
            // just rely on the naive implementation and let IEEE754 handle this
            result = 0;
            for (int i = 0; i < len; ++i) {
                result += a[i] * b[i];
            }
        }

        return result;
    }","public static double linearCombination(final double[] a, final double[] b)
        throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }

    final double[] prodHigh = new double[len];
    double prodLowSum = 0;

    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;

        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;

        prodHigh[i] = aHigh * bHigh;
        final double prodLow = aLow * bLow - (((prodHigh[i] -
                                                aHigh * bHigh) -
                                               aLow * bHigh) -
                                              aHigh * bLow);
        prodLowSum += prodLow;
    }

    double sHighPrev = prodHigh[0];
    double sLowSum = 0.0;
    final int lenMinusOne = len - 1;

    for (int i = 0; i < lenMinusOne; i++) {
        double prodHighNext = prodHigh[i + 1];
        double sHighCur = sHighPrev + prodHighNext;
        double sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }

    double result = sHighPrev + (prodLowSum + sLowSum);

    if (Double.isNaN(result)) {
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }

    return result;
}",0,0
400,Math_30,"private double calculateAsymptoticPValue(final double Umin,
                                             final int n1,
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
         final int n1n2prod = n1 * n2;
 
         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
         final double EU = n1n2prod / 2.0;
        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;

        final double z = (Umin - EU) / FastMath.sqrt(VarU);

        final NormalDistribution standardNormal = new NormalDistribution(0, 1);

        return 2 * standardNormal.cumulativeProbability(z);
    }","private double calculateAsymptoticPValue(final double Umin,
                                         final int n1,
                                         final int n2)
        throws ConvergenceException, MaxCountExceededException {

    final int n1n2prod = n1 * n2;

    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
    final double EU = n1n2prod / 2.0;
    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;

    if (VarU <= 0) {
        throw new IllegalArgumentException(""Variance cannot be zero or negative"");
    }

    final double z = (Umin - EU) / FastMath.sqrt(VarU);
    final NormalDistribution standardNormal = new NormalDistribution(0, 1);

    return 2 * (1.0 - standardNormal.cumulativeProbability(Math.abs(z)));
}",0,0
401,Math_31,"public double evaluate(double x, double epsilon, int maxIterations) {
        final double small = 1e-50;
        double hPrev = getA(0, x);

        // use the value of small as epsilon criteria for zero checks
        if (Precision.equals(hPrev, 0.0, small)) {
            hPrev = small;
        }

        int n = 1;
        double dPrev = 0.0;
        double p0 = 1.0;
        double q1 = 1.0;
        double cPrev = hPrev;
        double hN = hPrev;

        while (n < maxIterations) {
            final double a = getA(n, x);
            final double b = getB(n, x);

            double cN = a * hPrev + b * p0;
            double q2 = a * q1 + b * dPrev;
            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
                double scaleFactor = 1d;
                double lastScaleFactor = 1d;
                final int maxPower = 5;
                final double scale = FastMath.max(a,b);
                if (scale <= 0) {  // Can't scale
                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
                }
                for (int i = 0; i < maxPower; i++) {
                    lastScaleFactor = scaleFactor;
                    scaleFactor *= scale;
                    if (a != 0.0 && a > b) {
                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                    } else if (b != 0) {
                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                    }
                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                        break;
                    }
                }
            }

            final double deltaN = cN / q2 / cPrev;
            hN = cPrev * deltaN;

            if (Double.isInfinite(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
                                               x);
            }
            if (Double.isNaN(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
                                               x);
            }

            if (FastMath.abs(deltaN - 1.0) < epsilon) {
                 break;
             }
 
             dPrev = q1;
             cPrev = cN / q2;
             p0 = hPrev;
             hPrev = cN;
             q1 = q2;
             n++;
         }
 
        if (n >= maxIterations) {
            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,
                                                maxIterations, x);
        }

        return hN;
    }","public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);

    // use the value of small as epsilon criteria for zero checks
    if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }

    int n = 1;
    double dPrev = 0.0;
    double p0 = 1.0;
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;

    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);

        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;
        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
            double scaleFactor = 1d;
            double lastScaleFactor = 1d;
            final int maxPower = 5;
            final double scale = FastMath.max(a,b);
            if (scale <= 0) { 
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
            }
            for (int i = 0; i < maxPower; i++) {
                lastScaleFactor = scaleFactor;
                scaleFactor *= scale;
                if (a != 0.0 && a > b) {
                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                } else if (b != 0) {
                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                }
                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                    break;
                }
            }
        }

        final double deltaN = cN / q2;
        hN = cPrev * deltaN;

        if (Double.isInfinite(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
        }
        if (Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }

        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            break;
        }

        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }

    if (n >= maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
    }

    return hN;
}",0,0
402,Math_32,"@Override
    protected void computeGeometricalProperties() {

        final Vector2D[][] v = getVertices();
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
             if ((Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
            } else {
                setSize(0);
                setBarycenter(new Vector2D(0, 0));
            }
        } else if (v[0][0] == null) {
            // there is at least one open-loop: the polygon is infinite
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            // all loops are closed, we compute some integrals around the shape

            double sum  = 0;
            double sumX = 0;
            double sumY = 0;

            for (Vector2D[] loop : v) {
                double x1 = loop[loop.length - 1].getX();
                double y1 = loop[loop.length - 1].getY();
                for (final Vector2D point : loop) {
                    final double x0 = x1;
                    final double y0 = y1;
                    x1 = point.getX();
                    y1 = point.getY();
                    final double factor = x0 * y1 - y0 * x1;
                    sum  += factor;
                    sumX += factor * (x0 + x1);
                    sumY += factor * (y0 + y1);
                }
            }

            if (sum < 0) {
                // the polygon as a finite outside surrounded by an infinite inside
                setSize(Double.POSITIVE_INFINITY);
                setBarycenter(Vector2D.NaN);
            } else {
                setSize(sum / 2);
                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
            }

        }

    }","@Override
protected void computeGeometricalProperties() {
    final Vector2D[][] v = getVertices();

    if (v.length == 0) {
        final BSPTree<Euclidean2D> tree = getTree(false);
        if ((Boolean) tree.getAttribute()) {
            // the instance covers the whole space
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(0);
            setBarycenter(new Vector2D(0, 0));
        }
    } else if (v[0] == null || v[0][0] == null) {
        // there is at least one open-loop: the polygon is infinite
        setSize(Double.POSITIVE_INFINITY);
        setBarycenter(Vector2D.NaN);
    } else {
        // all loops are closed, we compute some integrals around the shape
        double sum = 0;
        double sumX = 0;
        double sumY = 0;

        for (Vector2D[] loop : v) {
            if (loop != null && loop.length > 0) {
                double x1 = loop[loop.length - 1].getX();
                double y1 = loop[loop.length - 1].getY();
                for (final Vector2D point : loop) {
                    final double x0 = x1;
                    final double y0 = y1;
                    x1 = point.getX();
                    y1 = point.getY();
                    final double factor = x0 * y1 - y0 * x1;
                    sum += factor;
                    sumX += factor * (x0 + x1);
                    sumY += factor * (y0 + y1);
                }
            }
        }

        if (sum < 0) {
            // the polygon as a finite outside surrounded by an infinite inside
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(sum / 2);
            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
        }
    }
}",0,0
403,Math_33,"protected void dropPhase1Objective() {
        if (getNumObjectiveFunctions() == 1) {
            return;
        }

        List<Integer> columnsToDrop = new ArrayList<Integer>();
        columnsToDrop.add(0);

         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }

        // non-basic artificial variables
        for (int i = 0; i < getNumArtificialVariables(); i++) {
          int col = i + getArtificialVariableOffset();
          if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
          }
        }

        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
        for (int i = 1; i < getHeight(); i++) {
          int col = 0;
          for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
              matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
          }
        }

        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
          columnLabels.remove((int) columnsToDrop.get(i));
        }

        this.tableau = new Array2DRowRealMatrix(matrix);
        this.numArtificialVariables = 0;
    }","protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }

    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);

    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }

    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }

    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }

    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
        columnLabels.remove((int) columnsToDrop.get(i));
    }

    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = getNumArtificialVariables() - columnsToDrop.size() + 1;
}",0,0
404,Math_34,"    public Iterator<Chromosome> iterator() {
        return chromosomes.iterator();
    }
",Match failed,0,0
405,Math_38,"private void prelim(double[] lowerBound,
                        double[] upperBound) {
        printMethod(); // XXX

        final int n = currentBest.getDimension();
        final int npt = numberOfInterpolationPoints;
        final int ndim = bMatrix.getRowDimension();

        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
        final double recip = 1d / rhosq;
        final int np = n + 1;

        // Set XBASE to the initial vector of variables, and set the initial
        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

        for (int j = 0; j < n; j++) {
            originShift.setEntry(j, currentBest.getEntry(j));
            for (int k = 0; k < npt; k++) {
                interpolationPoints.setEntry(k, j, ZERO);
            }
            for (int i = 0; i < ndim; i++) {
                bMatrix.setEntry(i, j, ZERO);
            }
        }
        for (int i = 0, max = n * np / 2; i < max; i++) {
            modelSecondDerivativesValues.setEntry(i, ZERO);
        }
        for (int k = 0; k < npt; k++) {
            modelSecondDerivativesParameters.setEntry(k, ZERO);
            for (int j = 0, max = npt - np; j < max; j++) {
                zMatrix.setEntry(k, j, ZERO);
            }
        }

        // Begin the initialization procedure. NF becomes one more than the number
        // of function values so far. The coordinates of the displacement of the
        // next initial interpolation point from XBASE are set in XPT(NF+1,.).

        int ipt = 0;
        int jpt = 0;
        double fbeg = Double.NaN;
        do {
            final int nfm = getEvaluations();
            final int nfx = nfm - n;
            final int nfmm = nfm - 1;
            final int nfxm = nfx - 1;
            double stepa = 0;
            double stepb = 0;
            if (nfm <= 2 * n) {
                if (nfm >= 1 &&
                    nfm <= n) {
                    stepa = initialTrustRegionRadius;
                    if (upperDifference.getEntry(nfmm) == ZERO) {
                        stepa = -stepa;
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfmm, stepa);
                } else if (nfm > n) {
                    stepa = interpolationPoints.getEntry(nfx, nfxm);
                    stepb = -initialTrustRegionRadius;
                    if (lowerDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    if (upperDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfxm, stepb);
                }
            } else {
                final int tmp1 = (nfm - np) / n;
                jpt = nfm - tmp1 * n - n;
                ipt = jpt + tmp1;
                if (ipt > n) {
                    final int tmp2 = jpt;
                    jpt = ipt - n;
                    ipt = tmp2;
                    throw new PathIsExploredException(); // XXX
                }
                final int iptMinus1 = ipt;
                final int jptMinus1 = jpt;
                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
            }

            // Calculate the next value of F. The least function value so far and
            // its index are required.

            for (int j = 0; j < n; j++) {
                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                                                 upperBound[j]));
                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                    currentBest.setEntry(j, lowerBound[j]);
                }
                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                    currentBest.setEntry(j, upperBound[j]);
                }
            }

            final double objectiveValue = computeObjectiveValue(currentBest.toArray());
            final double f = isMinimize ? objectiveValue : -objectiveValue;
            final int numEval = getEvaluations(); // nfm + 1
            fAtInterpolationPoints.setEntry(nfm, f);

            if (numEval == 1) {
                fbeg = f;
                trustRegionCenterInterpolationPointIndex = 0;
            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
                trustRegionCenterInterpolationPointIndex = nfm;
            }

            // Set the nonzero initial elements of BMAT and the quadratic model in the
            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
            // of the NF-th and (NF-N)-th interpolation points may be switched, in
            // order that the function value at the first of them contributes to the
            // off-diagonal second derivative terms of the initial quadratic model.

            if (numEval <= 2 * n + 1) {
                if (numEval >= 2 &&
                    numEval <= n + 1) {
                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                    if (npt < numEval + n) {
                        final double oneOverStepA = ONE / stepa;
                        bMatrix.setEntry(0, nfmm, -oneOverStepA);
                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                        throw new PathIsExploredException(); // XXX
                    }
                } else if (numEval >= n + 2) {
                    final int ih = nfx * (nfx + 1) / 2 - 1;
                    final double tmp = (f - fbeg) / stepb;
                    final double diff = stepb - stepa;
                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                    if (stepa * stepb < ZERO) {
                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                            fAtInterpolationPoints.setEntry(nfm - n, f);
                            if (trustRegionCenterInterpolationPointIndex == nfm) {
                                trustRegionCenterInterpolationPointIndex = nfm - n;
                            }
                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                            interpolationPoints.setEntry(nfm, nfxm, stepa);
                        }
                    }
                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                    bMatrix.setEntry(nfm - n, nfxm,
                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                    zMatrix.setEntry(nfm - n, nfxm,
                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
                }

                // Set the off-diagonal second derivatives of the Lagrange functions and
                // the initial quadratic model.

            } else {
                zMatrix.setEntry(0, nfxm, recip);
                zMatrix.setEntry(nfm, nfxm, recip);
                zMatrix.setEntry(ipt, nfxm, -recip);
                zMatrix.setEntry(jpt, nfxm, -recip);

                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                throw new PathIsExploredException(); // XXX
            }
        } while (getEvaluations() < npt);
    } // prelim",Match failed,0,0
406,Math_39,"@Override
  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0  = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp    = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
                              equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart         = equations.getTime();
    double  hNew      = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

      interpolator.shift();

      // iterate over step size, ensuring local normalized error is smaller than 1
      double error = 10;
      while (error >= 1.0) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[mainSetDimension];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
              }
          } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
              }
          }
          hNew = initializeStep(forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
         }
 
         stepSize = hNew;
 
         // next stages
         for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error >= 1.0) {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              FastMath.min(maxGrowth,
                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // local error is small enough: accept the step, trigger events and step handlers
      interpolator.storeTime(stepStart + stepSize);
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
      stepStart = acceptStep(interpolator, y, yDotTmp, t);
      System.arraycopy(y, 0, yTmp, 0, y.length);

      if (!isLastStep) {

          // prepare next step
          interpolator.storeTime(stepStart);

          if (fsal) {
              // save the last evaluation for the next step
              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
          }

          // stepsize control for next step
          final double factor =
              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          final double  scaledH    = stepSize * factor;
          final double  nextT      = stepStart + scaledH;
          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
          hNew = filterStep(scaledH, forward, nextIsLast);

          final double  filteredNextT      = stepStart + hNew;
          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
          if (filteredNextIsLast) {
              hNew = t - stepStart;
          }

      }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

  }","@Override
  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0  = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp    = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
                              equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart         = equations.getTime();
    double  hNew      = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

      interpolator.shift();

      // iterate over step size, ensuring local normalized error is smaller than 1
      double error = 10;
      while (error >= 1.0) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[mainSetDimension];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
              }
          } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
              }
          }
          hNew = initializeStep(forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
         }
 
         stepSize = hNew;
 
         // next stages
         for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error >= 1.0) {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              FastMath.min(maxGrowth,
                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // local error is small enough: accept the step, trigger events and step handlers
      interpolator.storeTime(stepStart + stepSize);
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
      stepStart = acceptStep(interpolator, y, yDotTmp, t);
      System.arraycopy(y, 0, yTmp, 0, y.length);

      if (!isLastStep) {

          // prepare next step
          interpolator.storeTime(stepStart);

          if (fsal) {
              // save the last evaluation for the next step
              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
          }

          // stepsize control for next step
          final double factor =
              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          final double  scaledH    = stepSize * factor;
          final double  nextT      = stepStart + scaledH;
          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
          hNew = filterStep(scaledH, forward, nextIsLast);

          final double  filteredNextT      = stepStart + hNew;
          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
          if (filteredNextIsLast) {
              hNew = t - stepStart;
          }

      }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

  }",0,0
407,Math_40,"@Override
    protected double doSolve() {

        // prepare arrays with the first points
        final double[] x = new double[maximalOrder + 1];
        final double[] y = new double[maximalOrder + 1];
        x[0] = getMin();
        x[1] = getStartValue();
        x[2] = getMax();
        verifySequence(x[0], x[1], x[2]);

        // evaluate initial guess
        y[1] = computeObjectiveValue(x[1]);
        if (Precision.equals(y[1], 0.0, 1)) {
            // return the initial guess if it is a perfect root.
            return x[1];
        }

        // evaluate first  endpoint
        y[0] = computeObjectiveValue(x[0]);
        if (Precision.equals(y[0], 0.0, 1)) {
            // return the first endpoint if it is a perfect root.
            return x[0];
        }

        int nbPoints;
        int signChangeIndex;
        if (y[0] * y[1] < 0) {

            // reduce interval if it brackets the root
            nbPoints        = 2;
            signChangeIndex = 1;

        } else {

            // evaluate second endpoint
            y[2] = computeObjectiveValue(x[2]);
            if (Precision.equals(y[2], 0.0, 1)) {
                // return the second endpoint if it is a perfect root.
                return x[2];
            }

            if (y[1] * y[2] < 0) {
                // use all computed point as a start sampling array for solving
                nbPoints        = 3;
                signChangeIndex = 2;
            } else {
                throw new NoBracketingException(x[0], x[2], y[0], y[2]);
            }

        }

        // prepare a work array for inverse polynomial interpolation
        final double[] tmpX = new double[x.length];

        // current tightest bracketing of the root
        double xA    = x[signChangeIndex - 1];
        double yA    = y[signChangeIndex - 1];
        double absYA = FastMath.abs(yA);
        int agingA   = 0;
        double xB    = x[signChangeIndex];
        double yB    = y[signChangeIndex];
        double absYB = FastMath.abs(yB);
        int agingB   = 0;

        // search loop
        while (true) {

            // check convergence of bracketing interval
            final double xTol = getAbsoluteAccuracy() +
                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
                switch (allowed) {
                case ANY_SIDE :
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE :
                    return xA;
                case RIGHT_SIDE :
                    return xB;
                case BELOW_SIDE :
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE :
                    return (yA <  0) ? xB : xA;
                default :
                    // this should never happen
                    throw new MathInternalError(null);
                }
            }

            // target for the next evaluation point
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
            }

            // make a few attempts to guess a root,
            double nextX;
            int start = 0;
            int end   = nbPoints;
            do {

                // guess a value for current target, using inverse polynomial interpolation
                System.arraycopy(x, start, tmpX, start, end - start);
                nextX = guessX(targetY, tmpX, y, start, end);

                if (!((nextX > xA) && (nextX < xB))) {
                    // the guessed root is not strictly inside of the tightest bracketing interval

                    // the guessed root is either not strictly inside the interval or it
                    // is a NaN (which occurs when some sampling points share the same y)
                    // we try again with a lower interpolation order
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        // we have more points before the sign change, drop the lowest point
                        ++start;
                    } else {
                        // we have more points after sign change, drop the highest point
                        --end;
                    }

                    // we need to do one more attempt
                    nextX = Double.NaN;

                }

            } while (Double.isNaN(nextX) && (end - start > 1));

            if (Double.isNaN(nextX)) {
                // fall back to bisection
                nextX = xA + 0.5 * (xB - xA);
                start = signChangeIndex - 1;
                end   = signChangeIndex;
            }

            // evaluate the function at the guessed root
            final double nextY = computeObjectiveValue(nextX);
            if (Precision.equals(nextY, 0.0, 1)) {
                // we have found an exact root, since it is not an approximation
                // we don't need to bother about the allowed solutions setting
                return nextX;
            }

            if ((nbPoints > 2) && (end - start != nbPoints)) {

                // we have been forced to ignore some points to keep bracketing,
                // they are probably too far from the root, drop them from now on
                nbPoints = end - start;
                System.arraycopy(x, start, x, 0, nbPoints);
                System.arraycopy(y, start, y, 0, nbPoints);
                signChangeIndex -= start;

            } else  if (nbPoints == x.length) {

                // we have to drop one point in order to insert the new one
                nbPoints--;

                // keep the tightest bracketing interval as centered as possible
                if (signChangeIndex >= (x.length + 1) / 2) {
                    // we drop the lowest point, we have to shift the arrays and the index
                    System.arraycopy(x, 1, x, 0, nbPoints);
                    System.arraycopy(y, 1, y, 0, nbPoints);
                    --signChangeIndex;
                }

            }

            // insert the last computed point
            //(by construction, we know it lies inside the tightest bracketing interval)
            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
            x[signChangeIndex] = nextX;
            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
            y[signChangeIndex] = nextY;
            ++nbPoints;

            // update the bracketing interval
            if (nextY * yA <= 0) {
                // the sign change occurs before the inserted point
                xB = nextX;
                yB = nextY;
                absYB = FastMath.abs(yB);
                ++agingA;
                agingB = 0;
            } else {
                // the sign change occurs after the inserted point
                xA = nextX;
                yA = nextY;
                absYA = FastMath.abs(yA);
                agingA = 0;
                ++agingB;

                // update the sign change index
                signChangeIndex++;

            }

        }

    }","@Override
protected double doSolve() {

    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);

    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }

    // evaluate first endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }

    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {

        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;

    } else {

        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }

        if (y[1] * y[2] < 0) {
            // use all computed points as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }

    }

    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];

    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;

    // search loop
    while (true) {

        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() +
                            getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch (allowed) {
            case ANY_SIDE:
                return absYA < absYB ? xA : xB;
            case LEFT_SIDE:
                return xA;
            case RIGHT_SIDE:
                return xB;
            case BELOW_SIDE:
                return (yA <= 0) ? xA : xB;
            case ABOVE_SIDE:
                return (yA < 0) ? xB : xA;
            default:
                // this should never happen
                throw new MathInternalError(null);
            }
        }

        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }

        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {

            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);

            if (!((nextX > xA) && (nextX < xB))) {
                // the guessed root is not strictly inside of the tightest bracketing interval

                // the guessed root is either not strictly inside the interval or it
                // is a NaN (which occurs when some sampling points share the same y)
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after the sign change, drop the highest point
                    --end;
                }

                // we need to do one more attempt
                nextX = Double.NaN;

            }

        } while (Double.isNaN(nextX) && (end - start > 1));

        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }

        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we have found an exact root, since it is not an approximation
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }

        if ((nbPoints > 2) && (end - start != nbPoints)) {

            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;

        } else if (nbPoints == x.length) {

            // we have to drop one point in order to insert the new one
            nbPoints--;

            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }

        }

        // insert the last computed point
        //(by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;

        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;

            // update the sign change index
            signChangeIndex++;

        }

    }

}",0,0
408,Math_41,"public double evaluate(final double[] values, final double[] weights,
                           final double mean, final int begin, final int length) {

        double var = Double.NaN;

        if (test(values, weights, begin, length)) {
            if (length == 1) {
                var = 0.0;
            } else if (length > 1) {
                double accum = 0.0;
                double dev = 0.0;
                double accum2 = 0.0;
                for (int i = begin; i < begin + length; i++) {
                    dev = values[i] - mean;
                    accum += weights[i] * (dev * dev);
                    accum2 += weights[i] * dev;
                 }
 
                 double sumWts = 0;
                 for (int i = 0; i < weights.length; i++) {
                     sumWts += weights[i];
                 }
 
                if (isBiasCorrected) {
                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
                } else {
                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
                }
            }
        }
        return var;
    }",Match failed,0,0
409,Math_42,"protected RealPointValuePair getSolution() {
      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

      Set<Integer> basicRows = new HashSet<Integer>();
      double[] coefficients = new double[getOriginalNumDecisionVariables()];
      for (int i = 0; i < coefficients.length; i++) {
          int colIndex = columnLabels.indexOf(""x"" + i);
          if (colIndex < 0) {
            coefficients[i] = 0;
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
      return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
    Integer negativeVarBasicRow = negativeVarColumn >= 0 ? getBasicRow(negativeVarColumn) : null;
    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

    Set<Integer> basicRows = new HashSet<Integer>();
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    for (int i = 0; i < coefficients.length; i++) {
        int colIndex = columnLabels.indexOf(""x"" + i);
        if (colIndex < 0) {
            coefficients[i] = 0;
            continue;
        }
        Integer basicRow = getBasicRow(colIndex);
        if (basicRow != null && basicRows.contains(basicRow)) {
            coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
        } else {
            basicRows.add(basicRow);
            coefficients[i] =
                (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                (restrictToNonNegative ? 0 : mostNegative);
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,0
410,Math_43,"public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        sumLogImpl.increment(value);
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
         if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
         if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
         if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
    }","public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        if (value > 0) {
            sumLogImpl.increment(Math.log(value));
            if (!(geoMeanImpl instanceof GeometricMean)) {
                geoMeanImpl.increment(value);
            }
        }
        secondMoment.increment(value);
        // If mean or variance have been overridden,
        // need to increment these
        if (!(meanImpl instanceof Mean)) {
            meanImpl.increment(value);
        }
        if (!(varianceImpl instanceof Variance)) {
            varianceImpl.increment(value);
        }
        n++;
    }",0,0
411,Math_44,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    computeDerivatives(eventT, y, yDot);
                    resetOccurred = true;
                    previousT = eventT; // ensure 'previousT' is updated
                    return eventT;
                }

                // prepare handling of the remaining part of the step
                previousT = eventT; // update previousT here, moving it outside the reset block
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }
            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;
    }",0,0
412,Math_45,"    public OpenMapRealMatrix(int rowDimension, int columnDimension) {
        super(rowDimension, columnDimension);
        this.rows = rowDimension;
        this.columns = columnDimension;
        this.entries = new OpenIntToDoubleHashMap(0.0);
    }
","public OpenMapRealMatrix(int rowDimension, int columnDimension) {
        super(rowDimension, columnDimension);
        if (rowDimension < 1 || columnDimension < 1) {
            throw new IllegalArgumentException(""Matrix dimensions must be positive"");
        }
        this.rows = rowDimension;
        this.columns = columnDimension;
        this.entries = new OpenIntToDoubleHashMap(0.0);
    }",0,0
413,Math_48,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    
    // If one of the bounds is the exact root, return it.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it.
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;

        // If the function value of the last approximation is too small,
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        // If the current interval is within the given accuracies, we're satisfied
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",0,0
414,Math_5,"public Complex reciprocal() {
        if (isNaN) {
            return NaN;
         }
 
         if (real == 0.0 && imaginary == 0.0) {
             return NaN;
         }
 
         if (isInfinite) {
            return ZERO;
        }

        if (FastMath.abs(real) < FastMath.abs(imaginary)) {
            double q = real / imaginary;
            double scale = 1. / (real * q + imaginary);
            return createComplex(scale * q, -scale);
        } else {
            double q = imaginary / real;
            double scale = 1. / (imaginary * q + real);
            return createComplex(scale, -scale * q);
        }
    }","public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }

    if (real == 0.0 && imaginary == 0.0) {
        return NaN; // Use NaN to indicate that reciprocal of zero is undefined
    }

    if (isInfinite) {
        return ZERO;
    }

    double scale;
    double q;
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        q = real / imaginary;
        scale = 1. / (imaginary * (1 + q * q)); // Corrected formula to properly scale
        return createComplex(scale * q, -scale);
    } else {
        q = imaginary / real;
        scale = 1. / (real * (1 + q * q)); // Corrected formula to properly scale
        return createComplex(scale, -scale * q);
    }
}",0,0
415,Math_50,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     if (x == x1) {
                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                         f0 = computeObjectiveValue(x0);
                     }
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        
        if (Double.isNaN(x) || Double.isInfinite(x)) {
            // Avoid returning NaN or infinite value
            throw new MathIllegalStateException();
        }
        
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it.
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // Interval inverted
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
            case ILLINOIS:
                f0 *= 0.5;
                break;
            case PEGASUS:
                f0 *= f1 / (f1 + fx);
                break;
            case REGULA_FALSI:
                // Check duplication and update if needed
                if (x == x1) {
                    x0 = 0.5 * (x0 + x1 - Math.max(rtol * Math.abs(x1), atol));
                    f0 = computeObjectiveValue(x0);
                }
                break;
            default:
                throw new MathInternalError();
            }
        }
        
        // Update to the new interval
        x1 = x;
        f1 = fx;

        // Check function value accuracy
        if (Math.abs(f1) <= ftol) {
            switch (allowed) {
            case ANY_SIDE:
                return x1;
            case LEFT_SIDE:
                if (inverted) {
                    return x1;
                }
                break;
            case RIGHT_SIDE:
                if (!inverted) {
                    return x1;
                }
                break;
            case BELOW_SIDE:
                if (f1 <= 0) {
                    return x1;
                }
                break;
            case ABOVE_SIDE:
                if (f1 >= 0) {
                    return x1;
                }
                break;
            default:
                throw new MathInternalError();
            }
        }

        // Check for interval within given accuracies
        if (Math.abs(x1 - x0) < Math.max(rtol * Math.abs(x1), atol)) {
            switch (allowed) {
            case ANY_SIDE:
                return x1;
            case LEFT_SIDE:
                return inverted ? x1 : x0;
            case RIGHT_SIDE:
                return inverted ? x0 : x1;
            case BELOW_SIDE:
                return (f1 <= 0) ? x1 : x0;
            case ABOVE_SIDE:
                return (f1 >= 0) ? x1 : x0;
            default:
                throw new MathInternalError();
            }
        }
    }
}",0,0
416,Math_51,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it.
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                default:
                    throw new MathInternalError(); // Add error handling for undefined methods
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;

        // If the function value of the last approximation is too small,
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        // If the current interval is within the given accuracies,
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",0,0
417,Math_52,"  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

  // norms computation
  double u1u1 = u1.getNormSq();
  double u2u2 = u2.getNormSq();
  double v1v1 = v1.getNormSq();
  double v2v2 = v2.getNormSq();
  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
  }

  // normalize v1 in order to have (v1'|v1') = (u1|u1)
  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
  double u1u2   = u1.dotProduct(u2);
  double v1v2   = v1.dotProduct(v2);
  double coeffU = u1u2 / u1u1;
  double coeffV = v1v2 / u1u1;
  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
  double alpha  = coeffU - beta * coeffV;
  v2 = new Vector3D(alpha, v1, beta, v2);

  // preliminary computation
  Vector3D uRef  = u1;
  Vector3D vRef  = v1;
  Vector3D v1Su1 = v1.subtract(u1);
  Vector3D v2Su2 = v2.subtract(u2);
  Vector3D k     = v1Su1.crossProduct(v2Su2);
  Vector3D u3    = u1.crossProduct(u2);
  double c       = k.dotProduct(u3);
  if (c == 0) {
    // the (q1, q2, q3) vector is close to the (u1, u2) plane
    // we try other vectors
    Vector3D v3 = Vector3D.crossProduct(v1, v2);
    Vector3D v3Su3 = v3.subtract(u3);
    k = v1Su1.crossProduct(v3Su3);
    Vector3D u2Prime = u1.crossProduct(u3);
    c = k.dotProduct(u2Prime);

    if (c == 0) {
      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
      k = v2Su2.crossProduct(v3Su3);;
      c = k.dotProduct(u2.crossProduct(u3));;

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

  }

  // compute the vectorial part
  c = FastMath.sqrt(c);
  double inv = 1.0 / (c + c);
  q1 = inv * k.getX();
  q2 = inv * k.getY();
  q3 = inv * k.getZ();

  // compute the scalar part
   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                    uRef.getZ() * q1 - uRef.getX() * q3,
                    uRef.getX() * q2 - uRef.getY() * q1);
  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

  }
","public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }

    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);

    // preliminary computation
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);

    if (c == 0) {
        // the (q1, q2, q3) vector is close to the (u1, u2) plane
        // we try other vectors
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);

        if (c == 0) {
            // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
            // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
            k = v2Su2.crossProduct(v3Su3);
            c = k.dotProduct(u2.crossProduct(u3));

            if (c == 0) {
                // the rotation is the identity rotation
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }

            // update reference vectors
            uRef = u2;
            vRef = v2;
        }
    }

    // calculate sqrt(c) only if c is non-zero
    c = FastMath.sqrt(Math.abs(c));
    
    // compute the vectorial part
    double inv = 1.0 / (2.0 * c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();

    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                     uRef.getZ() * q1 - uRef.getX() * q3,
                     uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}",0,0
418,Math_53,"public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }","public Complex add(Complex rhs) throws NullArgumentException {
    if (rhs == null) {
        throw new NullArgumentException();
    }
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}",0,0
419,Math_55,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


      // rescale both vectors without losing precision,
      // to ensure their norm are the same order of magnitude

      // we reduce cancellation errors by preconditioning,
      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
      // v3 without loss of precision. See Kahan lecture
      // ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
 
 
       // compute cross product from v3 and v2 instead of v1 and v2
       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }","public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
    // compute rho as an 8 bits approximation of v1.v2 / v2.v2
    double dotProductV1V2 = v1.getX() * v2.getX() + v1.getY() * v2.getY() + v1.getZ() * v2.getZ();
    double dotProductV2V2 = v2.getX() * v2.getX() + v2.getY() * v2.getY() + v2.getZ() * v2.getZ();
    double rho = dotProductV1V2 / dotProductV2V2;

    // compute v3 = v1 - rho * v2
    Vector3D v3 = new Vector3D(v1.getX() - rho * v2.getX(), v1.getY() - rho * v2.getY(), v1.getZ() - rho * v2.getZ());

    // compute the cross product from v3 and v2 instead of v1 and v2
    return new Vector3D(v3.getY() * v2.getZ() - v3.getZ() * v2.getY(), v3.getZ() * v2.getX() - v3.getX() * v2.getZ(), v3.getX() * v2.getY() - v3.getY() * v2.getX());
}",0,0
420,Math_56,"public int[] getCounts(int index) {
        if (index < 0 ||
            index >= totalSize) {
            throw new OutOfRangeException(index, 0, totalSize);
        }

        final int[] indices = new int[dimension];

        int count = 0;
        for (int i = 0; i < last; i++) {
            int idx = 0;
            final int offset = uniCounterOffset[i];
            while (count <= index) {
                count += offset;
                ++idx;
            }
            --idx;
            count -= offset;
             indices[i] = idx;
         }
 
         int idx = 1;
         while (count < index) {
             count += idx;
             ++idx;
         }
         --idx;
         indices[last] = idx;
 
         return indices;
     }","public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize - 1);
    }

    final int[] indices = new int[dimension];

    int count = 0;
    for (int i = 0; i < last; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while (count + offset <= index) {
            count += offset;
            ++idx;
        }
        indices[i] = idx;
    }

    int idx = 0;
    while (count < index) {
        ++count;
        ++idx;
    }
    indices[last] = idx;

    return indices;
}",0,0
421,Math_57,"private static <T extends Clusterable<T>> List<Cluster<T>>
        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {

        final List<T> pointSet = new ArrayList<T>(points);
        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();

        // Choose one center uniformly at random from among the data points.
        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
        resultSet.add(new Cluster<T>(firstPoint));

        final double[] dx2 = new double[pointSet.size()];
        while (resultSet.size() < k) {
            // For each data point x, compute D(x), the distance between x and
            // the nearest center that has already been chosen.
            int sum = 0;
            for (int i = 0; i < pointSet.size(); i++) {
                final T p = pointSet.get(i);
                final Cluster<T> nearest = getNearestCluster(resultSet, p);
                final double d = p.distanceFrom(nearest.getCenter());
                sum += d * d;
                dx2[i] = sum;
            }

            // Add one new data point as a center. Each point x is chosen with
            // probability proportional to D(x)2
            final double r = random.nextDouble() * sum;
            for (int i = 0 ; i < dx2.length; i++) {
                if (dx2[i] >= r) {
                    final T p = pointSet.remove(i);
                    resultSet.add(new Cluster<T>(p));
                    break;
                }
            }
        }

        return resultSet;

    }
","private static <T extends Clusterable<T>> List<Cluster<T>>
        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {

        final List<T> pointSet = new ArrayList<T>(points);
        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();

        // Choose one center uniformly at random from among the data points.
        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
        resultSet.add(new Cluster<T>(firstPoint));

        final double[] dx2 = new double[pointSet.size()];
        while (resultSet.size() < k) {
            // For each data point x, compute D(x), the distance between x and
            // the nearest center that has already been chosen.
            double sum = 0;  // Change int to double for sum to correctly accumulate squared distances.
            for (int i = 0; i < pointSet.size(); i++) {
                final T p = pointSet.get(i);
                final Cluster<T> nearest = getNearestCluster(resultSet, p);
                final double d = p.distanceFrom(nearest.getCenter());
                dx2[i] = d * d;  // Store squared distance in dx2.
                sum += dx2[i];   // Accumulate squared distances into sum.
            }

            // Add one new data point as a center. Each point x is chosen with
            // probability proportional to D(x)^2
            final double r = random.nextDouble() * sum;
            for (int i = 0; i < dx2.length; i++) {
                if (dx2[i] >= r) {
                    final T p = pointSet.remove(i);
                    resultSet.add(new Cluster<T>(p));
                    break;
                }
            }
        }

        return resultSet;

    }",0,0
422,Math_58,"public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
         return fit(new Gaussian.Parametric(), guess);
     }","public double[] fit() {
    final double[] guess;
    if (getObservations() == null || getObservations().isEmpty()) {
        throw new IllegalArgumentException(""Observations cannot be null or empty."");
    }
    try {
        guess = (new ParameterGuesser(getObservations())).guess();
    } catch (Exception e) {
        throw new RuntimeException(""Failed to guess parameters: "" + e.getMessage(), e);
    }
    try {
        return fit(new Gaussian.Parametric(), guess);
    } catch (Exception e) {
        throw new RuntimeException(""Failed to fit the model: "" + e.getMessage(), e);
    }
}",0,0
423,Math_59,"    public static float max(final float a, final float b) {
        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
    }
",Match failed,0,0
424,Math_60,"public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
         try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
         } catch (MaxIterationsExceededException ex) {
             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                 return 0;
             } else if (x > (mean + 20 * standardDeviation)) {
                 return 1;
             } else {
                 throw ex;
             }
         }
     }","public double cumulativeProbability(double x) throws MathException {
    final double dev = x - mean;
    try {
        return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0))));
    } catch (MaxIterationsExceededException ex) {
        // JDK 1.5 blows at 38 situations are not handled
        if (x < (mean - 20 * standardDeviation)) { 
            return 0.0;
        } else if (x > (mean + 20 * standardDeviation)) { 
            return 1.0;
        } else {
            throw new MathException(""Error computing erf"", ex);
        }
    }
}",0,0
425,Math_63,"    public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
","public static boolean equals(double x, double y) {
    return (Double.doubleToLongBits(x) == Double.doubleToLongBits(y));
}",0,0
426,Math_64,"@Override
    protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        // arrays shared with the other private methods
        solvedCols  = Math.min(rows, cols);
        diagR       = new double[cols];
        jacNorm     = new double[cols];
        beta        = new double[cols];
        permutation = new int[cols];
        lmDir       = new double[cols];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[cols];
        double[] oldX    = new double[cols];
        double[] oldRes  = new double[rows];
        double[] work1   = new double[cols];
        double[] work2   = new double[cols];
        double[] work3   = new double[cols];

        // evaluate the function at the starting point and calculate its norm
        updateResidualsAndCost();

        // outer loop
        lmPar = 0;
        boolean firstIteration = true;
        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
        while (true) {
            incrementIterationsCounter();

            // compute the Q.R. decomposition of the jacobian matrix
            VectorialPointValuePair previous = current;
            updateJacobian();
             qrDecomposition();
 
             // compute Qt.res
             qTy(residuals);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                jacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {

                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * point[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = Math.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (cost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // convergence has been reached
                return current;
            }

            // rescale if necessary
            for (int j = 0; j < cols; ++j) {
                diag[j] = Math.max(diag[j], jacNorm[j]);
            }

            // inner loop
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }
                double previousCost = cost;
                double[] tmpVec = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(oldRes, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = Math.sqrt(lmNorm);
                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = Math.min(delta, lmNorm);
                }

                // evaluate the function at x + p and calculate its norm
                updateResidualsAndCost();
                current = new VectorialPointValuePair(point, objective);

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * cost < previousCost) {
                    double r = cost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += jacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * Math.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < cols; ++k) {
                        double xK = diag[k] * point[k];
                        xNorm    += xK * xK;
                    }
                    xNorm = Math.sqrt(xNorm);

                    // tests for convergence.
                    // we use the vectorial convergence checker
                } else {
                    // failed iteration, reset the previous values
                    cost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }
                    tmpVec    = residuals;
                    residuals = oldRes;
                    oldRes    = tmpVec;
                }
                if (checker==null) {
                	if (((Math.abs(actRed) <= costRelativeTolerance) &&
                        (preRed <= costRelativeTolerance) &&
                        (ratio <= 2.0)) ||
                       (delta <= parRelativeTolerance * xNorm)) {
                       return current;
                   }
                } else {
                    if (checker.converged(getIterations(), previous, current)) {
                        return current;
                    }
                }
                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                            costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                            parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                            orthoTolerance);
                }

            }

        }

    }","@Override
protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    // arrays shared with the other private methods
    solvedCols  = Math.min(rows, cols);
    diagR       = new double[cols];
    jacNorm     = new double[cols];
    beta        = new double[cols];
    permutation = new int[cols];
    lmDir       = new double[cols];

    // local point
    double   delta   = 0;
    double   xNorm   = 0;
    double[] diag    = new double[cols];
    double[] oldX    = new double[cols];
    double[] oldRes  = new double[rows];
    double[] work1   = new double[cols];
    double[] work2   = new double[cols];
    double[] work3   = new double[cols];

    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();

    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
    while (true) {
        incrementIterationsCounter();

        // compute the Q.R. decomposition of the jacobian matrix
        VectorialPointValuePair previous = current;
        updateJacobian();
        qrDecomposition();

        // compute Qt.res
        qTy(residuals);

        // now we don't need Q anymore,
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }

        if (firstIteration) {

            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm  += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);

            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

        }

        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int    pj = permutation[j];
                double s  = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return current;
        }

        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }

        // inner loop
        for (double ratio = 0; ratio < 1.0e-4;) {

            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes    = tmpVec;

            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);

            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm  += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }

            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);

            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }

            // compute the scaled predicted reduction
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);

            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);

            // update the step bound
            if (ratio <= 0.25) {
                double tmp =
                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                        tmp = 0.1;
                    }
                    delta = tmp * Math.min(delta, 10.0 * lmNorm);
                    lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }

            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm    += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);

                // tests for convergence.
                // we use the vectorial convergence checker
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec    = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;
            }
            if (checker == null) {
                if (((Math.abs(actRed) <= costRelativeTolerance) &&
                        (preRed <= costRelativeTolerance) &&
                        (ratio <= 2.0)) ||
                        (delta <= parRelativeTolerance * xNorm)) {
                    return current;
                }
            } else {
                if (checker.converged(getIterations(), previous, current)) {
                    return current;
                }
            }
            // tests for termination and stringent tolerances
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                        costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                        parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16)  {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                        orthoTolerance);
            }
        }
    }
}",0,0
427,Math_69,"public RealMatrix getCorrelationPValues() throws MathException {
        TDistribution tDistribution = new TDistributionImpl(nObs - 2);
        int nVars = correlationMatrix.getColumnDimension();
        double[][] out = new double[nVars][nVars];
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < nVars; j++) {
                if (i == j) {
                    out[i][j] = 0d;
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
        return new BlockRealMatrix(out);
    }","public RealMatrix getCorrelationPValues() throws MathException {
    // Ensure the TDistribution is instantiated correctly and reuse for improved efficiency
    TDistribution tDistribution = new TDistribution(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                // P-value for diagonal elements (self-correlation) is 0
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                if (Double.isNaN(r) || r < -1 || r > 1) {
                    // Handle invalid correlation coefficient cases
                    throw new MathException(""Invalid correlation coefficient: "" + r);
                }
                double denominator = 1 - r * r;
                if (denominator == 0) {
                    // Avoid division by zero
                    out[i][j] = 0d;
                } else {
                    double t = Math.abs(r * Math.sqrt((nObs - 2) / denominator));
                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                }
            }
        }
    }
    return new BlockRealMatrix(out);
}",0,0
428,Math_7,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // get state at event time
                interpolator.setInterpolatedTime(eventT);
                 final double[] eventY = interpolator.getInterpolatedState().clone();
 
                 // advance all event states to current time
                 currentEvent.stepAccepted(eventT, eventY);
                 isLastStep = currentEvent.stop();
 
                 // handle the first part of the step, up to the event
                 for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                boolean needReset = currentEvent.reset(eventT, eventY);
                if (needReset) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    computeDerivatives(eventT, y, yDot);
                    resetOccurred = true;
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            // last part of the step, after the last event
            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();

            // initialize the events states if needed
            if (!statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occurringEvents.add(state);
                }
            }

            while (!occurringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occurringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove(); // Correctly remove the current event iterator

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // get state at event time
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState().clone();

                // advance all event states to current time
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    for (final EventState remaining : occurringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                boolean needReset = currentEvent.reset(eventT, eventY);
                if (needReset) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    computeDerivatives(eventT, y, yDot);
                    resetOccurred = true;
                    for (final EventState remaining : occurringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occurringEvents.add(currentEvent);
                }

            }

            // last part of the step, after the last event
            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState().clone(); // Ensure the state is properly cloned
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }",0,0
429,Math_70,"public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return solve(min, max);
     }","public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
    
    // Handle the initial value, possibly several fixes needed.
    setup(f, min, max, initial);
    return solve(min, max); // assuming solve(min, max) handles setup.
}",0,0
430,Math_72,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
             setResult(yMin, 0);
             return result;
         }
 
        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(f, initial, yInitial, max, yMax, initial, yInitial);
        }

        if (yMin * yMax > 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(min, 0);  // should return the x-value 'min', not the function value 'yMin'
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(max, 0);  // should return the x-value 'max', not the function value 'yMax'
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(f, initial, yInitial, max, yMax, initial, yInitial);
        }

        if (yMin * yMax > 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(f, min, yMin, max, yMax, initial, yInitial);

    }",0,0
431,Math_73,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(min, 0); // Fixed: Use ""min"" instead of ""yMin"" as the result
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(max, 0); // Fixed: Use ""max"" instead of ""yMax"" as the result
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);

    }",0,0
432,Math_74,"@Override
  public double integrate(final FirstOrderDifferentialEquations equations,
                          final double t0, final double[] y0,
                          final double t, final double[] y)
  throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart         = t0;
    double  hNew      = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      double error = 0;
      for (boolean loop = true; loop;) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
         }
 
         if (firstTime) {
           final double[] scale;
           if (vecAbsoluteTolerance == null) {
               scale = new double[y0.length];
               java.util.Arrays.fill(scale, scalAbsoluteTolerance);
             } else {
               scale = vecAbsoluteTolerance;
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
        }

        stepSize = hNew;

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error <= 1.0) {

          // discrete events handling
          interpolator.storeTime(stepStart + stepSize);
          if (manager.evaluateStep(interpolator)) {
              final double dt = manager.getEventTime() - stepStart;
              if (Math.abs(dt) <= Math.ulp(stepStart)) {
                  // rejecting the step would lead to a too small next step, we accept it
                  loop = false;
              } else {
                  // reject the step to match exactly the next switch time
                  hNew = dt;
              }
          } else {
            // accept the step
            loop = false;
          }

        } else {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              Math.min(maxGrowth,
                       Math.max(minReduction, safety * Math.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
          handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (fsal) {
        // save the last evaluation for the next step
        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
      }

      if (manager.reset(stepStart, y) && ! lastStep) {
        // some event handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      if (! lastStep) {
        // in some rare cases we may get here with stepSize = 0, for example
        // when an event occurs at integration start, reducing the first step
        // to zero; we have to reset the step to some safe non zero value
          stepSize = filterStep(stepSize, forward, true);

        // stepsize control for next step
        final double factor = Math.min(maxGrowth,
                                       Math.max(minReduction,
                                                safety * Math.pow(error, exp)));
        final double  scaledH    = stepSize * factor;
        final double  nextT      = stepStart + scaledH;
        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
        hNew = filterStep(scaledH, forward, nextIsLast);
      }

    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;

  }","@Override
public double integrate(final FirstOrderDifferentialEquations equations,
                        final double t0, final double[] y0,
                        final double t, final double[] y)
throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart         = t0;
    double  hNew      = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      double error = 0;
      while (true) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale;
          if (vecAbsoluteTolerance == null) {
            scale = new double[y0.length];
            java.util.Arrays.fill(scale, scalAbsoluteTolerance);
          } else {
            scale = vecAbsoluteTolerance;
          }
          hNew = initializeStep(equations, forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
        }

        stepSize = hNew;

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error <= 1.0) {

          // discrete events handling
          interpolator.storeTime(stepStart + stepSize);
          if (manager.evaluateStep(interpolator)) {
            final double dt = manager.getEventTime() - stepStart;
            if (Math.abs(dt) <= Math.ulp(stepStart)) {
              // rejecting the step would lead to a too small next step, we accept it
              break;
            } else {
              // reject the step to match exactly the next switch time
              hNew = dt;
            }
          } else {
            // accept the step
            break;
          }

        } else {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              Math.min(maxGrowth,
                       Math.max(minReduction, safety * Math.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (fsal) {
        // save the last evaluation for the next step
        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
      }

      if (manager.reset(stepStart, y) && !lastStep) {
        // some event handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      if (!lastStep) {
        // in some rare cases we may get here with stepSize = 0, for example
        // when an event occurs at integration start, reducing the first step
        // to zero; we have to reset the step to some safe non zero value
        stepSize = filterStep(stepSize, forward, true);

        // stepsize control for next step
        final double factor = Math.min(maxGrowth,
                                       Math.max(minReduction,
                                                safety * Math.pow(error, exp)));
        final double scaledH = stepSize * factor;
        final double nextT = stepStart + scaledH;
        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
        hNew = filterStep(scaledH, forward, nextIsLast);
      }

    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}",0,0
433,Math_75,"    public double getPct(Object v) {
        return getCumPct((Comparable<?>) v);
    }
","public double getPct(Object v) {
    if (v instanceof Comparable) {
        return getCumPct((Comparable<?>) v);
    } else {
        throw new IllegalArgumentException(""Input object is not comparable."");
    }
}",0,0
434,Math_78,"public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

    try {

        forward = interpolator.isForward();
        final double t1 = interpolator.getCurrentTime();
        final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
        final double h = (t1 - t0) / n;

        double ta = t0;
        double ga = g0;
        double tb = t0;
        for (int i = 0; i < n; ++i) {

            // evaluate handler value at the end of the substep
            tb += h;
            interpolator.setInterpolatedTime(tb);
            final double gb = handler.g(tb, interpolator.getInterpolatedState());

            // check events occurrence
            if (g0Positive ^ (gb >= 0)) {
                // there is a sign change: an event is expected during this step

                // variation direction, with respect to the integration direction
                increasing = gb >= ga;

                final UnivariateRealFunction f = new UnivariateRealFunction() {
                    public double value(final double t) throws FunctionEvaluationException {
                        try {
                            interpolator.setInterpolatedTime(t);
                            return handler.g(t, interpolator.getInterpolatedState());
                        } catch (DerivativeException e) {
                            throw new FunctionEvaluationException(e, t);
                        } catch (EventException e) {
                            throw new FunctionEvaluationException(e, t);
                        }
                    }
                };
                final BrentSolver solver = new BrentSolver();
                solver.setAbsoluteAccuracy(convergence);
                solver.setMaximalIterationCount(maxIterationCount);
                final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                if ((Math.abs(root - ta) <= convergence) &&
                        (Math.abs(root - previousEventTime) <= convergence)) {
                    // we have either found nothing or found (again ?) a past event, we simply ignore it
                    ta = tb;
                    ga = gb;
                } else if (Double.isNaN(previousEventTime) ||
                        (Math.abs(previousEventTime - root) > convergence)) {
                    pendingEventTime = root;
                    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                        // we were already waiting for this event which was
                        // found during a previous call for a step that was
                        // rejected, this step must now be accepted since it
                        // properly ends exactly at the event occurrence
                        return false;
                    }
                    // either we were not waiting for the event or it has
                    // moved in such a way the step cannot be accepted
                    pendingEvent = true;
                    return true;
                }

            } else {
                // no sign change: there is no event for now
                ta = tb;
                ga = gb;
            }

        }

        // no event during the whole step
        pendingEvent = false;
        pendingEventTime = Double.NaN;
        return false;

    } catch (FunctionEvaluationException e) {
        final Throwable cause = e.getCause();
        if ((cause != null) && (cause instanceof DerivativeException)) {
            throw (DerivativeException) cause;
        } else if ((cause != null) && (cause instanceof EventException)) {
            throw (EventException) cause;
        }
        throw new EventException(e);
    }

}",0,0
435,Math_79,"    public static double distance(int[] p1, int[] p2) {
      int sum = 0;
      for (int i = 0; i < p1.length; i++) {
          final int dp = p1[i] - p2[i];
          sum += dp * dp;
      }
      return Math.sqrt(sum);
    }
","public static double distance(int[] p1, int[] p2) {
    if (p1 == null || p2 == null || p1.length != p2.length) {
        throw new IllegalArgumentException(""Points must not be null and must have the same length"");
    }
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final int dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return Math.sqrt(sum);
}",0,0
436,Math_8,"    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
        if (sampleSize <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                    sampleSize);
        }

        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);

        for (int i = 0; i < sampleSize; i++) {
            out[i] = sample();
        }

        return out;

    }
","public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
    if (sampleSize <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);
    }

    if (singletons.isEmpty()) {
        throw new IllegalStateException(""Singletons list is empty, cannot determine array type."");
    }
  
    final T[] out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);

    for (int i = 0; i < sampleSize; i++) {
        out[i] = sample();
    }

    return out;
}",0,0
437,Math_80,"private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
             int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }
            return true;
        }
        return false;
    }","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        int j = 4 * n - 4;
        for (int i = 0; i < j; i += 4) {
            for (int k = 0; k < 4; k += step) {
                final double tmp = work[i + k];
                work[i + k] = work[j + k];
                work[j + k] = tmp;
            }
            j -= 4;
        }
        return true;
    }
    return false;
}",0,0
438,Math_82,"private Integer getPivotRow(final int col, final SimplexTableau tableau) {
        double minRatio = Double.MAX_VALUE;
        Integer minRatioPos = null;
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
             final double entry = tableau.getEntry(i, col);
             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
                 final double ratio = rhs / entry;
                 if (ratio < minRatio) {
                     minRatio = ratio;
                    minRatioPos = i; 
                }
            }
        }
        return minRatioPos;
    }","private Integer getPivotRow(final int col, final SimplexTableau tableau) {
    double minRatio = Double.MAX_VALUE;
    Integer minRatioPos = null;
    
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);
        
        // Ensure entry is positive to prevent division errors
        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {
            final double ratio = rhs / entry;
            if (ratio < minRatio) {
                minRatio = ratio;
                minRatioPos = i; 
            }
        }
    }
    
    return minRatioPos;
}",0,0
439,Math_84,"@Override
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();

            // save the original vertex
            final RealPointValuePair[] original = simplex;
            final RealPointValuePair best = original[0];

            // perform a reflection step
            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
            if (comparator.compare(reflected, best) < 0) {

                // compute the expanded simplex
                final RealPointValuePair[] reflectedSimplex = simplex;
                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
                if (comparator.compare(reflected, expanded) <= 0) {
                    // accept the reflected simplex
                    simplex = reflectedSimplex;
                }

                return;

            }

            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex

            // check convergence
                return;
            }

        }

    }","@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    while (true) {

        incrementIterationsCounter();

        // save the original vertex
        final RealPointValuePair[] original = simplex;
        final RealPointValuePair best = original[0];

        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {

            // compute the expanded simplex
            final RealPointValuePair[] reflectedSimplex = simplex;
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(reflected, expanded) <= 0) {
                // accept the expanded simplex
                simplex = new RealPointValuePair[expanded.length];
                System.arraycopy(expanded, 0, simplex, 0, expanded.length);
            } else {
                // accept the reflected simplex
                simplex = reflectedSimplex;
            }

            return;

        } else {

            // perform a contraction step
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex
                simplex = new RealPointValuePair[contracted.length];
                System.arraycopy(contracted, 0, simplex, 0, contracted.length);

                return;
            } else {
                // perform a shrink step
                shrinkSimplex(comparator, best);

                if (converged(SimplexOptimizer.simplexStartConfiguration, comparator, 
                    simplex[0])) {
                    return;
                }
            }
        }

    }
}",0,0
440,Math_85,"public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
        
        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0 ;
    
        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            
            fb = function.value(b);
            numIterations++ ;
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
         if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }
        
        return new double[]{a, b};
    }","public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
        
        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0;
        
        fa = function.value(a);
        fb = function.value(b);

        if (fa * fb <= 0.0) {
            return new double[]{a, b}; // early exit if initial values bracket the root
        }

        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            fb = function.value(b);
            numIterations++;
        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                ((a > lowerBound) || (b < upperBound)));
    
         if (fa * fb > 0.0) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }
        
        return new double[]{a, b};
    }",0,0
441,Math_86,"    public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }

    }","public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix and ensure symmetry before transformation
        for (int i = 0; i < order; ++i) {
                
            final double[] lI = lTData[i];
            
            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements for symmetry and reset lower elements to 0
            for (int j = 0; j < i; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
            }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element
            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = i + 1; q < order; ++q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }
    }",0,0
442,Math_87,"private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 if (row == null) {
                 row = i;
                 } else {
                 return null;
                 }
             }
         }
         return row;
    }","private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon)) {  // Ensure it checks for a unit value
                 if (row == null) {
                     row = i;
                 } else {
                     return null;
                 }
             } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 return null;  // Non-zero but not a unit value means not a basic column
             }
         }
         return row;
    }",0,0
443,Math_88,"protected RealPointValuePair getSolution() {
        double[] coefficients = new double[getOriginalNumDecisionVariables()];
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             if (basicRow != null) {
                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                     if (tableau.getEntry(basicRow, j) == 1) {
                          coefficients[i] = 0;
                     }
                 }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());

    for (int i = 0; i < coefficients.length; i++) {
        basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                          (restrictToNonNegative ? 0 : mostNegative);

        if (basicRow != null) {
            for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + coefficients.length; j++) { // Changed `i` to `coefficients.length`
                if (tableau.getEntry(basicRow, j) == 1 && j != i) { // Added check for j != i to ensure first variable is not set to zero incorrectly
                    coefficients[j - getNumObjectiveFunctions()] = 0; // Adjust index properly
                }
            }
        }
    }

    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,0
444,Math_89,"    public void addValue(Object v) {
            addValue((Comparable<?>) v);            
    }
","public void addValue(Object v) {
    if (v instanceof Comparable<?>) {
        addValue((Comparable<?>) v);
    } else {
        throw new IllegalArgumentException(""Object is not Comparable"");
    }
}",0,0
445,Math_9,"    public Line revert() {
        final Line reverted = new Line(zero, zero.subtract(direction));
        return reverted;
    }
",Match failed,0,0
446,Math_90,"    public void addValue(Object v) {
    
    /**
     * Adds 1 to the frequency count for v.
     * <p>
     * If other objects have already been added to this Frequency, v must
     * be comparable to those that have already been added.
     * </p>
     * 
     * @param v the value to add.
     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
     */
        Object obj = v;
        if (v instanceof Integer) {
           obj = Long.valueOf(((Integer) v).longValue());
        }
        try {
            Long count = (Long) freqTable.get(obj);
            if (count == null) {
                freqTable.put(obj, Long.valueOf(1));
            } else {
                freqTable.put(obj, Long.valueOf(count.longValue() + 1));
            }
        } catch (ClassCastException ex) {   
            //TreeMap will throw ClassCastException if v is not comparable
            throw new IllegalArgumentException(""Value not comparable to existing values."");
        }
    }","public void addValue(Object v) {
 
    /**
     * Adds 1 to the frequency count for v.
     * <p>
     * If other objects have already been added to this Frequency, v must
     * be comparable to those that have already been added.
     * </p>
     *
     * @param v the value to add.
     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
     */
    Object obj = v;
    if (v instanceof Integer) {
        obj = Long.valueOf(((Integer) v).longValue());
    }
    try {
        boolean isComparable = true;
        for (Object key : freqTable.keySet()) {
            if (!(key instanceof Comparable) || !(obj instanceof Comparable)) {
                isComparable = false;
                break;
            }
            if (((Comparable) obj).compareTo(key) != 0 && ((Comparable) key).compareTo(obj) == 0) {
                isComparable = false;
                break;
            }
        }
        if (!isComparable) {
            throw new IllegalArgumentException(""Value not comparable to existing values."");
        }
        Long count = (Long) freqTable.get(obj);
        if (count == null) {
            freqTable.put(obj, Long.valueOf(1));
        } else {
            freqTable.put(obj, Long.valueOf(count.longValue() + 1));
        }
    } catch (ClassCastException ex) {
        //TreeMap will throw ClassCastException if v is not comparable
        throw new IllegalArgumentException(""Value not comparable to existing values."");
    }
}",0,0
447,Math_91,"    public int compareTo(Fraction object) {
        double nOd = doubleValue();
        double dOn = object.doubleValue();
        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
    }
","public int compareTo(Fraction object) {
    long lhsNumerator = this.numerator * object.denominator;
    long rhsNumerator = object.numerator * this.denominator;
    
    return Long.compare(lhsNumerator, rhsNumerator);
}",0,0
448,Math_94,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }
","public static int gcd(int u, int v) {
    if (u == 0 || v == 0) {
        return Math.abs(u) + Math.abs(v);
    }

    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0) { // while u and v are both even...
        u >>= 1;
        v >>= 1;
        k++; // cast out twos.
    }

    // B2. Initialize: u and v have been divided by 2^k and at least one is odd.
    while ((u & 1) == 0) { // make u odd
        u >>= 1;
    }
    
    while ((v & 1) == 0) { // make v odd
        v >>= 1;
    }
    
    int t;
    do {
        if (u > v) {
            t = u;
            u = v;
            v = t; // make sure u <= v
        }
        
        t = v - u;
        v = t;
        
        while ((t & 1) == 0 && t != 0) { // make v odd
            v >>= 1;
        }
    } while (v != 0);

    return u << k; // gcd is u * 2^k
}",0,0
449,Math_95,"    protected double getInitialDomain(double p) {
        double ret;
        double d = getDenominatorDegreesOfFreedom();
            // use mean
            ret = d / (d - 2.0);
        return ret;
    }
","protected double getInitialDomain(double p) {
    double ret;
    double d = getDenominatorDegreesOfFreedom();
    // Ensure denominator degrees of freedom is greater than 2 to avoid division by zero or negative domain
    if (d > 2.0) {
        // use mean
        ret = d / (d - 2.0);
    } else {
        // Handle the case where degrees of freedom are not valid for mean computation
        // This could be some default behavior, such as setting ret to a sensible default value
        ret = 1.0; // Or some other appropriate default value
    }
    return ret;
}",0,0
450,Math_96,"public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else  {
            try {
                Complex rhs = (Complex)other;
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
                ret = false;
            }
        }
      
        return ret;
    }","@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null || !(other instanceof Complex)) {
        return false;
    }

    Complex rhs = (Complex) other;
    if (rhs.isNaN()) {
        return this.isNaN();
    } else {
        return Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal()) &&
               Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary());
    }
}",0,0
451,Math_97,"public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
        clearResult();
        verifyInterval(min, max);
        
        double ret = Double.NaN;
        
        double yMin = f.value(min);
        double yMax = f.value(max);
         
         // Verify bracketing
         double sign = yMin * yMax;
         if (sign >= 0) {
             // check if either value is close to a zero
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
         } else {
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
             // either min or max is a root
         }
 
         return ret;
    }","public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
        clearResult();
        verifyInterval(min, max);
        
        double yMin = f.value(min);
        double yMax = f.value(max);
         
        // Verify bracketing
        if (yMin == 0) {
            return min;
        } else if (yMax == 0) {
            return max;
        } else if (yMin * yMax > 0) {
            // neither min nor max is zero and do not bracket the root
            throw new IllegalArgumentException
                (""Function values at endpoints do not have different signs."" +
                 "" Endpoints: ["" + min + "","" + max + ""]"" + 
                 "" Values: ["" + yMin + "","" + yMax + ""]"");
        }

        // solve using the bracketed interval
        return solve(min, yMin, max, yMax, min, yMin);
    }",0,0
452,Mockito_1,"    public void captureArgumentsFrom(Invocation invocation) {
        if (invocation.getMethod().isVarArgs()) {
            int indexOfVararg = invocation.getRawArguments().length - 1;
            throw new UnsupportedOperationException();

        } else {
            for (int position = 0; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
        }

//        for (int position = 0; position < matchers.size(); position++) {
//            Matcher m = matchers.get(position);
//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {
//                //TODO SF - this whole lot can be moved captureFrom implementation
//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {
//                    Object array = invocation.getRawArguments()[position];
//                    for (int i = 0; i < Array.getLength(array); i++) {
//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));
//                    }
//                    //since we've captured all varargs already, it does not make sense to process other matchers.
//                    return;
//                } else {
//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);
//                }
//            }
//        }
    }
","public void captureArgumentsFrom(Invocation invocation) {
    if (invocation.getMethod().isVarArgs()) {
        for (int position = 0; position < matchers.size(); position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {
                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {
                    Object array = invocation.getRawArguments()[position];
                    for (int i = 0; i < Array.getLength(array); i++) {
                        ((CapturesArguments) m).captureFrom(Array.get(array, i));
                    }
                    // Since we've captured all varargs already, it does not make sense to process other matchers.
                    return;
                } else {
                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);
                }
            }
        }
    } else {
        for (int position = 0; position < matchers.size(); position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments) {
                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
            }
        }
    }
}",0,0
453,Mockito_12,"public Class getGenericType(Field field) {        
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
                 return (Class) actual;
                 //in case of nested generics we don't go deep
         }
         
         return Object.class;
    }","public Class<?> getGenericType(Field field) {
    Type generic = field.getGenericType();
    if (generic instanceof ParameterizedType) {
        Type[] actualTypes = ((ParameterizedType) generic).getActualTypeArguments();
        if (actualTypes.length > 0 && actualTypes[0] instanceof Class<?>) {
            return (Class<?>) actualTypes[0];
        }
        // Handle the case where the actual type is not a Class<?> but a type variable or generic
    }
    return Object.class;
}",0,0
454,Mockito_13,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             }
         }
         
        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }","public Object handle(Invocation invocation) throws Throwable {
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        // stubbing voids with stubVoid() or doAnswer() style
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(
            mockingProgress.getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }
    
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();

    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(
        mockingProgress.getArgumentMatcherStorage(), invocation);

    mockingProgress.validateState();

    // if verificationMode is not null then someone is doing verify()
    if (verificationMode != null) {
        // We need to check if verification was started on the correct mock 
        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
        if (verificationMode instanceof MockAwareVerificationMode) {
            MockAwareVerificationMode mockAwareMode = (MockAwareVerificationMode) verificationMode;
            if (mockAwareMode.getMock() == invocation.getMock()) {
                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
                verificationMode.verify(data);
                return null;
            } else {
                // Re-adding verification mode in case of invocation on a different mock
                mockingProgress.reportVerificationMode(verificationMode);
            }
        }
    }

    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);

    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);

    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);

        // Redo setting invocation for potential stubbing in case of partial mocks / spies
        // to avoid runtime exceptions due to incorrect invocation overwrite or validation.
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}",0,0
455,Mockito_18,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
","public Object answer(InvocationOnMock invocation) {
    if (methodsGuru.isToString(invocation.getMethod())) {
        Object mock = invocation.getMock();
        if (mock == null) {
            return null; // Ensure mock is not null to avoid NullPointerException
        }
        MockName name = mockUtil.getMockName(mock);
        if (name == null || mockUtil.getMockSettings(mock) == null) {
            return ""Mock object""; // Fallback response for missing name or settings
        }
        if (name.isDefault()) {
            return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
        } else {
            return name.toString();
        }
    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
        if (invocation == null || invocation.getArguments() == null || invocation.getArguments().length == 0) {
            return 1; // Fallback value if invocation arguments are invalid
        }
        // Ensure arguments are properly checked to avoid ArrayIndexOutOfBoundsException
        return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
    }

    if (invocation == null || invocation.getMethod() == null) {
        return null; // Return null for invalid invocation or method
    }
    Class<?> returnType = invocation.getMethod().getReturnType();
    return returnValueFor(returnType != null ? returnType : Object.class); // Ensuring returnType is not null
}",0,0
456,Mockito_20,"    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }
","public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(settings.getTypeToMock()),
                    ""  created class : "" + describeClass(mockedProxyType),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ), cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getName() + ""'"", e);
        }
    }",0,0
457,Mockito_22,"    public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }
","public static boolean areEqual(Object o1, Object o2) {
    if (o1 == o2) {
        return true;
    }
    if (o1 == null || o2 == null) {
        return false;
    }
    if (isArray(o1) && isArray(o2)) {
        return areArraysEqual(o1, o2);
    }
    return o1.equals(o2);
}",0,0
458,Mockito_24,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
","public Object answer(InvocationOnMock invocation) {
    if (invocation == null || invocation.getMethod() == null) {
        throw new IllegalArgumentException(""Invocation and method must not be null."");
    }
    if (methodsGuru.isToString(invocation.getMethod())) {
        Object mock = invocation.getMock();
        MockName name = mockUtil.getMockName(mock);
        if (name.isDefault()) {
            return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
        } else {
            return name.toString();
        }
    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
        // see issue 184.
        // mocks by default should return 0 if references are the same, otherwise some other value
        // because they are not the same. Hence we return 1 (anything but 0 is good).
        // Only for compareTo() method by the Comparable interface
        return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
    }

    Class<?> returnType = invocation.getMethod().getReturnType();
    return returnValueFor(returnType);
}",0,0
459,Mockito_26,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.util;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings(""unchecked"")
public class Primitives {
    
    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {
        if(clazz.isPrimitive()) {
            return clazz;
        }
        return (Class<T>) primitiveTypes.get(clazz);
    }

    public static boolean isPrimitiveWrapper(Class<?> type) {
        return wrapperReturnValues.containsKey(type);
    }

    public static <T> T primitiveWrapperOf(Class<T> type) {
        return (T) wrapperReturnValues.get(type);
    }

    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {
        return (T) primitiveValues.get(primitiveType);
    }
    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();
    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();

    static {
        primitiveTypes.put(Boolean.class, Boolean.TYPE);
        primitiveTypes.put(Character.class, Character.TYPE);
        primitiveTypes.put(Byte.class, Byte.TYPE);
        primitiveTypes.put(Short.class, Short.TYPE);
        primitiveTypes.put(Integer.class, Integer.TYPE);
        primitiveTypes.put(Long.class, Long.TYPE);
        primitiveTypes.put(Float.class, Float.TYPE);
        primitiveTypes.put(Double.class, Double.TYPE);
    }

    static {
        wrapperReturnValues.put(Boolean.class, false);
        wrapperReturnValues.put(Character.class, '\u0000');
        wrapperReturnValues.put(Byte.class, (byte) 0);
        wrapperReturnValues.put(Short.class, (short) 0);
        wrapperReturnValues.put(Integer.class, 0);
        wrapperReturnValues.put(Long.class, 0L);
        wrapperReturnValues.put(Float.class, 0F);
        wrapperReturnValues.put(Double.class, 0D);
    }

    static {
        primitiveValues.put(boolean.class, false);
        primitiveValues.put(char.class, '\u0000');
        primitiveValues.put(byte.class, (byte) 0);
        primitiveValues.put(short.class, (short) 0);
        primitiveValues.put(int.class, 0);
        primitiveValues.put(long.class, 0L);
        primitiveValues.put(float.class, 0F);
        primitiveValues.put(double.class, 0);
    }
}",Match failed,0,0
460,Mockito_27,"public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
         MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
         ((Factory) mock).setCallback(0, newFilter);
     }","public <T> void resetMock(T mock) {
    if (mock instanceof Factory) {
        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, 
            (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
        ((Factory) mock).setCallback(0, newFilter);
    } else {
        throw new IllegalArgumentException(""Argument is not a mock created by Mockito's mock method"");
    }
}",0,0
461,Mockito_28,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }","private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
        MockCandidate mockCandidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);
        if (mockCandidate != null) {
            mockCandidate.thenInject();
        }
    }
}",0,0
462,Mockito_29,"public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
         description.appendText(wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }","public void describeTo(Description description) {
    description.appendText(""same("");
    appendQuoting(description);
    description.appendText(String.valueOf(wanted)); // Ensure wanted.toString() is not null
    appendQuoting(description);
    description.appendText("")"");
}",0,0
463,Mockito_33,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
         	/* Avoid unnecessary cloning */
         return m1.equals(m2);
     }","public boolean hasSameMethod(Invocation candidate) {
    // not using method.equals() for 1 good reason:
    // sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
    Method m1 = invocation.getMethod();
    Method m2 = candidate.getMethod();

    /* Check if the methods are the same using other criteria, such as name and parameter types */
    return m1.getName().equals(m2.getName()) &&
           Arrays.equals(m1.getParameterTypes(), m2.getParameterTypes());
}",0,0
464,Mockito_34,"public void captureArgumentsFrom(Invocation i) {
         int k = 0;
         for (Matcher m : matchers) {
             if (m instanceof CapturesArguments) {
                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
             }
             k++;
        }
    }",Match failed,0,0
465,Mockito_38,"    private boolean safelyMatches(Matcher m, Object arg) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }
","private boolean safelyMatches(Matcher m, Object arg) {
    try {
        return m.matches(arg);
    } catch (Exception e) {
        return false;
    } catch (Error e) {
        return false;
    }
}",0,0
466,Mockito_5,"    public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }
","public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            } catch (org.mockito.exceptions.verification.ArgumentsAreDifferent e) {  // corrected package name
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }",0,0
467,Mockito_7,"        private void readTypeVariables() {
            for (Type type : typeVariable.getBounds()) {
                registerTypeVariablesOn(type);
            }
            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
        }
",Match failed,0,0
468,Mockito_8,"    protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
        }
    }
","protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable<?>[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable<?> typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(actualTypeArgument) + "")"" + ""' }"");
        }
    }",0,0
469,Time_11,"    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
    static {
        cVerbose.set(Boolean.FALSE);
    }
",static ThreadLocal<Boolean> cVerbose = ThreadLocal.withInitial(() -> Boolean.FALSE);,0,0
470,Time_14,"public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
        // overridden as superclass algorithm can't handle
        // 2004-02-29 + 48 months -> 2008-02-29 type dates
         if (valueToAdd == 0) {
             return values;
         }
             // month is largest field and being added to, such as month-day
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
            }
            instant = add(instant, valueToAdd);
            return iChronology.get(partial, instant);
        } else {
            return super.add(partial, fieldIndex, values, valueToAdd);
        }
    }","public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
        // overridden as superclass algorithm can't handle
        // 2004-02-29 + 48 months -> 2008-02-29 type dates
        if (valueToAdd == 0) {
            return values;
        }
        // month is largest field and being added to, such as month-day
        if (DateTimeUtils.isContiguous(partial)) {
            long instant = 0L;
            for (int i = 0, isize = partial.size(); i < isize; i++) {
                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
            }
            // Use the fieldIndex to properly add only to the specified field
            instant = partial.getFieldType(fieldIndex).getField(iChronology).add(instant, valueToAdd);
            return iChronology.get(partial, instant);
        } else {
            return super.add(partial, fieldIndex, values, valueToAdd);
        }
    }",0,0
471,Time_15,"public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
                 return -val1;
             case 0:
                 return 0L;
            case 1:
                return val1;
        }
        long total = val1 * val2;
        if (total / val2 != val1) {
          throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
        }
        return total;
    }","public static long safeMultiply(long val1, int val2) {
    switch (val2) {
        case -1:
            // Check for overflow case: Long.MIN_VALUE * -1
            if (val1 == Long.MIN_VALUE) {
                throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
            }
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
        default:
            long total = val1 * val2;
            if (total / val2 != val1) {
                throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
            }
            return total;
    }
}",0,0
472,Time_16,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        // Correct offset calculation by using time zone 
        long instantLocal = chrono.getZone().convertUTCToLocal(instantMillis);
        chrono = selectChronology(chrono);
         
        DateTimeParserBucket bucket = new DateTimeParserBucket(
            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        
        long computedMillis = bucket.computeMillis(false, text);
        // Ensure computedMillis is valid
        if (computedMillis == instantMillis) {
            return position; // No change in position if computedMillis did not change
        }
        instant.setMillis(computedMillis);
        
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        
        if (iZone != null) {
            instant.setZone(iZone);
        }
        
        return newPos;
    }",0,0
473,Time_17,"public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
         if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
         long local = convertUTCToLocal(instant);
         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }","public long adjustOffset(long instant, boolean earlierOrLater) {
    // a bit messy, but will work in all non-pathological cases

    // evaluate 3 hours before and after to work out if anything is happening
    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);

    if (instantBefore == instantAfter) {
        return instant;  // not an overlap (less than is a gap, equal is normal case)
    }

    // work out the range of instants that have duplicate local times
    long local = convertUTCToLocal(instant);

    // calculate result based on the flag indicating earlier or later preference
    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
}",0,0
474,Time_18,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
         // Assume date is Gregorian.
         long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (instant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist"");
            }
        }
        return instant;
    }","public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base = getBase();
        if (base != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
         // Assume date is Gregorian.
         long instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             long julianInstant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
             if (julianInstant >= iCutoverMillis) {
                 // Okay, it's in the illegal cutover gap.
                 throw new IllegalArgumentException(""Specified date does not exist"");
             }
             return julianInstant;
         }
         return instant;
    }",0,0
475,Time_19,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
        }
        return offsetAdjusted;
    }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalc the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // we need to ensure that time is always after the DST gap
        // this happens naturally for positive offsets, but not for negative
        if ((offsetLocal - offsetAdjusted) < 0) {
            // if we just return offsetAdjusted then the time is pushed
            // back before the transition, whereas it should be
            // on or after the transition
            long nextLocal = nextTransition(instantAdjusted);
            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
            if (nextLocal != nextAdjusted) {
                return offsetAdjusted; // Corrected from offsetLocal to offsetAdjusted
            }
        }
    } else if (offsetLocal > 0) {
        long prev = previousTransition(instantAdjusted);
        if (prev < instantAdjusted) {
            int offsetPrev = getOffset(prev);
            int diff = offsetPrev - offsetLocal;
            if (instantAdjusted - prev <= diff) {
                return offsetPrev;
            }
        }
    }
    return offsetAdjusted;
}",0,0
476,Time_20,"public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                     bucket.setZone(DateTimeZone.forID(id));
                     return position + id.length();
                 }
             }
             return ~position;
         }","public int parseInto(DateTimeParserBucket bucket, String text, int position) {
    if (position < 0 || position >= text.length()) {
        return ~position; // Early exit if position is out of bounds
    }

    String str = text.substring(position);
    for (String id : ALL_IDS) {
        if (str.startsWith(id)) {
            bucket.setZone(DateTimeZone.forID(id));
            return position + id.length();
        }
    }
    return ~position;
}",0,0
477,Time_22,"    protected BasePeriod(long duration) {
        this(duration, null, null);
        // bug [3264409]
    }
","protected BasePeriod(long duration) {
        super(duration, null, null);
    }",0,0
478,Time_23,"private static synchronized String getConvertedId(String id) {
        Map<String, String> map = cZoneIdConversion;
        if (map == null) {
            // Backwards compatibility with TimeZone.
            map = new HashMap<String, String>();
            map.put(""GMT"", ""UTC"");
            map.put(""MIT"", ""Pacific/Apia"");
            map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
            map.put(""AST"", ""America/Anchorage"");
            map.put(""PST"", ""America/Los_Angeles"");
            map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
             map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
             map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""WET"", ""Europe/London"");
             map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
             map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
             map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
            map.put(""AET"", ""Australia/Sydney"");
            map.put(""SST"", ""Pacific/Guadalcanal"");
            map.put(""NST"", ""Pacific/Auckland"");
            cZoneIdConversion = map;
        }
        return map.get(id);
    }","private static synchronized String getConvertedId(String id) {
     if (cZoneIdConversion == null) {
         // Backwards compatibility with TimeZone.
         Map<String, String> map = new HashMap<String, String>();
         map.put(""GMT"", ""UTC"");
         map.put(""MIT"", ""Pacific/Apia"");
         map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
         map.put(""AST"", ""America/Anchorage"");
         map.put(""PST"", ""America/Los_Angeles"");
         map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
         map.put(""PNT"", ""America/Phoenix"");
         map.put(""CST"", ""America/Chicago"");
         map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
         map.put(""IET"", ""America/Indianapolis"");
         map.put(""PRT"", ""America/Puerto_Rico"");
         map.put(""CNT"", ""America/St_Johns"");
         map.put(""AGT"", ""America/Buenos_Aires"");
         map.put(""BET"", ""America/Sao_Paulo"");
         map.put(""WET"", ""Europe/London"");
         map.put(""ECT"", ""Europe/Paris"");
         map.put(""ART"", ""Africa/Cairo"");
         map.put(""CAT"", ""Africa/Harare"");
         map.put(""EET"", ""Europe/Bucharest"");
         map.put(""EAT"", ""Africa/Addis_Ababa"");
         map.put(""MET"", ""Asia/Tehran"");
         map.put(""NET"", ""Asia/Yerevan"");
         map.put(""PLT"", ""Asia/Karachi"");
         map.put(""IST"", ""Asia/Calcutta"");
         map.put(""BST"", ""Asia/Dhaka"");
         map.put(""VST"", ""Asia/Saigon"");
         map.put(""CTT"", ""Asia/Shanghai"");
         map.put(""JST"", ""Asia/Tokyo"");
         map.put(""ACT"", ""Australia/Darwin"");
         map.put(""AET"", ""Australia/Sydney"");
         map.put(""SST"", ""Pacific/Guadalcanal"");
         map.put(""NST"", ""Pacific/Auckland"");
         cZoneIdConversion = map;
     }
     return cZoneIdConversion.get(id);
}",0,0
479,Time_24,"public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);
        if (count > 0) {
            // alter base year for parsing if first field is month or day
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }

        long millis = iMillis;
        try {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }
        
        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message =
                    ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }
        
        return millis;
    }","public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }

    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }

    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        int adjustedOffset = iZone.getOffset(millis);
        if (offset != adjustedOffset) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    
    return millis;
}",0,0
480,Time_25,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalc the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // we need to ensure that time is always after the DST gap
        // this happens naturally for positive offsets, but not for negative
        if (offsetLocal < offsetAdjusted) {
            // if we just return offsetAdjusted then the time is pushed
            // back before the transition, whereas it should be
            // on or after the transition
            long nextAdjusted = nextTransition(instantAdjusted);
            long nextLocal = nextTransition(instantLocal);
            if (nextLocal != nextAdjusted) {
                return offsetLocal;
            }
        }
    }
    return offsetAdjusted;
}",0,0
481,Time_27,"private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
        if (notPrinter && notParser) {
            throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
        }
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
            return new PeriodFormatter(null, (PeriodParser) comp[1]);
        } else if (notParser) {
            return new PeriodFormatter((PeriodPrinter) comp[0], null);
        } else {
            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
        }
    }","private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
    if (notPrinter && notParser) {
        throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
    }
    int size = elementPairs.size();
    if (size >= 2 && elementPairs.get(0) instanceof Separator) {
        Separator sep = (Separator) elementPairs.get(0);
        PeriodFormatter f = toFormatter(elementPairs.subList(1, size), notPrinter, notParser);
        sep = sep.finish(f.getPrinter(), f.getParser());
        return new PeriodFormatter(sep, sep);
    }
    Object[] comp = createComposite(elementPairs);
    if (notPrinter) {
        return new PeriodFormatter(null, (PeriodParser) comp[1]);
    } else if (notParser) {
        return new PeriodFormatter((PeriodPrinter) comp[0], null);
    } else {
        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
    }
}",0,0
482,Time_4,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                        if (compare > 0) {
                            break;
                        } else if (compare == 0) {
                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                            if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
             Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }

        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, iTypes.length - i);
        System.arraycopy(iValues, i, newValues, i + 1, iValues.length - i);

        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }

    if (value == getValue(index)) {
        return this;
    }

    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}",0,0
483,Time_5,"public Period normalizedStandard(PeriodType type) {
        type = DateTimeUtils.getPeriodType(type);
        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
             years = FieldUtils.safeAdd(years, months / 12);
             months = months % 12;
             if (years != 0) {
                 result = result.withYears(years);
             }
             if (months != 0) {
                 result = result.withMonths(months);
             }
         }
         return result;
    }","public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
    millis += (getSeconds() * (long) DateTimeConstants.MILLIS_PER_SECOND);
    millis += (getMinutes() * (long) DateTimeConstants.MILLIS_PER_MINUTE);
    millis += (getHours() * (long) DateTimeConstants.MILLIS_PER_HOUR);
    millis += (getDays() * (long) DateTimeConstants.MILLIS_PER_DAY);
    millis += (getWeeks() * (long) DateTimeConstants.MILLIS_PER_WEEK);

    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
    int years = getYears();
    int months = getMonths();

    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;
    }

    if (years != 0) {
        result = result.withYears(years);
    }
    if (months != 0) {
        result = result.withMonths(months);
    }
    
    return result;
}",0,0
484,Time_7,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }

        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
        chrono = selectChronology(chrono);
        int defaultYear = chrono.year().get(instantLocal);

        DateTimeParserBucket bucket = new DateTimeParserBucket(
            instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);

        if (newPos < 0) {
            return newPos; // Return immediately if parsing fails
        }

        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }",0,0
485,Time_8,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
        if (hoursOffset == 0 && minutesOffset == 0) {
            return DateTimeZone.UTC;
        }
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                 minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }",Match failed,0,0
