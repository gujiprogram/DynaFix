ID,slug,bug,fix,width_attempt,iteration
0,Chart_1,"public LegendItemCollection getLegendItems() {
        LegendItemCollection result = new LegendItemCollection();
        if (this.plot == null) {
            return result;
         }
         int index = this.plot.getIndexOf(this);
         CategoryDataset dataset = this.plot.getDataset(index);
         if (dataset != null) {
             return result;
         }
         int seriesCount = dataset.getRowCount();
        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {
            for (int i = 0; i < seriesCount; i++) {
                if (isSeriesVisibleInLegend(i)) {
                    LegendItem item = getLegendItem(index, i);
                    if (item != null) {
                        result.add(item);
                    }
                }
            }
        }
        else {
            for (int i = seriesCount - 1; i >= 0; i--) {
                if (isSeriesVisibleInLegend(i)) {
                    LegendItem item = getLegendItem(index, i);
                    if (item != null) {
                        result.add(item);
                    }
                }
            }
        }
        return result;
    }","public LegendItemCollection getLegendItems() {
    LegendItemCollection result = new LegendItemCollection();
    if (this.plot == null) {
        return result;
    }
    int index = this.plot.getIndexOf(this);
    CategoryDataset dataset = this.plot.getDataset(index);
    if (dataset == null) {
        return result;
    }
    int seriesCount = dataset.getRowCount();
    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {
        for (int i = 0; i < seriesCount; i++) {
            if (isSeriesVisibleInLegend(i)) {
                LegendItem item = getLegendItem(index, i);
                if (item != null) {
                    result.add(item);
                }
            }
        }
    } else {
        for (int i = seriesCount - 1; i >= 0; i--) {
            if (isSeriesVisibleInLegend(i)) {
                LegendItem item = getLegendItem(index, i);
                if (item != null) {
                    result.add(item);
                }
            }
        }
    }
    return result;
}",0,0
1,Chart_10,"    public String generateToolTipFragment(String toolTipText) {
        return "" title=\"""" + toolTipText
            + ""\"" alt=\""\"""";
    }
","public String generateToolTipFragment(String toolTipText) {
        if (toolTipText == null) {
            toolTipText = """";
        }
        return "" title=\"""" + escapeHtml(toolTipText)
            + ""\"" alt=\""\"""";
    }
    
private String escapeHtml(String text) {
        if (text == null) {
            return """";
        }
        return text.replace(""&"", ""&amp;"")
                   .replace(""<"", ""&lt;"")
                   .replace("">"", ""&gt;"")
                   .replace(""\"""", ""&quot;"")
                   .replace(""'"", ""&#x27;"")
                   .replace(""/"", ""&#x2F;"");
    }",0,0
2,Chart_11,"public static boolean equal(GeneralPath p1, GeneralPath p2) {
        if (p1 == null) {
            return (p2 == null);
        }
        if (p2 == null) {
            return false;
        }
        if (p1.getWindingRule() != p2.getWindingRule()) {
             return false;
         }
         PathIterator iterator1 = p1.getPathIterator(null);
         PathIterator iterator2 = p1.getPathIterator(null);
         double[] d1 = new double[6];
         double[] d2 = new double[6];
         boolean done = iterator1.isDone() && iterator2.isDone();
        while (!done) {
            if (iterator1.isDone() != iterator2.isDone()) {
                return false;
            }
            int seg1 = iterator1.currentSegment(d1);
            int seg2 = iterator2.currentSegment(d2);
            if (seg1 != seg2) {
                return false;
            }
            if (!Arrays.equals(d1, d2)) {
                return false;
            }
            iterator1.next();
            iterator2.next();
            done = iterator1.isDone() && iterator2.isDone();
        }
        return true;
    }","public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p2.getPathIterator(null); // Corrected: p2 instead of p1

    double[] d1 = new double[6];
    double[] d2 = new double[6];

    while (!iterator1.isDone() && !iterator2.isDone()) { // Corrected: stop when either iterator is done
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
    }
    return iterator1.isDone() && iterator2.isDone(); // Corrected: check both iterators are done
}",0,0
3,Chart_12,"    public MultiplePiePlot(CategoryDataset dataset) {
        super();
        this.dataset = dataset;
        PiePlot piePlot = new PiePlot(null);
        this.pieChart = new JFreeChart(piePlot);
        this.pieChart.removeLegend();
        this.dataExtractOrder = TableOrder.BY_COLUMN;
        this.pieChart.setBackgroundPaint(null);
        TextTitle seriesTitle = new TextTitle(""Series Title"",
                new Font(""SansSerif"", Font.BOLD, 12));
        seriesTitle.setPosition(RectangleEdge.BOTTOM);
        this.pieChart.setTitle(seriesTitle);
        this.aggregatedItemsKey = ""Other"";
        this.aggregatedItemsPaint = Color.lightGray;
        this.sectionPaints = new HashMap();
    }
","public MultiplePiePlot(CategoryDataset dataset) {
    super();
    this.dataset = dataset;
    PiePlot piePlot = new PiePlot((dataset != null && !dataset.getRowKeys().isEmpty()) ? dataset : null);
    this.pieChart = new JFreeChart(piePlot);
    this.pieChart.removeLegend();
    this.dataExtractOrder = TableOrder.BY_COLUMN;
    this.pieChart.setBackgroundPaint(Color.white); // Set to a default color instead of null
    TextTitle seriesTitle = new TextTitle(""Series Title"",
        new Font(""SansSerif"", Font.BOLD, 12));
    seriesTitle.setPosition(RectangleEdge.BOTTOM);
    this.pieChart.setTitle(seriesTitle);
    this.aggregatedItemsKey = ""Other"";
    this.aggregatedItemsPaint = Color.lightGray;
    this.sectionPaints = new HashMap<>();
}",0,0
4,Chart_13,"protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                               RectangleConstraint constraint) {
        double[] w = new double[5];
        double[] h = new double[5];
        w[0] = constraint.getWidth();
        if (this.topBlock != null) {
            RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0,
                    new Range(0.0, constraint.getHeight()),
                    LengthConstraintType.RANGE);
            Size2D size = this.topBlock.arrange(g2, c1);
            h[0] = size.height;
        }
        w[1] = w[0];
        if (this.bottomBlock != null) {
            RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0, new Range(0.0,
                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
            Size2D size = this.bottomBlock.arrange(g2, c2);
            h[1] = size.height;
        }
        h[2] = constraint.getHeight() - h[1] - h[0];
        if (this.leftBlock != null) {
            RectangleConstraint c3 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth()),
                    LengthConstraintType.RANGE, h[2], null,
                    LengthConstraintType.FIXED);
            Size2D size = this.leftBlock.arrange(g2, c3);
            w[2] = size.width;
        }
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                     new Range(0.0, constraint.getWidth() - w[2]),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
            w[3] = size.width;
        }
        h[4] = h[2];
        w[4] = constraint.getWidth() - w[3] - w[2];
        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
        if (this.centerBlock != null) {
            this.centerBlock.arrange(g2, c5);
        }

        if (this.topBlock != null) {
            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],
                    h[0]));
        }
        if (this.bottomBlock != null) {
            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],
                    w[1], h[1]));
        }
        if (this.leftBlock != null) {
            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
                    h[2]));
        }
        if (this.rightBlock != null) {
            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],
                    w[3], h[3]));
        }
        if (this.centerBlock != null) {
            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],
                    h[4]));
        }
        return new Size2D(constraint.getWidth(), constraint.getHeight());
    }","protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                               RectangleConstraint constraint) {
        double[] w = new double[5];
        double[] h = new double[5];
        w[0] = constraint.getWidth();
        h[0] = 0.0;
        if (this.topBlock != null) {
            RectangleConstraint c1 = new RectangleConstraint(w[0], 
                    LengthConstraintType.FIXED, 0.0,
                    new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE);
            Size2D size = this.topBlock.arrange(g2, c1);
            h[0] = size.height;
        }
        w[1] = w[0];
        h[1] = 0.0;
        if (this.bottomBlock != null) {
            RectangleConstraint c2 = new RectangleConstraint(w[0], 
                    LengthConstraintType.FIXED, 0.0, new Range(0.0,
                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
            Size2D size = this.bottomBlock.arrange(g2, c2);
            h[1] = size.height;
        }
        h[2] = Math.max(0.0, constraint.getHeight() - h[1] - h[0]);
        w[2] = 0.0;
        if (this.leftBlock != null) {
            RectangleConstraint c3 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], 
                    LengthConstraintType.FIXED);
            Size2D size = this.leftBlock.arrange(g2, c3);
            w[2] = size.width;
        }
        h[3] = h[2];
        w[3] = 0.0;
        if (this.rightBlock != null) {
            RectangleConstraint c4 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, 
                    h[2], LengthConstraintType.FIXED);
            Size2D size = this.rightBlock.arrange(g2, c4);
            w[3] = size.width;
        }
        h[4] = h[2];
        w[4] = Math.max(0.0, constraint.getWidth() - w[3] - w[2]);
        if (this.centerBlock != null) {
            RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
            this.centerBlock.arrange(g2, c5);
        }

        if (this.topBlock != null) {
            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0]));
        }
        if (this.bottomBlock != null) {
            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1]));
        }
        if (this.leftBlock != null) {
            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2]));
        }
        if (this.rightBlock != null) {
            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3]));
        }
        if (this.centerBlock != null) {
            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4]));
        }
        return new Size2D(constraint.getWidth(), constraint.getHeight());
    }",0,0
5,Chart_17,"    public Object clone() throws CloneNotSupportedException {
        Object clone = createCopy(0, getItemCount() - 1);
        return clone;
    }
","public Object clone() throws CloneNotSupportedException {
        Object clone = createCopy(0, Math.max(0, getItemCount() - 1));
        return clone;
}",0,0
6,Chart_20,"    public ValueMarker(double value, Paint paint, Stroke stroke, 
                       Paint outlinePaint, Stroke outlineStroke, float alpha) {
        super(paint, stroke, paint, stroke, alpha);
        this.value = value;
    }
","public ValueMarker(double value, Paint paint, Stroke stroke, 
                       Paint outlinePaint, Stroke outlineStroke, float alpha) {
        super(paint, stroke, outlinePaint, outlineStroke, alpha);
        this.value = value;
    }",0,0
7,Chart_24,"public Paint getPaint(double value) {
         double v = Math.max(value, this.lowerBound);
         v = Math.min(v, this.upperBound);
         int g = (int) ((value - this.lowerBound) / (this.upperBound 
                 - this.lowerBound) * 255.0);
         return new Color(g, g, g);
     }",Match failed,0,0
8,Chart_26,"    protected AxisState drawLabel(String label, Graphics2D g2, 
            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, 
            AxisState state, PlotRenderingInfo plotState) {

        // it is unlikely that 'state' will be null, but check anyway...
        if (state == null) {
            throw new IllegalArgumentException(""Null 'state' argument."");
        }
        
        if ((label == null) || (label.equals(""""))) {
            return state;
        }

        Font font = getLabelFont();
        RectangleInsets insets = getLabelInsets();
        g2.setFont(font);
        g2.setPaint(getLabelPaint());
        FontMetrics fm = g2.getFontMetrics();
        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);
        Shape hotspot = null;
        
        if (edge == RectangleEdge.TOP) {
            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle(), labelBounds.getCenterX(), 
                    labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) dataArea.getCenterX();
            float labely = (float) (state.getCursor() - insets.getBottom() 
                    - h / 2.0);
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorUp(insets.getTop() + labelBounds.getHeight() 
                    + insets.getBottom());
        }
        else if (edge == RectangleEdge.BOTTOM) {
            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle(), labelBounds.getCenterX(), 
                    labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) dataArea.getCenterX();
            float labely = (float) (state.getCursor() + insets.getTop() 
                    + h / 2.0);
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorDown(insets.getTop() + labelBounds.getHeight() 
                    + insets.getBottom());
        }
        else if (edge == RectangleEdge.LEFT) {
            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), 
                    labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) (state.getCursor() - insets.getRight() 
                    - w / 2.0);
            float labely = (float) dataArea.getCenterY();
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, 
                    TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() 
                    + insets.getRight());
        }
        else if (edge == RectangleEdge.RIGHT) {

            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle() + Math.PI / 2.0, 
                    labelBounds.getCenterX(), labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) (state.getCursor() 
                            + insets.getLeft() + w / 2.0);
            float labely = (float) (dataArea.getY() + dataArea.getHeight() 
                    / 2.0);
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, 
                    TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorRight(insets.getLeft() + labelBounds.getWidth() 
                    + insets.getRight());

        }
        if (plotState != null && hotspot != null) {
            ChartRenderingInfo owner = plotState.getOwner();
                EntityCollection entities = owner.getEntityCollection();
                if (entities != null) {
                    entities.add(new AxisLabelEntity(this, hotspot, 
                            this.labelToolTip, this.labelURL));
                }
        }
        return state;

    }
","protected AxisState drawLabel(String label, Graphics2D g2, 
        Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, 
        AxisState state, PlotRenderingInfo plotState) {

    if (state == null) {
        throw new IllegalArgumentException(""Null 'state' argument."");
    }
    
    if ((label == null) || (label.isEmpty())) {
        return state;
    }

    Font font = getLabelFont();
    RectangleInsets insets = getLabelInsets();
    g2.setFont(font);
    g2.setPaint(getLabelPaint());
    FontMetrics fm = g2.getFontMetrics();
    Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);
    Shape hotspot = null;
    
    double labelAngle = getLabelAngle();
    double labelX = dataArea.getCenterX();
    double labelY;
    double w, h;
    AffineTransform t;
    
    switch (edge) {
        case TOP:
            t = AffineTransform.getRotateInstance(labelAngle, labelBounds.getCenterX(), labelBounds.getCenterY());
            labelBounds = t.createTransformedShape(labelBounds).getBounds2D();
            w = labelBounds.getWidth();
            h = labelBounds.getHeight();
            labelY = state.getCursor() - insets.getBottom() - h / 2.0;
            TextUtilities.drawRotatedString(label, g2, (float) labelX, (float) labelY,
                TextAnchor.CENTER, labelAngle, TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float((float) (labelX - w / 2.0), (float) (labelY - h / 2.0), (float) w, (float) h);
            state.cursorUp(insets.getTop() + h + insets.getBottom());
            break;
        case BOTTOM:
            t = AffineTransform.getRotateInstance(labelAngle, labelBounds.getCenterX(), labelBounds.getCenterY());
            labelBounds = t.createTransformedShape(labelBounds).getBounds2D();
            w = labelBounds.getWidth();
            h = labelBounds.getHeight();
            labelY = state.getCursor() + insets.getTop() + h / 2.0;
            TextUtilities.drawRotatedString(label, g2, (float) labelX, (float) labelY,
                TextAnchor.CENTER, labelAngle, TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float((float) (labelX - w / 2.0), (float) (labelY - h / 2.0), (float) w, (float) h);
            state.cursorDown(insets.getTop() + h + insets.getBottom());
            break;
        case LEFT:
            t = AffineTransform.getRotateInstance(labelAngle - Math.PI / 2.0, labelBounds.getCenterX(), labelBounds.getCenterY());
            labelBounds = t.createTransformedShape(labelBounds).getBounds2D();
            w = labelBounds.getWidth();
            h = labelBounds.getHeight();
            labelX = state.getCursor() - insets.getRight() - w / 2.0;
            labelY = dataArea.getCenterY();
            TextUtilities.drawRotatedString(label, g2, (float) labelX, (float) labelY,
                TextAnchor.CENTER, labelAngle - Math.PI / 2.0, TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float((float) (labelX - w / 2.0), (float) (labelY - h / 2.0), (float) w, (float) h);
            state.cursorLeft(insets.getLeft() + w + insets.getRight());
            break;
        case RIGHT:
            t = AffineTransform.getRotateInstance(labelAngle + Math.PI / 2.0, labelBounds.getCenterX(), labelBounds.getCenterY());
            labelBounds = t.createTransformedShape(labelBounds).getBounds2D();
            w = labelBounds.getWidth();
            h = labelBounds.getHeight();
            labelX = state.getCursor() + insets.getLeft() + w / 2.0;
            labelY = dataArea.getCenterY();
            TextUtilities.drawRotatedString(label, g2, (float) labelX, (float) labelY,
                TextAnchor.CENTER, labelAngle + Math.PI / 2.0, TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float((float) (labelX - w / 2.0), (float) (labelY - h / 2.0), (float) w, (float) h);
            state.cursorRight(insets.getLeft() + w + insets.getRight());
            break;
    }

    if (plotState != null && hotspot != null) {
        ChartRenderingInfo owner = plotState.getOwner();
        EntityCollection entities = owner.getEntityCollection();
        if (entities != null) {
            entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL));
        }
    }
    return state;
}",0,0
9,Chart_3,"public TimeSeries createCopy(int start, int end)
            throws CloneNotSupportedException {
        if (start < 0) {
            throw new IllegalArgumentException(""Requires start >= 0."");
        }
        if (end < start) {
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
                TimeSeriesDataItem item
                        = (TimeSeriesDataItem) this.data.get(index);
                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
                try {
                    copy.add(clone);
                }
                catch (SeriesException e) {
                    e.printStackTrace();
                }
            }
        }
        return copy;
    }","public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {
    if (start < 0) {
        throw new IllegalArgumentException(""Requires start >= 0."");
    }
    if (end < start) {
        throw new IllegalArgumentException(""Requires start <= end."");
    }
    // Ensure the end does not exceed the available data size
    if (end >= this.data.size()) {
        throw new IllegalArgumentException(""End index exceeds data size."");
    }
    
    TimeSeries copy = (TimeSeries) super.clone();
    copy.data = new java.util.ArrayList<>();
    if (this.data.size() > 0) {
        for (int index = start; index <= end; index++) {
            TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);
            TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
            try {
                copy.add(clone);
            } catch (SeriesException e) {
                e.printStackTrace();
            }
        }
    }
    return copy;
}",0,0
10,Chart_4,"    public Range getDataRange(ValueAxis axis) {

        Range result = null;
        List mappedDatasets = new ArrayList();
        List includedAnnotations = new ArrayList();
        boolean isDomainAxis = true;

        // is it a domain axis?
        int domainIndex = getDomainAxisIndex(axis);
        if (domainIndex >= 0) {
            isDomainAxis = true;
            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(
                    new Integer(domainIndex)));
            if (domainIndex == 0) {
                // grab the plot's annotations
                Iterator iterator = this.annotations.iterator();
                while (iterator.hasNext()) {
                    XYAnnotation annotation = (XYAnnotation) iterator.next();
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }

        // or is it a range axis?
        int rangeIndex = getRangeAxisIndex(axis);
        if (rangeIndex >= 0) {
            isDomainAxis = false;
            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(
                    new Integer(rangeIndex)));
            if (rangeIndex == 0) {
                Iterator iterator = this.annotations.iterator();
                while (iterator.hasNext()) {
                    XYAnnotation annotation = (XYAnnotation) iterator.next();
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }

        // iterate through the datasets that map to the axis and get the union
        // of the ranges.
        Iterator iterator = mappedDatasets.iterator();
        while (iterator.hasNext()) {
            XYDataset d = (XYDataset) iterator.next();
            if (d != null) {
                XYItemRenderer r = getRendererForDataset(d);
                if (isDomainAxis) {
                    if (r != null) {
                        result = Range.combine(result, r.findDomainBounds(d));
                    }
                    else {
                        result = Range.combine(result,
                                DatasetUtilities.findDomainBounds(d));
                    }
                }
                else {
                    if (r != null) {
                        result = Range.combine(result, r.findRangeBounds(d));
                    }
                    else {
                        result = Range.combine(result,
                                DatasetUtilities.findRangeBounds(d));
                    }
                }
                
                    Collection c = r.getAnnotations();
                    Iterator i = c.iterator();
                    while (i.hasNext()) {
                        XYAnnotation a = (XYAnnotation) i.next();
                        if (a instanceof XYAnnotationBoundsInfo) {
                            includedAnnotations.add(a);
                        }
                    }
            }
        }

        Iterator it = includedAnnotations.iterator();
        while (it.hasNext()) {
            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();
            if (xyabi.getIncludeInDataBounds()) {
                if (isDomainAxis) {
                    result = Range.combine(result, xyabi.getXRange());
                }
                else {
                    result = Range.combine(result, xyabi.getYRange());
                }
            }
        }

        return result;

    }","public Range getDataRange(ValueAxis axis) {

    Range result = null;
    List mappedDatasets = new ArrayList();
    List includedAnnotations = new ArrayList();
    boolean isDomainAxis = true;

    // is it a domain axis?
    int domainIndex = getDomainAxisIndex(axis);
    if (domainIndex >= 0) {
        isDomainAxis = true;
        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(
                new Integer(domainIndex)));
        if (domainIndex == 0) {
            // grab the plot's annotations
            Iterator iterator = this.annotations.iterator();
            while (iterator.hasNext()) {
                XYAnnotation annotation = (XYAnnotation) iterator.next();
                if (annotation instanceof XYAnnotationBoundsInfo) {
                    includedAnnotations.add(annotation);
                }
            }
        }
    }

    // or is it a range axis?
    int rangeIndex = getRangeAxisIndex(axis);
    if (rangeIndex >= 0) {
        isDomainAxis = false;
        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(
                new Integer(rangeIndex)));
        if (rangeIndex == 0) {
            Iterator iterator = this.annotations.iterator();
            while (iterator.hasNext()) {
                XYAnnotation annotation = (XYAnnotation) iterator.next();
                if (annotation instanceof XYAnnotationBoundsInfo) {
                    includedAnnotations.add(annotation);
                }
            }
        }
    }

    // iterate through the datasets that map to the axis and get the union
    // of the ranges.
    Iterator iterator = mappedDatasets.iterator();
    while (iterator.hasNext()) {
        XYDataset d = (XYDataset) iterator.next();
        if (d != null) {
            XYItemRenderer r = getRendererForDataset(d);
            if (isDomainAxis) {
                if (r != null) {
                    result = Range.combine(result, r.findDomainBounds(d));
                }
                else {
                    result = Range.combine(result,
                            DatasetUtilities.findDomainBounds(d));
                }
            }
            else {
                if (r != null) {
                    result = Range.combine(result, r.findRangeBounds(d));
                }
                else {
                    result = Range.combine(result,
                            DatasetUtilities.findRangeBounds(d));
                }
            }
            
            Collection c = r != null ? r.getAnnotations() : Collections.emptyList();
            Iterator i = c.iterator();
            while (i.hasNext()) {
                XYAnnotation a = (XYAnnotation) i.next();
                if (a instanceof XYAnnotationBoundsInfo) {
                    includedAnnotations.add(a);
                }
            }
        }
    }

    Iterator it = includedAnnotations.iterator();
    while (it.hasNext()) {
        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();
        if (xyabi.getIncludeInDataBounds()) {
            if (isDomainAxis) {
                result = Range.combine(result, xyabi.getXRange());
            }
            else {
                result = Range.combine(result, xyabi.getYRange());
            }
        }
    }

    return result;

}",0,0
11,Chart_5,"public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
         if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
            }
            catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
        else {
            // if the series is sorted, the negative index is a result from
            // Collections.binarySearch() and tells us where to insert the
            // new item...otherwise it will be just -1 and we should just
            // append the value to the list...
            if (this.autoSort) {
                this.data.add(-index - 1, new XYDataItem(x, y));
            }
            else {
                this.data.add(new XYDataItem(x, y));
            }
            // check if this addition will exceed the maximum item count...
            if (getItemCount() > this.maximumItemCount) {
                this.data.remove(0);
            }
        }
        fireSeriesChanged();
        return overwritten;
    }","public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }
    
    XYDataItem overwritten = null;
    int index = indexOf(x);
    if (index >= 0) {
        if (!this.allowDuplicateXValues) {
            XYDataItem existing = (XYDataItem) this.data.get(index);
            try {
                overwritten = (XYDataItem) existing.clone();
            } catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
    } else {
        if (this.autoSort) {
            this.data.add(-index - 1, new XYDataItem(x, y));
        } else {
            this.data.add(new XYDataItem(x, y));
        }
        if (getItemCount() > this.maximumItemCount) {
            this.data.remove(0);
        }
    }
    fireSeriesChanged();
    return overwritten;
}",0,0
11,Chart_5,"public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
         if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
            }
            catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
        else {
            // if the series is sorted, the negative index is a result from
            // Collections.binarySearch() and tells us where to insert the
            // new item...otherwise it will be just -1 and we should just
            // append the value to the list...
            if (this.autoSort) {
                this.data.add(-index - 1, new XYDataItem(x, y));
            }
            else {
                this.data.add(new XYDataItem(x, y));
            }
            // check if this addition will exceed the maximum item count...
            if (getItemCount() > this.maximumItemCount) {
                this.data.remove(0);
            }
        }
        fireSeriesChanged();
        return overwritten;
    }","public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }

    XYDataItem overwritten = null;
    boolean duplicateHandled = false;
    int index = indexOf(x);

    if (index >= 0) {
        if (!this.allowDuplicateXValues) {
            XYDataItem existing = (XYDataItem) this.data.get(index);
            try {
                overwritten = (XYDataItem) existing.clone();
            } catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
            duplicateHandled = true;
        }
    }
    
    if (!duplicateHandled) {
        XYDataItem newItem = new XYDataItem(x, y);
        if (this.autoSort) {
            this.data.add(-index - 1, newItem);
        } else {
            this.data.add(newItem);
        }
        while (getItemCount() > this.maximumItemCount) {
            this.data.remove(0);
        }
    }
    
    fireSeriesChanged();
    return overwritten;
}",0,1
11,Chart_5,"public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
         if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
            }
            catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
        else {
            // if the series is sorted, the negative index is a result from
            // Collections.binarySearch() and tells us where to insert the
            // new item...otherwise it will be just -1 and we should just
            // append the value to the list...
            if (this.autoSort) {
                this.data.add(-index - 1, new XYDataItem(x, y));
            }
            else {
                this.data.add(new XYDataItem(x, y));
            }
            // check if this addition will exceed the maximum item count...
            if (getItemCount() > this.maximumItemCount) {
                this.data.remove(0);
            }
        }
        fireSeriesChanged();
        return overwritten;
    }","public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }
    
    XYDataItem overwritten = null;
    int index = indexOf(x);
    if (index >= 0) {
        if (!this.allowDuplicateXValues) {
            XYDataItem existing = (XYDataItem) this.data.get(index);
            try {
                overwritten = (XYDataItem) existing.clone();
            } catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
    } else {
        XYDataItem newItem = new XYDataItem(x, y);
        if (this.autoSort) {
            // Ensure insertion index is valid for sorted list to avoid IndexOutOfBoundsException
            index = Math.max(-index - 1, 0);
            this.data.add(index, newItem);
        } else {
            this.data.add(newItem);
        }
        while (getItemCount() > this.maximumItemCount) {
            this.data.remove(0);
        }
    }
    fireSeriesChanged();
    return overwritten;
}",0,2
12,Chart_6,"public boolean equals(Object obj) {

        if (obj == this) {
            return true;
        }
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }","public boolean equals(Object obj) {

    if (obj == this) {
        return true;
    }
    if (obj == null || !(obj instanceof ShapeList)) {
        return false;
    }
    return super.equals(obj);

}",0,0
12,Chart_6,"public boolean equals(Object obj) {

        if (obj == this) {
            return true;
        }
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }","public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof ShapeList)) {
        return false;
    }
    ShapeList other = (ShapeList) obj;
    // Compare the contents of the lists explicitly for equality
    return this.size() == other.size() && this.containsAll(other) && other.containsAll(this);
}",0,1
13,Chart_7,"private void updateBounds(TimePeriod period, int index) {
        
        long start = period.getStart().getTime();
        long end = period.getEnd().getTime();
        long middle = start + ((end - start) / 2);

        if (this.minStartIndex >= 0) {
            long minStart = getDataItem(this.minStartIndex).getPeriod()
                .getStart().getTime();
            if (start < minStart) {
                this.minStartIndex = index;           
            }
        }
        else {
            this.minStartIndex = index;
        }
        
        if (this.maxStartIndex >= 0) {
            long maxStart = getDataItem(this.maxStartIndex).getPeriod()
                .getStart().getTime();
            if (start > maxStart) {
                this.maxStartIndex = index;           
            }
        }
        else {
            this.maxStartIndex = index;
        }
        
        if (this.minMiddleIndex >= 0) {
            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                .getTime();
            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                .getTime();
            long minMiddle = s + (e - s) / 2;
            if (middle < minMiddle) {
                this.minMiddleIndex = index;           
            }
        }
        else {
            this.minMiddleIndex = index;
        }
        
        if (this.maxMiddleIndex >= 0) {
            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                .getTime();
            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                .getTime();
            long maxMiddle = s + (e - s) / 2;
            if (middle > maxMiddle) {
                this.maxMiddleIndex = index;           
            }
        }
        else {
            this.maxMiddleIndex = index;
        }
        
        if (this.minEndIndex >= 0) {
            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()
                .getTime();
            if (end < minEnd) {
                this.minEndIndex = index;           
            }
        }
        else {
            this.minEndIndex = index;
        }
       
        if (this.maxEndIndex >= 0) {
            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()
                .getTime();
            if (end > maxEnd) {
                this.maxEndIndex = index;           
            }
        }
        else {
            this.maxEndIndex = index;
        }
        
    }","private void updateBounds(TimePeriod period, int index) {

    long start = period.getStart().getTime();
    long end = period.getEnd().getTime();
    long middle = start + ((end - start) / 2);

    if (this.minStartIndex >= 0) {
        long minStart = getDataItem(this.minStartIndex).getPeriod().getStart().getTime();
        if (start < minStart) {
            this.minStartIndex = index;
        }
    } else {
        this.minStartIndex = index;
    }

    if (this.maxStartIndex >= 0) {
        long maxStart = getDataItem(this.maxStartIndex).getPeriod().getStart().getTime();
        if (start > maxStart) {
            this.maxStartIndex = index;
        }
    } else {
        this.maxStartIndex = index;
    }

    if (this.minMiddleIndex >= 0) {
        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime();
        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime();
        long minMiddle = s + ((e - s) / 2);  // Corrected operator precedence for clarity
        if (middle < minMiddle) {
            this.minMiddleIndex = index;
        }
    } else {
        this.minMiddleIndex = index;
    }

    if (this.maxMiddleIndex >= 0) {
        long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime();
        long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd().getTime();  // Corrected the variable used
        long maxMiddle = s + ((e - s) / 2);  // Corrected operator precedence for clarity
        if (middle > maxMiddle) {
            this.maxMiddleIndex = index;
        }
    } else {
        this.maxMiddleIndex = index;
    }

    if (this.minEndIndex >= 0) {
        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd().getTime();
        if (end < minEnd) {
            this.minEndIndex = index;
        }
    } else {
        this.minEndIndex = index;
    }

    if (this.maxEndIndex >= 0) {
        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd().getTime();
        if (end > maxEnd) {
            this.maxEndIndex = index;
        }
    } else {
        this.maxEndIndex = index;
    }
}",0,0
14,Chart_8,"    public Week(Date time, TimeZone zone) {
        // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
    }
","public Week(Date time, TimeZone zone) {
    // Check for null arguments to ensure robustness
    if (time == null) {
        throw new IllegalArgumentException(""Null 'time' argument."");
    }
    if (zone == null) {
        throw new IllegalArgumentException(""Null 'zone' argument."");
    }
    this(time, zone, Locale.getDefault());
}",0,0
15,Chart_9,"public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

        if (start == null) {
            throw new IllegalArgumentException(""Null 'start' argument."");
        }
        if (end == null) {
            throw new IllegalArgumentException(""Null 'end' argument."");
        }
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(
                    ""Requires start on or before end."");
        }
        boolean emptyRange = false;
        int startIndex = getIndex(start);
        if (startIndex < 0) {
            startIndex = -(startIndex + 1);
            if (startIndex == this.data.size()) {
                emptyRange = true;  // start is after last data item
            }
        }
        int endIndex = getIndex(end);
        if (endIndex < 0) {             // end period is not in original series
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
         if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
            TimeSeries copy = (TimeSeries) super.clone();
            copy.data = new java.util.ArrayList();
            return copy;
        }
        else {
            return createCopy(startIndex, endIndex);
        }

    }","public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

    if (start == null) {
        throw new IllegalArgumentException(""Null 'start' argument."");
    }
    if (end == null) {
        throw new IllegalArgumentException(""Null 'end' argument."");
    }
    if (start.compareTo(end) > 0) {
        throw new IllegalArgumentException(""Requires start on or before end."");
    }

    boolean emptyRange = false;
    int startIndex = getIndex(start);

    if (startIndex < 0) {
        startIndex = -(startIndex + 1);
        if (startIndex >= this.data.size()) {
            emptyRange = true;
        }
    }

    int endIndex = getIndex(end);

    if (endIndex < 0) {
        endIndex = -(endIndex + 1) - 1;
        if (endIndex < 0) {
            emptyRange = true;
        }
    }

    if (emptyRange || startIndex > endIndex) {
        TimeSeries copy = (TimeSeries) super.clone();
        copy.data = new java.util.ArrayList<>();
        return copy;
    } else {
        return createCopy(startIndex, endIndex);
    }
}",0,0
16,Closure_1,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
      // The parameters object literal setters can not be removed.
      return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
      // Strip unreferenced args off the end of the function declaration.
      Node lastArg;
      while ((lastArg = argList.getLastChild()) != null) {
        Var var = fnScope.getVar(lastArg.getString());
        if (!referenced.contains(var)) {
          argList.removeChild(lastArg);
          compiler.reportCodeChange();
        } else {
          break;
        }
      }
    } else {
      callSiteOptimizer.optimize(fnScope, referenced);
    }
  }","private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
    // is removing globals, then it's OK to remove unused function args.
    //
    // See http://code.google.com/p/closure-compiler/issues/detail?id=253

    Node function = fnScope.getRootNode();

    Preconditions.checkState(function.isFunction());
    if (function.getParent() != null && NodeUtil.isGetOrSetKey(function.getParent())) {
        // The parameters object literal setters cannot be removed.
        return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
            && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
        // Strip unreferenced args off the end of the function declaration.
        Node lastArg;
        while ((lastArg = argList.getLastChild()) != null) {
            String argName = lastArg.getString();
            Var var = fnScope.getVar(argName);

            // Ensure var exists before checking its reference state
            if (var != null && !referenced.contains(var)) {
                argList.removeChild(lastArg);
                compiler.reportCodeChange();
            } else {
                break;
            }
        }
    } else {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}",0,0
16,Closure_1,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
      // The parameters object literal setters can not be removed.
      return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
      // Strip unreferenced args off the end of the function declaration.
      Node lastArg;
      while ((lastArg = argList.getLastChild()) != null) {
        Var var = fnScope.getVar(lastArg.getString());
        if (!referenced.contains(var)) {
          argList.removeChild(lastArg);
          compiler.reportCodeChange();
        } else {
          break;
        }
      }
    } else {
      callSiteOptimizer.optimize(fnScope, referenced);
    }
  }","private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
    // is removing globals, then it's OK to remove unused function args.
    //
    // See http://code.google.com/p/closure-compiler/issues/detail?id=253

    Node function = fnScope.getRootNode();

    Preconditions.checkState(function.isFunction());
    
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
        // The parameters object literal setters cannot be removed.
        return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites 
            && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
        // Strip unreferenced args off the end of the function declaration.
        Node lastArg;
        while ((lastArg = argList.getLastChild()) != null) {
            Var var = fnScope.getVar(lastArg.getString());

            // Ensure var exists before checking its reference state
            if (var == null || !referenced.contains(var)) {
                argList.removeChild(lastArg);
                compiler.reportCodeChange();
            } else {
                break;
            }
        }
    } else {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}",0,1
16,Closure_1,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
      // The parameters object literal setters can not be removed.
      return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
      // Strip unreferenced args off the end of the function declaration.
      Node lastArg;
      while ((lastArg = argList.getLastChild()) != null) {
        Var var = fnScope.getVar(lastArg.getString());
        if (!referenced.contains(var)) {
          argList.removeChild(lastArg);
          compiler.reportCodeChange();
        } else {
          break;
        }
      }
    } else {
      callSiteOptimizer.optimize(fnScope, referenced);
    }
  }","private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
    // is removing globals, then it's OK to remove unused function args.
    //
    // See http://code.google.com/p/closure-compiler/issues/detail?id=253

    Node function = fnScope.getRootNode();
    Preconditions.checkState(function.isFunction());

    if (function.getParent() != null && NodeUtil.isGetOrSetKey(function.getParent())) {
        // The parameters object literal setters cannot be removed.
        return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);

    if (!modifyCallers) {
        // Strip unreferenced args off the end of the function declaration.
        while (argList != null && argList.hasChildren()) {
            Node lastArg = argList.getLastChild();
            if (lastArg == null) {
                break;
            }

            String argName = lastArg.getString();
            Var var = fnScope.getVar(argName);

            if (var == null || !referenced.contains(var)) {
                argList.removeChild(lastArg);
                compiler.reportCodeChange();
            } else {
                break;
            }
        }
    } else if (callSiteOptimizer != null) {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}",0,2
17,Closure_10,"static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
  }","static boolean mayBeString(Node n, boolean recurse) {
    if (n == null) {
        return false;
    }
    if (recurse) {
        return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
    } else {
        return mayBeStringHelper(n);
    }
}",0,0
17,Closure_10,"static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
  }","static boolean mayBeString(Node n, boolean recurse) {
    if (n == null) {
        return false;
    }
    if (recurse) {
        // Ensure validity by checking both predicates and node content
        return allResultsMatch(n, MAY_BE_STRING_PREDICATE) && validateNodeForStrings(n);
    } else {
        // Introduce additional checks for robustness in non-recursive mode
        return mayBeStringHelper(n) || validateNodeForStrings(n);
    }
}

// Helper Method for Validating Node Content
private static boolean validateNodeForStrings(Node n) {
    // Perform more complex validation for nodes that could represent strings
    if (n.getType() == NodeType.STRING_LITERAL) {
        return true;
    }
    if (n.getType() == NodeType.CONCATENATION && n.hasStringChild()) {
        return true;
    }
    return false;
}",0,1
18,Closure_101,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
     if (flags.process_closure_primitives) {
       options.closurePass = true;
     }
 
     initOptionsFromFlags(options);
     return options;
   }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    
    if (flags.debug) {
        options.setDebugOptionsForCompilationLevel(level);
    }

    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);

    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }

    if (flags.process_closure_primitives) {
        options.closurePass = true;
    }

    initOptionsFromFlags(options);
    return options;
}",0,0
19,Closure_102,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }","@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, this);

    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }

    // Ensure duplicate declarations are removed before proceeding further
    if (root != null) {
        removeDuplicateDeclarations(root);
    }

    // Process constant annotations
    if (externs != null && root != null) {
        new PropogateConstantAnnotations(compiler, assertOnChange)
            .process(externs, root);
    }
}",0,0
19,Closure_102,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }","@Override
public void process(Node externs, Node root) {
    if (root == null) {
        return; // Ensure root is not null before proceeding
    }

    // Traverse the AST
    NodeTraversal.traverse(compiler, root, this);

    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }

    // Remove duplicate declarations only if root has children
    if (root.hasChildren()) {
        removeDuplicateDeclarations(root);
    }

    // Propagate constant annotations only when externs and root are valid
    if (externs != null && root.hasChildren()) {
        new PropogateConstantAnnotations(compiler, assertOnChange)
            .process(externs, root);
    }
}",0,1
19,Closure_102,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }","@Override
public void process(Node externs, Node root) {
    if (root == null || externs == null) {
        return;  // Return early if root or externs are null
    }

    // Ensure the traversal only happens if there are children to process
    if (root.hasChildren()) {
        NodeTraversal.traverse(compiler, root, this);
    }

    // Handle local name uniqueness conditionally
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }

    // Ensure duplicate declarations are only removed if node has children
    if (root.hasChildren()) {
        removeDuplicateDeclarations(root);
    }

    // Check and propagate constant annotations only if externs and root have children
    if (externs.hasChildren() && root.hasChildren()) {
        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
    }
}",0,2
20,Closure_104,"JSType meet(JSType that) {
    UnionTypeBuilder builder = new UnionTypeBuilder(registry);
    for (JSType alternate : alternates) {
      if (alternate.isSubtype(that)) {
        builder.addAlternate(alternate);
      }
    }

    if (that instanceof UnionType) {
      for (JSType otherAlternate : ((UnionType) that).alternates) {
        if (otherAlternate.isSubtype(this)) {
          builder.addAlternate(otherAlternate);
        }
      }
    } else if (that.isSubtype(this)) {
       builder.addAlternate(that);
     }
     JSType result = builder.build();
     if (result != null) {
       return result;
     } else if (this.isObject() && that.isObject()) {
       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    } else {
      return getNativeType(JSTypeNative.NO_TYPE);
    }
  }","JSType meet(JSType that) {
    UnionTypeBuilder builder = new UnionTypeBuilder(registry);
    for (JSType alternate : alternates) {
        if (alternate.isSubtype(that)) {
            builder.addAlternate(alternate);
        }
    }

    if (that instanceof UnionType) {
        for (JSType otherAlternate : ((UnionType) that).alternates) {
            if (otherAlternate.isSubtype(this)) {
                builder.addAlternate(otherAlternate);
            }
        }
    } else if (that.isSubtype(this)) {
        builder.addAlternate(that);
    }
    
    JSType result = builder.build();
    if (result != null && !(result instanceof NoType)) {
        return result;
    } else if (this.isObject() && that.isObject()) {
        return registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    } else {
        return registry.getNativeType(JSTypeNative.NO_TYPE);
    }
}",0,0
21,Closure_105,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
         if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
         if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
           sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }

    Node arrayNode = left.getFirstChild();
    if (arrayNode == null || arrayNode.getNext() == null) {
        return;
    }

    Node functionName = arrayNode.getNext();

    if (arrayNode.getType() != Token.ARRAYLIT || !functionName.getString().equals(""join"")) {
        return;
    }

    String joinString = NodeUtil.getStringValue(right);
    if (joinString == null) {
        return;
    }

    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    int foldedSize = 0;

    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            String value = NodeUtil.getStringValue(elem);
            if (value != null) {
                sb.append(value);
            }
        } else {
            if (sb.length() > 0) {
                foldedSize += sb.length() + 2; // +2 for quotes
                arrayFoldedChildren.add(Node.newString(sb.toString()));
                sb = new StringBuilder();
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }

    if (sb.length() > 0) {
        foldedSize += sb.length() + 2; // +2 for quotes
        arrayFoldedChildren.add(Node.newString(sb.toString()));
    }

    foldedSize += arrayFoldedChildren.size() - 1; // one for each comma

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
        case 0: {
            Node emptyStringNode = Node.newString("""");
            parent.replaceChild(n, emptyStringNode);
            break;
        }
        case 1: {
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                Node replacement = new Node(Token.ADD, Node.newString(""""), foldedStringNode);
                foldedStringNode = replacement;
            }
            parent.replaceChild(n, foldedStringNode);
            break;
        }
        default: {
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += InlineCostEstimator.getCost(right);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            break;
        }
    }
    t.getCompiler().reportCodeChange();
}",0,0
21,Closure_105,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
         if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
         if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
           sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }

    Node arrayNode = left.getFirstChild();
    if (arrayNode == null || arrayNode.getNext() == null) {
        return;
    }

    Node functionName = arrayNode.getNext();
    if (arrayNode.getType() != Token.ARRAYLIT || !functionName.getString().equals(""join"")) {
        return;
    }

    String joinString = NodeUtil.getStringValue(right);
    if (joinString == null || joinString.length() > 10) { // Add robustness for large join strings
        return;
    }

    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    int foldedSize = 0;

    Node elem = arrayNode.getFirstChild();
    boolean foldable = true; // Track if folding is feasible

    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            String value = NodeUtil.getStringValue(elem);
            if (value != null) {
                sb.append(value);
            } else {
                foldable = false; // Avoid folding if any immutable value fails
                break;
            }
        } else {
            if (sb.length() > 0) {
                foldedSize += sb.length() + 2; // +2 for quotes
                arrayFoldedChildren.add(Node.newString(sb.toString()));
                sb = new StringBuilder();
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }

    if (!foldable) {
        return; // Early exit to avoid incorrect folding
    }

    if (sb.length() > 0) {
        foldedSize += sb.length() + 2; // +2 for quotes
        arrayFoldedChildren.add(Node.newString(sb.toString()));
    }

    foldedSize += arrayFoldedChildren.size() - 1; // one for each comma

    int originalSize = InlineCostEstimator.getCost(n);
    int kJoinOverhead = ""[].join()"".length();
    foldedSize += kJoinOverhead + InlineCostEstimator.getCost(right);

    if (foldedSize >= originalSize) {
        return; // Ensure folding decreases overall size
    }

    switch (arrayFoldedChildren.size()) {
        case 0: {
            Node emptyStringNode = Node.newString("""");
            parent.replaceChild(n, emptyStringNode);
            break;
        }
        case 1: {
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                Node replacement = new Node(Token.ADD, Node.newString(""""), foldedStringNode);
                foldedStringNode = replacement;
            }
            parent.replaceChild(n, foldedStringNode);
            break;
        }
        default: {
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            break;
        }
    }
    t.getCompiler().reportCodeChange();
}",0,1
21,Closure_105,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
         if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
         if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
           sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode != null ? arrayNode.getNext() : null;

    if (arrayNode == null || functionName == null ||
        arrayNode.getType() != Token.ARRAYLIT ||
        !""join"".equals(functionName.getString())) {
        return;
    }

    String joinString = NodeUtil.getStringValue(right);
    if (joinString == null) {
        return;
    }

    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    Node elem = arrayNode.getFirstChild();

    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            String value = NodeUtil.getStringValue(elem);
            if (value != null) {
                if (sb.length() > 0) {
                    sb.append(joinString);
                }
                sb.append(value);
            } else {
                return;  // If any immutable value fails, abort processing.
            }
        } else {
            if (sb.length() > 0) {
                arrayFoldedChildren.add(Node.newString(sb.toString()));
                sb.setLength(0);
            }
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }

    // Add any remaining concatenated string.
    if (sb.length() > 0) {
        arrayFoldedChildren.add(Node.newString(sb.toString()));
    }

    if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
        return;  // No reduction in size; abort folding.
    }

    int foldedSize = arrayFoldedChildren.stream()
            .mapToInt(node -> node.getType() == Token.STRING 
                    ? node.getString().length() + 2 
                    : InlineCostEstimator.getCost(node))
            .sum();
    foldedSize += arrayFoldedChildren.size() - 1; // Account for commas.
    foldedSize += ""[].join()"".length() + InlineCostEstimator.getCost(right);

    int originalSize = InlineCostEstimator.getCost(n);
    if (foldedSize >= originalSize) {
        return;  // Ensure folding decreases overall size.
    }

    switch (arrayFoldedChildren.size()) {
        case 0:
            parent.replaceChild(n, Node.newString(""""));
            break;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                foldedStringNode = new Node(Token.ADD, Node.newString(""""), foldedStringNode);
            }
            parent.replaceChild(n, foldedStringNode);
            break;
        default:
            arrayNode.detachChildren();
            arrayFoldedChildren.forEach(arrayNode::addChildToBack);
            break;
    }
    t.getCompiler().reportCodeChange();
}",0,2
22,Closure_107,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
      options.setCodingConvention(new JqueryCodingConvention());
    } else {
      options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
      level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
      options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (!flags.translationsFile.isEmpty()) {
      try {
        options.messageBundle = new XtbMessageBundle(
            new FileInputStream(flags.translationsFile),
            flags.translationsProject);
      } catch (IOException e) {
        throw new RuntimeException(""Reading XTB file"", e);
      }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
      // translations file, they might reasonably try to write their own
      // implementation of goog.getMsg that makes the substitution at
      // run-time.
      //
      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
  }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
        options.setCodingConvention(new JqueryCodingConvention());
    } else {
        options.setCodingConvention(new ClosureCodingConvention());
    }

    // Ensure extraAnnotationNames is properly handled with non-null flags
    if (flags.extraAnnotationName != null) {
        options.setExtraAnnotationNames(flags.extraAnnotationName);
    }

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
        options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);

    if (flags.formatting != null) {
        for (FormattingOption formattingOption : flags.formatting) {
            formattingOption.applyToOptions(options);
        }
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level && flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    // Fix for empty translationsFile and handling IOException correctly
    if (flags.translationsFile != null && !flags.translationsFile.isEmpty()) {
        FileInputStream inputStream = null;
        try {
            inputStream = new FileInputStream(flags.translationsFile);
            options.messageBundle = new XtbMessageBundle(inputStream, flags.translationsProject);
        } catch (IOException e) {
            throw new RuntimeException(""Reading XTB file failed: "" + flags.translationsFile, e);
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException e) {
                    // Log the error or handle it appropriately
                }
            }
        }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
        options.messageBundle = new EmptyMessageBundle();
    }

    return options;
}",0,0
22,Closure_107,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
      options.setCodingConvention(new JqueryCodingConvention());
    } else {
      options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
      level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
      options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (!flags.translationsFile.isEmpty()) {
      try {
        options.messageBundle = new XtbMessageBundle(
            new FileInputStream(flags.translationsFile),
            flags.translationsProject);
      } catch (IOException e) {
        throw new RuntimeException(""Reading XTB file"", e);
      }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
      // translations file, they might reasonably try to write their own
      // implementation of goog.getMsg that makes the substitution at
      // run-time.
      //
      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
  }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();

    // Set coding convention based on flags
    options.setCodingConvention(flags.processJqueryPrimitives 
        ? new JqueryCodingConvention() 
        : new ClosureCodingConvention());

    // Handle extra annotation names if provided
    if (flags.extraAnnotationName != null && !flags.extraAnnotationName.isEmpty()) {
        options.setExtraAnnotationNames(flags.extraAnnotationName);
    }

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    // Apply debugging options if debug flag is enabled
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }

    // Apply type-based optimization options if needed
    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }

    // Generate exports when flag is enabled
    if (flags.generateExports) {
        options.setGenerateExports(flags.generateExports);
    }

    // Set warning level options
    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);

    // Apply formatting options if available
    if (flags.formatting != null) {
        for (FormattingOption formattingOption : flags.formatting) {
            formattingOption.applyToOptions(options);
        }
    }

    // Set closure, jQuery, and Angular pass options based on flags
    options.closurePass = flags.processClosurePrimitives;
    options.jqueryPass = flags.processJqueryPrimitives && CompilationLevel.ADVANCED_OPTIMIZATIONS == level;
    options.angularPass = flags.angularPass;

    // Handle translations file and message bundle options
    if (flags.translationsFile != null && !flags.translationsFile.isEmpty()) {
        try (FileInputStream inputStream = new FileInputStream(flags.translationsFile)) {
            options.messageBundle = new XtbMessageBundle(inputStream, flags.translationsProject);
        } catch (IOException e) {
            throw new RuntimeException(""Failed to read the XTB translations file: "" + flags.translationsFile, e);
        }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
        // Use an empty message bundle when no translations file is provided
        options.messageBundle = new EmptyMessageBundle();
    }

    return options;
}",0,1
22,Closure_107,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
      options.setCodingConvention(new JqueryCodingConvention());
    } else {
      options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
      level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
      options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (!flags.translationsFile.isEmpty()) {
      try {
        options.messageBundle = new XtbMessageBundle(
            new FileInputStream(flags.translationsFile),
            flags.translationsProject);
      } catch (IOException e) {
        throw new RuntimeException(""Reading XTB file"", e);
      }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
      // translations file, they might reasonably try to write their own
      // implementation of goog.getMsg that makes the substitution at
      // run-time.
      //
      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
  }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();

    // Set coding convention based on flags
    options.setCodingConvention(flags.processJqueryPrimitives 
        ? new JqueryCodingConvention() 
        : new ClosureCodingConvention());

    // Handle extra annotation names if provided
    if (flags.extraAnnotationName != null && !flags.extraAnnotationName.isEmpty()) {
        options.setExtraAnnotationNames(flags.extraAnnotationName);
    }

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    // Apply debugging options if debug flag is enabled
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }

    // Apply type-based optimization options if needed
    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }

    // Generate exports when flag is enabled
    if (flags.generateExports) {
        options.setGenerateExports(flags.generateExports);
    }

    // Set warning level options
    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);

    // Apply formatting options if available
    if (flags.formatting != null) {
        for (FormattingOption formattingOption : flags.formatting) {
            formattingOption.applyToOptions(options);
        }
    }

    // Set closure, jQuery, and Angular pass options based on flags
    options.closurePass = flags.processClosurePrimitives;
    options.jqueryPass = flags.processJqueryPrimitives && CompilationLevel.ADVANCED_OPTIMIZATIONS == level;
    options.angularPass = flags.angularPass;

    // Improved handling of translations file and message bundle options
    if (flags.translationsFile != null && !flags.translationsFile.trim().isEmpty()) {
        try (FileInputStream inputStream = new FileInputStream(flags.translationsFile.trim())) {
            options.messageBundle = new XtbMessageBundle(inputStream, flags.translationsProject);
        } catch (IOException e) {
            throw new RuntimeException(""Failed to read the XTB translations file: "" + flags.translationsFile.trim(), e);
        }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
        // Use an empty message bundle when no translations file is provided
        options.messageBundle = new EmptyMessageBundle();
    }

    return options;
}",0,2
23,Closure_109,"  private Node parseContextTypeExpression(JsDocToken token) {
          return parseTypeName(token);
  }
","private Node parseContextTypeExpression(JsDocToken token) {
    if (token == JsDocToken.QMARK || token == JsDocToken.STAR) {
        // Handle special case for QMARK or STAR tokens
        return parseTopLevelTypeExpression(token);
    } else {
        return parseTypeName(token);
    }
}",0,0
24,Closure_11,"private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    // Lots of types can appear on the left, a call to a void function can
    // never be on the left. getPropertyType will decide what is acceptable
    // and what isn't.
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
     } else if (n.getJSType() != null && parent.isAssign()) {
       return;
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
  }","private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);

    if (childType.isDict()) {
        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
    } else if (n.getJSType() != null && parent.isAssign()) {
        ensureTyped(t, n);
        return; // Added ensureTyped before return to prevent missed type assignments
    } else if (validator.expectNotNullOrUndefined(t, n, childType,
        ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
        checkPropertyAccess(childType, property.getString(), t, n);
    }

    ensureTyped(t, n); // Ensure the node is always typed in all execution paths
}",0,0
24,Closure_11,"private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    // Lots of types can appear on the left, a call to a void function can
    // never be on the left. getPropertyType will decide what is acceptable
    // and what isn't.
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
     } else if (n.getJSType() != null && parent.isAssign()) {
       return;
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
  }","private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);

    if (childType.isDict()) {
        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
    } else {
        boolean shouldEnsureTyped = true;
        
        if (n.getJSType() != null && parent.isAssign()) {
            ensureTyped(t, n); // Ensure the type assignment is done before returning
            shouldEnsureTyped = false;
        } else if (validator.expectNotNullOrUndefined(t, n, childType, 
                   ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
            checkPropertyAccess(childType, property.getString(), t, n);
        }
        
        if (shouldEnsureTyped) {
            ensureTyped(t, n); // Ensure typing is done in all valid paths
        }
    }
}",0,1
24,Closure_11,"private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    // Lots of types can appear on the left, a call to a void function can
    // never be on the left. getPropertyType will decide what is acceptable
    // and what isn't.
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
     } else if (n.getJSType() != null && parent.isAssign()) {
       return;
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
  }","private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);

    if (childType.isDict()) {
        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
        ensureTyped(t, n);
        return;
    }

    if (validator.expectNotNullOrUndefined(t, n, childType,
        ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
        checkPropertyAccess(childType, property.getString(), t, n);
        ensureTyped(t, n);
        return;
    }

    if (n.getJSType() == null || !parent.isAssign()) {
        ensureTyped(t, n);
    }
}",0,2
25,Closure_111,"        protected JSType caseTopType(JSType topType) {
          return topType;
        }
","protected JSType caseTopType(JSType topType) {
    if (topType == null) {
        return null;
    }
    return topType;
}",0,0
25,Closure_111,"        protected JSType caseTopType(JSType topType) {
          return topType;
        }
","protected JSType caseTopType(JSType topType) {
    if (topType == null || topType.isError()) {
        return JSType.getUnknownType();
    }
    return topType.getResolvedType();
}",0,1
26,Closure_112,"    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()
        .getTemplateKeys();
    if (keys.isEmpty()) {
      return false;
    }
","final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
if (keys == null || keys.isEmpty()) {
    return false;
}",0,0
26,Closure_112,"    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()
        .getTemplateKeys();
    if (keys.isEmpty()) {
      return false;
    }
","final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
if (keys == null || keys.isEmpty()) {
    return false;
}
boolean hasValidKey = false;
for (TemplateType key : keys) {
    if (key.isNonTrivial() && key.hasConstraints()) {
        hasValidKey = true;
        break;
    }
}
return hasValidKey;",0,1
27,Closure_113,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
      String ns = arg.getString();
      ProvidedName provided = providedNames.get(ns);
      if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
      } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
          compiler.report(
              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                  providedModule.getName(),
                  module.getName()));
        }
      }

      maybeAddToSymbolTable(left);
      maybeAddStringNodeToSymbolTable(arg);

      // Requires should be removed before further processing.
      // Some clients run closure pass multiple times, first with
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
       if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
    }
  }","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();

    // Verify that the argument is a string
    if (arg == null || !verifyLastArgumentIsString(t, left, arg)) {
        return;
    }

    String ns = arg.getString();
    ProvidedName provided = providedNames.get(ns);
    if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
    } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
            compiler.report(t.makeError(
                n, XMODULE_REQUIRE_ERROR, ns,
                providedModule.getName(),
                module.getName()));
        }
    }

    maybeAddToSymbolTable(left);
    maybeAddStringNodeToSymbolTable(arg);

    // Requires should be removed before further processing if provided is not null.
    if (provided != null) {
        parent.detachFromParent();
        compiler.reportCodeChange();
    }
}",0,0
27,Closure_113,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
      String ns = arg.getString();
      ProvidedName provided = providedNames.get(ns);
      if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
      } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
          compiler.report(
              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                  providedModule.getName(),
                  module.getName()));
        }
      }

      maybeAddToSymbolTable(left);
      maybeAddStringNodeToSymbolTable(arg);

      // Requires should be removed before further processing.
      // Some clients run closure pass multiple times, first with
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
       if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
    }
  }","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();

    // Verify that the argument is a string and left is not null
    if (left == null || arg == null || !verifyLastArgumentIsString(t, left, arg)) {
        return;
    }

    String ns = arg.getString();
    ProvidedName provided = providedNames.get(ns);
    if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));
    } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) {
            compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName()));
        }
    }

    maybeAddToSymbolTable(left);
    maybeAddStringNodeToSymbolTable(arg);

    // Requires should be removed before further processing if provided is not null.
    if (provided != null) {
        parent.detachFromParent();
        compiler.reportCodeChange();
    }
}",0,1
27,Closure_113,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
      String ns = arg.getString();
      ProvidedName provided = providedNames.get(ns);
      if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
      } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
          compiler.report(
              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                  providedModule.getName(),
                  module.getName()));
        }
      }

      maybeAddToSymbolTable(left);
      maybeAddStringNodeToSymbolTable(arg);

      // Requires should be removed before further processing.
      // Some clients run closure pass multiple times, first with
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
       if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
    }
  }","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = (left != null) ? left.getNext() : null;

    // Ensure left and arg nodes are valid, and argument is a string
    if (left == null || arg == null || !verifyLastArgumentIsString(t, left, arg)) {
        return;
    }

    String ns = arg.getString();
    ProvidedName provided = providedNames.get(ns);

    if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));
    } else {
        JSModule providedModule = provided.explicitModule;
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) {
            compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName()));
        }

        // Remove the parent only if a valid `provided` is found, irrespective of explicitly provided or not
        parent.detachFromParent();
        compiler.reportCodeChange();
    }

    // Add nodes to symbol table only if `arg` and `provided` are determined
    maybeAddToSymbolTable(left);
    maybeAddStringNodeToSymbolTable(arg);
}",0,2
28,Closure_114,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
      Node nameNode = n.getFirstChild();
      Node parent = n.getParent();
      NameInformation ns = createNameInformation(t, nameNode);
      if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
          // Patch for assignments that appear in the init,
          // condition or iteration part of a FOR loop.  Without
          // this change, all 3 of those parts try to claim the for
          // loop as their dependency scope.  The last assignment in
          // those three fields wins, which can result in incorrect
          // reference edges between referenced and assigned variables.
          //
          // TODO(user) revisit the dependency scope calculation
          // logic.
          if (parent.getFirstChild().getNext() != n) {
            recordDepScope(recordNode, ns);
           } else {
             recordDepScope(nameNode, ns);
           }
         } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
          // caller expression, but it could be nested deeper in the caller and
          // we would still get a bug.
          // See testAssignWithCall2 for an example of this.
          recordDepScope(recordNode, ns);
        }
      }
    }","private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    if (n == null) {
        return;
    }
    Node nameNode = n.getFirstChild();
    if (nameNode == null) {
        return;
    }
    Node parent = n.getParent();
    if (parent == null) {
        return;
    }
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // Patch for assignments that appear in the init,
            // condition or iteration part of a FOR loop. Without
            // this change, all 3 of those parts try to claim the for
            // loop as their dependency scope. The last assignment in
            // those three fields wins, which can result in incorrect
            // reference edges between referenced and assigned variables.
            //
            // TODO revisit the dependency scope calculation
            // logic.
            if (!parent.getFirstChild().isEquivalentTo(n)) {
                recordDepScope(recordNode, ns);
            } else {
                recordDepScope(nameNode, ns);
            }
        } else {
            // The rhs of the assignment is the caller, so it's used by the
            // context. Don't associate it with the lhs.
            // FYI: this fixes only the specific case where the assignment is the
            // caller expression, but it could be nested deeper in the caller and
            // we would still get a bug.
            // See testAssignWithCall2 for an example of this.
            recordDepScope(recordNode, ns);
        }
    }
}",0,0
28,Closure_114,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
      Node nameNode = n.getFirstChild();
      Node parent = n.getParent();
      NameInformation ns = createNameInformation(t, nameNode);
      if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
          // Patch for assignments that appear in the init,
          // condition or iteration part of a FOR loop.  Without
          // this change, all 3 of those parts try to claim the for
          // loop as their dependency scope.  The last assignment in
          // those three fields wins, which can result in incorrect
          // reference edges between referenced and assigned variables.
          //
          // TODO(user) revisit the dependency scope calculation
          // logic.
          if (parent.getFirstChild().getNext() != n) {
            recordDepScope(recordNode, ns);
           } else {
             recordDepScope(nameNode, ns);
           }
         } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
          // caller expression, but it could be nested deeper in the caller and
          // we would still get a bug.
          // See testAssignWithCall2 for an example of this.
          recordDepScope(recordNode, ns);
        }
      }
    }","private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    if (n == null) {
        return;
    }
    Node nameNode = n.getFirstChild();
    if (nameNode == null) {
        return;
    }
    Node parent = n.getParent();
    if (parent == null) {
        return;
    }
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor()) {
            Node loopInit = parent.getFirstChild();
            Node loopCondition = loopInit.getNext();
            Node loopIteration = loopCondition != null ? loopCondition.getNext() : null;
            // Explicitly check if the current node `n` is part of the loop initialization, condition, or iteration
            if (n.isEquivalentTo(loopInit) || n.isEquivalentTo(loopCondition) || n.isEquivalentTo(loopIteration)) {
                // Only treat as within the dependency scope if it strictly matches
                recordDepScope(nameNode, ns);
            } else {
                // Otherwise, handle it like any other node
                recordDepScope(recordNode, ns);
            }
        } else {
            // Outside of FOR loop context, record dependency scope as usual
            recordDepScope(recordNode, ns);
        }
    }
}",0,1
28,Closure_114,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
      Node nameNode = n.getFirstChild();
      Node parent = n.getParent();
      NameInformation ns = createNameInformation(t, nameNode);
      if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
          // Patch for assignments that appear in the init,
          // condition or iteration part of a FOR loop.  Without
          // this change, all 3 of those parts try to claim the for
          // loop as their dependency scope.  The last assignment in
          // those three fields wins, which can result in incorrect
          // reference edges between referenced and assigned variables.
          //
          // TODO(user) revisit the dependency scope calculation
          // logic.
          if (parent.getFirstChild().getNext() != n) {
            recordDepScope(recordNode, ns);
           } else {
             recordDepScope(nameNode, ns);
           }
         } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
          // caller expression, but it could be nested deeper in the caller and
          // we would still get a bug.
          // See testAssignWithCall2 for an example of this.
          recordDepScope(recordNode, ns);
        }
      }
    }","private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    if (n == null) {
        return;
    }
    Node nameNode = n.getFirstChild();
    if (nameNode == null) {
        return;
    }
    Node parent = n.getParent();
    if (parent == null) {
        return;
    }
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // For loops have separate handling based on location in init, condition or iteration.
            Node loopInit = parent.getFirstChild();
            Node loopCondition = loopInit != null ? loopInit.getNext() : null;
            Node loopIteration = loopCondition != null ? loopCondition.getNext() : null;
            if (n.isEquivalentTo(loopInit) || n.isEquivalentTo(loopCondition) || n.isEquivalentTo(loopIteration)) {
                recordDepScope(nameNode, ns);
            } else {
                recordDepScope(recordNode, ns);
            }
        } else if (parent.isIf() || parent.isWhile()) {
            // Ensure assignments within IF or WHILE conditions are handled correctly.
            Node testNode = parent.getFirstChild();
            if (n.isEquivalentTo(testNode)) {
                recordDepScope(nameNode, ns);
            } else {
                recordDepScope(recordNode, ns);
            }
        } else {
            // Default case for other contexts.
            recordDepScope(recordNode, ns);
        }
    }
}",0,2
29,Closure_115,"private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
             return CanInlineResult.NO;
           }
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }","private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
        Preconditions.checkState(block.hasOneChild());
        Node stmt = block.getFirstChild();
        if (stmt.isReturn() && stmt.getFirstChild() != null) {
            hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
        }
    }

    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        if (fnParam != null) {
            if (cArg != null) {
                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
                    return CanInlineResult.NO;
                }
                if (NodeUtil.mayEffectMutableState(cArg, compiler)
                        && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            fnParam = fnParam.getNext();
        }

        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }

    return CanInlineResult.YES;
}",0,0
29,Closure_115,"private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
             return CanInlineResult.NO;
           }
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }","private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    if (block.hasChildren() && !block.getFirstChild().isReturn()) {
        Node stmt = block.getFirstChild();
        if (NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler)) {
            return CanInlineResult.NO;
        }
    }

    Node cArg = callNode.getFirstChild().getNext();
    
    // Adjust handling of 'call' and 'apply' to ensure 'this' is correctly processed
    if (!callNode.getFirstChild().isName() && NodeUtil.isFunctionObjectCall(callNode)) {
        if (cArg == null || !cArg.isThis()) {
            return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
    }

    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        if (fnParam != null && cArg != null) {
            if (NodeUtil.mayEffectMutableState(cArg, compiler) && 
                NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                return CanInlineResult.NO;
            }
            fnParam = fnParam.getNext();
        }

        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }

    return CanInlineResult.YES;
}",0,1
30,Closure_117,"String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
      ObjectType objectType = getJSType(n.getFirstChild()).dereference();
      if (objectType != null) {
        String propName = n.getLastChild().getString();
        if (objectType.getConstructor() != null &&
            objectType.getConstructor().isInterface()) {
          objectType = FunctionType.getTopDefiningInterface(
              objectType, propName);
        } else {
          // classes
          while (objectType != null && !objectType.hasOwnProperty(propName)) {
            objectType = objectType.getImplicitPrototype();
          }
        }

        // Don't show complex function names or anonymous types.
        // Instead, try to get a human-readable type name.
        if (objectType != null &&
            (objectType.getConstructor() != null ||
             objectType.isFunctionPrototypeType())) {
          return objectType.toString() + ""."" + propName;
        }
      }
    }

    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
      return qualifiedName;
    } else if (type.isFunctionType()) {
      // Don't show complex function names.
      return ""function"";
    } else {
      return type.toString();
    }
  }","String getReadableJSTypeName(Node n, boolean dereference) {

    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(objectType, propName);
            } else {
                // Classes should traverse the prototype chain
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }

            // Generate human-readable type name if applicable
            if (objectType != null &&
                    (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }

    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }

    if (type.isFunctionPrototypeType() || 
            (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }

    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        return ""function"";
    } else {
        return type.toString();
    }
}",0,0
30,Closure_117,"String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
      ObjectType objectType = getJSType(n.getFirstChild()).dereference();
      if (objectType != null) {
        String propName = n.getLastChild().getString();
        if (objectType.getConstructor() != null &&
            objectType.getConstructor().isInterface()) {
          objectType = FunctionType.getTopDefiningInterface(
              objectType, propName);
        } else {
          // classes
          while (objectType != null && !objectType.hasOwnProperty(propName)) {
            objectType = objectType.getImplicitPrototype();
          }
        }

        // Don't show complex function names or anonymous types.
        // Instead, try to get a human-readable type name.
        if (objectType != null &&
            (objectType.getConstructor() != null ||
             objectType.isFunctionPrototypeType())) {
          return objectType.toString() + ""."" + propName;
        }
      }
    }

    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
      return qualifiedName;
    } else if (type.isFunctionType()) {
      // Don't show complex function names.
      return ""function"";
    } else {
      return type.toString();
    }
  }","String getReadableJSTypeName(Node n, boolean dereference) {

    // Handle GETPROP nodes specially
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();

            // Handle interfaces via top-defining interface lookup
            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(objectType, propName);
            } else {
                // Classes should traverse the prototype chain for properties
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }

            // Generate readable property name for functions or constructors
            if (objectType != null &&
                    (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }

    // Ensure n is valid and dereference JSType if needed
    if (n == null || n.getJSType() == null) {
        return ""unknown"";
    }

    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }

    // Handle specific function prototype types
    if (type.isFunctionPrototypeType() ||
            (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }

    // Return qualified name or fallback to basic type representation
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        // Avoid complex function names
        return ""function"";
    } else if (type.isEnumType()) {
        // Differentiate enum types
        return ""enum"";
    } else {
        return type.toString();
    }
}",0,1
30,Closure_117,"String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
      ObjectType objectType = getJSType(n.getFirstChild()).dereference();
      if (objectType != null) {
        String propName = n.getLastChild().getString();
        if (objectType.getConstructor() != null &&
            objectType.getConstructor().isInterface()) {
          objectType = FunctionType.getTopDefiningInterface(
              objectType, propName);
        } else {
          // classes
          while (objectType != null && !objectType.hasOwnProperty(propName)) {
            objectType = objectType.getImplicitPrototype();
          }
        }

        // Don't show complex function names or anonymous types.
        // Instead, try to get a human-readable type name.
        if (objectType != null &&
            (objectType.getConstructor() != null ||
             objectType.isFunctionPrototypeType())) {
          return objectType.toString() + ""."" + propName;
        }
      }
    }

    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
      return qualifiedName;
    } else if (type.isFunctionType()) {
      // Don't show complex function names.
      return ""function"";
    } else {
      return type.toString();
    }
  }","String getReadableJSTypeName(Node n, boolean dereference) {

    if (n == null || n.getJSType() == null) {
        return ""unknown"";
    }

    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(objectType, propName);
            } else {
                Set<ObjectType> checkedTypes = new HashSet<>();
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    if (checkedTypes.contains(objectType)) {
                        break; // Avoid infinite loops due to cyclic prototypes
                    }
                    checkedTypes.add(objectType);
                    objectType = objectType.getImplicitPrototype();
                }
            }

            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                String readableName = objectType.toString() + ""."" + propName;
                return readableName.replaceAll(""\\$.*"", """"); // Strip internal details for readability
            }
        }
    }

    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }

    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString().replaceAll(""\\$.*"", """"); // Make the output more human-readable
    }

    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        return ""function"";
    } else if (type.isEnumType()) {
        return ""enum"";
    } else if (type.isUnknownType()) {
        return ""unknown"";
    } else {
        return type.toString();
    }
}",0,2
31,Closure_118,"private void handleObjectLit(NodeTraversal t, Node n) {
      for (Node child = n.getFirstChild();
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
          // TODO(user): It doesn't look like the user can do much in this
          // case right now.
          if (propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(
                t.getSourceName(), child, propertiesToErrorFor.get(name),
                Warnings.INVALIDATION, name,
                (type == null ? ""null"" : type.toString()), n.toString(), """"));
          }
        }
      }
    }","private void handleObjectLit(NodeTraversal t, Node n) {
    for (Node child = n.getFirstChild();
         child != null;
         child = child.getNext()) {
        // Ensure the child node has a valid string name
        String name = child.getString();
        if (name == null) {
            continue; // Skip nodes without valid names
        }

        // Retrieve type information
        T type = typeSystem.getType(getScope(), n, name);

        // Retrieve and process property
        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
            // Handle errors for invalid properties
            if (propertiesToErrorFor.containsKey(name)) {
                compiler.report(JSError.make(
                    t.getSourceName(), child, propertiesToErrorFor.get(name),
                    Warnings.INVALIDATION, name,
                    (type == null ? ""null"" : type.toString()), n.toString(), """"));
            }
        }
    }
}",0,0
31,Closure_118,"private void handleObjectLit(NodeTraversal t, Node n) {
      for (Node child = n.getFirstChild();
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
          // TODO(user): It doesn't look like the user can do much in this
          // case right now.
          if (propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(
                t.getSourceName(), child, propertiesToErrorFor.get(name),
                Warnings.INVALIDATION, name,
                (type == null ? ""null"" : type.toString()), n.toString(), """"));
          }
        }
      }
    }","private void handleObjectLit(NodeTraversal t, Node n) {
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        // Ensure the child node has a valid string name
        if (!child.isName() && !child.isString()) {
            continue; // Skip nodes that are not valid string or name nodes
        }

        String name = child.getString();
        if (name == null || name.trim().isEmpty()) {
            continue; // Skip nodes without meaningful names
        }

        // Retrieve type information
        T type = null;
        try {
            type = typeSystem.getType(getScope(), n, name);
        } catch (Exception e) {
            compiler.report(JSError.make(t.getSourceName(), child, Warnings.INVALIDATION,
                    ""Failed to retrieve type for name: "" + name));
            continue; // Handle potential errors gracefully and skip invalid types
        }

        // Retrieve and process property
        Property prop = getProperty(name);
        if (prop == null) {
            compiler.report(JSError.make(t.getSourceName(), child, Warnings.INVALIDATION,
                    ""Property not found for name: "" + name));
            continue; // Skip invalid properties
        }

        // Process scheduling and handle errors for invalid properties
        boolean scheduled = prop.scheduleRenaming(child, processProperty(t, prop, type, null));
        if (!scheduled && propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name),
                    Warnings.INVALIDATION, name, (type == null ? ""null"" : type.toString()), n.toString(), """"));
        }
    }
}",0,1
31,Closure_118,"private void handleObjectLit(NodeTraversal t, Node n) {
      for (Node child = n.getFirstChild();
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
          // TODO(user): It doesn't look like the user can do much in this
          // case right now.
          if (propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(
                t.getSourceName(), child, propertiesToErrorFor.get(name),
                Warnings.INVALIDATION, name,
                (type == null ? ""null"" : type.toString()), n.toString(), """"));
          }
        }
      }
    }","private void handleObjectLit(NodeTraversal t, Node n) {
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        // Ensure the child node is valid
        if (!child.isString() && !child.isName()) {
            continue; // Skip nodes that are neither string nor name
        }

        String name = child.getString();
        if (name == null || name.trim().isEmpty()) {
            continue; // Skip nodes without a valid name
        }

        // Retrieve type information safely
        T type = null;
        try {
            type = typeSystem.getType(getScope(), n, name);
        } catch (Exception e) {
            compiler.report(JSError.make(t.getSourceName(), child, Warnings.INVALIDATION,
                    ""Error retrieving type for name: "" + name));
            continue; // Log and skip invalid types
        }

        // Retrieve property and validate
        Property prop = getProperty(name);
        if (prop == null) {
            compiler.report(JSError.make(t.getSourceName(), child, Warnings.INVALIDATION,
                    ""Property not found for name: "" + name));
            continue; // Log and skip missing properties
        }

        // Process property scheduling with fallback
        boolean scheduled = false;
        try {
            scheduled = prop.scheduleRenaming(child, processProperty(t, prop, type, null));
        } catch (Exception e) {
            compiler.report(JSError.make(t.getSourceName(), child, Warnings.INVALIDATION,
                    ""Error scheduling renaming for name: "" + name));
        }

        // Handle unscheduled properties with detailed error reporting
        if (!scheduled && propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name),
                    Warnings.INVALIDATION, name, (type == null ? ""null"" : type.toString()), n.toString(), """"));
        }
    }
}",0,2
32,Closure_119,"public void collect(JSModule module, Scope scope, Node n) {
      Node parent = n.getParent();

      String name;
      boolean isSet = false;
      Name.Type type = Name.Type.OTHER;
      boolean isPropAssign = false;

      switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
          // This may be a key in an object literal declaration.
          name = null;
          if (parent != null && parent.isObjectLit()) {
            name = getNameForObjLitKey(n);
          }
          if (name == null) {
            return;
          }
          isSet = true;
          switch (n.getType()) {
            case Token.STRING_KEY:
              type = getValueType(n.getFirstChild());
              break;
            case Token.GETTER_DEF:
              type = Name.Type.GET;
              break;
            case Token.SETTER_DEF:
              type = Name.Type.SET;
              break;
            default:
              throw new IllegalStateException(""unexpected:"" + n);
          }
          break;
        case Token.NAME:
          // This may be a variable get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.VAR:
                isSet = true;
                Node rvalue = n.getFirstChild();
                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                break;
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                }
                break;
              case Token.GETPROP:
                return;
              case Token.FUNCTION:
                Node gramps = parent.getParent();
                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                  return;
                }
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
                type = Name.Type.OTHER;
                break;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getString();
          break;
        case Token.GETPROP:
          // This may be a namespaced name get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                  isPropAssign = true;
                }
                break;
              case Token.INC:
              case Token.DEC:
                isSet = true;
                type = Name.Type.OTHER;
                break;
              case Token.GETPROP:
                return;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getQualifiedName();
          if (name == null) {
            return;
          }
          break;
        default:
          return;
      }

      // We are only interested in global names.
      if (!isGlobalNameReference(name, scope)) {
        return;
      }

      if (isSet) {
        if (isGlobalScope(scope)) {
          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
          handleSetFromLocal(module, scope, n, parent, name);
        }
      } else {
        handleGet(module, scope, n, parent, name);
      }
    }","public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();

    String name = null;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;

    switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            // This may be a key in an object literal declaration.
            if (parent != null && parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
            }
            if (name == null) {
                return;
            }
            isSet = true;

            switch (n.getType()) {
                case Token.STRING_KEY:
                    type = getValueType(n.getFirstChild());
                    break;
                case Token.GETTER_DEF:
                    type = Name.Type.GET;
                    break;
                case Token.SETTER_DEF:
                    type = Name.Type.SET;
                    break;
                default:
                    throw new IllegalStateException(""unexpected: "" + n);
            }
            break;

        case Token.NAME:
            // This may be a variable get or set.
            if (parent != null) {
                switch (parent.getType()) {
                    case Token.VAR:
                        isSet = true;
                        Node rvalue = n.getFirstChild();
                        type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                        break;
                    case Token.ASSIGN:
                        if (parent.getFirstChild() == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                        }
                        break;
                    case Token.GETPROP:
                        return;
                    case Token.FUNCTION:
                        Node gramps = parent.getParent();
                        if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                            return;
                        }
                        isSet = true;
                        type = Name.Type.FUNCTION;
                        break;
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) &&
                            parent.getFirstChild() == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getString();
            break;

        case Token.GETPROP:
            // This may be a namespaced name get or set.
            if (parent != null) {
                switch (parent.getType()) {
                    case Token.ASSIGN:
                        if (parent.getFirstChild() == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                            isPropAssign = true;
                        }
                        break;
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    case Token.GETPROP:
                        return;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) &&
                            parent.getFirstChild() == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;

        default:
            return;
    }

    // We are only interested in global names.
    if (name == null || !isGlobalNameReference(name, scope)) {
        return;
    }

    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}",0,0
32,Closure_119,"public void collect(JSModule module, Scope scope, Node n) {
      Node parent = n.getParent();

      String name;
      boolean isSet = false;
      Name.Type type = Name.Type.OTHER;
      boolean isPropAssign = false;

      switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
          // This may be a key in an object literal declaration.
          name = null;
          if (parent != null && parent.isObjectLit()) {
            name = getNameForObjLitKey(n);
          }
          if (name == null) {
            return;
          }
          isSet = true;
          switch (n.getType()) {
            case Token.STRING_KEY:
              type = getValueType(n.getFirstChild());
              break;
            case Token.GETTER_DEF:
              type = Name.Type.GET;
              break;
            case Token.SETTER_DEF:
              type = Name.Type.SET;
              break;
            default:
              throw new IllegalStateException(""unexpected:"" + n);
          }
          break;
        case Token.NAME:
          // This may be a variable get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.VAR:
                isSet = true;
                Node rvalue = n.getFirstChild();
                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                break;
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                }
                break;
              case Token.GETPROP:
                return;
              case Token.FUNCTION:
                Node gramps = parent.getParent();
                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                  return;
                }
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
                type = Name.Type.OTHER;
                break;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getString();
          break;
        case Token.GETPROP:
          // This may be a namespaced name get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                  isPropAssign = true;
                }
                break;
              case Token.INC:
              case Token.DEC:
                isSet = true;
                type = Name.Type.OTHER;
                break;
              case Token.GETPROP:
                return;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getQualifiedName();
          if (name == null) {
            return;
          }
          break;
        default:
          return;
      }

      // We are only interested in global names.
      if (!isGlobalNameReference(name, scope)) {
        return;
      }

      if (isSet) {
        if (isGlobalScope(scope)) {
          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
          handleSetFromLocal(module, scope, n, parent, name);
        }
      } else {
        handleGet(module, scope, n, parent, name);
      }
    }","public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();

    String name = null;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;

    switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            if (parent != null && parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
            }
            if (name == null) {
                return;
            }
            isSet = true;

            if (parent.hasChildren()) {
                switch (n.getType()) {
                    case Token.STRING_KEY:
                        type = getValueType(n.getFirstChild());
                        break;
                    case Token.GETTER_DEF:
                        type = Name.Type.GET;
                        break;
                    case Token.SETTER_DEF:
                        type = Name.Type.SET;
                        break;
                    default:
                        throw new IllegalStateException(""Unexpected node type: "" + n);
                }
            }
            break;

        case Token.NAME:
            if (parent != null) {
                Node firstChild = parent.getFirstChild();
                switch (parent.getType()) {
                    case Token.VAR:
                        isSet = true;
                        Node rvalue = n.getFirstChild();
                        type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                        break;
                    case Token.ASSIGN:
                        if (firstChild == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                        }
                        break;
                    case Token.GETPROP:
                        return;
                    case Token.FUNCTION:
                        Node gramps = parent.getParent();
                        if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                            return;
                        }
                        isSet = true;
                        type = Name.Type.FUNCTION;
                        break;
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) && firstChild == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getString();
            break;

        case Token.GETPROP:
            if (parent != null) {
                Node firstChild = parent.getFirstChild();
                switch (parent.getType()) {
                    case Token.ASSIGN:
                        if (firstChild == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                            isPropAssign = true;
                        }
                        break;
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) && firstChild == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;

        default:
            return;
    }

    if (name == null || !isGlobalNameReference(name, scope)) {
        return;
    }

    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}",0,1
32,Closure_119,"public void collect(JSModule module, Scope scope, Node n) {
      Node parent = n.getParent();

      String name;
      boolean isSet = false;
      Name.Type type = Name.Type.OTHER;
      boolean isPropAssign = false;

      switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
          // This may be a key in an object literal declaration.
          name = null;
          if (parent != null && parent.isObjectLit()) {
            name = getNameForObjLitKey(n);
          }
          if (name == null) {
            return;
          }
          isSet = true;
          switch (n.getType()) {
            case Token.STRING_KEY:
              type = getValueType(n.getFirstChild());
              break;
            case Token.GETTER_DEF:
              type = Name.Type.GET;
              break;
            case Token.SETTER_DEF:
              type = Name.Type.SET;
              break;
            default:
              throw new IllegalStateException(""unexpected:"" + n);
          }
          break;
        case Token.NAME:
          // This may be a variable get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.VAR:
                isSet = true;
                Node rvalue = n.getFirstChild();
                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                break;
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                }
                break;
              case Token.GETPROP:
                return;
              case Token.FUNCTION:
                Node gramps = parent.getParent();
                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                  return;
                }
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
                type = Name.Type.OTHER;
                break;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getString();
          break;
        case Token.GETPROP:
          // This may be a namespaced name get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                  isPropAssign = true;
                }
                break;
              case Token.INC:
              case Token.DEC:
                isSet = true;
                type = Name.Type.OTHER;
                break;
              case Token.GETPROP:
                return;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getQualifiedName();
          if (name == null) {
            return;
          }
          break;
        default:
          return;
      }

      // We are only interested in global names.
      if (!isGlobalNameReference(name, scope)) {
        return;
      }

      if (isSet) {
        if (isGlobalScope(scope)) {
          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
          handleSetFromLocal(module, scope, n, parent, name);
        }
      } else {
        handleGet(module, scope, n, parent, name);
      }
    }","public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();

    String name = null;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;

    switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            // Handle object literal keys.
            if (parent != null && parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
            }
            if (name == null) {
                return;
            }
            isSet = true;
            type = switch (n.getType()) {
                case Token.STRING_KEY -> getValueType(n.getFirstChild());
                case Token.GETTER_DEF -> Name.Type.GET;
                case Token.SETTER_DEF -> Name.Type.SET;
                default -> throw new IllegalStateException(""Unexpected node type: "" + n);
            };
            break;

        case Token.NAME:
            // Handle variable declarations and assignments.
            if (parent != null) {
                Node firstChild = parent.getFirstChild();
                switch (parent.getType()) {
                    case Token.VAR -> {
                        isSet = true;
                        Node rvalue = n.getFirstChild();
                        type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                    }
                    case Token.ASSIGN -> {
                        if (firstChild == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                        }
                    }
                    case Token.FUNCTION -> {
                        Node gramps = parent.getParent();
                        if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                            return;
                        }
                        isSet = true;
                        type = Name.Type.FUNCTION;
                    }
                    case Token.INC:
                    case Token.DEC -> {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
                    default -> {
                        if (NodeUtil.isAssignmentOp(parent) && firstChild == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                    }
                }
            }
            name = n.getString();
            break;

        case Token.GETPROP:
            // Handle namespaced names.
            if (parent != null) {
                Node firstChild = parent.getFirstChild();
                switch (parent.getType()) {
                    case Token.ASSIGN -> {
                        if (firstChild == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                            isPropAssign = true;
                        }
                    }
                    case Token.INC:
                    case Token.DEC -> {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
                    default -> {
                        if (NodeUtil.isAssignmentOp(parent) && firstChild == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                    }
                }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;

        default:
            return;
    }

    // Ensure global name reference validity, including ""catch"" clauses.
    if (name == null || !isGlobalNameReference(name, scope) || !isValidGlobalCatch(name, scope)) {
        return;
    }

    // Handle global or local names accordingly.
    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}

/**
 * Helper method to check if a global name in a catch block is valid.
 */
private boolean isValidGlobalCatch(String name, Scope scope) {
    return scope.isGlobal() || !isCatchVariable(name, scope);
}

/**
 * Helper method to check if a name corresponds to a catch variable.
 */
private boolean isCatchVariable(String name, Scope scope) {
    // Assuming NodeUtil function exists: checks if `name` is bound
    // inside a catch scope for error handling.
    return NodeUtil.isCatchScopeVariable(name, scope);
}",0,2
33,Closure_12,"    public ReachingUses apply(List<ReachingUses> from) {
      ReachingUses result = new ReachingUses();
      for (ReachingUses uses : from) {
        result.mayUseMap.putAll(uses.mayUseMap);
      }
      return result;
    }
","public ReachingUses apply(List<ReachingUses> from) {
    ReachingUses result = new ReachingUses();
    if (from == null || from.isEmpty()) {
        return result;
    }
    for (ReachingUses uses : from) {
        if (uses != null && uses.mayUseMap != null) {
            result.mayUseMap.putAll(uses.mayUseMap);
        }
    }
    return result;
}",0,0
33,Closure_12,"    public ReachingUses apply(List<ReachingUses> from) {
      ReachingUses result = new ReachingUses();
      for (ReachingUses uses : from) {
        result.mayUseMap.putAll(uses.mayUseMap);
      }
      return result;
    }
","public ReachingUses apply(List<ReachingUses> from) {
    ReachingUses result = new ReachingUses();
    if (from == null || from.isEmpty()) {
        return result;
    }
    for (ReachingUses uses : from) {
        if (uses != null && uses.mayUseMap != null) {
            for (Map.Entry<String, Object> entry : uses.mayUseMap.entrySet()) {
                result.mayUseMap.merge(entry.getKey(), entry.getValue(), (v1, v2) -> {
                    // Customize merge logic based on possible conflicts
                    return v1.equals(v2) ? v1 : v2; // Preserve values if identical, otherwise use the second value
                });
            }
        }
    }
    return result;
}",0,1
34,Closure_120,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
      }

      // Make sure this assignment is not in a loop.
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
        }
      }

      return true;
    }","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }

    // Make sure this assignment is not in a loop.
    BasicBlock block = ref.getBasicBlock();
    while (block != null && !block.isFunction) {
        if (block.isLoop) {
            return false;
        }
        block = block.getParent();
    }

    return true;
}",0,0
34,Closure_120,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
      }

      // Make sure this assignment is not in a loop.
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
        }
      }

      return true;
    }","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }

    // Ensure assignment is not in a loop and is part of a linear execution path
    BasicBlock block = ref.getBasicBlock();
    while (block != null) {
        if (block.isLoop) {
            return false;
        }
        if (block.isConditional()) {
            return false; // Prevent assignments within conditionals
        }
        if (block.isFunction) {
            break; // Stop traversal once function scope is reached
        }
        block = block.getParent();
    }

    return true;
}",0,1
35,Closure_121,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration == init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
      if (!maybeModifiedArguments &&
          !staleVars.contains(v) &&
          referenceInfo.isWellDefined() &&
          referenceInfo.isAssignedOnceInLifetime()) {
        // Inlining the variable based solely on well-defined and assigned
        // once is *NOT* correct. We relax the correctness requirement if
        // the variable is declared constant.
        List<Reference> refs = referenceInfo.references;
        for (int i = 1 /* start from a read */; i < refs.size(); i++) {
          Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }",0,0
35,Closure_121,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    boolean hasSeparateInit = init != null && declaration != init;

    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        Node value = (init != null) ? init.getAssignedValue() : NodeUtil.newUndefinedNode(declaration.getNode());
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == (hasSeparateInit ? 3 : 2)) {
        Reference reference = referenceInfo.references.get(hasSeparateInit ? 2 : 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (hasSeparateInit && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }

    if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit = candidate.refInfo.getInitializingReference();
                    if (aliasInit != null) {
                        Node value = aliasInit.getAssignedValue();
                        Preconditions.checkNotNull(value);
                        inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                        staleVars.add(candidate.alias);
                    }
                }
            }
        }
    }
}",0,1
35,Closure_121,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    boolean hasSeparateInit = init != null && declaration != init;

    // Check if the variable can safely be inlined when immutable and well-defined
    if (refCount > 1 &&
        isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        Node value = (init != null) ? init.getAssignedValue() : NodeUtil.newUndefinedNode(declaration.getNode());
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } 
    // Attempt complex inlining for single-use variables
    else if (refCount == (hasSeparateInit ? 3 : 2)) {
        int referenceIndex = hasSeparateInit ? 2 : 1;
        Reference reference = referenceInfo.references.get(referenceIndex);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } 
    // Inline variables with only initialization references
    else if (!hasSeparateInit && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    } 

    // Check for alias references and inline them conditionally
    if (!maybeModifiedArguments &&
        !staleVars.contains(v) &&
        referenceInfo.isWellDefined() &&
        referenceInfo.isAssignedOnceInLifetime()) {
        for (Reference ref : referenceInfo.references) {
            Node nameNode = ref.getNode();
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (candidate != null &&
                !staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
                Reference aliasInit = candidate.refInfo.getInitializingReference();
                if (aliasInit != null) {
                    Node value = aliasInit.getAssignedValue();
                    Preconditions.checkNotNull(value);
                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                    staleVars.add(candidate.alias);
                }
            }
        }
    }

    // Apply fallback alias inlining for specific cases without complex assumptions
    if (!maybeModifiedArguments &&
        hasSeparateInit &&
        !staleVars.contains(v) &&
        referenceInfo.isAssignedMultipleTimes() &&
        !isVarInlineForbidden(v)) {
        Reference aliasInit = init;
        if (aliasInit != null) {
            Node value = aliasInit.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }
}",0,2
36,Closure_122,"  private void handleBlockComment(Comment comment) {
    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
      errorReporter.warning(
          SUSPICIOUS_COMMENT_WARNING,
          sourceName,
          comment.getLineno(), """", 0);
    }
  }
","private void handleBlockComment(Comment comment) {
    String commentValue = comment.getValue();
    if (commentValue.contains(""/* @"") || commentValue.contains(""\n * @"")) {
        errorReporter.warning(
            SUSPICIOUS_COMMENT_WARNING,
            sourceName,
            comment.getLineno(),
            """",
            0);
    }
}",0,0
36,Closure_122,"  private void handleBlockComment(Comment comment) {
    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
      errorReporter.warning(
          SUSPICIOUS_COMMENT_WARNING,
          sourceName,
          comment.getLineno(), """", 0);
    }
  }
","private void handleBlockComment(Comment comment) {
    String commentValue = comment.getValue();
    if (commentValue != null && commentValue.contains(""@"")) {
        int atStartIndex = commentValue.indexOf(""@"");
        if (commentValue.substring(0, atStartIndex).contains(""/*"") || 
            commentValue.substring(0, atStartIndex).contains(""\n *"")) {
            errorReporter.warning(
                SUSPICIOUS_COMMENT_WARNING,
                sourceName,
                comment.getLineno(),
                """",
                0);
        }
    }
}",0,1
37,Closure_123,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context,
            getContextForNoInOperator(context), 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // Unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top-level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3
            && TokenStream.isKeyword(last.getString())) {
          // Check for ECMASCRIPT3 keywords.
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(
            childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(
            childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString()
                && !(languageMode == LanguageMode.ECMASCRIPT3
                    && TokenStream.isKeyword(key))
                && TokenStream.isJSIdentifier(key)
                // do not encode literally any non-literal characters that
                // were Unicode escaped.
                && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && childCount == 2 && first != last) { // Ensure proper binary operator conditions
        Preconditions.checkState(
            childCount == 2,
            ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
            opstr, childCount);
        int p = NodeUtil.precedence(type);

        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);

        // Handle associativity.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }

    cc.startSourceMapping(n);

    // Improve switch-case checks and throws for consistency 
    switch (type) {
        case Token.TRY: {
            Preconditions.checkState(first != null);
            Preconditions.checkState(first.getNext().isBlock() &&
                    !first.getNext().hasMoreThanOneChild());
            Preconditions.checkState(childCount >= 2 && childCount <= 3);

            add(""try"");
            add(first, Context.PRESERVE_BLOCK);

            Node catchblock = first.getNext().getFirstChild();
            if (catchblock != null) {
                add(catchblock);
            }

            if (childCount == 3) {
                add(""finally"");
                add(last, Context.PRESERVE_BLOCK);
            }
            break;
        }

        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;

        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;

        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;

        case Token.NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;

        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;

        case Token.FUNCTION:
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }

            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);

            if (funcNeedsParens) {
                add("")"");
            }
            break;

        case Token.INC:
        case Token.DEC: {
            Preconditions.checkState(childCount == 1);
            String o = type == Token.INC ? ""++"" : ""--"";
            int postProp = n.getIntProp(Node.INCRDECR_PROP);
            if (postProp != 0) {
                addExpr(first, NodeUtil.precedence(type), context);
                cc.addOp(o, false);
            } else {
                cc.addOp(o, false);
                addExpr(first);
            }
            break;
        }

        case Token.CALL:
            Node next = first.getNext();
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(next);
            add("")"");
            break;

        // Handle additional operators and utility edge cases.
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
}",0,0
38,Closure_124,"private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
      return true;
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
    }

    return true;
  }","private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
        return true;
    }

    Preconditions.checkArgument(node != null && node.isGetProp(), ""Node must be a GETPROP."");
    node = node.getFirstChild();
    
    if (node != null && node.isName() 
        && replacement != null 
        && isNameAssignedTo(node.getString(), replacement)) {
        return false;
    }

    return true;
}",0,0
38,Closure_124,"private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
      return true;
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
    }

    return true;
  }","private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node == null || node.isName()) {
        return true;
    }

    Preconditions.checkArgument(node.isGetProp(), ""Node must be a GETPROP."");

    Node firstChild = node.getFirstChild();
    if (firstChild == null || !firstChild.isName()) {
        return true;
    }

    if (replacement == null || !isNameAssignedTo(firstChild.getString(), replacement)) {
        return true;
    }

    return false;
}",0,1
38,Closure_124,"private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
      return true;
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
    }

    return true;
  }","private boolean isSafeReplacement(Node node, Node replacement) {
    // Check if node is null or a simple name, in both cases replacement is safe
    if (node == null || node.isName()) {
        return true;
    }

    // Ensure node is of type GETPROP
    Preconditions.checkArgument(node.isGetProp(), ""Node must be a GETPROP."");

    Node firstChild = node.getFirstChild();
    if (firstChild == null) {
        return true;
    }

    // If the first child is a name and the replacement is not assigned,
    // it is safe to replace.
    if (!firstChild.isName() || replacement == null || !isNameAssignedTo(firstChild.getString(), replacement)) {
        return true;
    }

    return false;
}",0,2
39,Closure_125,"private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
       if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
        ensureTyped(t, n);
      }
    } else {
      report(t, n, NOT_A_CONSTRUCTOR);
      ensureTyped(t, n);
    }
  }","private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    if (type != null && (type.isConstructor() || type.isEmptyType() || type.isUnknownType())) {
        FunctionType fnType = type.toMaybeFunctionType();
        if (fnType != null) {
            visitParameterList(t, n, fnType);
            ensureTyped(t, n, fnType.getInstanceType());
        } else {
            ensureTyped(t, n);
        }
    } else {
        report(t, n, NOT_A_CONSTRUCTOR);
        ensureTyped(t, n);
    }
}",0,0
39,Closure_125,"private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
       if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
        ensureTyped(t, n);
      }
    } else {
      report(t, n, NOT_A_CONSTRUCTOR);
      ensureTyped(t, n);
    }
  }","private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();

    // Check for null before proceeding to avoid potential null pointer issues
    if (type == null) {
        report(t, n, NOT_A_CONSTRUCTOR);
        ensureTyped(t, n);
        return;
    }

    // Perform stricter type validation to ensure consistency
    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
        FunctionType fnType = type.toMaybeFunctionType();

        // Additional validation to guard against invalid function type scenarios
        if (fnType != null && fnType.getInstanceType() != null) {
            visitParameterList(t, n, fnType);
            ensureTyped(t, n, fnType.getInstanceType());
        } else if (fnType != null) {
            report(t, n, INVALID_FUNCTION_TYPE);
            ensureTyped(t, n);
        } else {
            ensureTyped(t, n);
        }
    } else {
        report(t, n, NOT_A_CONSTRUCTOR);
        ensureTyped(t, n);
    }
}",0,1
40,Closure_126,"void tryMinimizeExits(Node n, int exitType, String labelName) {

    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
      NodeUtil.removeChild(n.getParent(), n);
      compiler.reportCodeChange();
      return;
    }

    // Just an 'if'.
    if (n.isIf()) {
      Node ifBlock = n.getFirstChild().getNext();
      tryMinimizeExits(ifBlock, exitType, labelName);
      Node elseBlock = ifBlock.getNext();
      if (elseBlock != null) {
        tryMinimizeExits(elseBlock, exitType, labelName);
      }
      return;
    }

    // Just a 'try/catch/finally'.
    if (n.isTry()) {
      Node tryBlock = n.getFirstChild();
      tryMinimizeExits(tryBlock, exitType, labelName);
      Node allCatchNodes = NodeUtil.getCatchBlock(n);
      if (NodeUtil.hasCatchHandler(allCatchNodes)) {
        Preconditions.checkState(allCatchNodes.hasOneChild());
        Node catchNode = allCatchNodes.getFirstChild();
        Node catchCodeBlock = catchNode.getLastChild();
        tryMinimizeExits(catchCodeBlock, exitType, labelName);
      }
      /* Don't try to minimize the exits of finally blocks, as this
        * can cause problems if it changes the completion type of the finally
        * block. See ECMA 262 Sections 8.9 & 12.14
        */
       if (NodeUtil.hasFinally(n)) {
         Node finallyBlock = n.getLastChild();
         tryMinimizeExits(finallyBlock, exitType, labelName);
       }
     }
 
     // Just a 'label'.
    if (n.isLabel()) {
      Node labelBlock = n.getLastChild();
      tryMinimizeExits(labelBlock, exitType, labelName);
    }

    // TODO(johnlenz): The last case of SWITCH statement?

    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
      return;
    }

    // Multiple if-exits can be converted in a single pass.
    // Convert ""if (blah) break;  if (blah2) break; other_stmt;"" to
    // become ""if (blah); else { if (blah2); else { other_stmt; } }""
    // which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
    for (Node c : n.children()) {

      // An 'if' block to process below.
      if (c.isIf()) {
        Node ifTree = c;
        Node trueBlock, falseBlock;

        // First, the true condition block.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        tryMinimizeIfBlockExits(trueBlock, falseBlock,
            ifTree, exitType, labelName);

        // Now the else block.
        // The if blocks may have changed, get them again.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        if (falseBlock != null) {
          tryMinimizeIfBlockExits(falseBlock, trueBlock,
              ifTree, exitType, labelName);
        }
      }

      if (c == n.getLastChild()) {
        break;
      }
    }

    // Now try to minimize the exits of the last child, if it is removed
    // look at what has become the last child.
    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
      tryMinimizeExits(c, exitType, labelName);
      // If the node is still the last child, we are done.
      if (c == n.getLastChild()) {
        break;
      }
    }
  }","void tryMinimizeExits(Node n, int exitType, String labelName) {

    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
        Node parent = n.getParent();
        if (parent != null) {
            NodeUtil.removeChild(parent, n);
            compiler.reportCodeChange();
        }
        return;
    }

    // Just an 'if'.
    if (n.isIf()) {
        Node ifBlock = n.getFirstChild().getNext();
        if (ifBlock != null) {
            tryMinimizeExits(ifBlock, exitType, labelName);
        }
        Node elseBlock = ifBlock != null ? ifBlock.getNext() : null;
        if (elseBlock != null) {
            tryMinimizeExits(elseBlock, exitType, labelName);
        }
        return;
    }

    // Just a 'try/catch/finally'.
    if (n.isTry()) {
        Node tryBlock = n.getFirstChild();
        if (tryBlock != null) {
            tryMinimizeExits(tryBlock, exitType, labelName);
        }
        Node allCatchNodes = NodeUtil.getCatchBlock(n);
        if (NodeUtil.hasCatchHandler(allCatchNodes) && allCatchNodes != null) {
            Preconditions.checkState(allCatchNodes.hasOneChild());
            Node catchNode = allCatchNodes.getFirstChild();
            if (catchNode != null) {
                Node catchCodeBlock = catchNode.getLastChild();
                if (catchCodeBlock != null) {
                    tryMinimizeExits(catchCodeBlock, exitType, labelName);
                }
            }
        }
        /* Don't try to minimize the exits of finally blocks, as this
         * can cause problems if it changes the completion type of the finally
         * block. See ECMA 262 Sections 8.9 & 12.14
         */
        if (NodeUtil.hasFinally(n)) {
            Node finallyBlock = n.getLastChild();
            if (finallyBlock != null) {
                tryMinimizeExits(finallyBlock, exitType, labelName);
            }
        }
        return;
    }

    // Just a 'label'.
    if (n.isLabel()) {
        Node labelBlock = n.getLastChild();
        if (labelBlock != null) {
            tryMinimizeExits(labelBlock, exitType, labelName);
        }
        return;
    }

    // TODO(johnlenz): The last case of SWITCH statement?

    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
        return;
    }

    // Multiple if-exits can be converted in a single pass.
    for (Node c : n.children()) {

        // An 'if' block to process below.
        if (c.isIf()) {
            Node ifTree = c;
            Node trueBlock, falseBlock;

            // First, the true condition block.
            trueBlock = ifTree.getFirstChild().getNext();
            if (trueBlock != null) {
                falseBlock = trueBlock.getNext();
                tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);

                // Now the else block.
                // The if blocks may have changed, get them again.
                trueBlock = ifTree.getFirstChild().getNext();
                falseBlock = trueBlock != null ? trueBlock.getNext() : null;
                if (falseBlock != null) {
                    tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);
                }
            }
        }

        if (c == n.getLastChild()) {
            break;
        }
    }

    // Now try to minimize the exits of the last child, if it is removed
    // look at what has become the last child.
    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
        tryMinimizeExits(c, exitType, labelName);
        // If the node is still the last child, we are done.
        if (c == n.getLastChild()) {
            break;
        }
    }
}",0,0
40,Closure_126,"void tryMinimizeExits(Node n, int exitType, String labelName) {

    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
      NodeUtil.removeChild(n.getParent(), n);
      compiler.reportCodeChange();
      return;
    }

    // Just an 'if'.
    if (n.isIf()) {
      Node ifBlock = n.getFirstChild().getNext();
      tryMinimizeExits(ifBlock, exitType, labelName);
      Node elseBlock = ifBlock.getNext();
      if (elseBlock != null) {
        tryMinimizeExits(elseBlock, exitType, labelName);
      }
      return;
    }

    // Just a 'try/catch/finally'.
    if (n.isTry()) {
      Node tryBlock = n.getFirstChild();
      tryMinimizeExits(tryBlock, exitType, labelName);
      Node allCatchNodes = NodeUtil.getCatchBlock(n);
      if (NodeUtil.hasCatchHandler(allCatchNodes)) {
        Preconditions.checkState(allCatchNodes.hasOneChild());
        Node catchNode = allCatchNodes.getFirstChild();
        Node catchCodeBlock = catchNode.getLastChild();
        tryMinimizeExits(catchCodeBlock, exitType, labelName);
      }
      /* Don't try to minimize the exits of finally blocks, as this
        * can cause problems if it changes the completion type of the finally
        * block. See ECMA 262 Sections 8.9 & 12.14
        */
       if (NodeUtil.hasFinally(n)) {
         Node finallyBlock = n.getLastChild();
         tryMinimizeExits(finallyBlock, exitType, labelName);
       }
     }
 
     // Just a 'label'.
    if (n.isLabel()) {
      Node labelBlock = n.getLastChild();
      tryMinimizeExits(labelBlock, exitType, labelName);
    }

    // TODO(johnlenz): The last case of SWITCH statement?

    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
      return;
    }

    // Multiple if-exits can be converted in a single pass.
    // Convert ""if (blah) break;  if (blah2) break; other_stmt;"" to
    // become ""if (blah); else { if (blah2); else { other_stmt; } }""
    // which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
    for (Node c : n.children()) {

      // An 'if' block to process below.
      if (c.isIf()) {
        Node ifTree = c;
        Node trueBlock, falseBlock;

        // First, the true condition block.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        tryMinimizeIfBlockExits(trueBlock, falseBlock,
            ifTree, exitType, labelName);

        // Now the else block.
        // The if blocks may have changed, get them again.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        if (falseBlock != null) {
          tryMinimizeIfBlockExits(falseBlock, trueBlock,
              ifTree, exitType, labelName);
        }
      }

      if (c == n.getLastChild()) {
        break;
      }
    }

    // Now try to minimize the exits of the last child, if it is removed
    // look at what has become the last child.
    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
      tryMinimizeExits(c, exitType, labelName);
      // If the node is still the last child, we are done.
      if (c == n.getLastChild()) {
        break;
      }
    }
  }","void tryMinimizeExits(Node n, int exitType, String labelName) {

    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
        Node parent = n.getParent();
        if (parent != null) {
            NodeUtil.removeChild(parent, n);
            compiler.reportCodeChange();
        }
        return;
    }

    // Just an 'if'.
    if (n.isIf()) {
        Node ifBlock = n.getFirstChild().getNext();
        if (ifBlock != null) {
            tryMinimizeExits(ifBlock, exitType, labelName);
        }
        Node elseBlock = ifBlock != null ? ifBlock.getNext() : null;
        if (elseBlock != null) {
            tryMinimizeExits(elseBlock, exitType, labelName);
        }
        return;
    }

    // Just a 'try/catch/finally'.
    if (n.isTry()) {
        Node tryBlock = n.getFirstChild();
        if (tryBlock != null) {
            tryMinimizeExits(tryBlock, exitType, labelName);
        }
        Node allCatchNodes = NodeUtil.getCatchBlock(n);
        if (allCatchNodes != null && NodeUtil.hasCatchHandler(allCatchNodes)) {
            Preconditions.checkState(allCatchNodes.hasOneChild());
            Node catchNode = allCatchNodes.getFirstChild();
            if (catchNode != null) {
                Node catchCodeBlock = catchNode.getLastChild();
                if (catchCodeBlock != null) {
                    tryMinimizeExits(catchCodeBlock, exitType, labelName);
                }
            }
        }
        /* Don't try to minimize the exits of finally blocks, as this
         * can cause problems if it changes the completion type of the finally
         * block. See ECMA 262 Sections 8.9 & 12.14
         */
        if (NodeUtil.hasFinally(n)) {
            Node finallyBlock = n.getLastChild();
            if (finallyBlock != null) {
                tryMinimizeExits(finallyBlock, exitType, labelName);
            }
        }
        return;
    }

    // Just a 'label'.
    if (n.isLabel()) {
        Node labelBlock = n.getLastChild();
        if (labelBlock != null) {
            tryMinimizeExits(labelBlock, exitType, labelName);
        }
        return;
    }

    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
        return;
    }

    // Multiple if-exits can be converted in a single pass.
    for (Node c : n.children()) {
        // An 'if' block to process below.
        if (c.isIf()) {
            Node ifTree = c;
            Node trueBlock, falseBlock;

            // First, the true condition block.
            trueBlock = ifTree.getFirstChild().getNext();
            if (trueBlock != null) {
                falseBlock = trueBlock.getNext();
                tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);

                // Now the else block.
                // The if blocks may have changed, get them again.
                trueBlock = ifTree.getFirstChild().getNext();
                falseBlock = trueBlock != null ? trueBlock.getNext() : null;
                if (falseBlock != null) {
                    tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);
                }
            }
        }

        if (c == n.getLastChild()) {
            break;
        }
    }

    // Now try to minimize the exits of the last child, if it is removed
    // look at what has become the last child.
    while (n.hasChildren()) {
        Node c = n.getLastChild();
        tryMinimizeExits(c, exitType, labelName);
        // If the node is still the last child, we are done.
        if (c == n.getLastChild()) {
            break;
        }
    }
}",0,1
40,Closure_126,"void tryMinimizeExits(Node n, int exitType, String labelName) {

    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
      NodeUtil.removeChild(n.getParent(), n);
      compiler.reportCodeChange();
      return;
    }

    // Just an 'if'.
    if (n.isIf()) {
      Node ifBlock = n.getFirstChild().getNext();
      tryMinimizeExits(ifBlock, exitType, labelName);
      Node elseBlock = ifBlock.getNext();
      if (elseBlock != null) {
        tryMinimizeExits(elseBlock, exitType, labelName);
      }
      return;
    }

    // Just a 'try/catch/finally'.
    if (n.isTry()) {
      Node tryBlock = n.getFirstChild();
      tryMinimizeExits(tryBlock, exitType, labelName);
      Node allCatchNodes = NodeUtil.getCatchBlock(n);
      if (NodeUtil.hasCatchHandler(allCatchNodes)) {
        Preconditions.checkState(allCatchNodes.hasOneChild());
        Node catchNode = allCatchNodes.getFirstChild();
        Node catchCodeBlock = catchNode.getLastChild();
        tryMinimizeExits(catchCodeBlock, exitType, labelName);
      }
      /* Don't try to minimize the exits of finally blocks, as this
        * can cause problems if it changes the completion type of the finally
        * block. See ECMA 262 Sections 8.9 & 12.14
        */
       if (NodeUtil.hasFinally(n)) {
         Node finallyBlock = n.getLastChild();
         tryMinimizeExits(finallyBlock, exitType, labelName);
       }
     }
 
     // Just a 'label'.
    if (n.isLabel()) {
      Node labelBlock = n.getLastChild();
      tryMinimizeExits(labelBlock, exitType, labelName);
    }

    // TODO(johnlenz): The last case of SWITCH statement?

    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
      return;
    }

    // Multiple if-exits can be converted in a single pass.
    // Convert ""if (blah) break;  if (blah2) break; other_stmt;"" to
    // become ""if (blah); else { if (blah2); else { other_stmt; } }""
    // which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
    for (Node c : n.children()) {

      // An 'if' block to process below.
      if (c.isIf()) {
        Node ifTree = c;
        Node trueBlock, falseBlock;

        // First, the true condition block.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        tryMinimizeIfBlockExits(trueBlock, falseBlock,
            ifTree, exitType, labelName);

        // Now the else block.
        // The if blocks may have changed, get them again.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        if (falseBlock != null) {
          tryMinimizeIfBlockExits(falseBlock, trueBlock,
              ifTree, exitType, labelName);
        }
      }

      if (c == n.getLastChild()) {
        break;
      }
    }

    // Now try to minimize the exits of the last child, if it is removed
    // look at what has become the last child.
    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
      tryMinimizeExits(c, exitType, labelName);
      // If the node is still the last child, we are done.
      if (c == n.getLastChild()) {
        break;
      }
    }
  }","void tryMinimizeExits(Node n, int exitType, String labelName) {
    
    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
        Node parent = n.getParent();
        if (parent != null) {
            NodeUtil.removeChild(parent, n);
            compiler.reportCodeChange();
        }
        return;
    }
    
    // Just an 'if'.
    if (n.isIf()) {
        Node condition = n.getFirstChild();
        Node ifBlock = condition.getNext();
        if (ifBlock != null) {
            tryMinimizeExits(ifBlock, exitType, labelName);
        }
        Node elseBlock = ifBlock != null ? ifBlock.getNext() : null;
        if (elseBlock != null) {
            tryMinimizeExits(elseBlock, exitType, labelName);
        }
        return;
    }
    
    // Just a 'try/catch/finally'.
    if (n.isTry()) {
        Node tryBlock = n.getFirstChild();
        if (tryBlock != null) {
            tryMinimizeExits(tryBlock, exitType, labelName);
        }
        Node allCatchNodes = NodeUtil.getCatchBlock(n);
        if (allCatchNodes != null && NodeUtil.hasCatchHandler(allCatchNodes)) {
            Node catchNode = allCatchNodes.getFirstChild();
            if (catchNode != null) {
                Node catchCodeBlock = catchNode.getLastChild();
                if (catchCodeBlock != null) {
                    tryMinimizeExits(catchCodeBlock, exitType, labelName);
                }
            }
        }
        // Do not alter finally block exits
        return;
    }
    
    // Just a 'label'.
    if (n.isLabel()) {
        Node labelBlock = n.getLastChild();
        if (labelBlock != null) {
            tryMinimizeExits(labelBlock, exitType, labelName);
        }
        return;
    }
    
    // Assuming a block with at least one child
    if (!n.isBlock() || n.getLastChild() == null) {
        return;
    }
    
    List<Node> children = new ArrayList<>();
    for (Node c : n.children()) {
        children.add(c);
    }

    for (int i = 0; i < children.size(); i++) {
        Node c = children.get(i);
        if (c == null) continue;

        // Special handling for 'if' statements
        if (c.isIf()) {
            Node ifTree = c;
            Node trueBlock = ifTree.getFirstChild().getNext();
            Node falseBlock = trueBlock != null ? trueBlock.getNext() : null;
            
            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);
            
            if (falseBlock != null) {
                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);
            }
        }

        if (c == children.get(children.size() - 1)) {
            break;
        }
    }

    // Minimize exits of the last child
    Node lastChild = n.getLastChild();
    while (lastChild != null) {
        tryMinimizeExits(lastChild, exitType, labelName);
        if (n.getLastChild() == lastChild) {
            break;
        }
        lastChild = n.getLastChild();
    }
}",0,2
41,Closure_128,"static boolean isSimpleNumber(String s) {
     int len = s.length();
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
       if (c < '0' || c > '9') {
         return false;
       }
     }
     return len > 0 && s.charAt(0) != '0';
   }","static boolean isSimpleNumber(String s) {
    int len = s.length();
    if (len == 0 || (len > 1 && s.charAt(0) == '0')) {
        return false;
    }
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return true;
}",0,0
42,Closure_129,"private void annotateCalls(Node n) {
      Preconditions.checkState(n.isCall());

      // Keep track of of the ""this"" context of a call.  A call without an
      // explicit ""this"" is a free call.
       Node first = n.getFirstChild();
 
       // ignore cast nodes.
 
       if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
      }

      // Keep track of the context in which eval is called. It is important
      // to distinguish between ""(0, eval)()"" and ""eval()"".
      if (first.isName() &&
          ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
      }
    }","private void annotateCalls(Node n) {
    Preconditions.checkState(n.isCall());

    // Keep track of the ""this"" context of a call. A call without an
    // explicit ""this"" is a free call.
    Node first = n.getFirstChild();

    // Ignore cast nodes.
    while (NodeUtil.isCast(first)) {
        first = first.getFirstChild();
    }

    if (!NodeUtil.isGet(first)) {
        n.putBooleanProp(Node.FREE_CALL, true);
    }

    // Keep track of the context in which eval is called. It is important
    // to distinguish between ""(0, eval)()"" and ""eval()"".
    if (first.isName() && ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
    }
}",0,0
43,Closure_13,"private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
      return;
    }

    int visits = 0;
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
      visit(node);
      visits++;

      Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));

    exitNode(node);
  }","private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
        return;
    }

    int visits = 0;
    do {
        Node c = node.getFirstChild();
        while (c != null) {
            traverse(c);
            c = c.getNext(); // Simplified by directly assigning to `c`
        }

        visit(node);
        visits++;
        Preconditions.checkState(visits < 10000, ""Too many iterations while traversing node: "" + node);

    } while (shouldRetraverse(node));

    exitNode(node);
}",0,0
43,Closure_13,"private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
      return;
    }

    int visits = 0;
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
      visit(node);
      visits++;

      Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));

    exitNode(node);
  }","private void traverse(Node node) {
    if (!shouldVisit(node)) {
        return;
    }
   
    boolean shouldContinueTraversal = true;
    while (shouldContinueTraversal) {
        // Traverse children nodes lazily, ensuring no unnecessary re-traversals
        Node child = node.getFirstChild();
        while (child != null) {
            traverse(child);
            child = child.getNext();
        }

        // Visit the current node once all its children have been processed
        visit(node);

        // Check if further traversal is needed based on changes made during visit
        shouldContinueTraversal = shouldRetraverse(node);
    }
  
    // Exit the node after traversal is complete
    exitNode(node);
}",0,1
43,Closure_13,"private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
      return;
    }

    int visits = 0;
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
      visit(node);
      visits++;

      Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));

    exitNode(node);
  }","private void traverse(Node node) {
    if (!shouldVisit(node)) {
        return;
    }

    boolean nodeChanged = true;
    while (nodeChanged) {
        Node child = node.getFirstChild();
        while (child != null) {
            traverse(child);
            child = child.getNext();
        }

        visit(node);

        nodeChanged = shouldRetraverse(node);
    }

    exitNode(node);
}",0,2
44,Closure_130,"private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
      Name name = workList.pop();

      // Don't attempt to inline a getter or setter property as a variable.
      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
         continue;
       }
 
       if (name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
        List<Ref> refs = Lists.newArrayList(name.getRefs());
        for (Ref ref : refs) {
          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
            // {@code name} meets condition (c). Try to inline it.
            if (inlineAliasIfPossible(ref, namespace)) {
              name.removeRef(ref);
            }
          }
        }
      }

      // Check if {@code name} has any aliases left after the
      // local-alias-inlining above.
      if ((name.type == Name.Type.OBJECTLIT ||
           name.type == Name.Type.FUNCTION) &&
          name.aliasingGets == 0 && name.props != null) {
        // All of {@code name}'s children meet condition (a), so they can be
        // added to the worklist.
        workList.addAll(name.props);
      }
    }
  }","private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();

        // Don't attempt to inline a getter or setter property as a variable.
        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }

        if (name.globalSets == 1 && name.localSets == 0 &&
            name.aliasingGets > 0) {
            // {@code name} meets condition (b). Find all of its local aliases
            // and try to inline them.
            List<Ref> refs = Lists.newArrayList(name.getRefs());
            for (Iterator<Ref> iterator = refs.iterator(); iterator.hasNext();) {
                Ref ref = iterator.next();
                if (ref.type == Ref.Type.ALIASING_GET && ref.scope.isLocal()) {
                    // {@code name} meets condition (c). Try to inline it.
                    if (inlineAliasIfPossible(ref, namespace)) {
                        name.removeRef(ref);
                        iterator.remove(); // Ensure the iterator stays consistent
                    }
                }
            }
        }

        // Check if {@code name} has any aliases left after the
        // local-alias-inlining above.
        if ((name.type == Name.Type.OBJECTLIT ||
             name.type == Name.Type.FUNCTION) &&
            name.aliasingGets == 0 && name.props != null) {
            // All of {@code name}'s children meet condition (a), so they can be
            // added to the worklist.
            workList.addAll(name.props);
        }
    }
}",0,0
45,Closure_131,"public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
         if (
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
      }

      return true;
    }",Match failed,0,0
46,Closure_132,"private Node tryMinimizeIf(Node n) {

    Node parent = n.getParent();

    Node cond = n.getFirstChild();

    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
      return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
      if (isFoldableExpressBlock(thenBranch)) {
        Node expr = getBlockExpression(thenBranch);
        if (!late && isPropertyAssignmentInExpression(expr)) {
          // Keep opportunities for CollapseProperties such as
          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
          // until CollapseProperties has been run.
          return n;
        }

        if (cond.isNot()) {
          // if(!x)bar(); -> x||bar();
          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
              isLowerPrecedenceInExpression(expr.getFirstChild(),
                  OR_PRECEDENCE)) {
            // It's not okay to add two sets of parentheses.
            return n;
          }

          Node or = IR.or(
              cond.removeFirstChild(),
              expr.removeFirstChild()).srcref(n);
          Node newExpr = NodeUtil.newExpr(or);
          parent.replaceChild(n, newExpr);
          reportCodeChange();

          return newExpr;
        }

        // if(x)foo(); -> x&&foo();
        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
            isLowerPrecedenceInExpression(expr.getFirstChild(),
                AND_PRECEDENCE)) {
          // One additional set of parentheses is worth the change even if
          // there is no immediate code size win. However, two extra pair of
          // {}, we would have to think twice. (unless we know for sure the
          // we can further optimize its parent.
          return n;
        }

        n.removeChild(cond);
        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
        Node newExpr = NodeUtil.newExpr(and);
        parent.replaceChild(n, newExpr);
        reportCodeChange();

        return newExpr;
      } else {

        // Try to combine two IF-ELSE
        if (NodeUtil.isStatementBlock(thenBranch) &&
            thenBranch.hasOneChild()) {
          Node innerIf = thenBranch.getFirstChild();

          if (innerIf.isIf()) {
            Node innerCond = innerIf.getFirstChild();
            Node innerThenBranch = innerCond.getNext();
            Node innerElseBranch = innerThenBranch.getNext();

            if (innerElseBranch == null &&
                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
              n.detachChildren();
              n.addChildToBack(
                  IR.and(
                      cond,
                      innerCond.detachFromParent())
                      .srcref(cond));
              n.addChildrenToBack(innerThenBranch.detachFromParent());
              reportCodeChange();
              // Not worth trying to fold the current IF-ELSE into && because
              // the inner IF-ELSE wasn't able to be folded into && anyways.
              return n;
            }
          }
        }
      }

      return n;
    }

    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);

    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
      n.replaceChild(cond, cond.removeFirstChild());
      n.removeChild(thenBranch);
      n.addChildToBack(thenBranch);
      reportCodeChange();
      return n;
    }

    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
      Node thenExpr = getBlockReturnExpression(thenBranch);
      Node elseExpr = getBlockReturnExpression(elseBranch);
      n.removeChild(cond);
      thenExpr.detachFromParent();
      elseExpr.detachFromParent();

      // note - we ignore any cases with ""return;"", technically this
      // can be converted to ""return undefined;"" or some variant, but
      // that does not help code size.
      Node returnNode = IR.returnNode(
                            IR.hook(cond, thenExpr, elseExpr)
                                .srcref(n));
      parent.replaceChild(n, returnNode);
      reportCodeChange();
      return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
      Node thenOp = getBlockExpression(thenBranch).getFirstChild();
      Node elseOp = getBlockExpression(elseBranch).getFirstChild();
      if (thenOp.getType() == elseOp.getType()) {
        // if(x)a=1;else a=2; -> a=x?1:2;
        if (NodeUtil.isAssignmentOp(thenOp)) {
          Node lhs = thenOp.getFirstChild();
          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
              // if LHS has side effects, don't proceed [since the optimization
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
               !mayEffectMutableState(lhs)) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
            Node thenExpr = thenOp.removeFirstChild();
            Node elseExpr = elseOp.getLastChild();
            elseOp.removeChild(elseExpr);

            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            Node assign = new Node(thenOp.getType(), assignName, hookNode)
                              .srcref(thenOp);
            Node expr = NodeUtil.newExpr(assign);
            parent.replaceChild(n, expr);
            reportCodeChange();

            return expr;
          }
        }
      }
      // if(x)foo();else bar(); -> x?foo():bar()
      n.removeChild(cond);
      thenOp.detachFromParent();
      elseOp.detachFromParent();
      Node expr = IR.exprResult(
          IR.hook(cond, thenOp, elseOp).srcref(n));
      parent.replaceChild(n, expr);
      reportCodeChange();
      return expr;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(thenBranch);
      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

      Node name1 = var.getFirstChild();
      Node maybeName2 = elseAssign.getFirstChild();

      if (name1.hasChildren()
          && maybeName2.isName()
          && name1.getString().equals(maybeName2.getString())) {
        Node thenExpr = name1.removeChildren();
        Node elseExpr = elseAssign.getLastChild().detachFromParent();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name1.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();
        return var;
      }

    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
        getBlockExpression(thenBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(elseBranch);
      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

      Node maybeName1 = thenAssign.getFirstChild();
      Node name2 = var.getFirstChild();

      if (name2.hasChildren()
          && maybeName1.isName()
          && maybeName1.getString().equals(name2.getString())) {
        Node thenExpr = thenAssign.getLastChild().detachFromParent();
        Node elseExpr = name2.removeChildren();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name2.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();

        return var;
      }
    }

    return n;
  }","private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();

    // If the condition is a literal, no optimization is needed.
    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch != null ? thenBranch.getNext() : null;

    // Handle ""if"" without ""else"".
    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                return n;
            }

            if (cond.isNot()) {
                if (!canMergeWithLowerPrecedence(cond, expr, OR_PRECEDENCE)) {
                    return n;
                }

                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }

            if (!canMergeWithLowerPrecedence(cond, expr, AND_PRECEDENCE)) {
                return n;
            }

            n.removeChild(cond);
            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        } else if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
            Node innerIf = thenBranch.getFirstChild();
            if (innerIf.isIf() && tryCombineIfElse(cond, innerIf)) {
                return n;
            }
        }
        return n;
    }

    tryRemoveRepeatedStatements(n);

    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }

    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        return convertToHookReturn(n, parent, cond, thenBranch, elseBranch);
    }

    return minimizeAssignmentOrVarBlocks(n, cond, thenBranch, elseBranch, parent);
}

private boolean canMergeWithLowerPrecedence(Node cond, Node expr, int precedence) {
    return !isLowerPrecedenceInExpression(cond, precedence) || isLowerPrecedenceInExpression(expr.getFirstChild(), precedence);
}

private boolean tryCombineIfElse(Node cond, Node innerIf) {
    Node innerCond = innerIf.getFirstChild();
    Node innerThenBranch = innerCond.getNext();
    Node innerElseBranch = innerThenBranch.getNext();

    if (innerElseBranch == null && !canMergeWithLowerPrecedence(cond, innerCond, AND_PRECEDENCE)) {
        innerIf.detachChildren();
        innerIf.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));
        innerIf.addChildrenToBack(innerThenBranch.detachFromParent());
        reportCodeChange();
        return true;
    }
    return false;
}

private Node convertToHookReturn(Node n, Node parent, Node cond, Node thenBranch, Node elseBranch) {
    Node thenExpr = getBlockReturnExpression(thenBranch);
    Node elseExpr = getBlockReturnExpression(elseBranch);
    n.removeChild(cond);
    thenExpr.detachFromParent();
    elseExpr.detachFromParent();
    Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));
    parent.replaceChild(n, returnNode);
    reportCodeChange();
    return returnNode;
}

private Node minimizeAssignmentOrVarBlocks(Node n, Node cond, Node thenBranch, Node elseBranch, Node parent) {
    Node varOrExprNode = handleVariableOrExpression(cond, thenBranch, elseBranch, parent);
    if (varOrExprNode != null) {
        return varOrExprNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        return handleExpressionBlocks(n, cond, thenBranch, elseBranch, parent);
    }

    return n;
}

private Node handleVariableOrExpression(Node cond, Node thenBranch, Node elseBranch, Node parent) {
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        return minimizeVarAndAssign(cond, thenBranch, elseBranch, parent);
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        return minimizeVarAndAssign(cond, elseBranch, thenBranch, parent);
    }
    return null;
}

private Node minimizeVarAndAssign(Node cond, Node varBranch, Node exprBranch, Node parent) {
    Node var = getBlockVar(varBranch);
    Node assignNode = getBlockExpression(exprBranch).getFirstChild();

    Node name1 = var.getFirstChild();
    Node maybeName2 = assignNode.getFirstChild();

    if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {
        Node thenExpr = name1.removeChildren();
        Node elseExpr = assignNode.getLastChild().detachFromParent();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(varBranch);
        name1.addChildrenToBack(hookNode);
        parent.replaceChild(varBranch, var);
        reportCodeChange();
        return var;
    }
    return null;
}

private Node handleExpressionBlocks(Node n, Node cond, Node thenBranch, Node elseBranch, Node parent) {
    Node thenOp = getBlockExpression(thenBranch).getFirstChild();
    Node elseOp = getBlockExpression(elseBranch).getFirstChild();

    if (thenOp.getType() == elseOp.getType() && NodeUtil.isAssignmentOp(thenOp)) {
        Node lhs = thenOp.getFirstChild();
        if (!mayEffectMutableState(lhs) && areNodesEqualForInlining(lhs, elseOp.getFirstChild())) {
            Node assignName = thenOp.removeFirstChild();
            Node thenExpr = thenOp.removeFirstChild();
            Node elseExpr = elseOp.getLastChild();
            elseOp.removeChild(elseExpr);
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);
            Node expr = NodeUtil.newExpr(assign);
            parent.replaceChild(n, expr);
            reportCodeChange();
            return expr;
        }
    }

    cond.detachFromParent();
    thenOp.detachFromParent();
    elseOp.detachFromParent();
    Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));
    parent.replaceChild(n, expr);
    reportCodeChange();
    return expr;
}",0,0
47,Closure_133,"private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }","private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();
    return (result != null && !result.trim().isEmpty()) ? result : """";
}",0,0
47,Closure_133,"private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }","private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();
    if (result == null) {
        return """"; // Return an empty string if the result is null
    }
    result = result.trim(); // Trim whitespace from the result
    int commentIndex = result.indexOf('*'); // Identify if the line contains a JSDoc comment marker
    if (commentIndex != -1 && commentIndex < result.length() - 1) {
        // Return the portion of the line after the '*' marker
        return result.substring(commentIndex + 1).trim(); 
    }
    return result.isEmpty() ? """" : result; // Return the cleaned result or empty string if it's empty
}",0,1
47,Closure_133,"private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }","private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();

    // Handle case where result is null
    if (result == null) {
        return """";
    }

    // Trim the spaces and filter out invalid characters
    result = result.trim();

    // Remove any trailing '}' or other unexpected characters after normal text
    int closingBraceIndex = result.indexOf('}');
    if (closingBraceIndex != -1) {
        result = result.substring(0, closingBraceIndex).trim();
    }

    // Return cleaned string
    return result.isEmpty() ? """" : result;
}",0,2
48,Closure_14,"private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
      return null;
    }

    // If we are just before a IF/WHILE/DO/FOR:
    switch (parent.getType()) {
      // The follow() of any of the path from IF would be what follows IF.
      case Token.IF:
        return computeFollowNode(fromNode, parent, cfa);
      case Token.CASE:
      case Token.DEFAULT_CASE:
        // After the body of a CASE, the control goes to the body of the next
        // case, without having to go to the case condition.
        if (parent.getNext() != null) {
          if (parent.getNext().isCase()) {
            return parent.getNext().getFirstChild().getNext();
          } else if (parent.getNext().isDefaultCase()) {
            return parent.getNext().getFirstChild();
          } else {
            Preconditions.checkState(false, ""Not reachable"");
          }
        } else {
          return computeFollowNode(fromNode, parent, cfa);
        }
        break;
      case Token.FOR:
        if (NodeUtil.isForIn(parent)) {
          return parent;
        } else {
          return parent.getFirstChild().getNext().getNext();
        }
      case Token.WHILE:
      case Token.DO:
        return parent;
      case Token.TRY:
        // If we are coming out of the TRY block...
        if (parent.getFirstChild() == node) {
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(parent.getLastChild());
          } else { // and have no FINALLY.
            return computeFollowNode(fromNode, parent, cfa);
          }
        // CATCH block.
        } else if (NodeUtil.getCatchBlock(parent) == node){
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(node.getNext());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        // If we are coming out of the FINALLY block...
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
        }
    }

    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();

    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
      nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
      return computeFallThrough(nextSibling);
    } else {
      // If there are no more siblings, control is transferred up the AST.
      return computeFollowNode(fromNode, parent, cfa);
    }
  }","private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
        return null;
    }

    switch (parent.getType()) {
        case Token.IF:
            return computeFollowNode(fromNode, parent, cfa);

        case Token.CASE:
        case Token.DEFAULT_CASE:
            if (parent.getNext() != null) {
                if (parent.getNext().isCase() || parent.getNext().isDefaultCase()) {
                    return parent.getNext().getFirstChild();
                } else {
                    Preconditions.checkState(false, ""Not reachable"");
                }
            } else {
                return computeFollowNode(fromNode, parent, cfa);
            }
            break;

        case Token.FOR:
            if (NodeUtil.isForIn(parent)) {
                return parent;
            } else {
                Node secondChild = parent.getFirstChild().getNext();
                return (secondChild != null) ? secondChild.getNext() : null;
            }

        case Token.WHILE:
        case Token.DO:
            return parent;

        case Token.TRY:
            if (parent.getFirstChild() == node) {
                if (NodeUtil.hasFinally(parent)) {
                    return computeFallThrough(parent.getLastChild());
                } else {
                    return computeFollowNode(fromNode, parent, cfa);
                }
            } else if (NodeUtil.getCatchBlock(parent) == node) {
                if (NodeUtil.hasFinally(parent)) {
                    return computeFallThrough(node.getNext());
                } else {
                    return computeFollowNode(fromNode, parent, cfa);
                }
            } else if (parent.getLastChild() == node) {
                if (cfa != null && cfa.finallyMap != null) {
                    for (Node finallyNode : cfa.finallyMap.get(parent)) {
                        cfa.createEdge(fromNode, ControlFlowGraph.Branch.UNCOND, finallyNode);
                    }
                }
                return computeFollowNode(fromNode, parent, cfa);
            }
            break;
    }

    Node nextSibling = node.getNext();
    while (nextSibling != null && nextSibling.isFunction()) {
        nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
        return computeFallThrough(nextSibling);
    } else {
        return computeFollowNode(fromNode, parent, cfa);
    }
}",0,0
48,Closure_14,"private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
      return null;
    }

    // If we are just before a IF/WHILE/DO/FOR:
    switch (parent.getType()) {
      // The follow() of any of the path from IF would be what follows IF.
      case Token.IF:
        return computeFollowNode(fromNode, parent, cfa);
      case Token.CASE:
      case Token.DEFAULT_CASE:
        // After the body of a CASE, the control goes to the body of the next
        // case, without having to go to the case condition.
        if (parent.getNext() != null) {
          if (parent.getNext().isCase()) {
            return parent.getNext().getFirstChild().getNext();
          } else if (parent.getNext().isDefaultCase()) {
            return parent.getNext().getFirstChild();
          } else {
            Preconditions.checkState(false, ""Not reachable"");
          }
        } else {
          return computeFollowNode(fromNode, parent, cfa);
        }
        break;
      case Token.FOR:
        if (NodeUtil.isForIn(parent)) {
          return parent;
        } else {
          return parent.getFirstChild().getNext().getNext();
        }
      case Token.WHILE:
      case Token.DO:
        return parent;
      case Token.TRY:
        // If we are coming out of the TRY block...
        if (parent.getFirstChild() == node) {
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(parent.getLastChild());
          } else { // and have no FINALLY.
            return computeFollowNode(fromNode, parent, cfa);
          }
        // CATCH block.
        } else if (NodeUtil.getCatchBlock(parent) == node){
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(node.getNext());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        // If we are coming out of the FINALLY block...
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
        }
    }

    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();

    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
      nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
      return computeFallThrough(nextSibling);
    } else {
      // If there are no more siblings, control is transferred up the AST.
      return computeFollowNode(fromNode, parent, cfa);
    }
  }","private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {

    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
        return null;
    }

    switch (parent.getType()) {
        case Token.IF:
            return computeFollowNode(fromNode, parent, cfa);

        case Token.CASE:
        case Token.DEFAULT_CASE:
            return computeCaseFollowNode(fromNode, parent, node, cfa);

        case Token.FOR:
            if (NodeUtil.isForIn(parent)) {
                return parent;
            } else {
                Node update = parent.getSecondChild().getNext();
                return (update != null) ? update : parent.getFirstChild().getNext();
            }

        case Token.WHILE:
        case Token.DO:
            return parent;

        case Token.TRY:
            return computeTryFollowNode(fromNode, parent, node, cfa);

        default:
            return computeDefaultFollowNode(fromNode, node, parent, cfa);
    }
}

private static Node computeCaseFollowNode(Node fromNode, Node parent, Node node, ControlFlowAnalysis cfa) {
    Node next = parent.getNext();
    if (next != null) {
        if (next.isCase() || next.isDefaultCase()) {
            return next.getFirstChild();
        } else {
            Preconditions.checkState(false, ""Not reachable"");
        }
    } else {
        return computeFollowNode(fromNode, parent, cfa);
    }
}

private static Node computeTryFollowNode(Node fromNode, Node parent, Node node, ControlFlowAnalysis cfa) {
    if (parent.getFirstChild() == node) {
        return computeTryBlockFollowNode(parent);
    } else if (NodeUtil.getCatchBlock(parent) == node) {
        return computeCatchBlockFollowNode(node);
    } else if (parent.getLastChild() == node) {
        return computeFinallyBlockFollowNode(fromNode, parent, cfa);
    }
    return null;
}

private static Node computeTryBlockFollowNode(Node parent) {
    if (NodeUtil.hasFinally(parent)) {
        return computeFallThrough(parent.getLastChild());
    } else {
        return parent;
    }
}

private static Node computeCatchBlockFollowNode(Node node) {
    if (NodeUtil.hasFinally(node.getParent())) {
        return computeFallThrough(node.getNext());
    } else {
        return node.getParent();
    }
}

private static Node computeFinallyBlockFollowNode(Node fromNode, Node parent, ControlFlowAnalysis cfa) {
    if (cfa != null && cfa.finallyMap != null) {
        for (Node finallyNode : cfa.finallyMap.get(parent)) {
            cfa.createEdge(fromNode, ControlFlowGraph.Branch.UNCOND, finallyNode);
        }
    }
    return parent;
}

private static Node computeDefaultFollowNode(Node fromNode, Node node, Node parent, ControlFlowAnalysis cfa) {
    Node nextSibling = node.getNext();
    while (nextSibling != null && nextSibling.isFunction()) {
        nextSibling = nextSibling.getNext();
    }
    if (nextSibling != null) {
        return computeFallThrough(nextSibling);
    } else {
        return computeFollowNode(fromNode, parent, cfa);
    }
}",0,1
49,Closure_15,"@Override
      public boolean apply(Node n) {
        // When the node is null it means, we reached the implicit return
        // where the function returns (possibly without an return statement)
        if (n == null) {
          return false;
        }

        // TODO(user): We only care about calls to functions that
        // passes one of the dependent variable to a non-side-effect free
        // function.
        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
          return true;
        }

        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
           return true;
         }
 
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
          }
        }
        return false;
      }","@Override
public boolean apply(Node n) {
    // When the node is null it means, we reached the implicit return
    // where the function returns (possibly without a return statement)
    if (n == null) {
        return false;
    }

    // TODO: We only care about calls to functions that
    // pass one of the dependent variables to a non-side-effect free
    // function.
    if (n.isCall()) {
        if (NodeUtil.functionCallHasSideEffects(n)) {
            return true;
        }
    }

    if (n.isNew()) {
        if (NodeUtil.constructorCallHasSideEffects(n)) {
            return true;
        }
    }

    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
        }
    }
    return false;
}",0,0
49,Closure_15,"@Override
      public boolean apply(Node n) {
        // When the node is null it means, we reached the implicit return
        // where the function returns (possibly without an return statement)
        if (n == null) {
          return false;
        }

        // TODO(user): We only care about calls to functions that
        // passes one of the dependent variable to a non-side-effect free
        // function.
        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
          return true;
        }

        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
           return true;
         }
 
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
          }
        }
        return false;
      }","@Override
public boolean apply(Node n) {
    // When the node is null it means, we reached the implicit return
    // where the function returns (possibly without a return statement)
    if (n == null) {
        return false;
    }
    
    // Check if the node is a function call and has side effects or 
    // one of its arguments is a dependent variable
    if (n.isCall()) {
        if (NodeUtil.functionCallHasSideEffects(n) || hasDependentArgument(n)) {
            return true;
        }
    }

    // Check if the node is a constructor call and has side effects or 
    // one of its arguments is a dependent variable
    if (n.isNew()) {
        if (NodeUtil.constructorCallHasSideEffects(n) || hasDependentArgument(n)) {
            return true;
        }
    }

    // Recursively check child nodes
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
        }
    }
    return false;
}

// Added helper method to identify dependent variables
private boolean hasDependentArgument(Node n) {
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        if (isDependentVariable(child)) {
            return true;
        }
    }
    return false;
}

// Stub for dependent variable check, needs to be implemented depending on context
private boolean isDependentVariable(Node n) {
    // Assume dependency logic is handled here based on specific use case
    return false;
}",0,1
49,Closure_15,"@Override
      public boolean apply(Node n) {
        // When the node is null it means, we reached the implicit return
        // where the function returns (possibly without an return statement)
        if (n == null) {
          return false;
        }

        // TODO(user): We only care about calls to functions that
        // passes one of the dependent variable to a non-side-effect free
        // function.
        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
          return true;
        }

        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
           return true;
         }
 
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
          }
        }
        return false;
      }","@Override
public boolean apply(Node n) {
    // When the node is null it means, we reached the implicit return
    // where the function returns (possibly without a return statement)
    if (n == null) {
        return false;
    }

    // Check calls and constructors, considering side effects and dependent variables
    if ((n.isCall() && (NodeUtil.functionCallHasSideEffects(n) || hasDependentArgument(n))) ||
        (n.isNew() && (NodeUtil.constructorCallHasSideEffects(n) || hasDependentArgument(n)))) {
        return true;
    }

    // Recursively check child nodes
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
        }
    }
    return false;
}

// Additional checks for dependent variables
private boolean hasDependentArgument(Node n) {
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        if (isDependentVariable(child)) {
            return true;
        }
    }
    return false;
}

// Simulated dependent variable check; should be tailor-made for actual use case
private boolean isDependentVariable(Node n) {
    // Example logic for dependent variable
    return n.isName() && n.getString().equals(""dependentVar"");
}",0,2
50,Closure_17,"private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else {
          // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
              } else if (rValue.isOr()) {
                // Check for a very specific JS idiom:
                // var x = x || TYPE;
                // This is used by Closure's base namespace for esoteric
                // reasons.
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName()
                    && lValue.isName()
                    && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null
                    && !secondClause.getJSType().isUnknownType()) {
                  return secondClause.getJSType();
                }
              }
            }
          }
        }
      }

      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }","private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
    if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    } else if (rValue != null && rValue.isFunction() &&
            shouldUseFunctionLiteralType(
                    JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    } else if (info != null) {
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(
                        rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(
                    rValue, lValue.getQualifiedName(), info, lValue);
        } else {
            // Check if this is constant, and if it has a known type.
            if (info.isConstant()) {
                if (rValue != null) {
                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                        // If rValue has a type-cast, we use the type in the type-cast.
                        // If rValue's type was already computed during scope creation,
                        // then we can safely use that.
                        return rValue.getJSType();
                    } else if (rValue.isOr()) {
                        // Check for a very specific JS idiom:
                        // var x = x || TYPE;
                        // This is used by Closure's base namespace for esoteric
                        // reasons.
                        Node firstClause = rValue.getFirstChild();
                        Node secondClause = firstClause.getNext();
                        boolean namesMatch = firstClause.isName()
                                && lValue.isName()
                                && firstClause.getString().equals(lValue.getString());
                        if (namesMatch && secondClause.getJSType() != null
                                && !secondClause.getJSType().isUnknownType()) {
                            return secondClause.getJSType();
                        }
                    }
                }
            }
        }
    }

    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}",0,0
50,Closure_17,"private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else {
          // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
              } else if (rValue.isOr()) {
                // Check for a very specific JS idiom:
                // var x = x || TYPE;
                // This is used by Closure's base namespace for esoteric
                // reasons.
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName()
                    && lValue.isName()
                    && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null
                    && !secondClause.getJSType().isUnknownType()) {
                  return secondClause.getJSType();
                }
              }
            }
          }
        }
      }

      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }","private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
    if (info != null) {
        if (info.hasType()) {
            return getDeclaredTypeInAnnotation(sourceName, lValue, info);
        }
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        }
        if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        }
        if (info.isConstant()) {
            if (rValue != null) {
                JSType rValueType = rValue.getJSType();
                if (rValueType != null && !rValueType.isUnknownType()) {
                    return rValueType;
                }
                if (rValue.isOr()) {
                    Node firstClause = rValue.getFirstChild();
                    Node secondClause = firstClause.getNext();
                    if (firstClause.isName() && lValue.isName() &&
                            firstClause.getString().equals(lValue.getString()) &&
                            secondClause.getJSType() != null &&
                            !secondClause.getJSType().isUnknownType()) {
                        return secondClause.getJSType();
                    }
                }
            }
        }
    } else if (rValue != null && rValue.isFunction() &&
            shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    }
    
    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}",0,1
50,Closure_17,"private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else {
          // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
              } else if (rValue.isOr()) {
                // Check for a very specific JS idiom:
                // var x = x || TYPE;
                // This is used by Closure's base namespace for esoteric
                // reasons.
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName()
                    && lValue.isName()
                    && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null
                    && !secondClause.getJSType().isUnknownType()) {
                  return secondClause.getJSType();
                }
              }
            }
          }
        }
      }

      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }","private JSType getDeclaredType(String sourceName, JSDocInfo info,
                               Node lValue, @Nullable Node rValue) {
    if (info != null) {
        if (info.hasType()) {
            return getDeclaredTypeInAnnotation(sourceName, lValue, info);
        } else if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(
                        rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(
                    rValue, lValue.getQualifiedName(), info, lValue);
        } else if (info.isConstant()) {
            return getTypeForConstant(info, lValue, rValue);
        }
    }

    // If no specific type information is given, default to a function literal type if applicable.
    if (rValue != null && rValue.isFunction() &&
            shouldUseFunctionLiteralType(
                    JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    }

    return null;  // Return null if no valid type could be determined
}

// Fix: Separated the logic for determining type for constant into a helper method
private JSType getTypeForConstant(JSDocInfo info, Node lValue, Node rValue) {
    if (rValue != null) {
        JSType rValueType = rValue.getJSType();
        if (rValueType != null && !rValueType.isUnknownType()) {
            return rValueType;
        } else if (rValue.isOr()) {
            Node firstClause = rValue.getFirstChild();
            Node secondClause = firstClause.getNext();
            if (firstClause.isName() && lValue.isName() &&
                firstClause.getString().equals(lValue.getString()) &&
                secondClause.getJSType() != null &&
                !secondClause.getJSType().isUnknownType()) {
                return secondClause.getJSType();
            }
        }
    }
    return null;
}",0,2
51,Closure_18,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      hoistExterns(externsRoot);
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
       if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      hoistNoCompileFiles();

      if (staleInputs) {
        repartitionInputs();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        hoistExterns(externsRoot);

        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                        .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }

        hoistNoCompileFiles();

        if (staleInputs) {
            repartitionInputs();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(
                        input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",0,0
51,Closure_18,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      hoistExterns(externsRoot);
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
       if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      hoistNoCompileFiles();

      if (staleInputs) {
        repartitionInputs();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Initialize the new JS and externs roots
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Process modules if options are set
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
        
        hoistExterns(externsRoot);

        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare provided types
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                JSModuleGraph graph = moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;
                inputs = graph.manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException | MissingProvideException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                if (hasErrors()) {
                    return null;
                }
            }
        }

        hoistNoCompileFiles();

        if (staleInputs) {
            repartitionInputs();
        }

        // Iterate through inputs to build AST
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            // Perform sanity check in dev mode
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            // Annotate nodes if required
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), devMode);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }

        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",0,1
52,Closure_19,"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch (node.getType()) {
      case Token.NAME:
        scope.inferSlotType(node.getString(), type);
        break;

      case Token.GETPROP:
        String qualifiedName = node.getQualifiedName();
        Preconditions.checkNotNull(qualifiedName);

        JSType origType = node.getJSType();
        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
         scope.inferQualifiedSlot(node, qualifiedName, origType, type);
         break;
 
         // ""this"" references aren't currently modeled in the CFG.
 
       default:
         throw new IllegalArgumentException(""Node cannot be refined. \n"" +
            node.toStringTree());
    }
  }","protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch (node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;

        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);

            JSType origType = node.getJSType();
            origType = (origType == null) ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;

        case Token.THIS:
            // No inference should be done for ""this"" references. Just return.
            return;
            
        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" +
                node.toStringTree());
    }
}",0,0
53,Closure_2,"private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
      String functionName, HashMap<String, ObjectType> properties,
      HashMap<String, ObjectType> currentProperties,
       ObjectType interfaceType) {
     ObjectType implicitProto = interfaceType.getImplicitPrototype();
     Set<String> currentPropertyNames;
       // This can be the case if interfaceType is proxy to a non-existent
       // object (which is a bad type annotation, but shouldn't crash).
       currentPropertyNames = implicitProto.getOwnPropertyNames();
     for (String name : currentPropertyNames) {
       ObjectType oType = properties.get(name);
       if (oType != null) {
        if (!interfaceType.getPropertyType(name).isEquivalentTo(
            oType.getPropertyType(name))) {
          compiler.report(
              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
                  functionName, name, oType.toString(),
                  interfaceType.toString()));
        }
      }
      currentProperties.put(name, interfaceType);
    }
    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
      checkInterfaceConflictProperties(t, n, functionName, properties,
          currentProperties, iType);
    }
  }","private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
      String functionName, HashMap<String, ObjectType> properties,
      HashMap<String, ObjectType> currentProperties,
      ObjectType interfaceType) {
    ObjectType implicitProto = interfaceType.getImplicitPrototype();
    if (implicitProto == null) {
        // Handle the case when implicitProto is null
        return;
    }
    Set<String> currentPropertyNames = implicitProto.getOwnPropertyNames();
    for (String name : currentPropertyNames) {
        ObjectType oType = properties.get(name);
        if (oType != null) {
            if (!interfaceType.getPropertyType(name).isEquivalentTo(
                oType.getPropertyType(name))) {
                compiler.report(
                    t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
                        functionName, name, oType.toString(),
                        interfaceType.toString()));
            }
        }
        currentProperties.put(name, interfaceType);
    }
    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
        checkInterfaceConflictProperties(t, n, functionName, properties,
            currentProperties, iType);
    }
}",0,0
54,Closure_20,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
       if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
      }
    }
    return n;
  }","private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(""String"")) {
        // Fold String(a) to '' + (a) on immutable literals,
        // which allows further optimizations
        //
        // We can't do this in the general case, because String(a) has
        // slightly different semantics than '' + (a). See
        // http://code.google.com/p/closure-compiler/issues/detail?id=759
        Node value = callTarget.getNext();
        if (value != null && value.getNext() == null) {
            Node addition = IR.add(
                IR.string("""").srcref(callTarget),
                value.detachFromParent()
            );
            n.getParent().replaceChild(n, addition);
            reportCodeChange();
            return addition;
        }
    }
    return n;
}",0,0
54,Closure_20,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
       if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
      }
    }
    return n;
  }","private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget.isName() && ""String"".equals(callTarget.getString()) && callTarget.getNext() != null && callTarget.getNext().getNext() == null) {
        Node value = callTarget.getNext();
        Node addition = IR.add(IR.string("""").srcref(callTarget), value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
    }
    return n;
}",0,1
54,Closure_20,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
       if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
      }
    }
    return n;
  }","private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() && 
        ""String"".equals(callTarget.getString())) {
        Node value = callTarget.getNext();
        if (value != null && value.getNext() == null) {
            if (value.isString() || value.isNumber() || value.isBoolean()) {
                Node addition = IR.add(
                    IR.string("""").srcref(callTarget),
                    value.detachFromParent()
                );
                n.getParent().replaceChild(n, addition);
                reportCodeChange();
                return addition;
            }
        }
    }
    return n;
}",0,2
55,Closure_21,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
      return;
    }

    // This no-op statement was there so that JSDoc information could
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
         return;
       }
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA) continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
           else break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
         return;
       }
     }
     if (
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
        msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null || n.isExprResult()) {
        return;
    }

    // This no-op statement was there so that JSDoc information could be attached to the name.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    if (parent.getType() == Token.COMMA) {
        if (isResultUsed) {
            return;
        }
        if (n == parent.getLastChild()) {
            Node current = parent;
            while (current != null) {
                int ancestorType = current.getType();
                if (ancestorType == Token.COMMA) {
                    current = current.getParent();
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                } else {
                    break;
                }
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 && 
              (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + 
                  ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));

        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",0,0
55,Closure_21,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
      return;
    }

    // This no-op statement was there so that JSDoc information could
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
         return;
       }
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA) continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
           else break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
         return;
       }
     }
     if (
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
        msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null || n.isExprResult()) {
        return;
    }

    // This no-op statement was there so that JSDoc information could be attached to the name.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    if (parent.getType() == Token.COMMA) {
        if (isResultUsed) {
            return;
        }
        if (n == parent.getLastChild()) {
            Node current = parent;
            while (current != null) {
                int ancestorType = current.getType();
                if (ancestorType == Token.COMMA) {
                    current = current.getParent();
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                } else {
                    break;
                }
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 &&
              (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {

        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }

        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }

        // Provided test failure hint indicates some statements were being removed or altered incorrectly. 
        // Ensure that statements with side-effects are retained.
        if (NodeUtil.mayHaveSideEffects(n, t.getCompiler()) || NodeUtil.isStatement(n)) {
            return;
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
    }
}",0,1
55,Closure_21,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
      return;
    }

    // This no-op statement was there so that JSDoc information could
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
         return;
       }
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA) continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
           else break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
         return;
       }
     }
     if (
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
        msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    // Skip blocks and expression results; let peephole optimizations handle them.
    if (n.isExprResult()) {
        return;
    }

    // Allow qualified names with JSDoc info.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    if (parent.getType() == Token.COMMA) {
        // Skip result-used nodes and handle comma ancestry carefully.
        if (isResultUsed) {
            return;
        }
        if (n == parent.getLastChild()) {
            Node current = parent;
            while (current != null) {
                int ancestorType = current.getType();
                if (ancestorType == Token.COMMA) {
                    current = current.getParent();
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    // Ignore nodes with non-block or non-expression result ancestors.
                    return;
                } else {
                    break;
                }
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        // Handle ""FOR"" loop specifically only when it conforms to expected structure.
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 && 
              (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    // Check for side-effects before reporting warnings or marking nodes as problematic.
    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {
        if (!NodeUtil.isStatement(n) && !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {
            problemNodes.add(n);
        }

        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + 
                  ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
    }
}",0,2
56,Closure_22,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
     if (parent.getType() == Token.COMMA) {
       Node gramps = parent.getParent();
       if (gramps.isCall() && parent == gramps.getFirstChild()) {
         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
         }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA)
             continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
             return;
           else
             break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
            n == parent.getFirstChild().getNext().getNext())) {
       } else {
       return;
       }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       if (n.isQualifiedName() && n.getJSDocInfo() != null) {
         return;
       } else if (n.isExprResult()) {
         return;
       }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    // Handle special cases for specific parent node types
    if (parent.getType() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps != null && gramps.isCall() && parent == gramps.getFirstChild()) {
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 &&
                n.getNext() != null && n.getNext().isName() &&
                ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }

        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType == Token.COMMA) continue;
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                } else {
                    break;
                }
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 &&
            (n == parent.getFirstChild() ||
             n == parent.getFirstChild().getNext().getNext())) {
            // Allow some FOR loop constructs
        } else {
            return;
        }
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        if (n.isQualifiedName() && n.getJSDocInfo() != null) {
            return;
        } else if (n.isExprResult()) {
            return;
        }

        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
                  ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",0,0
56,Closure_22,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
     if (parent.getType() == Token.COMMA) {
       Node gramps = parent.getParent();
       if (gramps.isCall() && parent == gramps.getFirstChild()) {
         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
         }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA)
             continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
             return;
           else
             break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
            n == parent.getFirstChild().getNext().getNext())) {
       } else {
       return;
       }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       if (n.isQualifiedName() && n.getJSDocInfo() != null) {
         return;
       } else if (n.isExprResult()) {
         return;
       }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // Early exit for empty and comma nodes
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    // Handle specific parent node types
    if (parent.getType() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps != null && gramps.isCall() && parent == gramps.getFirstChild()) {
            // Allow ""eval"" calls in specific cases
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 &&
                n.getNext() != null && n.getNext().isName() &&
                ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }

        // Check ancestor chain for BLOCK or EXPR_RESULT
        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType == Token.COMMA) {
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                }
                break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        // Allow certain FOR loop constructs
        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 &&
            (n == parent.getFirstChild() ||
             n == parent.getFirstChild().getNext().getNext())) {
        } else {
            return;
        }
    }

    // Evaluate node side-effects and usage
    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) &&
        !isSafeNoOpStatement(n)) { // Added helper method for safe no-op statements
        String msg = generateErrorMessage(n, isSimpleOp);
        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}

// New Helper Method: Checks if a node is a safe no-op statement
private boolean isSafeNoOpStatement(Node n) {
    return n.isQualifiedName() && n.getJSDocInfo() != null || n.isExprResult();
}

// New Helper Method: Generates an appropriate error message
private String generateErrorMessage(Node n, boolean isSimpleOp) {
    if (n.isString()) {
        return ""Is there a missing '+' on the previous line?"";
    } else if (isSimpleOp) {
        return ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
               ""' operator is not being used."";
    }
    return ""This code lacks side-effects. Is there a bug?"";
}",0,1
56,Closure_22,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
     if (parent.getType() == Token.COMMA) {
       Node gramps = parent.getParent();
       if (gramps.isCall() && parent == gramps.getFirstChild()) {
         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
         }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA)
             continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
             return;
           else
             break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
            n == parent.getFirstChild().getNext().getNext())) {
       } else {
       return;
       }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       if (n.isQualifiedName() && n.getJSDocInfo() != null) {
         return;
       } else if (n.isExprResult()) {
         return;
       }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // Terminate early for empty and comma nodes
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    // Do not attempt removal for block or expr result nodes
    if (parent.getType() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps != null && gramps.isCall() && parent == gramps.getFirstChild()) {
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && 
                n.getNext() != null && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }

        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType == Token.COMMA) continue;
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                }
                break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 &&
            (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {
            // Allow some FOR loop constructs
        } else {
            return;
        }
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    boolean shouldExclude = n.isQualifiedName() && n.getJSDocInfo() != null;

    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) && !shouldExclude) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",0,2
57,Closure_23,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }
 
     Node current = left.getFirstChild();
     Node elem = null;
     for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
  }","private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }
 
    Node current = left.getFirstChild();
    Node elem = null;
    for (int i = 0; current != null && i <= intIndex; i++) {
        elem = current;
        current = current.getNext();
    }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    parent.replaceChild(n, elem);
    reportCodeChange();
    return elem;
}",0,0
57,Closure_23,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }
 
     Node current = left.getFirstChild();
     Node elem = null;
     for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
  }","private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index || intIndex < 0) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }
 
    Node current = left.getFirstChild();
    Node elem = null;
    for (int i = 0; current != null && i <= intIndex; i++) {
        elem = current;
        current = current.getNext();
    }

    if (elem == null || intIndex >= left.getChildCount()) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      elem.detach();
    }

    parent.replaceChild(n, elem);
    reportCodeChange();
    return elem;
}",0,1
58,Closure_24,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
         if (parent.isVar()) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);

          String qualifiedName =
              aliasVar.getInitialValue().getQualifiedName();
          transformation.addAlias(name, qualifiedName);
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else {
          // TODO(robbyw): Support using locals for private variables.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
        }
      }
    }","private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();

        // Check if there is a node and parent node
        if (n == null || n.getParent() == null) {
            continue;
        }

        int type = n.getType();
        Node parent = n.getParent();

        if (parent.isVar()) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);

                if (aliasVar != null && aliasVar.getInitialValue() != null) {
                    String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                    aliases.put(name, aliasVar);
                    transformation.addAlias(name, qualifiedName);
                } else {
                    report(t, n, GOOG_SCOPE_BAD_ALIAS, name);
                }
            } else {
                // TODO: Support using locals for private variables.
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",0,0
59,Closure_25,"private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
      constructorType = constructorType.restrictByNotNullOrUndefined();
      if (constructorType.isUnknownType()) {
        type = getNativeType(UNKNOWN_TYPE);
      } else {
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct == null && constructorType instanceof FunctionType) {
          // If constructorType is a NoObjectType, then toMaybeFunctionType will
          // return null. But NoObjectType implements the FunctionType
          // interface, precisely because it can validly construct objects.
          ct = (FunctionType) constructorType;
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
       scope = traverse(arg, scope);
     }
     return scope;
   }","private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
        constructorType = constructorType.restrictByNotNullOrUndefined();
        if (constructorType.isUnknownType()) {
            type = getNativeType(UNKNOWN_TYPE);
        } else {
            FunctionType ct = constructorType.toMaybeFunctionType();
            if (ct == null && constructorType instanceof FunctionType) {
                // If constructorType is a NoObjectType, then toMaybeFunctionType will
                // return null. But NoObjectType implements the FunctionType
                // interface, precisely because it can validly construct objects.
                ct = (FunctionType) constructorType;
            }
            if (ct != null && ct.isConstructor()) {
                type = ct.getInstanceType();
            }
        }
    }
    n.setJSType(type);
    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
        scope = traverse(arg, scope);
    }
    return scope;
}",0,0
59,Closure_25,"private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
      constructorType = constructorType.restrictByNotNullOrUndefined();
      if (constructorType.isUnknownType()) {
        type = getNativeType(UNKNOWN_TYPE);
      } else {
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct == null && constructorType instanceof FunctionType) {
          // If constructorType is a NoObjectType, then toMaybeFunctionType will
          // return null. But NoObjectType implements the FunctionType
          // interface, precisely because it can validly construct objects.
          ct = (FunctionType) constructorType;
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
       scope = traverse(arg, scope);
     }
     return scope;
   }","private FlowScope traverseNew(Node n, FlowScope scope) {
    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
        constructorType = constructorType.restrictByNotNullOrUndefined();
        if (!constructorType.isEmptyType()) {
            FunctionType ct = constructorType.toMaybeFunctionType();
            if (ct != null && ct.isConstructor()) {
                type = ct.getInstanceType();
            } else if (constructorType instanceof FunctionType) {
                // Handle NoObjectType or other FunctionTypes that are not constructors
                if (ct == null) {
                    ct = (FunctionType) constructorType;
                }
                if (ct != null && ct.canBeCalled()) {
                    type = getNativeType(UNKNOWN_TYPE); // Consider function that can return unknown
                }
            }
        }
    }
    n.setJSType(type);
    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
        scope = traverse(arg, scope);
    }
    return scope;
}",0,1
59,Closure_25,"private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
      constructorType = constructorType.restrictByNotNullOrUndefined();
      if (constructorType.isUnknownType()) {
        type = getNativeType(UNKNOWN_TYPE);
      } else {
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct == null && constructorType instanceof FunctionType) {
          // If constructorType is a NoObjectType, then toMaybeFunctionType will
          // return null. But NoObjectType implements the FunctionType
          // interface, precisely because it can validly construct objects.
          ct = (FunctionType) constructorType;
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
       scope = traverse(arg, scope);
     }
     return scope;
   }","private FlowScope traverseNew(Node n, FlowScope scope) {
    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;

    if (constructorType != null) {
        constructorType = constructorType.restrictByNotNullOrUndefined();

        // Handle case for unknown or empty type upfront
        if (constructorType.isUnknownType() || constructorType.isEmptyType()) {
            type = getNativeType(UNKNOWN_TYPE);
        } else {
            FunctionType ct = constructorType.toMaybeFunctionType();
           
            // Handle valid function types that are constructors
            if (ct != null && ct.isConstructor()) {
                type = ct.getInstanceType();
            } else if (ct == null && constructorType instanceof FunctionType) {
                ct = (FunctionType) constructorType;

                // Consider edge cases for callable functions that are not clear constructors
                if (ct.canBeCalled() && !ct.isConstructor()) {
                    type = getNativeType(UNKNOWN_TYPE);
                }
            }
        }
    }

    // Assign default type if none resolved
    if (type == null) {
        type = getNativeType(UNKNOWN_TYPE);
    }

    n.setJSType(type);

    // Traverse arguments of the 'new' call
    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
        scope = traverse(arg, scope);
    }
    return scope;
}",0,2
60,Closure_28,"/*
 * Copyright 2008 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      add(ESTIMATED_IDENTIFIER);
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}
",Match failed,0,0
61,Closure_29,"private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target maybe using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-refential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }


          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target maybe using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            // NOTE(nicksantos): This pass's object-splitting algorithm has
            // a blind spot. It assumes that if a property isn't defined on an
            // object, then the value is undefined. This is not true, because
            // Object.prototype can have arbitrary properties on it.
            //
            // We short-circuit this problem by bailing out if we see a reference
            // to a property that isn't defined on the object literal. This
            // isn't a perfect algorithm, but it should catch most cases.
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            continue;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }

            Node childVal = child.getFirstChild();
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }

        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}",0,0
61,Closure_29,"private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target maybe using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-refential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }


          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = true; // Start by assuming it is inlinable
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false; // Early return, as this cannot be inlined
            }
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            continue;
        }

        Node val = ref.getAssignedValue();
        if (val == null || !val.isObjectLit()) {
            ret = false; // Mark as non-inlinable if val is null or not an object literal
            continue;
        }

        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                return false; // Early exit if unsupported ES5 getters/setters are found
            }

            Node childVal = child.getFirstChild();
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        return false; // Early exit for self-referential assignment
                    }
                    refNode = refNode.getParent();
                }
            }
        }
    }
    return ret; // Return after entire loop has processed
}",0,1
61,Closure_29,"private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target maybe using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-refential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }


          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null || !val.isObjectLit()) {
            return false; // Ensure only object literal assignments are considered valid
        }

        // Check for unsupported ES5 getters/setters or circular references
        Set<Node> assignedValues = new HashSet<>();
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                return false; // Unsupported ES5 getters/setters
            }

            Node childVal = child.getFirstChild();
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal || assignedValues.contains(childVal)) {
                        return false; // Self-referential or circular reference detected
                    }
                    refNode = refNode.getParent();
                }
            }
            assignedValues.add(childVal);
        }
    }
    return true; // Return true if no invalid assignments were detected
}",0,2
62,Closure_31,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
           !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) { // Check for null AST and errors
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        // Check if inputs need to be rebuilt from modules.
        boolean staleInputs = false;

        // Check if the sources need to be re-ordered.
        if (options.dependencyOptions.needsManagement() &&
            !options.skipAllPasses &&
            options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs =
                    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                    .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(
                    JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(
                    MISSING_ENTRY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }

        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);

            // Inputs can have a null AST during initial parse.
            if (n == null) {
                continue;
            }

            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    // If the input file is explicitly marked as an externs file, then
                    // assume the programmer made a mistake and throw it into
                    // the externs pile anyways.
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);

                    input.getModule().remove(input);

                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }

        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null ||
                options.nameReferenceReportPath != null) {

                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia =
                    new SourceInformationAnnotator(
                        input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",0,0
62,Closure_31,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
           !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Initialize main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) { // Properly handle null and errors
                reportError(input, ""Error in externs parsing.""); // Notify specific error
                continue; // Skip processing the problematic input
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        boolean staleInputs = false;

        // Check and reorder sources if needed.
        if (requiresDependencyManagement()) {
            staleInputs = handleDependencies();
        }

        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                reportWarning(input, ""Null AST detected during parse.""); // Log warning for null AST
                continue;
            }

            if (hasJSDocInfoForExternOrNoCompile(n, input)) {
                staleInputs = true;
            }
        }

        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }

        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode && hasErrors()) {
                return null;
            }

            annotateSourceMap(n, input);

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}

private boolean requiresDependencyManagement() {
    return options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass;
}

private boolean handleDependencies() {
    boolean staleInputs = false;
    for (CompilerInput input : inputs) {
        for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
        }
    }

    try {
        inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
            .manageDependencies(options.dependencyOptions, inputs);
        staleInputs = true;
    } catch (CircularDependencyException e) {
        report(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage());
        if (hasErrors()) {
            return false;
        }
    } catch (MissingProvideException e) {
        report(MISSING_ENTRY_ERROR, e.getMessage());
        if (hasErrors()) {
            return false;
        }
    }
    return staleInputs;
}

private boolean hasJSDocInfoForExternOrNoCompile(Node n, CompilerInput input) {
    if (n.getJSDocInfo() != null) {
        JSDocInfo info = n.getJSDocInfo();
        if (info.isExterns()) {
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);
            input.getModule().remove(input);
            externs.add(input);
            return true;
        } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            return true;
        }
    }
    return false;
}

private void annotateSourceMap(Node n, CompilerInput input) {
    if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
        SourceInformationAnnotator sia = new SourceInformationAnnotator(
            input.getName(), options.devMode != DevMode.OFF);
        NodeTraversal.traverse(this, n, sia);
    }
}

private void reportError(CompilerInput input, String message) {
    report(JSError.make(input.getName(), message));
}

private void reportWarning(CompilerInput input, String message) {
    report(JSError.warning(input.getName(), message));
}",0,1
63,Closure_32,"@SuppressWarnings(""fallthrough"")
  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                      WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
      return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
      line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.

    do {
      switch (token) {
        case STAR:
          if (ignoreStar) {
            // Mark the position after the star as the new start of the line.
          } else {
            // The star is part of the comment.
            if (builder.length() > 0) {
              builder.append(' ');
            }

            builder.append('*');
          }

          token = next();
          continue;

        case EOL:
          if (option != WhitespaceOption.SINGLE_LINE) {
            builder.append(""\n"");
           }
 
           ignoreStar = true;
           token = next();
           continue;
 
        default:
          ignoreStar = false;
          state = State.SEARCHING_ANNOTATION;

              // All tokens must be separated by a space.

          if (token == JsDocToken.EOC ||
              token == JsDocToken.EOF ||
              // When we're capturing a license block, annotations
              // in the block are ok.
              (token == JsDocToken.ANNOTATION &&
               option != WhitespaceOption.PRESERVE)) {
            String multilineText = builder.toString();

            if (option != WhitespaceOption.PRESERVE) {
              multilineText = multilineText.trim();
            }

            int endLineno = stream.getLineno();
            int endCharno = stream.getCharno();

            if (multilineText.length() > 0) {
              jsdocBuilder.markText(multilineText, startLineno, startCharno,
                  endLineno, endCharno);
            }

            return new ExtractionInfo(multilineText, token);
          }

          if (builder.length() > 0) {
            builder.append(' ');
          }
          builder.append(toString(token));

          line = stream.getRemainingJSDocLine();

          if (option != WhitespaceOption.PRESERVE) {
            line = trimEnd(line);
          }

          builder.append(line);
          token = next();
      }
    } while (true);
  }","@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }

    StringBuilder builder = new StringBuilder(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    do {
        switch (token) {
            case STAR:
                if (ignoreStar) {
                    // Mark the position after the star as the new start of the line
                } else {
                    // The star is part of the comment
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;

            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                continue;

            case EOC:
            case EOF:
                String multilineText = builder.toString();
                if (option != WhitespaceOption.PRESERVE) {
                    multilineText = multilineText.trim();
                }

                int endLineno = stream.getLineno();
                int endCharno = stream.getCharno();

                if (multilineText.length() > 0) {
                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                }

                return new ExtractionInfo(multilineText, token);

            case ANNOTATION:
                if (option == WhitespaceOption.PRESERVE) {
                    break;
                }
                // Fall through intentional

            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;

                // All tokens must be separated by a space
                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));

                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
                break;
        }
    } while (true);
}",0,0
64,Closure_33,"@Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj.isRecordType()) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!hasProperty(prop)) {
            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                .getLeastSupertype(propType);
          }
          defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
  }","@Override
public void matchConstraint(ObjectType constraintObj) {
    // We only want to match constraints on anonymous types.

    // Handle the case where the constraint object is a record type.
    if (constraintObj != null && constraintObj.isRecordType()) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
            JSType propType = constraintObj.getPropertyType(prop);
            if (!isPropertyTypeDeclared(prop)) {
                JSType typeToInfer = propType;
                if (!hasProperty(prop)) {
                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                        .getLeastSupertype(propType);
                }
                defineInferredProperty(prop, typeToInfer, null);
            }
        }
    }
}",0,0
64,Closure_33,"@Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj.isRecordType()) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!hasProperty(prop)) {
            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                .getLeastSupertype(propType);
          }
          defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
  }","@Override
public void matchConstraint(ObjectType constraintObj) {
    // We only want to match constraints on anonymous types.

    if (constraintObj != null && constraintObj.isRecordType()) {  // Check for null to avoid NPE
        for (String prop : constraintObj.getOwnPropertyNames()) {
            JSType propType = constraintObj.getPropertyType(prop);
            JSType currentType = getPropertyType(prop);
            if (currentType == null || currentType.isSubtype(propType)) { // Match subtype logic
                JSType typeToInfer = propType;
                if (currentType == null) { // Change conditions for void type
                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);
                }
                defineInferredProperty(prop, typeToInfer, null);
            }
        }
    }
}",0,1
64,Closure_33,"@Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj.isRecordType()) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!hasProperty(prop)) {
            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                .getLeastSupertype(propType);
          }
          defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
  }","@Override
public void matchConstraint(ObjectType constraintObj) {
    // Check if the constraint object is null and handle accordingly.
    if (constraintObj == null || !constraintObj.isRecordType()) {
        return;
    }

    // Loop through all property names of the constraint object.
    for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);

        // Obtain current type of the property and check type declaration.
        JSType currentType = getPropertyType(prop);
        boolean isDeclared = isPropertyTypeDeclared(prop);

        // If current property type is null or is a subtype OR the property type is not declared.
        if (currentType == null || currentType.isSubtype(propType) || !isDeclared) {
            JSType typeToInfer = propType;

            if (currentType == null && !hasProperty(prop)) {
                // Default to VOID_TYPE if no property exists.
                typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);
            }

            // Define inferred property with determined type and null source.
            defineInferredProperty(prop, typeToInfer, null);
        }
    }
}",0,2
65,Closure_35,"private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     if (constraintObj != null && constraintObj.isRecordType()) {
       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
       if (objType != null) {
         for (String prop : constraintObj.getOwnPropertyNames()) {
           JSType propType = constraintObj.getPropertyType(prop);
           if (!objType.isPropertyTypeDeclared(prop)) {
             JSType typeToInfer = propType;
             if (!objType.hasProperty(prop)) {
               typeToInfer =
                   getNativeType(VOID_TYPE).getLeastSupertype(propType);
             }
             objType.defineInferredProperty(prop, typeToInfer, null);
           }
         }
       }
     }
   }","private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }

    ObjectType constraintObj =
        ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null && constraintObj.isRecordType()) {
      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
      if (objType != null) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
          JSType propType = constraintObj.getPropertyType(prop);
          if (!objType.isPropertyTypeDeclared(prop) && constraintObj.hasProperty(prop)) {
            JSType typeToInfer = propType;
            if (!objType.hasProperty(prop)) {
              typeToInfer =
                  getNativeType(VOID_TYPE).getLeastSupertype(propType);
            }
            objType.defineInferredProperty(prop, typeToInfer, null);
          }
        }
      }
    }
  }",0,0
65,Closure_35,"private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     if (constraintObj != null && constraintObj.isRecordType()) {
       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
       if (objType != null) {
         for (String prop : constraintObj.getOwnPropertyNames()) {
           JSType propType = constraintObj.getPropertyType(prop);
           if (!objType.isPropertyTypeDeclared(prop)) {
             JSType typeToInfer = propType;
             if (!objType.hasProperty(prop)) {
               typeToInfer =
                   getNativeType(VOID_TYPE).getLeastSupertype(propType);
             }
             objType.defineInferredProperty(prop, typeToInfer, null);
           }
         }
       }
     }
   }","private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
  
    ObjectType constraintObj =
        ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null && constraintObj.isRecordType()) {
      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
      if (objType != null) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
          JSType propType = constraintObj.getPropertyType(prop);
          if (!objType.isPropertyTypeDeclared(prop)) {
            JSType existingPropType = objType.getPropertyType(prop);
            JSType typeToInfer = existingPropType != null ? existingPropType.getLeastSupertype(propType) 
                                                          : getNativeType(VOID_TYPE).getLeastSupertype(propType);
            objType.defineInferredProperty(prop, typeToInfer, null);
          }
        }
      }
    }
  }",0,1
65,Closure_35,"private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     if (constraintObj != null && constraintObj.isRecordType()) {
       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
       if (objType != null) {
         for (String prop : constraintObj.getOwnPropertyNames()) {
           JSType propType = constraintObj.getPropertyType(prop);
           if (!objType.isPropertyTypeDeclared(prop)) {
             JSType typeToInfer = propType;
             if (!objType.hasProperty(prop)) {
               typeToInfer =
                   getNativeType(VOID_TYPE).getLeastSupertype(propType);
             }
             objType.defineInferredProperty(prop, typeToInfer, null);
           }
         }
       }
     }
   }","private void inferPropertyTypesToMatchConstraint(JSType type, JSType constraint) {
    if (type == null || constraint == null) {
        return;
    }

    ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj == null || !constraintObj.isRecordType()) {
        return;
    }

    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
    if (objType == null) {
        return;
    }

    for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType constraintPropType = constraintObj.getPropertyType(prop);
        boolean isDeclared = objType.isPropertyTypeDeclared(prop);

        if (!isDeclared) {
            JSType existingType = objType.hasProperty(prop) ? objType.getPropertyType(prop) : null;

            if (existingType == null) {
                // Infer a property type if it doesn't exist
                objType.defineInferredProperty(prop, constraintPropType, null);
            } else {
                // Compute a supertype if types conflict or combine them intelligently
                JSType inferredType = existingType.getLeastSupertype(constraintPropType);
                objType.defineInferredProperty(prop, inferredType, null);
            }
        }
    }
}",0,2
66,Closure_36,"private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Be very conservative and do no cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is ok.
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confused class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }","private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
    if (!isValidDeclaration(declaration)
            || !isValidInitialization(initialization)
            || !isValidReference(reference)) {
        return false;
    }

    // If the value is read more than once, skip it.
    // VAR declarations and EXPR_RESULT don't need the value, but other
    // ASSIGN expressions parents do.
    if (declaration != initialization &&
            (!initialization.getGrandparent().isExprResult() 
             || initialization.getGrandparent() == null)) {
        return false;
    }

    // Be very conservative and do not cross control structures or
    // scope boundaries
    if (declaration.getBasicBlock() == null ||
            initialization.getBasicBlock() == null ||
            reference.getBasicBlock() == null ||
            declaration.getBasicBlock() != initialization.getBasicBlock() ||
            declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
    }

    // Do not inline into a call node. This would change
    // the context in which it was being called. For example,
    //   var a = b.c;
    //   a();
    // should not be inlined, because it calls a in the context of b
    // rather than the context of the window.
    //   var a = b.c;
    //   f(a)
    // is ok.
    Node value = initialization.getAssignedValue();
    if (value == null) {
        return false;
    }

    if (value.isGetProp()
            && reference.getParent().isCall()
            && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
    }

    if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (callNode != null && callNode.isCall()) {
            CodingConvention convention = compiler.getCodingConvention();
            // Bug 2388531: Don't inline subclass definitions into class defining
            // calls as this confused class removing logic.
            SubclassRelationship relationship =
                    convention.getClassesDefinedByCall(callNode);
            if (relationship != null) {
                return false;
            }

            // Issue 668: Don't inline singleton getter methods
            // calls as this confused class removing logic.
        }
    }

    return canMoveAggressively(value) ||
            canMoveModerately(initialization, reference);
}",0,0
66,Closure_36,"private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Be very conservative and do no cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is ok.
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confused class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }","private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
    if (!isValidDeclaration(declaration)
            || !isValidInitialization(initialization)
            || !isValidReference(reference)) {
        return false;
    }

    // Skip if the value is read multiple times or the initialization is irrelevant.
    if (declaration != initialization) {
        Node grandParent = initialization.getGrandparent();
        if (grandParent == null || !grandParent.isExprResult()) {
            return false;
        }
    }

    // Ensure all references exist in the same scope and avoid boundary crossing.
    BasicBlock declarationBlock = declaration.getBasicBlock();
    BasicBlock initializationBlock = initialization.getBasicBlock();
    BasicBlock referenceBlock = reference.getBasicBlock();
    if (declarationBlock == null || initializationBlock == null || referenceBlock == null) {
        return false;
    }
    if (!declarationBlock.equals(initializationBlock) || !declarationBlock.equals(referenceBlock)) {
        return false;
    }

    // Validate assigned value for the initialization.
    Node value = initialization.getAssignedValue();
    if (value == null) {
        return false;
    }

    // Prevent inlining into problematic call contexts.
    Node parent = reference.getParent();
    if (value.isGetProp() && parent.isCall() && parent.getFirstChild() == reference.getNode()) {
        return false;
    }

    // Avoid inlining functions in inappropriate cases.
    if (value.isFunction()) {
        if (parent != null && parent.isCall()) {
            CodingConvention convention = compiler.getCodingConvention();
            SubclassRelationship relationship = convention.getClassesDefinedByCall(parent);
            if (relationship != null) {
                return false;
            }
            // Avoid singleton getter method inlining.
            if (parent.isExprResult() || parent.isVar()) {
                return false;
            }
        }
    }

    // Implement more refined checks before aggressive or moderate moves.
    if (!canSafelyInline(value, declaration, reference)) {
        return false;
    }

    return canMoveAggressively(value) || canMoveModerately(initialization, reference);
}

// Helper Method
private boolean canSafelyInline(Node value, Reference declaration, Reference reference) {
    // Apply additional safety checks to determine if inlining is a valid option.
    // For example, avoid inlining if value modifies shared state or introduces side effects.
    if (value.hasSideEffects() || modifiesSharedState(value)) {
        return false;
    }
    // Ensure reference context does not change due to inlining.
    return declaration.getBasicBlock().isCompatibleWith(reference.getBasicBlock());
}",0,1
67,Closure_38,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
     if (x < 0 && prev == '-') {
       add("" "");
     }
 
    if ((long) x == x && !negativeZero) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }
  }","void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);

    if (negativeZero) {
        add(""-0.0""); // Explicitly handle negative zero representation
        return;
    }

    if (x < 0 && prev == '-') {
        add("" "");
    }

    if ((long) x == x) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(value) >= 100) {
            while (mantissa >= 10 && (mantissa / 10) * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        add(String.valueOf(x));
    }
}",0,0
67,Closure_38,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
     if (x < 0 && prev == '-') {
       add("" "");
     }
 
    if ((long) x == x && !negativeZero) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }
  }","void addNumber(double x) {
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);

    if (x < 0 && prev == '-') {
        add("" "");
    }

    if (negativeZero) {
        add(""-0.0"");
        return;
    }

    if ((long) x == x) {
        long value = (long) x;
        int exp = 0;
        while (Math.abs(value) >= 10 && (value % 10 == 0)) {
            value /= 10;
            exp++;
        }
        if (exp > 2 || Math.abs((long) x) >= 1000) {
            add(value + ""E"" + exp);
        } else {
            add(Long.toString((long) x));
        }
    } else {
        add(String.format(""%.15g"", x)); // Ensure proper precision for floating-point numbers
    }
}",0,1
67,Closure_38,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
     if (x < 0 && prev == '-') {
       add("" "");
     }
 
    if ((long) x == x && !negativeZero) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }
  }","void addNumber(double x) {
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);

    // Handle negative zero explicitly
    if (negativeZero) {
        if (prev == '-') {
            add("" ""); // Insert space before -0.0 if previous char was '-'
        }
        add(""-0.0"");
        return;
    }

    // Handle case where number is negative and follows '-'
    if (x < 0 && prev == '-') {
        add("" "");
    }

    // Determine if the number is an integer
    if ((long) x == x) {
        long value = (long) x;

        // Handle scientific notation for large integers
        if (Math.abs(value) >= 1000 || value % 10 == 0) {
            long mantissa = value;
            int exp = 0;
            while (mantissa % 10 == 0 && Math.abs(mantissa) >= 10) {
                mantissa /= 10;
                exp++;
            }
            add(mantissa + ""E"" + exp);
        } else {
            add(Long.toString(value));
        }
    } else {
        // Use formatted string for floating-point precision
        add(String.format(""%.15g"", x));
    }
}",0,2
68,Closure_39,"@Override
  String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
      return getReferenceName();
    } else if (prettyPrint) {
      // Don't pretty print recursively.
      prettyPrint = false;

      // Use a tree set so that the properties are sorted.
      Set<String> propertyNames = Sets.newTreeSet();
      for (ObjectType current = this;
           current != null && !current.isNativeObjectType() &&
               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
           current = current.getImplicitPrototype()) {
        propertyNames.addAll(current.getOwnPropertyNames());
      }

      StringBuilder sb = new StringBuilder();
      sb.append(""{"");

      int i = 0;
      for (String property : propertyNames) {
        if (i > 0) {
          sb.append("", "");
        }

        sb.append(property);
        sb.append("": "");
        sb.append(getPropertyType(property).toString());

        ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
          sb.append("", ..."");
          break;
        }
      }

      sb.append(""}"");

       prettyPrint = true;
       return sb.toString();
     } else {
       return ""{...}"";
     }
   }","@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        boolean originalPrettyPrint = prettyPrint;
        prettyPrint = false;
    
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this;
             current != null && !current.isNativeObjectType() &&
             propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
             current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
    
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
    
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
    
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toString());
    
            ++i;
            if (i >= MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
    
        sb.append(""}"");
    
        prettyPrint = originalPrettyPrint;
        return sb.toString();
    } else {
        return ""{...}"";
    }
}",0,0
68,Closure_39,"@Override
  String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
      return getReferenceName();
    } else if (prettyPrint) {
      // Don't pretty print recursively.
      prettyPrint = false;

      // Use a tree set so that the properties are sorted.
      Set<String> propertyNames = Sets.newTreeSet();
      for (ObjectType current = this;
           current != null && !current.isNativeObjectType() &&
               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
           current = current.getImplicitPrototype()) {
        propertyNames.addAll(current.getOwnPropertyNames());
      }

      StringBuilder sb = new StringBuilder();
      sb.append(""{"");

      int i = 0;
      for (String property : propertyNames) {
        if (i > 0) {
          sb.append("", "");
        }

        sb.append(property);
        sb.append("": "");
        sb.append(getPropertyType(property).toString());

        ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
          sb.append("", ..."");
          break;
        }
      }

      sb.append(""}"");

       prettyPrint = true;
       return sb.toString();
     } else {
       return ""{...}"";
     }
   }","@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Create a new instance to manage pretty printing state
        PrettyPrintManager printManager = new PrettyPrintManager();
        return printManager.prettyPrintObjectType(this);
    } else {
        return ""{...}"";
    }
}

class PrettyPrintManager {
    private boolean prettyPrintFlag = false;
    
    String prettyPrintObjectType(ObjectType objectType) {
        if (!prettyPrintFlag) {
            prettyPrintFlag = true;
            Set<String> propertyNames = Sets.newTreeSet();
            for (ObjectType current = objectType;
                 current != null && !current.isNativeObjectType() &&
                 propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
                 current = current.getImplicitPrototype()) {
                propertyNames.addAll(current.getOwnPropertyNames());
            }

            StringBuilder sb = new StringBuilder();
            sb.append(""{"");

            int i = 0;
            for (String property : propertyNames) {
                if (i > 0) {
                    sb.append("", "");
                }
                sb.append(property);
                sb.append("": "");
                sb.append(objectType.getPropertyType(property).toString());

                ++i;
                if (i >= MAX_PRETTY_PRINTED_PROPERTIES) {
                    sb.append("", ..."");
                    break;
                }
            }

            sb.append(""}"");
            prettyPrintFlag = false;
            return sb.toString();
        } else {
            return ""{}"";  // Return an empty representation to avoid recursive prints
        }
    }
}",0,1
68,Closure_39,"@Override
  String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
      return getReferenceName();
    } else if (prettyPrint) {
      // Don't pretty print recursively.
      prettyPrint = false;

      // Use a tree set so that the properties are sorted.
      Set<String> propertyNames = Sets.newTreeSet();
      for (ObjectType current = this;
           current != null && !current.isNativeObjectType() &&
               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
           current = current.getImplicitPrototype()) {
        propertyNames.addAll(current.getOwnPropertyNames());
      }

      StringBuilder sb = new StringBuilder();
      sb.append(""{"");

      int i = 0;
      for (String property : propertyNames) {
        if (i > 0) {
          sb.append("", "");
        }

        sb.append(property);
        sb.append("": "");
        sb.append(getPropertyType(property).toString());

        ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
          sb.append("", ..."");
          break;
        }
      }

      sb.append(""}"");

       prettyPrint = true;
       return sb.toString();
     } else {
       return ""{...}"";
     }
   }","@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else {
        // Avoid tedious pretty print for recursive records
        Set<String> propertyNames = collectUniquePropertyNames();
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");

        int printedCount = 0;
        for (String property : propertyNames) {
            if (printedCount > 0) {
                sb.append("", "");
            }

            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toString());

            printedCount++;
            if (printedCount >= MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }

        sb.append(""}"");
        return sb.toString();
    }
}

private Set<String> collectUniquePropertyNames() {
    Set<String> propertyNames = Sets.newTreeSet();
    Set<ObjectType> visited = new HashSet<>();
    
    for (ObjectType current = this; 
         current != null && !current.isNativeObjectType(); 
         current = current.getImplicitPrototype()) {
        if (!visited.add(current)) {
            // Stop if we encountered an already visited object type.
            break;
        }
        propertyNames.addAll(current.getOwnPropertyNames());
    }
    return propertyNames;
}",0,2
69,Closure_4,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
      handleTypeCycle(t);
    }

    if (resolved) {
      super.resolveInternal(t, enclosing);
      finishPropertyContinuations();
      return registry.isLastGeneration() ?
          getReferencedType() : this;
     }
 
     resolveViaProperties(t, enclosing);
     if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
      finishPropertyContinuations();
    }
    return registry.isLastGeneration() ?
        getReferencedType() : this;
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
    }

    if (resolved) {
        JSType resultType = super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ? getReferencedType() : resultType;
    }

    resolveViaProperties(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
    }

    JSType resultType = super.resolveInternal(t, enclosing);
    if (isResolved()) {
        finishPropertyContinuations();
    }
    return registry.isLastGeneration() ? getReferencedType() : resultType;
}",0,0
69,Closure_4,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
      handleTypeCycle(t);
    }

    if (resolved) {
      super.resolveInternal(t, enclosing);
      finishPropertyContinuations();
      return registry.isLastGeneration() ?
          getReferencedType() : this;
     }
 
     resolveViaProperties(t, enclosing);
     if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
      finishPropertyContinuations();
    }
    return registry.isLastGeneration() ?
        getReferencedType() : this;
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    boolean resolved = resolveViaRegistry(t, enclosing);
    boolean hasCycle = detectImplicitPrototypeCycle();

    if (hasCycle) {
        handleTypeCycle(t);
    }

    if (resolved && !hasCycle) {
        super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ? getReferencedType() : this;
    }

    resolved = resolveViaProperties(t, enclosing);
    hasCycle = detectImplicitPrototypeCycle();

    if (hasCycle) {
        handleTypeCycle(t);
    }

    super.resolveInternal(t, enclosing);
    if (isResolved() && !hasCycle) {
        finishPropertyContinuations();
    }
    return registry.isLastGeneration() ? getReferencedType() : this;
}",0,1
70,Closure_40,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          Preconditions.checkNotNull(ns);
          recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            recordSet(nameInfo.name, nameNode);
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
           }
         }
       }
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {

    // Record global variable and function declarations
    if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
            NameInformation ns = createNameInformation(t, n, parent);
            Preconditions.checkNotNull(ns);
            recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null) {
                JsName nameInfo = getName(nameNode.getString(), true);
                recordSet(nameInfo.name, nameNode);
            }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
            NameInformation ns = createNameInformation(t, n, parent);
            if (ns != null) {
                recordSet(ns.name, n);
            }
        }
    }

    // Record assignments and call sites
    if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
            if (ns.isPrototype) {
                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
            } else {
                recordSet(ns.name, nameNode);
            }
        }
    } else if (n.isCall()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null && ns.onlyAffectsClassDef) {
            JsName name = getName(ns.name, false);
            if (name != null) {
                refNodes.add(new ClassDefiningFunctionNode(
                        name, n, parent, parent.getParent()));
            }
        }
    }
}",0,0
70,Closure_40,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          Preconditions.checkNotNull(ns);
          recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            recordSet(nameInfo.name, nameNode);
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
           }
         }
       }
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    try {
        // Record global variable and function declarations
        if (t.inGlobalScope()) {
            if (NodeUtil.isVarDeclaration(n)) {
                NameInformation ns = createNameInformation(t, n, parent);
                // Ensure ns is not null before proceeding
                if (ns != null) {
                    recordSet(ns.name, n);
                }
            } else if (NodeUtil.isFunctionDeclaration(n)) {
                Node nameNode = n.getFirstChild();
                NameInformation ns = createNameInformation(t, nameNode, n);
                if (ns != null) {
                    JsName nameInfo = getName(nameNode.getString(), true);
                    if (nameInfo != null) {
                        recordSet(nameInfo.name, nameNode);
                    }
                }
            } else if (NodeUtil.isObjectLitKey(n, parent)) {
                NameInformation ns = createNameInformation(t, n, parent);
                if (ns != null) {
                    recordSet(ns.name, n);
                }
            }
        }

        // Record assignments and call sites
        if (n.isAssign()) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null) {
                if (ns.isPrototype) {
                    recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
                } else {
                    recordSet(ns.name, nameNode);
                }
            }
        } else if (n.isCall()) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null && ns.onlyAffectsClassDef) {
                JsName name = getName(ns.name, false);
                if (name != null) {
                    refNodes.add(new ClassDefiningFunctionNode(
                        name, n, parent, parent.getParent()));
                }
            }
        }
    } catch (Exception e) {
        // Log error details for easier debugging
        System.err.println(""Error visiting node: "" + n + "", parent: "" + parent);
        e.printStackTrace();
    }
}",0,1
70,Closure_40,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          Preconditions.checkNotNull(ns);
          recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            recordSet(nameInfo.name, nameNode);
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
           }
         }
       }
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    try {
        // Record global variable and function declarations
        if (t.inGlobalScope()) {
            processGlobalDeclarations(t, n, parent);
        }

        // Record assignments and call sites
        processAssignmentsOrCallSites(t, n, parent);

    } catch (Exception e) {
        // Log error details for easier debugging
        System.err.println(""Error visiting node: "" + n + "", parent: "" + parent);
        e.printStackTrace();
    }
}

private void processGlobalDeclarations(NodeTraversal t, Node n, Node parent) {
    if (NodeUtil.isVarDeclaration(n)) {
        recordNameInformation(t, n, parent);
    } else if (NodeUtil.isFunctionDeclaration(n)) {
        Node nameNode = n.getFirstChild();
        recordNameInformation(t, nameNode, n);
    } else if (NodeUtil.isObjectLitKey(n, parent)) {
        recordNameInformation(t, n, parent);
    }
}

private void recordNameInformation(NodeTraversal t, Node n, Node parent) {
    NameInformation ns = createNameInformation(t, n, parent);
    if (ns != null) {
        JsName nameInfo = getName(ns.name, true);
        if (nameInfo != null) {
            recordSet(ns.name, n);
        }
    }
}

private void processAssignmentsOrCallSites(NodeTraversal t, Node n, Node parent) {
    if (n.isAssign()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
            if (ns.isPrototype) {
                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
            } else {
                recordSet(ns.name, nameNode);
            }
        }
    } else if (n.isCall()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null && ns.onlyAffectsClassDef) {
            JsName name = getName(ns.name, false);
            if (name != null) {
                refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));
            }
        }
    }
}",0,2
71,Closure_42,"@Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
          transform(loopNode.getIteratedObject()),
          transformBlock(loopNode.getBody()));
    }","@Override
Node processForInLoop(ForInLoop loopNode) {

    // Check if the loopNode is null to avoid NullPointerExceptions
    if (loopNode == null) {
        throw new IllegalArgumentException(""LoopNode cannot be null"");
    }

    // Check if iterator and iterated object are valid
    if (loopNode.getIterator() == null || loopNode.getIteratedObject() == null) {
        throw new IllegalArgumentException(""Iterator and Iterated Object cannot be null"");
    }

    // Return the bare minimum to put the AST in a valid state.
    return newNode(
            Token.FOR,
            transform(loopNode.getIterator()),
            transform(loopNode.getIteratedObject()),
            transformBlock(loopNode.getBody()));
}",0,0
71,Closure_42,"@Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
          transform(loopNode.getIteratedObject()),
          transformBlock(loopNode.getBody()));
    }","@Override
Node processForInLoop(ForInLoop loopNode) {

    // Check if the loopNode is null to avoid NullPointerExceptions
    if (loopNode == null) {
        throw new IllegalArgumentException(""LoopNode cannot be null"");
    }

    // Check if loop node has all necessary components to iterate
    List<Node> iteratorChildren = loopNode.getIterator().getChildren();
    if (iteratorChildren.isEmpty()) {
        throw new IllegalArgumentException(""Iterator must have at least one child node"");
    }

    // Ensure the iterated object is iterable
    if (!isIterable(loopNode.getIteratedObject())) {
        throw new IllegalStateException(""Iterated Object is not iterable"");
    }

    // Return the bare minimum to put the AST in a valid state while handling special cases
    return newNode(
        Token.FOR,
        transform(loopNode.getIterator()),
        transform(loopNode.getIteratedObject()),
        transformBlock(loopNode.getBody()));
}

// Helper method to check if an object is iterable
private boolean isIterable(Node node) {
    // Implement logic to determine if the node represents an iterable object
    // This is a placeholder and should be replaced with actual implementation
    return node != null; // Example condition, adjust as necessary based on real criteria
}",0,1
72,Closure_44,"void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
      return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar())) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
  }","void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
        return;
    }

    char c = newcode.charAt(0);
    char lastChar = getLastChar();
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(lastChar)) {
        // Need space to separate. This is not pretty printing.
        // For example: ""return foo;""
        append("" "");
        // Do not allow a forward slash to appear after a DIV.
        // For example,
        // REGEXP DIV REGEXP
        // is valid and should print like
        // / // / /
    }

    append(newcode);
}",0,0
72,Closure_44,"void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
      return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar())) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
  }","void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
        return;
    }

    char c = newcode.charAt(0);
    char lastChar = getLastChar();
    
    // Handle special characters that should appear after a word or certain conditions
    boolean needsSpace = (isWordChar(c) || c == '\\') && isWordChar(lastChar);
    boolean isSpecialCase = (c == '/' && lastChar == '/'); // Handle cases like / // / /
    
    if (needsSpace || isSpecialCase) {
        append("" "");
    }

    append(newcode);
}",0,1
73,Closure_46,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
","public ObjectType getImplicitPrototype() {
    ObjectType objectType = registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    return objectType != null && !objectType.hasReferenceName() ? objectType : null;
}",0,0
73,Closure_46,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
","public ObjectType getImplicitPrototype() {
    if (registry == null) {
        return null; // Handle the case where registry might be null
    }
    ObjectType objectType = registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    if (objectType == null) {
        return null; // If OBJECT_TYPE is not available, return null
    }
    // Check if object type is actually of prototype kind and has a reference name
    if (objectType.hasReferenceName() && objectType.getReferenceName().equals(""Object"")) {
        return objectType;
    }
    return null;
}",0,1
73,Closure_46,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
","public ObjectType getImplicitPrototype() {
    ObjectType objectType = registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    if (objectType == null || objectType.hasReferenceName()) {
        // If OBJECT_TYPE is absent or not an implicit prototype, return null
        return null;
    }
    // Ensure it's a prototype type by checking if it has certain properties
    if (!objectType.hasProperty(""prototype"")) {
        return null;
    }
    return objectType;
}",0,2
74,Closure_48,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode != null ? ownerNode.getQualifiedName() : null;
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        valueType = rhsValue.getJSType();
      }

      if (""prototype"".equals(propName) && valueType != null) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
          return;
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }
        return;
      }

      boolean inferred = true;
      if (info != null) {
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
      }

      if (inferred) {
        inferred = !(rhsValue != null &&
            rhsValue.isFunction() &&
            (info != null || !scope.isDeclared(qName, false)));
      }

      if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }",0,0
74,Closure_48,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode != null ? ownerNode.getQualifiedName() : null;
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        valueType = rhsValue.getJSType();
      }

      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
          return;
        } else {
          // If prototype qVar is not declared yet, simply return.
          return;
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }
        return;
      }

      boolean inferred = true;
      if (info != null) {
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
      }

      if (inferred) {
        inferred = !(rhsValue != null &&
            rhsValue.isFunction() &&
            (info != null || !scope.isDeclared(qName, false)));
      }

      if (!inferred) {
        ObjectType ownerType = getObjectOwnerType(ownerName);
        if (ownerType != null) {
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName))) {
            ownerType.defineInferredProperty(propName, valueType, n);
          }
        }
        defineSlot(n, parent, valueType, false);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        FunctionType ownerType =
            JSType.toMaybeFunctionType(findOwnerType(qName, ownerName));
        if (ownerType != null &&
            ownerType.isInterface() &&
            !hasLocalVariableDefinition(n)) {
          defineSlot(n, parent, getNativeType(BOOLEAN_VALUE), inferred);
        }
      }
    }",0,1
75,Closure_5,"private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = true; // Start with assumption it can be inlined
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false; // Used as 'this' in call
            }

            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false; // Found property not defined on literal
                }
            }
            continue; // Skip further checks for properties
        }

        if (!isVarOrAssignExprLhs(name)) {
           return false; // Not allowed VAR declaration or assignment
        }

        Node val = ref.getAssignedValue();
        if (val != null && val.isObjectLit()) {
            for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
                if (child.isGetterDef() || child.isSetterDef()) {
                    return false; // ES5 get/set not supported
                }
                validProperties.add(child.getString());

                Node childVal = child.getFirstChild();
                for (Reference t : refs) {
                    Node refNode = t.getParent();
                    while (!NodeUtil.isStatementBlock(refNode)) {
                        if (refNode == childVal) {
                            return false; // Self-referential assignment
                        }
                        refNode = refNode.getParent();
                    }
                }
            }
            // Object literal assignment found
        } else if (val == null) {
            ret = false; // No assignment, cannot inline
        } else {
            return false; // Assignment is not object literal
        }
    }
    return ret;
}",0,0
75,Closure_5,"private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    Set<String> validProperties = Sets.newHashSet();
    boolean hasObjectLiteralAssignment = false;

    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false; // Used as 'this' in call
            }

            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false; // Found property not defined on literal
                }
            }
            continue;
        }

        if (!isVarOrAssignExprLhs(name)) {
            return false; // Not allowed VAR declaration or assignment
        }

        Node val = ref.getAssignedValue();
        if (val != null && val.isObjectLit()) {
            hasObjectLiteralAssignment = true;
            for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
                if (child.isGetterDef() || child.isSetterDef()) {
                    return false; // ES5 get/set not supported
                }
                validProperties.add(child.getString());
                Node childVal = child.getFirstChild();

                for (Reference t : refs) {
                    Node refNode = t.getParent();
                    while (!NodeUtil.isStatementBlock(refNode)) {
                        if (refNode == childVal) {
                            return false; // Self-referential assignment
                        }
                        refNode = refNode.getParent();
                    }
                }
            }
        } else if (val == null) {
            continue; // Var with no assignment, ignore
        } else {
            return false; // Assignment is not an object literal
        }
    }

    return hasObjectLiteralAssignment;
}",0,1
75,Closure_5,"private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    Set<String> validProperties = Sets.newHashSet();
    boolean hasObjectLiteralAssignment = false;

    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false; // Used as 'this' in call
            }

            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName) && !NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                return false; // Found property not defined on literal
            }
            continue;
        }

        if (!isVarOrAssignExprLhs(name)) {
            return false; // Not allowed VAR declaration or assignment
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
            continue; // Var with no assignment, ignore
        }

        if (!val.isObjectLit()) {
            return false; // Assignment is not an object literal
        }

        hasObjectLiteralAssignment = true;
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                return false; // ES5 get/set not supported
            }

            validProperties.add(child.getString());
            Node childVal = child.getFirstChild();

            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        return false; // Self-referential assignment
                    }
                    refNode = refNode.getParent();
                }
            }
        }
    }

    return hasObjectLiteralAssignment && !refs.stream().anyMatch(ref -> ref.getParent().isDelete());
}",0,2
76,Closure_50,"private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
      return n;
    }
 
     Node right = callTarget.getNext();
     if (right != null) {
       if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return n;
    }

      // "","" is the default, it doesn't need to be explicit

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getArrayElementStringValue(elem));
      } else {
        if (sb != null) {
          Preconditions.checkNotNull(prev);
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(
              Node.newString(sb.toString()).copyInformationFrom(prev));
          sb = null;
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem);
      }
      prev = elem;
      elem = elem.getNext();
    }

    if (sb != null) {
      Preconditions.checkNotNull(prev);
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(
          Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        n.getParent().replaceChild(n, emptyStringNode);
        reportCodeChange();
        return emptyStringNode;
      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString("""").copyInformationFrom(n),
              foldedStringNode);
          foldedStringNode = replacement;
        }
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return n;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        reportCodeChange();
        break;
    }

    return n;
  }","private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }

    Node right = callTarget.getNext();
    if (right != null && !NodeUtil.isImmutableValue(right)) {
        return n;
    }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if (arrayNode.getType() != Token.ARRAYLIT || !functionName.getString().equals(""join"")) {
        return n;
    }

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();

    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            if (sb == null) {
                sb = new StringBuilder();
            } else {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        } else {
            if (sb != null) {
                Preconditions.checkNotNull(prev);
                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(
                    Node.newString(sb.toString()).copyInformationFrom(prev));
                sb = null;
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        prev = elem;
        elem = elem.getNext();
    }

    if (sb != null) {
        Preconditions.checkNotNull(prev);
        foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(
            Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            n.getParent().replaceChild(n, emptyStringNode);
            reportCodeChange();
            return emptyStringNode;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return n;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                Node replacement = new Node(Token.ADD,
                    Node.newString("""").copyInformationFrom(n),
                    foldedStringNode);
                foldedStringNode = replacement;
            }
            n.getParent().replaceChild(n, foldedStringNode);
            reportCodeChange();
            return foldedStringNode;
        default:
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return n;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
            if (foldedSize > originalSize) {
                return n;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            reportCodeChange();
            break;
    }

    return n;
}",0,0
76,Closure_50,"private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
      return n;
    }
 
     Node right = callTarget.getNext();
     if (right != null) {
       if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return n;
    }

      // "","" is the default, it doesn't need to be explicit

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getArrayElementStringValue(elem));
      } else {
        if (sb != null) {
          Preconditions.checkNotNull(prev);
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(
              Node.newString(sb.toString()).copyInformationFrom(prev));
          sb = null;
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem);
      }
      prev = elem;
      elem = elem.getNext();
    }

    if (sb != null) {
      Preconditions.checkNotNull(prev);
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(
          Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        n.getParent().replaceChild(n, emptyStringNode);
        reportCodeChange();
        return emptyStringNode;
      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString("""").copyInformationFrom(n),
              foldedStringNode);
          foldedStringNode = replacement;
        }
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return n;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        reportCodeChange();
        break;
    }

    return n;
  }","private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }

    Node right = callTarget.getNext();
    if (right != null && !NodeUtil.isImmutableValue(right)) {
        return n;
    }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if (arrayNode.getType() != Token.ARRAYLIT || functionName == null || !functionName.getString().equals(""join"")) {
        return n;
    }
    
    boolean allImmutable = true;
    Node elem = arrayNode.getFirstChild();
    while (elem != null) {
        if (!NodeUtil.isImmutableValue(elem) && elem.getType() != Token.EMPTY) {
            allImmutable = false;
            break;
        }
        elem = elem.getNext();
    }

    if (!allImmutable) {
        return n;
    }

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    Node prev = null;
    elem = arrayNode.getFirstChild();
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        }
        prev = elem;
        elem = elem.getNext();
    }

    int foldedSize = sb.length() + 2;
    int originalSize = InlineCostEstimator.getCost(n);

    if (foldedSize <= originalSize) {
        Node foldedStringNode = Node.newString(sb.toString()).copyInformationFrom(prev);
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
    }

    return n;
}",0,1
76,Closure_50,"private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
      return n;
    }
 
     Node right = callTarget.getNext();
     if (right != null) {
       if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return n;
    }

      // "","" is the default, it doesn't need to be explicit

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getArrayElementStringValue(elem));
      } else {
        if (sb != null) {
          Preconditions.checkNotNull(prev);
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(
              Node.newString(sb.toString()).copyInformationFrom(prev));
          sb = null;
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem);
      }
      prev = elem;
      elem = elem.getNext();
    }

    if (sb != null) {
      Preconditions.checkNotNull(prev);
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(
          Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        n.getParent().replaceChild(n, emptyStringNode);
        reportCodeChange();
        return emptyStringNode;
      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString("""").copyInformationFrom(n),
              foldedStringNode);
          foldedStringNode = replacement;
        }
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return n;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        reportCodeChange();
        break;
    }

    return n;
  }","private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }

    Node right = callTarget.getNext();
    String joinString = "","";
    if (right != null) {
        if (!NodeUtil.isImmutableValue(right)) {
            return n;
        }
        joinString = NodeUtil.getStringValue(right);
    }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = functionNameSafe(arrayNode);

    if (arrayNode.getType() != Token.ARRAYLIT || functionName == null || !functionName.equals(""join"")) {
        return n;
    }

    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();

    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            if (sb == null) {
                sb = new StringBuilder();
            } else {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        } else {
            finalizeString(sb, prev, arrayFoldedChildren);
            sb = null;
            arrayFoldedChildren.add(elem);
        }
        prev = elem;
        elem = elem.getNext();
    }
    finalizeString(sb, prev, arrayFoldedChildren);

    int foldedSize = calculateFoldedSize(arrayFoldedChildren);
    int originalSize = InlineCostEstimator.getCost(n);

    if (shouldReplace(arrayFoldedChildren, foldedSize, originalSize)) {
        return replaceNode(n, arrayNode, arrayFoldedChildren);
    }

    return n;
}

private String functionNameSafe(Node arrayNode) {
    Node functionNameNode = arrayNode.getNext();
    if (functionNameNode != null && functionNameNode.getType() == Token.STRING) {
        return functionNameNode.getString();
    }
    return null;
}

private void finalizeString(StringBuilder sb, Node prev, List<Node> arrayFoldedChildren) {
    if (sb != null) {
        Preconditions.checkNotNull(prev);
        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
    }
}

private int calculateFoldedSize(List<Node> arrayFoldedChildren) {
    int size = 0;
    for (Node node : arrayFoldedChildren) {
        size += InlineCostEstimator.getCost(node) + 2;
    }
    return size + arrayFoldedChildren.size() - 1;
}

private boolean shouldReplace(List<Node> arrayFoldedChildren, int foldedSize, int originalSize) {
    return foldedSize <= originalSize || arrayFoldedChildren.size() <= 1;
}

private Node replaceNode(Node n, Node arrayNode, List<Node> arrayFoldedChildren) {
    if (arrayFoldedChildren.size() == 1) {
        Node foldedStringNode = arrayFoldedChildren.get(0);
        replaceSingleNode(n, arrayNode, foldedStringNode);
        return foldedStringNode;
    }
    arrayNode.detachChildren();
    for (Node node : arrayFoldedChildren) {
        arrayNode.addChildToBack(node);
    }
    reportCodeChange();
    return n;
}

private void replaceSingleNode(Node n, Node arrayNode, Node foldedStringNode) {
    if (foldedStringNode.getType() != Token.STRING) {
        foldedStringNode = new Node(Token.ADD, Node.newString("""").copyInformationFrom(n), foldedStringNode);
    }
    arrayNode.detachChildren();
    n.getParent().replaceChild(n, foldedStringNode);
    reportCodeChange();
}",0,2
77,Closure_51,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
      add("" "");
    }

    if ((long) x == x) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }

  }","void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
        add("" "");
    }

    if ((long) x == x) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(x) >= 100) {
            while (mantissa / 10 >= 10) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        add(String.valueOf(x));
    }
}",0,0
77,Closure_51,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
      add("" "");
    }

    if ((long) x == x) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }

  }","void addNumber(double x) {
    // Prevent misparsing of negative numbers
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
        add("" "");
    }

    if ((long) x == x) {  // Check if x is an integer
        long value = (long) x;
        String result;
        if (Math.abs(value) >= 1000) {  // Change threshold from 100 to 1000
            long mantissa = value;
            int exp = 0;
            while (Math.abs(mantissa) >= 10) {
                mantissa /= 10;
                exp++;
            }
            result = mantissa + ""E"" + exp;
        } else {
            result = Long.toString(value);
        }
        add(result);
    } else {
        add(String.valueOf(x));
    }
}",0,1
77,Closure_51,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
      add("" "");
    }

    if ((long) x == x) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }

  }","void addNumber(double x) {
    // Prevent misparsing of negative numbers
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
        add("" "");
    }

    // Handle the -0.0 case separately
    if (x == 0 && Double.doubleToLongBits(x) == Double.doubleToLongBits(-0.0)) {
        add(""-0"");
        return;
    }

    if ((long) x == x) {  // Check if x is an integer
        long value = (long) x;
        String result;
        if (Math.abs(value) >= 1000) {  // Change threshold from 100 to 1000
            long mantissa = value;
            int exp = 0;
            while (Math.abs(mantissa) >= 10) {
                mantissa /= 10;
                exp++;
            }
            result = mantissa + ""E"" + exp;
        } else {
            result = Long.toString(value);
        }
        add(result);
    } else {
        add(String.valueOf(x));
    }
}",0,2
78,Closure_52,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
      char c = s.charAt(index);
      if (c < '0' || c > '9') {
         return false;
       }
     }
     return len > 0;
   }","static boolean isSimpleNumber(String s) {
    if (s == null || s.isEmpty()) {
        return false;
    }
    int len = s.length();
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return true;
}",0,0
78,Closure_52,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
      char c = s.charAt(index);
      if (c < '0' || c > '9') {
         return false;
       }
     }
     return len > 0;
   }","static boolean isSimpleNumber(String s) {
    if (s == null) {
        return false;
    }
    String trimmed = s.trim();
    if (trimmed.isEmpty()) {
        return false;
    }
    for (int index = 0; index < trimmed.length(); index++) {
        char c = trimmed.charAt(index);
        if (!Character.isDigit(c)) {
            return false;
        }
    }
    return true;
}",0,1
78,Closure_52,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
      char c = s.charAt(index);
      if (c < '0' || c > '9') {
         return false;
       }
     }
     return len > 0;
   }","static boolean isSimpleNumber(String s) {
    if (s == null || s.isEmpty()) {
        return false;
    }

    String trimmed = s.trim();
    int length = trimmed.length();

    // Check for leading zero indicating a non-simple number format
    if (length > 1 && trimmed.charAt(0) == '0') {
        return false;
    }

    for (int index = 0; index < length; index++) {
        char c = trimmed.charAt(index);
        if (!Character.isDigit(c)) {
            return false;
        }
    }
    return true;
}",0,2
79,Closure_53,"private void replaceAssignmentExpression(Var v, Reference ref,
                                             Map<String, String> varmap) {
      // Compute all of the assignments necessary
      List<Node> nodes = Lists.newArrayList();
      Node val = ref.getAssignedValue();
      blacklistVarReferencesInTree(val, v.scope);
      Preconditions.checkState(val.getType() == Token.OBJECTLIT);
      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
      for (Node key = val.getFirstChild(); key != null;
           key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
      }

      // TODO(user): Better source information.
      for (String var : all) {
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)),
                   NodeUtil.newUndefinedNode(null)));
       }
 
       Node replacement;
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));

        // Join these using COMMA.  A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
          cur.addChildToFront(nodes.get(i));
          Node t = new Node(Token.COMMA);
          cur.addChildToFront(t);
          cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));

      Node replace = ref.getParent();
      replacement.copyInformationFromForTree(replace);

      if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(
            replace, NodeUtil.newExpr(replacement));
      } else {
        replace.getParent().replaceChild(replace, replacement);
      }
    }","private void replaceAssignmentExpression(Var v, Reference ref,
                                         Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(
                new Node(Token.ASSIGN,
                        Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
    }

    // TODO(user): Better source information.
    for (String var : all) {
        nodes.add(
                new Node(Token.ASSIGN,
                        Node.newString(Token.NAME, varmap.get(var)),
                        NodeUtil.newUndefinedNode()));
    }

    Node replacement = null;

    if (!nodes.isEmpty()) {
        // All assignments evaluate to true, so make sure that the
        // expr statement evaluates to true in case it matters.
        nodes.add(new Node(Token.TRUE));

        // Join these using COMMA. A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
            cur.addChildToFront(nodes.get(i));
            Node t = new Node(Token.COMMA);
            cur.addChildToFront(t);
            cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));
    }

    Node replace = ref.getParent();
    if (replacement != null) {
        replacement.copyInformationFromForTree(replace);
    }

    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(
                replace, NodeUtil.newExpr(replacement));
    } else if (replacement != null) {
        replace.getParent().replaceChild(replace, replacement);
    }
}",0,0
80,Closure_55,"  public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }
","public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().getName() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }",0,0
80,Closure_55,"  public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }
","public Node parseHelperCode(Reducer reducer) {
    String syntheticCodeName = reducer.getClass().getName().replace('$', '.') + "":helper"";
    Node root = compiler.parseSyntheticCode(syntheticCodeName, reducer.getHelperSource());
    return (root != null && root.hasChildren()) ? root.removeFirstChild() : null;
}",0,1
80,Closure_55,"  public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }
","public Node parseHelperCode(Reducer reducer) {
    String syntheticCodeName = reducer.getClass().getSimpleName() + "":helper"";
    Node root = compiler.parseSyntheticCode(syntheticCodeName, reducer.getHelperSource());
    if (root != null) {
        if (NodeUtil.isFunctionExpression(root.getFirstChild())) {
            return root.removeFirstChild();
        }
    }
    return null;
}",0,2
81,Closure_56,"public String getLine(int lineNumber) {
    String js = """";
    try {
      // NOTE(nicksantos): Right now, this is optimized for few warnings.
      // This is probably the right trade-off, but will be slow if there
      // are lots of warnings in one file.
      js = getCode();
    } catch (IOException e) {
      return null;
    }

    int pos = 0;
    int startLine = 1;

    // If we've saved a previous offset and it's for a line less than the
    // one we're searching for, then start at that point.
    if (lineNumber >= lastLine) {
      pos = lastOffset;
      startLine = lastLine;
    }

    for (int n = startLine; n < lineNumber; n++) {
      int nextpos = js.indexOf('\n', pos);
      if (nextpos == -1) {
        return null;
      }
      pos = nextpos + 1;
    }

    // Remember this offset for the next search we do.
    lastOffset = pos;
    lastLine = lineNumber;

    if (js.indexOf('\n', pos) == -1) {
       // If next new line cannot be found, there are two cases
       // 1. pos already reaches the end of file, then null should be returned
       // 2. otherwise, return the contents between pos and the end of file.
         return null;
     } else {
       return js.substring(pos, js.indexOf('\n', pos));
     }
  }","public String getLine(int lineNumber) {
    String js = """";
    try {
        // NOTE(nicksantos): Right now, this is optimized for few warnings.
        // This is probably the right trade-off, but will be slow if there
        // are lots of warnings in one file.
        js = getCode();
    } catch (IOException e) {
        return null;
    }

    int pos = 0;
    int startLine = 1;

    // If we've saved a previous offset and it's for a line less than the
    // one we're searching for, then start at that point.
    if (lineNumber > lastLine) {
        pos = lastOffset;
        startLine = lastLine;
    }

    for (int n = startLine; n < lineNumber; n++) {
        int nextpos = js.indexOf('\n', pos);
        if (nextpos == -1) {
            return null;
        }
        pos = nextpos + 1;
    }

    // Remember this offset for the next search we do.
    lastOffset = pos;
    lastLine = lineNumber;

    int nextNewLine = js.indexOf('\n', pos);
    if (nextNewLine == -1) {
        // If next new line cannot be found, return the contents between pos and the end of file.
        return pos < js.length() ? js.substring(pos) : null;
    } else {
        return js.substring(pos, nextNewLine);
    }
}",0,0
82,Closure_57,"private static String extractClassNameIfGoog(Node node, Node parent,
      String functionName){
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
      Node callee = node.getFirstChild();
      if (callee != null && callee.getType() == Token.GETPROP) {
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
           if (target != null) {
             className = target.getString();
           }
         }
      }
    }
    return className;
  }","private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
        Node callee = node.getFirstChild();
        if (callee != null && callee.getType() == Token.GETPROP) {
            String qualifiedName = callee.getQualifiedName();
            if (qualifiedName != null && functionName.equals(qualifiedName)) {
                Node target = node.getLastChild();
                if (target != null && target.getType() == Token.STRING) {
                    className = target.getString();
                }
            }
        }
    }
    return className;
}",0,0
83,Closure_58,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }","private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        Node conditionExpr = NodeUtil.getConditionExpression(n);
        if (conditionExpr != null) {
            computeGenKill(conditionExpr, gen, kill, conditional);
        }
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          Node forConditionExpr = NodeUtil.getConditionExpression(n);
          if (forConditionExpr != null) {
              computeGenKill(forConditionExpr, gen, kill, conditional);
          }
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
           addToSetIfLocal(lhs, kill);
           if (!conditional) {
               addToSetIfLocal(lhs, gen);
           }
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          } else if (!conditional) {
            addToSetIfLocal(c, kill);
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          Node next = lhs.getNext();
          if (next != null) {
              computeGenKill(next, gen, kill, conditional);
          }
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
}",0,0
83,Closure_58,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }","private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        Node conditionExpr = NodeUtil.getConditionExpression(n);
        if (conditionExpr != null) {
            computeGenKill(conditionExpr, gen, kill, conditional);
        }
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          Node forConditionExpr = NodeUtil.getConditionExpression(n);
          if (forConditionExpr != null) {
              computeGenKill(forConditionExpr, gen, kill, conditional);
          }
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
           addToSetIfLocal(lhs, kill); // Consider the lhs as part of kill
           computeGenKill(rhs, gen, kill, conditional); // Only rhs should be computed on
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
          }
          if (!conditional) {
            addToSetIfLocal(c, kill);
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          addToSetIfLocal(lhs, gen); // Ensure lhs is added to gen on assignment
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          Node next = lhs.getNext();
          if (next != null) {
              computeGenKill(next, gen, kill, conditional);
          }
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
    }
}",0,1
83,Closure_58,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }","private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {

    switch (n.getType()) {
        case Token.SCRIPT:
        case Token.BLOCK:
        case Token.FUNCTION:
            // Do nothing
            break;

        case Token.WHILE:
        case Token.DO:
        case Token.IF:
            computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);
            break;

        case Token.FOR:
            if (!NodeUtil.isForIn(n)) {
                computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);
            } else {
                Node lhs = n.getFirstChild();
                Node rhs = lhs.getNext();
                if (NodeUtil.isVar(lhs)) {
                    lhs = lhs.getLastChild();
                }
                // Process rhs first then lhs
                computeGenKill(rhs, gen, kill, conditional);
                addToSetIfLocal(lhs, kill);
                addToSetIfLocal(lhs, gen);
            }
            break;

        case Token.VAR:
            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
                if (c.hasChildren()) {
                    Node child = c.getFirstChild();
                    computeGenKill(child, gen, kill, conditional);
                    addToSetIfLocal(child, kill);
                }
                addToSetIfLocal(c, gen);
            }
            break;

        case Token.AND:
        case Token.OR:
            computeGenKill(n.getFirstChild(), gen, kill, conditional);
            // May short circuit.
            computeGenKill(n.getLastChild(), gen, kill, true);
            break;

        case Token.HOOK:
            computeGenKill(n.getFirstChild(), gen, kill, conditional);
            // Assume both sides are conditional.
            computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
            computeGenKill(n.getLastChild(), gen, kill, true);
            break;

        case Token.NAME:
            if (isArgumentsName(n)) {
                markAllParametersEscaped();
            } else {
                addToSetIfLocal(n, gen);
            }
            break;

        default:
            if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
                Node lhs = n.getFirstChild();
                if (!conditional) {
                    addToSetIfLocal(lhs, kill);
                }
                if (!NodeUtil.isAssign(n)) {
                    addToSetIfLocal(lhs, gen);
                }
                computeGenKill(lhs.getNext(), gen, kill, conditional);
            } else {
                for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
                    computeGenKill(c, gen, kill, conditional);
                }
            }
            break;
    }
}",0,2
84,Closure_59,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
           CheckLevel.OFF);
     }
 
     if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }","public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(
                new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer =
                new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (options.checkTypes) {
        // If DiagnosticGroups did not override the plain checkTypes
        // option, and checkTypes is enabled, then turn off the
        // parser type warnings.
        options.setWarningLevel(
            DiagnosticGroup.forType(
                RhinoErrorReporter.TYPE_PARSE_ERROR),
            CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(
            DiagnosticGroups.GLOBAL_THIS,
            options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
        options.setWarningLevel(
            DiagnosticGroups.ES5_STRICT,
            CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
            DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
}",0,0
84,Closure_59,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
           CheckLevel.OFF);
     }
 
     if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }","public void initOptions(CompilerOptions options) {
    this.options = options;
    setupErrorManager(options);

    handleDiagnosticGroups(options);

    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);
    }
    
    initializeWarningsGuard(options);
}

private void setupErrorManager(CompilerOptions options) {
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }
}

private void handleDiagnosticGroups(CompilerOptions options) {
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    }

    if (!options.checkTypes && options.enables(ParserWarningGroups.PARSE_ERROR)) {
        options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
    }
}

private void initializeWarningsGuard(CompilerOptions options) {
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
}",0,1
85,Closure_61,"static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }","static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Check if the node is a NAME and set name variable
    String name = null;
    if (nameNode.getType() == Token.NAME) {
      name = nameNode.getString();
    } else if (nameNode.getType() == Token.GETPROP) {
      name = nameNode.getLastChild().getString();
      // If it modifies only 'this' and evaluates to local, then no side effects
      if (callNode.isOnlyModifiesThisCall() &&
          evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
      }
    }

    // Built-in functions with no side effects.
    if (name != null && BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
      return false;
    }

    // Functions in the ""Object"" namespace with no side effects.
    if (nameNode.getType() == Token.GETPROP && callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(name)) {
      return false;
    }

    // Functions in the ""Math"" namespace have no side effects.
    if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
      if (nameNode.getFirstChild().getType() == Token.REGEXP
          && REGEXP_METHODS.contains(name)) {
        return false;
      } else if (nameNode.getFirstChild().getType() == Token.STRING
          && STRING_REGEXP_METHODS.contains(name)) {
        Node param = nameNode.getNext();
        if (param != null && (param.getType() == Token.STRING ||
            param.getType() == Token.REGEXP)) {
          return false;
        }
      }
    }

    return true;
}",0,0
85,Closure_61,"static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }","static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    // Check for no side effects at the node level
    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Function name handling
    if (nameNode != null) {
        String name = (nameNode.getType() == Token.NAME) ? nameNode.getString() : nameNode.getLastChild().getString();

        // Built-in functions and specific property calls with known no side effects
        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
            return false;
        }

        if (nameNode.getType() == Token.GETPROP && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(name)) {
            return false;
        }

        // Process for 'Math' namespace based on compiler settings
        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
            if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(name)) {
                return false;
            }
            // Additional thorough checks for STRING function calls with REGEXP parameter
            Node param = nameNode.getNext();
            if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains(name)) {
                if (param != null && param.getType() == Token.STRING) {
                    return false;
                }
            }
        }
    }

    return true;
}",0,1
85,Closure_61,"static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }","static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    // Immediately check for no side effects property to exit early
    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();
    if (nameNode == null) {
        return true;  // Cannot determine side effects without name node
    }

    String functionName = null;
    boolean isGetProp = false;

    if (nameNode.getType() == Token.NAME) {
      functionName = nameNode.getString();
    } else if (nameNode.getType() == Token.GETPROP) {
      isGetProp = true;
      Node lastChild = nameNode.getLastChild();
      if (lastChild != null) {
          functionName = lastChild.getString();
      }
    }

    // Early return for built-in functions known to have no side effects
    if (functionName != null && BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(functionName)) {
      return false;
    }

    // Handle the special case where we have object methods with no side effects
    if (isGetProp && callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(functionName)) {
      return false;
    }

    // If the call only modifies 'this' and evaluates to a local value, it has no side effects
    if (isGetProp && callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {
      return false;
    }

    // Check functions in the ""Math"" or ""RegExp"" namespace based on global references consideration
    if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
      Node firstChild = nameNode.getFirstChild();
      if (firstChild != null) {
        int firstChildType = firstChild.getType();
        if ((firstChildType == Token.REGEXP && REGEXP_METHODS.contains(functionName)) ||
              (firstChildType == Token.STRING && STRING_REGEXP_METHODS.contains(functionName) && isStringOrRegExpParam(nameNode))) {
            return false;
        }
      }
    }

    return true;
}

private static boolean isStringOrRegExpParam(Node nameNode) {
    Node param = nameNode.getNext();
    return param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP);
}",0,2
86,Closure_62,"private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null :
        excerpt.get(
            source, error.sourceName, error.lineNumber, excerptFormatter);

    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
      b.append(error.sourceName);
      if (error.lineNumber > 0) {
        b.append(':');
        b.append(error.lineNumber);
      }
      b.append("": "");
    }

    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");

    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
      b.append(sourceExcerpt);
      b.append('\n');
      int charno = error.getCharno();

      // padding equal to the excerpt and arrow at the end
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
           && 0 <= charno && charno < sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
            b.append(c);
          } else {
            b.append(' ');
          }
        }
        b.append(""^\n"");
      }
    }
    return b.toString();
  }","private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null :
        excerpt.get(
            source, error.sourceName, error.lineNumber, excerptFormatter);

    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
      b.append(error.sourceName);
      if (error.lineNumber > 0) {
        b.append(':');
        b.append(error.lineNumber);
      }
      b.append("": "");
    }

    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");

    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
      b.append(sourceExcerpt);
      b.append('\n');
      int charno = error.getCharno();

      // padding equal to the excerpt and arrow at the end
      if (excerpt.equals(SourceExcerptProvider.SourceExcerpt.LINE)
          && 0 <= charno && charno < sourceExcerpt.length()) {
        for (int i = 0; i < charno; i++) {
          char c = sourceExcerpt.charAt(i);
          if (Character.isWhitespace(c)) {
            b.append(c);
          } else {
            b.append(' ');
          }
        }
        b.append(""^\n"");
      }
    }
    return b.toString();
}",0,0
86,Closure_62,"private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null :
        excerpt.get(
            source, error.sourceName, error.lineNumber, excerptFormatter);

    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
      b.append(error.sourceName);
      if (error.lineNumber > 0) {
        b.append(':');
        b.append(error.lineNumber);
      }
      b.append("": "");
    }

    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");

    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
      b.append(sourceExcerpt);
      b.append('\n');
      int charno = error.getCharno();

      // padding equal to the excerpt and arrow at the end
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
           && 0 <= charno && charno < sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
            b.append(c);
          } else {
            b.append(' ');
          }
        }
        b.append(""^\n"");
      }
    }
    return b.toString();
  }","private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null :
        excerpt.get(
            source, error.sourceName, error.lineNumber, excerptFormatter);

    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
      b.append(error.sourceName);
      if (error.lineNumber > 0) {
        b.append(':');
        b.append(error.lineNumber);
      }
      b.append("": "");
    }

    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");

    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
      b.append(sourceExcerpt);
      b.append('\n');
      int charno = error.getCharno();

      // Ensure charno is not out of bounds and handle edge cases correctly
      if (charno >= 0 && charno <= sourceExcerpt.length() && excerpt.equals(SourceExcerptProvider.SourceExcerpt.LINE)) {
        for (int i = 0; i < charno; i++) {
          char c = sourceExcerpt.charAt(i);
          if (Character.isWhitespace(c)) {
            b.append(c);
          } else {
            b.append(' ');
          }
        }
        b.append(""^\n"");
      }
    }
    return b.toString();
}",0,1
87,Closure_65,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c < 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case '>':
                // Break --> into --\> or ]]> into ]]\>
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";

                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";

                if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                                  END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                         START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // If we're given an outputCharsetEncoder, then check if the
                // character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // No charsetEncoder provided - pass straight latin characters
                    // through, and escape the rest. Doing the explicit character
                    // check is measurably faster than using the CharsetEncoder.
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,0
87,Closure_65,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c < 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case '>':
                // Break --!> into --\!> or ]]!> into ]]\!>
                if (i >= 3 && ((s.charAt(i - 1) == '!' && s.charAt(i - 2) == '-' && s.charAt(i - 3) == '-'))) {
                    sb.append(""\\>"");
                } else if (i >= 3 && ((s.charAt(i - 1) == '>' && s.charAt(i - 2) == ']' && s.charAt(i - 3) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                // Break <!-- --> into <\!-- -->
                final String START_COMMENT = ""!--"";

                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}

private static void appendHexJavaScriptRepresentation(StringBuilder sb, char c) {
    sb.append(""\\u"");
    sb.append(String.format(""%04x"", (int) c));
}",0,1
88,Closure_66,"public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }","public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent == null || parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
        // Object literal keys are handled with OBJECTLIT
        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
          ensureTyped(t, n, STRING_TYPE);
        }
        break;

      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent != null && parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !(parent != null && NodeUtil.isExpressionNode(parent));
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        if (parent != null) {
          JSType switchType = getJSType(parent.getFirstChild());
          JSType caseType = getJSType(n.getFirstChild());
          validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        }
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) {
          ensureTyped(t, n);
        } else {
          if (n.getType() == Token.OBJECTLIT && parent != null && parent.getJSType() instanceof EnumType) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }",0,0
88,Closure_66,"public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }","public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    boolean typeable = true;

    switch (n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;

        case Token.LP:
            if (parent == null || parent.getType() != Token.FUNCTION) {
                ensureTyped(t, n, getJSType(n.getFirstChild()));
            } else {
                typeable = false;
            }
            break;

        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;

        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;

        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;

        case Token.GET_REF:
            ensureTyped(t, n, getJSType(n.getFirstChild()));
            break;

        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;

        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;

        case Token.STRING:
            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                ensureTyped(t, n, STRING_TYPE);
            }
            break;

        case Token.GETPROP:
            if (parent == null || (parent.getType() != Token.ASSIGN || parent.getFirstChild() != n)) {
                visitGetProp(t, n, parent);
            }
            break;

        case Token.GETELEM:
            visitGetElem(t, n);
            break;

        case Token.VAR:
            visitVar(t, n);
            break;

        case Token.NEW:
            visitNew(t, n);
            break;

        case Token.CALL:
            if (parent == null || !NodeUtil.isExpressionNode(parent)) {
                visitCall(t, n);
            }
            break;

        case Token.RETURN:
            visitReturn(t, n);
            break;

        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;

        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;

        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;

        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;

        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;

        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;

        case Token.EQ:
        case Token.NE: {
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());

            JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
            JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
            TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);
            if (result != TernaryValue.UNKNOWN) {
                if (n.getType() == Token.NE) {
                    result = result.not();
                }
                report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        }

        case Token.SHEQ:
        case Token.SHNE: {
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());

            JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
            JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
            if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        }

        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                validator.expectString(t, n, leftType, ""left side of comparison"");
                validator.expectNotNullOrUndefined(t, n, leftType, ""left side of comparison"", getNativeType(STRING_TYPE));
                validator.expectString(t, n, rightType, ""right side of comparison"");
                validator.expectNotNullOrUndefined(t, n, rightType, ""right side of comparison"", getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;

        case Token.IN:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right);
            validator.expectObject(t, n, rightType, ""'in' requires an object"");
            validator.expectString(t, left, leftType, ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;

        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, leftType, ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;

        case Token.ASSIGN:
            visitAssign(t, n);
            break;

        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;

        case Token.DELPROP:
            if (!isReference(n.getFirstChild())) {
                report(t, n, BAD_DELETE);
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;

        case Token.CASE:
            if (parent != null) {
                JSType switchType = getJSType(parent.getFirstChild());
                JSType caseType = getJSType(n.getFirstChild());
                validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            }
            break;

        case Token.WITH: {
            Node child = n.getFirstChild();
            childType = getJSType(child);
            validator.expectObject(t, child, childType, ""with requires an object"");
            break;
        }

        case Token.FUNCTION:
            visitFunction(t, n);
            break;

        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            break;

        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                ensureTyped(t, n);
            } else if (n.getType() == Token.OBJECTLIT && parent != null && parent.getJSType() instanceof EnumType) {
                ensureTyped(t, n, parent.getJSType());
            } else {
                ensureTyped(t, n);
            }
            if (n.getType() == Token.OBJECTLIT) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;

        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }

    if (typeable && !inExterns) {
        doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
}",0,1
88,Closure_66,"public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }","public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    boolean typeable = true;

    switch (n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;

        case Token.LP:
            if (parent == null || parent.getType() != Token.FUNCTION) {
                ensureTyped(t, n, getJSType(n.getFirstChild()));
            } else {
                typeable = false;
            }
            break;

        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;

        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            typeable = false;
            break;

        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            typeable = false;
            break;

        case Token.GET_REF:
            ensureTyped(t, n, getJSType(n.getFirstChild()));
            typeable = false;
            break;

        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            typeable = false;
            break;

        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            typeable = false;
            break;

        case Token.STRING:
            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                ensureTyped(t, n, STRING_TYPE);
                typeable = false;
            }
            break;

        case Token.GETPROP:
            if (parent == null || (parent.getType() != Token.ASSIGN || parent.getFirstChild() != n)) {
                visitGetProp(t, n, parent);
                typeable = true;
            }
            break;

        case Token.GETELEM:
            visitGetElem(t, n);
            typeable = false;
            break;

        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;

        case Token.NEW:
            visitNew(t, n);
            typeable = true;
            break;

        case Token.CALL:
            if (parent == null || !NodeUtil.isExpressionNode(parent)) {
                visitCall(t, n);
                typeable = true;
            }
            break;

        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;

        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            typeable = false;
            break;

        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            typeable = false;
            break;

        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            typeable = false;
            break;

        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            typeable = false;
            break;

        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            typeable = false;
            break;

        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            typeable = false;
            break;

        case Token.EQ:
        case Token.NE: {
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());

            JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
            JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
            TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);
            if (result != TernaryValue.UNKNOWN) {
                if (n.getType() == Token.NE) {
                    result = result.not();
                }
                report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            typeable = false;
            break;
        }

        case Token.SHEQ:
        case Token.SHNE: {
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());

            JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
            JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
            if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            typeable = false;
            break;
        }

        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                validator.expectString(t, n, leftType, ""left side of comparison"");
                validator.expectNotNullOrUndefined(t, n, leftType, ""left side of comparison"", getNativeType(STRING_TYPE));
                validator.expectString(t, n, rightType, ""right side of comparison"");
                validator.expectNotNullOrUndefined(t, n, rightType, ""right side of comparison"", getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            typeable = false;
            break;

        case Token.IN:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right);
            validator.expectObject(t, n, rightType, ""'in' requires an object"");
            validator.expectString(t, left, leftType, ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            typeable = false;
            break;

        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, leftType, ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            typeable = false;
            break;

        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;

        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            typeable = false;
            break;

        case Token.DELPROP:
            if (!isReference(n.getFirstChild())) {
                report(t, n, BAD_DELETE);
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            typeable = false;
            break;

        case Token.CASE:
            if (parent != null) {
                JSType switchType = getJSType(parent.getFirstChild());
                JSType caseType = getJSType(n.getFirstChild());
                validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            }
            typeable = false;
            break;

        case Token.WITH: {
            Node child = n.getFirstChild();
            childType = getJSType(child);
            validator.expectObject(t, child, childType, ""with requires an object"");
            typeable = false;
            break;
        }

        case Token.FUNCTION:
            visitFunction(t, n);
            break;

        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;

        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                ensureTyped(t, n);
            } else if (n.getType() == Token.OBJECTLIT && parent != null && parent.getJSType() instanceof EnumType) {
                ensureTyped(t, n, parent.getJSType());
            } else {
                ensureTyped(t, n);
            }
            if (n.getType() == Token.OBJECTLIT) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            typeable = false;
            break;

        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }

    if (typeable && !inExterns) {
        doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
}",0,2
89,Closure_67,"private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
           ) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;

        if (isChainedProperty) {
          Node child = n.getFirstChild().getFirstChild().getNext();

          if (child.getType() == Token.STRING &&
              child.getString().equals(""prototype"")) {
            return true;
          }
        }
      }

      return false;
    }",Match failed,0,0
90,Closure_69,"private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
      report(t, n, NOT_CALLABLE, childType.toString());
      ensureTyped(t, n);
      return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
      FunctionType functionType = (FunctionType) childType;

      boolean isExtern = false;
      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
      if(functionJSDocInfo != null) {
        String sourceName = functionJSDocInfo.getSourceName();
        CompilerInput functionSource = compiler.getInput(sourceName);
        isExtern = functionSource.isExtern();
      }

      // Non-native constructors should not be called directly
      // unless they specify a return type and are defined
      // in an extern.
      if (functionType.isConstructor() &&
          !functionType.isNativeObjectType() &&
          (functionType.getReturnType().isUnknownType() ||
           functionType.getReturnType().isVoidType() ||
           !isExtern)) {
        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
      }
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
    } else {
      ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
  }","private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
      report(t, n, NOT_CALLABLE, childType.toString());
      ensureTyped(t, n);
      return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
      FunctionType functionType = (FunctionType) childType;

      boolean isExtern = false;
      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
      if (functionJSDocInfo != null) {
        String sourceName = functionJSDocInfo.getSourceName();
        if (sourceName != null) {
          CompilerInput functionSource = compiler.getInput(sourceName);
          isExtern = functionSource != null && functionSource.isExtern();
        }
      }

      // Non-native constructors should not be called directly
      // unless they specify a return type and are defined
      // in an extern.
      if (functionType.isConstructor() &&
              !functionType.isNativeObjectType() &&
              (functionType.getReturnType().isUnknownType() ||
                      functionType.getReturnType().isVoidType() ||
                      !isExtern)) {
        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
      }

      // Functions with explicit 'this' types must be called in a GETPROP
      // or GETELEM.

      visitParameterList(t, n, functionType);
      ensureTyped(t, n, functionType.getReturnType());
    } else {
      ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
  }",0,0
90,Closure_69,"private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
      report(t, n, NOT_CALLABLE, childType.toString());
      ensureTyped(t, n);
      return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
      FunctionType functionType = (FunctionType) childType;

      boolean isExtern = false;
      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
      if(functionJSDocInfo != null) {
        String sourceName = functionJSDocInfo.getSourceName();
        CompilerInput functionSource = compiler.getInput(sourceName);
        isExtern = functionSource.isExtern();
      }

      // Non-native constructors should not be called directly
      // unless they specify a return type and are defined
      // in an extern.
      if (functionType.isConstructor() &&
          !functionType.isNativeObjectType() &&
          (functionType.getReturnType().isUnknownType() ||
           functionType.getReturnType().isVoidType() ||
           !isExtern)) {
        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
      }
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
    } else {
      ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
  }","private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;

        boolean isExtern = false;
        JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
        if (functionJSDocInfo != null) {
            String sourceName = functionJSDocInfo.getSourceName();
            if (sourceName != null) {
                CompilerInput functionSource = compiler.getInput(sourceName);
                isExtern = functionSource != null && functionSource.isExtern();
            }
        }

        // Non-native constructors should not be called directly
        // unless they specify a return type and are defined
        // in an extern.
        if (functionType.isConstructor() &&
                !functionType.isNativeObjectType() &&
                (functionType.getReturnType().isUnknownType() ||
                        functionType.getReturnType().isVoidType()) ||
                !isExtern) {
            report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
        }

        // Functions with explicit 'this' types must be called in a GETPROP
        // or GETELEM.
        if (functionType.getTypeOfThis() != null &&
                !n.isGetProp() && !n.isGetElem()) {
            report(t, n, FUNCTION_THIS_TYPE_MISMATCH, childType.toString());
        }

        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE. Either say something about the return type or warn
    // about the non-portability of the call or both.
}",0,1
91,Closure_7,"@Override
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }","@Override
public JSType caseObjectType(ObjectType type) {
    if (value.equals(""function"")) {
        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        return resultEqualsValue ? ctorType : null;
    }
    return matchesExpectation(""object"") ? type : null;
}",0,0
91,Closure_7,"@Override
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }","@Override
public JSType caseObjectType(ObjectType type) {
    if (value.equals(""function"")) {
        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        if (ctorType.isSubtype(type) || ctorType.equals(type)) {
            return resultEqualsValue ? ctorType : null;
        }
        return null;
    }
    return matchesExpectation(""object"") && !type.isUnknownType() ? type : null;
}",0,1
91,Closure_7,"@Override
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }","@Override
public JSType caseObjectType(ObjectType type) {
    if (value.equals(""function"")) {
        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        if (ctorType.isSubtype(getNativeType(FUNCTION_TYPE)) && resultEqualsValue) {
            // Allow subtypes of ""Function"" and check resultEqualsValue for ""function"" cases
            return ctorType;
        }
        return null;
    }
    if (matchesExpectation(""object"")) {
        // Ensure the type is not unknown which can cause type mismatch
        return !type.isUnknownType() ? type : null;
    }
    // Handle broader cases by allowing primitives like boolean, number, and string
    if (matchesExpectation(""boolean"") || matchesExpectation(""number"") || matchesExpectation(""string"")) {
        return getNativeType(getPrimitiveTypeName(value));
    }
    return null;
}

// Helper Method to support Fixed Method 1
private String getPrimitiveTypeName(String value) {
    switch (value) {
        case ""boolean"":
            return BOOLEAN_TYPE;
        case ""number"":
            return NUMBER_TYPE;
        case ""string"":
            return STRING_TYPE;
        default:
            return value;
    }
}",0,2
92,Closure_70,"private void declareArguments(Node functionNode) {
      Node astParameters = functionNode.getFirstChild().getNext();
      Node body = astParameters.getNext();
      FunctionType functionType = (FunctionType) functionNode.getJSType();
      if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
          Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                   jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
            }
          }
        }
      }
    } // end declareArguments","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Node jsDocParameter = jsDocParameters.getFirstChild();
            for (Node astParameter : astParameters.children()) {
                if (jsDocParameter != null) {
                    defineSlot(astParameter, functionNode, 
                               jsDocParameter.getJSType(), true);
                    jsDocParameter = jsDocParameter.getNext();
                } else {
                    defineSlot(astParameter, functionNode, null, true);
                }
            }
        }
    }
}",0,0
92,Closure_70,"private void declareArguments(Node functionNode) {
      Node astParameters = functionNode.getFirstChild().getNext();
      Node body = astParameters.getNext();
      FunctionType functionType = (FunctionType) functionNode.getJSType();
      if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
          Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                   jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
            }
          }
        }
      }
    } // end declareArguments","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Iterator<Node> jsDocParameterIterator = jsDocParameters.children().iterator();
            for (Node astParameter : astParameters.children()) {
                JSType jsDocParameterType = jsDocParameterIterator.hasNext() ? jsDocParameterIterator.next().getJSType() : null;
                defineSlot(astParameter, functionNode, jsDocParameterType, true);
            }
        } else {
            for (Node astParameter : astParameters.children()) {
                defineSlot(astParameter, functionNode, null, true);
            }
        }
    }
}",0,1
92,Closure_70,"private void declareArguments(Node functionNode) {
      Node astParameters = functionNode.getFirstChild().getNext();
      Node body = astParameters.getNext();
      FunctionType functionType = (FunctionType) functionNode.getJSType();
      if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
          Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                   jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
            }
          }
        }
      }
    } // end declareArguments","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    boolean hasValidJSType = (functionType != null);
    
    Map<String, JSType> paramTypeMap = new HashMap<>();
    if (hasValidJSType) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            for (Node jsDocParameter : jsDocParameters.children()) {
                paramTypeMap.put(jsDocParameter.getString(), jsDocParameter.getJSType());
            }
        }
    }
    
    for (Node astParameter : astParameters.children()) {
        JSType paramType = hasValidJSType ? paramTypeMap.get(astParameter.getString()) : null;
        defineSlot(astParameter, functionNode, paramType, true);
    }
}",0,2
93,Closure_71,"private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
       boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
      // Find the lowest property defined on a class with visibility
      // information.
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      for (; objectType != null;
           objectType = objectType.getImplicitPrototype()) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
      }

      if (objectType == null) {
        // We couldn't find a visibility modifier; assume it's public.
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);
      if (isOverride) {
        // Check an ASSIGN statement that's trying to override a property
        // on a superclass.
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check that (a) the property *can* be overridden, and
        // (b) that the visibility of the override is the same as the
        // visibility of the original property.
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          // private access is always allowed in the same file.
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          // private access is not allowed outside the file from a different
          // enclosing class.
          compiler.report(
              t.makeError(getprop,
                  BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          // There are 3 types of legal accesses of a protected property:
          // 1) Accesses in the same file
          // 2) Overriding the property in a subclass
          // 3) Accessing the property from inside a subclass
          // The first two have already been checked for.
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
  }","private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

    if (objectType != null) {
        // Is this a normal property access, or are we trying to override
        // an existing property?
        boolean isOverride = t.inGlobalScope() &&
            parent.getType() == Token.ASSIGN &&
            parent.getFirstChild() == getprop;

        // Find the lowest property defined on a class with visibility
        // information.
        if (isOverride) {
            objectType = objectType.getImplicitPrototype();
        }
        JSDocInfo docInfo = null;
        while (objectType != null) {
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null &&
                docInfo.getVisibility() != Visibility.INHERITED) {
                break;
            }
            objectType = objectType.getImplicitPrototype();
        }

        if (docInfo == null) {
            // We couldn't find a visibility modifier; assume it's public.
            return;
        }

        boolean sameInput =
            t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(objectType);
        if (isOverride) {
            // Check an ASSIGN statement that's trying to override a property
            // on a superclass.
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ?
                Visibility.INHERITED : overridingInfo.getVisibility();

            // Check that (a) the property *can* be overridden, and
            // (b) that the visibility of the override is the same as the
            // visibility of the original property.
            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(
                    t.makeError(getprop, PRIVATE_OVERRIDE,
                        objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED &&
                overridingVisibility != visibility) {
                compiler.report(
                    t.makeError(getprop, VISIBILITY_MISMATCH,
                        visibility.name(), objectType.toString(),
                        overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                // private access is always allowed in the same file.
                return;
            } else if (visibility == Visibility.PRIVATE &&
                (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() &&
                    isValidPrivateConstructorAccess(parent)) {
                    return;
                }

                // private access is not allowed outside the file from a different
                // enclosing class.
                compiler.report(
                    t.makeError(getprop,
                        BAD_PRIVATE_PROPERTY_ACCESS,
                        propertyName,
                        validator.getReadableJSTypeName(
                            getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED) {
                // There are 3 types of legal accesses of a protected property:
                // 1) Accesses in the same file
                // 2) Overriding the property in a subclass
                // 3) Accessing the property from inside a subclass
                // The first two have already been checked for.
                if (currentClass == null || !currentClass.isSubtype(ownerType)) {
                    compiler.report(
                        t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,
                            propertyName,
                            validator.getReadableJSTypeName(
                                getprop.getFirstChild(), true)));
                }
            }
        }
    }
}",0,0
93,Closure_71,"private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
       boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
      // Find the lowest property defined on a class with visibility
      // information.
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      for (; objectType != null;
           objectType = objectType.getImplicitPrototype()) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
      }

      if (objectType == null) {
        // We couldn't find a visibility modifier; assume it's public.
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);
      if (isOverride) {
        // Check an ASSIGN statement that's trying to override a property
        // on a superclass.
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check that (a) the property *can* be overridden, and
        // (b) that the visibility of the override is the same as the
        // visibility of the original property.
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          // private access is always allowed in the same file.
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          // private access is not allowed outside the file from a different
          // enclosing class.
          compiler.report(
              t.makeError(getprop,
                  BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          // There are 3 types of legal accesses of a protected property:
          // 1) Accesses in the same file
          // 2) Overriding the property in a subclass
          // 3) Accessing the property from inside a subclass
          // The first two have already been checked for.
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
  }","private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {
    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

    if (objectType != null) {
        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;
        JSDocInfo docInfo = null;

        while (objectType != null) {
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {
                objectType = docInfo.getVisibility() == Visibility.PRIVATE ? null : objectType.getImplicitPrototype();
                break;
            }
            objectType = objectType.getImplicitPrototype();
        }

        if (docInfo == null || objectType == null) {
            return;
        }

        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(ObjectType.cast(objectType));

        if (isOverride) {
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();

            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {
                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                return;
            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {
                    return;
                }
                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED) {
                if (currentClass == null || !currentClass.isSubtype(ownerType)) {
                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
                }
            }
        }
    }
}",0,1
93,Closure_71,"private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
       boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
      // Find the lowest property defined on a class with visibility
      // information.
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      for (; objectType != null;
           objectType = objectType.getImplicitPrototype()) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
      }

      if (objectType == null) {
        // We couldn't find a visibility modifier; assume it's public.
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);
      if (isOverride) {
        // Check an ASSIGN statement that's trying to override a property
        // on a superclass.
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check that (a) the property *can* be overridden, and
        // (b) that the visibility of the override is the same as the
        // visibility of the original property.
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          // private access is always allowed in the same file.
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          // private access is not allowed outside the file from a different
          // enclosing class.
          compiler.report(
              t.makeError(getprop,
                  BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          // There are 3 types of legal accesses of a protected property:
          // 1) Accesses in the same file
          // 2) Overriding the property in a subclass
          // 3) Accessing the property from inside a subclass
          // The first two have already been checked for.
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
  }","private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {
    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

    if (objectType != null) {
        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;
        JSDocInfo docInfo = null;

        // Updated logic: Traverse prototype chain up to find non-inherited visibility
        while (objectType != null) {
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null) {
                Visibility visibility = docInfo.getVisibility();
                if (visibility != Visibility.INHERITED) {
                    if (visibility == Visibility.PRIVATE && !isOverride) {
                        objectType = (ObjectType) objectType.getImplicitPrototype();
                        continue;
                    }
                    break;
                }
            }
            objectType = (ObjectType) objectType.getImplicitPrototype();
        }

        if (docInfo == null || objectType == null) {
            return;
        }

        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(ObjectType.cast(objectType));

        if (isOverride) {
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();

            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {
                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                return;
            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {
                    return;
                }
                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED) {
                if (currentClass == null || !currentClass.isSubtype(ownerType)) {
                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
                }
            }
        }
    }
}",0,2
94,Closure_73,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      switch (c) {
        case '\0': sb.append(""\\0""); break;
        case '\n': sb.append(""\\n""); break;
        case '\r': sb.append(""\\r""); break;
        case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
             if (c > 0x1f && c <= 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      switch (c) {
        case '\0': sb.append(""\\0""); break;
        case '\n': sb.append(""\\n""); break;
        case '\r': sb.append(""\\r""); break;
        case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
            i += END_SCRIPT.length();
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
            i += START_COMMENT.length();
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
             if (c > 0x1f && c <= 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }",0,0
94,Closure_73,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      switch (c) {
        case '\0': sb.append(""\\0""); break;
        case '\n': sb.append(""\\n""); break;
        case '\r': sb.append(""\\r""); break;
        case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
             if (c > 0x1f && c <= 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                        String doublequoteEscape,
                        String singlequoteEscape,
                        String backslashEscape,
                        CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case '>':
                // Break --> into --\> or ]]> into ]]\>
                if (i >= 2 && (s.startsWith(""--"", i - 2) || s.startsWith(""]]"", i - 2))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";

                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                    i += END_SCRIPT.length();
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                    i += START_COMMENT.length();
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    if (c > 0x1f && c <= 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,1
94,Closure_73,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      switch (c) {
        case '\0': sb.append(""\\0""); break;
        case '\n': sb.append(""\\n""); break;
        case '\r': sb.append(""\\r""); break;
        case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
             if (c > 0x1f && c <= 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                        String doublequoteEscape,
                        String singlequoteEscape,
                        String backslashEscape,
                        CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case '>':
                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";
                if (i + 1 + END_SCRIPT.length() <= s.length() && s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                    i += END_SCRIPT.length();
                } else if (i + 1 + START_COMMENT.length() <= s.length() && s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                    i += START_COMMENT.length();
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    if (c > 0x1f && c <= 0x7f) {
                        sb.append(c);
                    } else if (c > 0x7f || c < 0x20) {
                        appendHexJavaScriptRepresentation(sb, c);
                    } else {
                        sb.append(""\\u"" + String.format(""%04x"", (int) c));
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,2
95,Closure_77,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c <= 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>': // Break --> into --\> or ]]> into ]]\>
                if (i >= 2 && 
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || 
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<': 
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";

                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // If we're given an outputCharsetEncoder, then check if the
                //  character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // No charsetEncoder provided - pass straight latin characters
                    // through, and escape the rest.  Doing the explicit character
                    // check is measurably faster than using the CharsetEncoder.
                    if (c >= 0x20 && c <= 0x7f) { // Fixed condition to allow Unicode escape for control characters
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,0
95,Closure_77,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c <= 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);

    final Pattern END_SCRIPT_PATTERN = Pattern.compile(""(?i)</script.*"");
    final Pattern START_COMMENT_PATTERN = Pattern.compile(""<!--.*"");

    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>': 
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<': 
                String substring = s.substring(i);
                if (END_SCRIPT_PATTERN.matcher(substring).matches()) {
                    sb.append(""<\\"");
                } else if (START_COMMENT_PATTERN.matcher(substring).matches()) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    if (c >= 0x20 && c <= 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,1
96,Closure_78,"private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
         break;
       case Token.MOD:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // TODO(johnlenz): consider removing the result length check.
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }","private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted to Number.
    if (opType == Token.ADD
            && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
        return null;
    }

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
        return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
        return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    double result;
    switch (opType) {
        case Token.BITAND:
            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
            break;
        case Token.BITOR:
            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
            break;
        case Token.BITXOR:
            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
            break;
        case Token.ADD:
            result = lval + rval;
            break;
        case Token.SUB:
            result = lval - rval;
            break;
        case Token.MUL:
            result = lval * rval;
            break;
        case Token.MOD:
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval % rval;
            break;
        case Token.DIV:
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval / rval;
            break;
        default:
            throw new Error(""Unexpected arithmetic operator"");
    }

    if (Double.isNaN(result)) {
        return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
        return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
        return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    // Only fold arithmetic when the result length would not exceed the operand lengths plus operator
    // and the Math.abs result is lower than MAX_FOLD_NUMBER
    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1
            && Math.abs(result) <= MAX_FOLD_NUMBER) {
        Node newNumber = Node.newNumber(result);
        return newNumber;
    }

    return null;
}",0,0
96,Closure_78,"private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
         break;
       case Token.MOD:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // TODO(johnlenz): consider removing the result length check.
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }","private Node performArithmeticOp(int opType, Node left, Node right) {
    // Handle ADD operation with possible string operands.
    if (opType == Token.ADD
            && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
        return null;
    }

    Double lValObj = NodeUtil.getNumberValue(left);
    Double rValObj = NodeUtil.getNumberValue(right);

    // Ensure operands are valid numbers.
    if (lValObj == null || rValObj == null) {
        return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    // Compute result based on operation type.
    double result;
    switch (opType) {
        case Token.BITAND:
            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
            break;
        case Token.BITOR:
            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
            break;
        case Token.BITXOR:
            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
            break;
        case Token.ADD:
            result = lval + rval;
            break;
        case Token.SUB:
            result = lval - rval;
            break;
        case Token.MUL:
            result = lval * rval;
            break;
        case Token.MOD:
            // Handle divide by zero for modulo.
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval % rval;
            break;
        case Token.DIV:
            // Handle divide by zero for division.
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval / rval;
            break;
        default:
            throw new Error(""Unexpected arithmetic operator"");
    }

    // Handle special number cases.
    if (Double.isNaN(result)) {
        return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
        return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
        return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    // Fold arithmetic results with enhanced criteria.
    boolean isFoldable = String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1
            && Math.abs(result) <= MAX_FOLD_NUMBER
            && !(result > MAX_FOLD_NUMBER || result < -MAX_FOLD_NUMBER);

    if (isFoldable) {
        return Node.newNumber(result);
    }

    return null;
}",0,1
96,Closure_78,"private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
         break;
       case Token.MOD:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // TODO(johnlenz): consider removing the result length check.
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }","private Node performArithmeticOp(int opType, Node left, Node right) {
    // Handle ADD operation with possible string operands.
    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {
        return null;
    }

    Double lValObj = NodeUtil.getNumberValue(left);
    Double rValObj = NodeUtil.getNumberValue(right);

    // Ensure operands are valid numbers.
    if (lValObj == null || rValObj == null) {
        return null;
    }

    double lval = lValObj.doubleValue();
    double rval = rValObj.doubleValue();

    // Special case: Return early for divide and modulo by zero.
    switch (opType) {
        case Token.MOD:
        case Token.DIV:
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return Node.newNumber(Double.NaN); // More descriptive return for invalid cases
            }
            break;
    }

    double result;
    switch (opType) {
        case Token.BITAND:
            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
            break;
        case Token.BITOR:
            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
            break;
        case Token.BITXOR:
            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
            break;
        case Token.ADD:
            result = lval + rval;
            break;
        case Token.SUB:
            result = lval - rval;
            break;
        case Token.MUL:
            result = lval * rval;
            break;
        case Token.MOD:
            result = lval % rval;
            break;
        case Token.DIV:
            result = lval / rval;
            break;
        default:
            throw new Error(""Unexpected arithmetic operator: "" + opType);
    }

    // Handle special number cases.
    if (Double.isNaN(result)) {
        return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
        return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
        return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    // Fold result only if it meets all foldable conditions.
    boolean foldCondition = String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1
            && Math.abs(result) <= MAX_FOLD_NUMBER;
    if (foldCondition) {
        return Node.newNumber(result);
    }

    return null;
}",0,2
97,Closure_81,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.LP);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
      node.addChildToBack(lp);

      Node bodyNode = transform(functionNode.getBody());
      parseDirectives(bodyNode);
      node.addChildToBack(bodyNode);
     return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    boolean isUnnamedFunction = false;
    if (name == null) {
        name = new Name();
        name.setIdentifier("""");
        isUnnamedFunction = true;
    }
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
    }

    node.addChildToBack(newName);
    Node lp = newNode(Token.LP);
    // The left paren's complicated because it's not represented by an
    // AstNode, so there's nothing that has the actual line number that it
    // appeared on. We know the paren has to appear on the same line as the
    // function name (or else a semicolon will be inserted.) If there's no
    // function name, assume the paren was on the same line as the function.
    // TODO(bowdidge): Mark line number of paren correctly.
    Name fnName = functionNode.getFunctionName();
    if (fnName != null) {
        lp.setLineno(fnName.getLineno());
    } else {
        lp.setLineno(functionNode.getLineno());
    }
    int lparenCharno = functionNode.getLp() +
        functionNode.getAbsolutePosition();

    lp.setCharno(position2charno(lparenCharno));
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);

    Node bodyNode = transform(functionNode.getBody());
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);
    return node;
}",0,0
97,Closure_81,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.LP);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
      node.addChildToBack(lp);

      Node bodyNode = transform(functionNode.getBody());
      parseDirectives(bodyNode);
      node.addChildToBack(bodyNode);
     return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    boolean isUnnamedFunction = (name == null || name.getIdentifier().isEmpty());
    if (isUnnamedFunction) {
        name = new Name();
        name.setIdentifier("""");
    }

    // Create and set up the FUNCTION node
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    if (isUnnamedFunction) {
        newName.setLineno(functionNode.getLineno());
        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
    }
    node.addChildToBack(newName);

    // Handle left parentheses for parameters
    Node lp = newNode(Token.LP);
    lp.setLineno(functionNode.getFunctionName() != null ? 
                 functionNode.getFunctionName().getLineno() : functionNode.getLineno());

    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));

    // Process parameters and add them to the LP node
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);

    // Handle function body
    Node bodyNode = transform(functionNode.getBody());
    parseDirectives(bodyNode);
    // Ensure body node gets proper charno and lineno alignment
    bodyNode.setLineno(functionNode.getBody() != null ? functionNode.getBody().getLineno() : functionNode.getLineno());
    bodyNode.setCharno(position2charno(functionNode.getAbsolutePosition()));
    node.addChildToBack(bodyNode);

    return node;
}",0,1
97,Closure_81,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.LP);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
      node.addChildToBack(lp);

      Node bodyNode = transform(functionNode.getBody());
      parseDirectives(bodyNode);
      node.addChildToBack(bodyNode);
     return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
    // Retrieve or create the function name
    Name name = functionNode.getFunctionName();
    boolean isUnnamedFunction = (name == null);
    if (isUnnamedFunction) {
        name = new Name();
        name.setIdentifier("""");
    }

    // Create and setup the FUNCTION node
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);

    if (isUnnamedFunction) {
        newName.setLineno(functionNode.getLineno());
        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
    }

    node.addChildToBack(newName);

    // Handle left parentheses and parameter nodes
    Node lp = newNode(Token.LP);
    int lpLineno = (functionNode.getFunctionName() != null) 
                    ? functionNode.getFunctionName().getLineno() 
                    : functionNode.getLineno();
    lp.setLineno(lpLineno);

    int lparenCharno = functionNode.getAbsolutePosition() + functionNode.getLp();
    lp.setCharno(position2charno(lparenCharno));

    // Add transformed parameters to the LP node
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }

    node.addChildToBack(lp);

    // Transform and process the function body
    Node bodyNode = transform(functionNode.getBody());
    if (functionNode.getBody() != null) {
        bodyNode.setLineno(functionNode.getBody().getLineno());
        bodyNode.setCharno(position2charno(functionNode.getBody().getAbsolutePosition()));
    } else {
        bodyNode.setLineno(functionNode.getLineno());
        bodyNode.setCharno(position2charno(functionNode.getAbsolutePosition()));
    }

    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);

    return node;
}",0,2
98,Closure_82,"  public boolean isNoObjectType() {
    return false;
  }
",Match failed,0,0
99,Closure_83,"      public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
      }
","public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
        if (setter == null) {
            throw new IllegalArgumentException(""Setter cannot be null"");
        }
      }",0,0
99,Closure_83,"      public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
      }
","public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
        if (parser == null) {
            throw new IllegalArgumentException(""Parser cannot be null"");
        }
        if (option == null) {
            throw new IllegalArgumentException(""Option cannot be null"");
        }
        if (setter == null) {
            throw new IllegalArgumentException(""Setter cannot be null"");
        }
    }",0,1
99,Closure_83,"      public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
      }
","public BooleanOptionHandler(
        CmdLineParser parser, OptionDef option,
        Setter<? super Boolean> setter) {
    super(parser, option, setter);

    if (parser == null) {
        throw new IllegalArgumentException(""Parser cannot be null"");
    }
    if (option == null || option.name() == null || option.name().isEmpty()) {
        throw new IllegalArgumentException(""Option name cannot be null or empty"");
    }
    if (setter == null) {
        throw new IllegalArgumentException(""Setter cannot be null"");
    }

    if (!(setter.getType() == Boolean.class || setter.getType() == boolean.class)) {
        throw new IllegalArgumentException(""Setter must handle Boolean or boolean types"");
    }
}",0,2
100,Closure_86,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        // Literals objects with non-literal children are allowed.
        return true;
      case Token.IN:
        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
        return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    if (value == null || locals == null) {
        throw new IllegalArgumentException(""Node value and locals must not be null"");
    }

    switch (value.getType()) {
        case Token.ASSIGN:
            return NodeUtil.isImmutableValue(value.getLastChild())
                || (locals.apply(value.getFirstChild())
                    && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals)
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            return value.getBooleanProp(Node.INCRDECR_PROP)
                ? evaluatesToLocalValue(value.getFirstChild(), locals)
                : true;
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return NodeUtil.isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
            return false; // No reliable locality information for properties
        case Token.CALL:
            return NodeUtil.callHasLocalResult(value)
                || NodeUtil.isToStringMethodCall(value)
                || locals.apply(value);
        case Token.NEW:
            return NodeUtil.callHasLocalResult(value); // Adjusted based on actual implementation
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return true;
        case Token.IN:
            return true; // IN operator treated as consistent with local value
        default:
            if (NodeUtil.isAssignmentOp(value)
                || NodeUtil.isSimpleOperator(value)
                || NodeUtil.isImmutableValue(value)) {
                return true;
            }

            throw new IllegalStateException(
                ""Unexpected expression node: "" + value +
                ""\n parent: "" + value.getParent());
    }
}",0,0
100,Closure_86,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        // Literals objects with non-literal children are allowed.
        return true;
      case Token.IN:
        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
        return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    if (value == null || locals == null) {
        throw new IllegalArgumentException(""Node value and locals must not be null"");
    }

    switch (value.getType()) {
        case Token.ASSIGN:
            return NodeUtil.isImmutableValue(value.getLastChild())
                && evaluatesToLocalValue(value.getFirstChild(), locals)
                || evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals)
                || evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return (evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
                && evaluatesToLocalValue(value.getLastChild(), locals))
                || evaluatesToLocalValue(value.getFirstChild(), locals);
        case Token.INC:
        case Token.DEC:
            return value.getBooleanProp(Node.INCRDECR_PROP)
                ? evaluatesToLocalValue(value.getFirstChild(), locals)
                : NodeUtil.isImmutableValue(value.getFirstChild());
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return NodeUtil.isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
            return false; // Adjusted logic for properties
        case Token.CALL:
            return callHasLocalResult(value)
                && NodeUtil.isToStringMethodCall(value)
                || locals.apply(value);
        case Token.NEW:
            return false; // Fixed logic to avoid optimistic assumption
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return NodeUtil.isImmutableValue(value); // Added stricter local check
        case Token.IN:
            return NodeUtil.isSimpleOperator(value); // Narrowed operator logic
        default:
            if (NodeUtil.isAssignmentOp(value)
                || NodeUtil.isSimpleOperator(value)
                || NodeUtil.isImmutableValue(value)) {
                return true;
            }

            return false; // Adjusted logic for unexpected nodes
    }
}",0,1
100,Closure_86,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        // Literals objects with non-literal children are allowed.
        return true;
      case Token.IN:
        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
        return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    if (value == null || locals == null) {
        throw new IllegalArgumentException(""Node value and locals must not be null"");
    }

    switch (value.getType()) {
        case Token.ASSIGN:
            // Check both the assigned value and the left-hand side for locality
            return evaluatesToLocalValue(value.getLastChild(), locals)
                && (NodeUtil.isImmutableValue(value.getLastChild()) || locals.apply(value.getFirstChild()));
        case Token.COMMA:
            // Only the last child matters for locality in comma expressions
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            // Both sides must have local values for the result to be local
            return evaluatesToLocalValue(value.getFirstChild(), locals) 
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            // All branches must have local values for the result to be local
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) 
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            // Only track pre- or post-increment/decrement locality
            return value.getBooleanProp(Node.INCRDECR_PROP) 
                && evaluatesToLocalValue(value.getFirstChild(), locals);
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return NodeUtil.isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
            // We assume properties cannot reliably determine locality
            return false;
        case Token.CALL:
            // Combine multiple checks for calls with local results
            return NodeUtil.callHasLocalResult(value) 
                || NodeUtil.isToStringMethodCall(value);
        case Token.NEW:
            // Only constructors with guaranteed locality should pass
            return NodeUtil.constructorHasLocalResult(value);
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            // Literal creations are inherently local
            return true;
        case Token.IN:
            // Special case for the 'in' operator
            return evaluatesToLocalValue(value.getFirstChild(), locals);
        default:
            // Check if the value is a simple operator or immutable
            return NodeUtil.isAssignmentOp(value)
                || NodeUtil.isSimpleOperator(value)
                || NodeUtil.isImmutableValue(value);
    }
}",0,2
101,Closure_87,"private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
 
           return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
    return false;
  }","private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK) {
        if (n.hasOneChild()) {
            Node maybeExpr = n.getFirstChild();
            // IE has a bug where event handlers behave differently when
            // their return value is used vs. when their return value is in
            // an EXPR_RESULT. It's pretty freaking weird. See:
            // http://code.google.com/p/closure-compiler/issues/detail?id=291
            // We try to detect this case, and not fold EXPR_RESULTs
            // into other expressions.
    
            // We only have to worry about methods with an implicit 'this'
            // param, or this doesn't happen.
    
            if (maybeExpr.getType() == Token.EXPR_RESULT) {
                return false;
            }
    
            return NodeUtil.isExpressionNode(maybeExpr);
        }
    }
 
    return false;
}",0,0
101,Closure_87,"private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
 
           return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
    return false;
  }","private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK && n.hasOneChild()) {
        Node maybeExpr = n.getFirstChild();
        if (maybeExpr.getType() == Token.EXPR_RESULT && !NodeUtil.mayHaveSideEffects(maybeExpr)) {
            return false; // Don't fold if it is an EXPR_RESULT with side effects.
        }
        return NodeUtil.isExpressionNode(maybeExpr) && !NodeUtil.isPlaceHolder(maybeExpr);
    }
    return false;
}",0,1
102,Closure_88,"private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
      }
    }

    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild();
        child != null; child = child.getNext()) {
      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
        VariableLiveness state = isVariableReadBeforeKill(child, variable);
        if (state != VariableLiveness.MAYBE_LIVE) {
          return state;
        }
      }
    }
    return VariableLiveness.MAYBE_LIVE;
  }","private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {
    if (n == null || variable == null) {
        return VariableLiveness.MAYBE_LIVE;
    }
    
    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        Node parent = n.getParent();
        if (parent != null && NodeUtil.isLhs(n, parent)) {
            // The expression to which the assignment is made is evaluated before
            // the RHS is evaluated (normal left to right evaluation) but the KILL
            // occurs after the RHS is evaluated.
            return VariableLiveness.KILL;
        } else {
            return VariableLiveness.READ;
        }
    }

    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
            VariableLiveness state = isVariableReadBeforeKill(child, variable);
            if (state != VariableLiveness.MAYBE_LIVE) {
                return state;
            }
        }
    }
    return VariableLiveness.MAYBE_LIVE;
}",0,0
102,Closure_88,"private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
      }
    }

    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild();
        child != null; child = child.getNext()) {
      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
        VariableLiveness state = isVariableReadBeforeKill(child, variable);
        if (state != VariableLiveness.MAYBE_LIVE) {
          return state;
        }
      }
    }
    return VariableLiveness.MAYBE_LIVE;
  }","private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {
    if (n == null || variable == null) {
        return VariableLiveness.MAYBE_LIVE;
    }

    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        Node parent = n.getParent();
        if (parent != null && NodeUtil.isLhs(n, parent)) {
            // The variable is killed after evaluation of the RHS.
            return VariableLiveness.KILL;
        } else {
            // The variable is read before any potential kill.
            return VariableLiveness.READ;
        }
    }

    // Evaluate expressions left-to-right, depth-first.
    boolean hasRead = false;
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION node
            VariableLiveness state = isVariableReadBeforeKill(child, variable);
            if (state == VariableLiveness.READ) {
                hasRead = true; // Track any read state encountered
            } else if (state == VariableLiveness.KILL && !hasRead) {
                return VariableLiveness.KILL; // Return KILL only if no READ found yet
            }
        }
    }
    return hasRead ? VariableLiveness.READ : VariableLiveness.MAYBE_LIVE;
}",0,1
102,Closure_88,"private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
      }
    }

    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild();
        child != null; child = child.getNext()) {
      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
        VariableLiveness state = isVariableReadBeforeKill(child, variable);
        if (state != VariableLiveness.MAYBE_LIVE) {
          return state;
        }
      }
    }
    return VariableLiveness.MAYBE_LIVE;
  }",Match failed,0,2
103,Closure_91,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||

            // object literal keys
            pType == Token.STRING ||
            pType == Token.NUMBER)) {
        return false;
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.isInterface() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
            return false;
        }

        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {}; // or
        // var a = {x: function() {}};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.NAME ||
              pType == Token.ASSIGN ||

              // object literal keys
              pType == Token.STRING ||
              pType == Token.NUMBER)) {
            return false;
        }

        // Don't traverse functions that are getting lent to a prototype.
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            // Always traverse the left side of the assignment. To handle
            // nested assignments properly (e.g., (a = this).property = c;),
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // Only traverse the right side if it's not an assignment to a prototype
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP &&
                    lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP &&
                    llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }

    return true;
}",0,0
103,Closure_91,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||

            // object literal keys
            pType == Token.STRING ||
            pType == Token.NUMBER)) {
        return false;
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.isInterface() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
            return false;
        }

        int pType = parent.getType();
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.NAME ||
              pType == Token.ASSIGN ||
              pType == Token.EXPR_RESULT)) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && 
                    ""prototype"".equals(lhs.getLastChild().getString())) {
                    return false;
                }
                Node base = lhs.getFirstChild();
                if (base.getType() == Token.GETPROP && 
                    ""prototype"".equals(base.getLastChild().getString())) {
                    return false;
                }
            }
        }
    }

    return true;
}",0,1
103,Closure_91,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||

            // object literal keys
            pType == Token.STRING ||
            pType == Token.NUMBER)) {
        return false;
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.isInterface() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
            return false;
        }

        int pType = (parent != null) ? parent.getType() : Token.SCRIPT;
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.NAME ||
              pType == Token.ASSIGN ||
              pType == Token.EXPR_RESULT)) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            assignLhsChild = lhs;
        } else {
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && 
                    ""prototype"".equals(lhs.getLastChild().getString())) {
                    return false;
                }
                Node base = lhs.getFirstChild();
                if (base.getType() == Token.GETPROP && 
                    ""prototype"".equals(base.getLastChild().getString())) {
                    return false;
                }
            }
        }
    }

    return true;
}",0,2
104,Closure_92,"void replace() {
      if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
      }

      // Handle the case where there is a duplicate definition for an explicitly
      // provided symbol.
      if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
          Node assignNode = candidateDefinition.getFirstChild();
          Node nameNode = assignNode.getFirstChild();
          if (nameNode.getType() == Token.NAME) {
            // Need to convert this assign to a var declaration.
            Node valueNode = nameNode.getNext();
            assignNode.removeChild(nameNode);
            assignNode.removeChild(valueNode);
            nameNode.addChildToFront(valueNode);
            Node varNode = new Node(Token.VAR, nameNode);
            varNode.copyInformationFrom(candidateDefinition);
            candidateDefinition.getParent().replaceChild(
                candidateDefinition, varNode);
            nameNode.setJSDocInfo(assignNode.getJSDocInfo());
            compiler.reportCodeChange();
            replacementNode = varNode;
          }
        }
      } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
          firstNode.getParent().addChildBefore(replacementNode, firstNode);
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
           int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
                .addChildToBack(replacementNode);
          } else {
            // Add it after the parent namespace.
            ProvidedName parentName =
                providedNames.get(namespace.substring(0, indexOfDot));
            Preconditions.checkNotNull(parentName);
            Preconditions.checkNotNull(parentName.replacementNode);
            parentName.replacementNode.getParent().addChildAfter(
                replacementNode, parentName.replacementNode);
          }
        }
        if (explicitNode != null) {
          explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
      }
    }","void replace() {
    if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
    }

    // Handle the case where there is a duplicate definition for an explicitly
    // provided symbol.
    if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
            Node assignNode = candidateDefinition.getFirstChild();
            Node nameNode = assignNode.getFirstChild();
            if (nameNode.getType() == Token.NAME) {
                // Need to convert this assign to a var declaration.
                Node valueNode = nameNode.getNext();
                assignNode.removeChild(nameNode);
                assignNode.removeChild(valueNode);
                nameNode.addChildToFront(valueNode);
                Node varNode = new Node(Token.VAR, nameNode);
                varNode.copyInformationFrom(candidateDefinition);
                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);
                nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                compiler.reportCodeChange();
                replacementNode = varNode;
            }
        }
    } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
            firstNode.getParent().addChildBefore(replacementNode, firstNode);
        } else {
            // In this case, the name was implicitly provided by two independent
            // modules. We need to move this code up to a common module.
            int indexOfDot = namespace.indexOf('.');
            if (indexOfDot == -1) {
                // Any old place is fine.
                compiler.getNodeForCodeInsertion(minimumModule)
                    .addChildToBack(replacementNode);
            } else {
                // Add it after the parent namespace.
                ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));
                Preconditions.checkNotNull(parentName);
                Preconditions.checkNotNull(parentName.replacementNode);
                parentName.replacementNode.getParent().addChildAfter(
                    replacementNode, parentName.replacementNode);
            }
        }
        if (explicitNode != null) {
            explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
    }
}",0,0
104,Closure_92,"void replace() {
      if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
      }

      // Handle the case where there is a duplicate definition for an explicitly
      // provided symbol.
      if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
          Node assignNode = candidateDefinition.getFirstChild();
          Node nameNode = assignNode.getFirstChild();
          if (nameNode.getType() == Token.NAME) {
            // Need to convert this assign to a var declaration.
            Node valueNode = nameNode.getNext();
            assignNode.removeChild(nameNode);
            assignNode.removeChild(valueNode);
            nameNode.addChildToFront(valueNode);
            Node varNode = new Node(Token.VAR, nameNode);
            varNode.copyInformationFrom(candidateDefinition);
            candidateDefinition.getParent().replaceChild(
                candidateDefinition, varNode);
            nameNode.setJSDocInfo(assignNode.getJSDocInfo());
            compiler.reportCodeChange();
            replacementNode = varNode;
          }
        }
      } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
          firstNode.getParent().addChildBefore(replacementNode, firstNode);
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
           int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
                .addChildToBack(replacementNode);
          } else {
            // Add it after the parent namespace.
            ProvidedName parentName =
                providedNames.get(namespace.substring(0, indexOfDot));
            Preconditions.checkNotNull(parentName);
            Preconditions.checkNotNull(parentName.replacementNode);
            parentName.replacementNode.getParent().addChildAfter(
                replacementNode, parentName.replacementNode);
          }
        }
        if (explicitNode != null) {
          explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
      }
    }","void replace() {
    if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
    }

    // Handle the case where there is a candidate definition for an explicitly provided symbol.
    if (explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();
    }

    if (candidateDefinition != null) {
        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
            Node assignNode = candidateDefinition.getFirstChild();
            Node nameNode = assignNode.getFirstChild();
            if (nameNode.getType() == Token.NAME) {
                // Convert this assign to a var declaration.
                Node valueNode = nameNode.getNext();
                nameNode.removeChild(valueNode);
                Node varNode = new Node(Token.VAR, nameNode);
                varNode.addChildToBack(valueNode);
                varNode.copyInformationFrom(assignNode);
                candidateDefinition.getParent().replaceChild(assignNode, varNode);
                nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                compiler.reportCodeChange();
                replacementNode = varNode;
            }
        }
    } else {
        // Handle the case where there's no candidate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
            firstNode.getParent().addChildBefore(replacementNode, firstNode);
        } else {
            // In this case, the name was implicitly provided by two independent modules.
            int indexOfDot = namespace.indexOf('.');
            if (indexOfDot == -1) {
                // Any old place is fine.
                compiler.getNodeForCodeInsertion(minimumModule)
                    .addChildToBack(replacementNode);
            } else {
                // Add it after the parent namespace.
                ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));
                Preconditions.checkNotNull(parentName);
                Preconditions.checkNotNull(parentName.replacementNode);
                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);
            }
        }
    }
}",0,1
104,Closure_92,"void replace() {
      if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
      }

      // Handle the case where there is a duplicate definition for an explicitly
      // provided symbol.
      if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
          Node assignNode = candidateDefinition.getFirstChild();
          Node nameNode = assignNode.getFirstChild();
          if (nameNode.getType() == Token.NAME) {
            // Need to convert this assign to a var declaration.
            Node valueNode = nameNode.getNext();
            assignNode.removeChild(nameNode);
            assignNode.removeChild(valueNode);
            nameNode.addChildToFront(valueNode);
            Node varNode = new Node(Token.VAR, nameNode);
            varNode.copyInformationFrom(candidateDefinition);
            candidateDefinition.getParent().replaceChild(
                candidateDefinition, varNode);
            nameNode.setJSDocInfo(assignNode.getJSDocInfo());
            compiler.reportCodeChange();
            replacementNode = varNode;
          }
        }
      } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
          firstNode.getParent().addChildBefore(replacementNode, firstNode);
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
           int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
                .addChildToBack(replacementNode);
          } else {
            // Add it after the parent namespace.
            ProvidedName parentName =
                providedNames.get(namespace.substring(0, indexOfDot));
            Preconditions.checkNotNull(parentName);
            Preconditions.checkNotNull(parentName.replacementNode);
            parentName.replacementNode.getParent().addChildAfter(
                replacementNode, parentName.replacementNode);
          }
        }
        if (explicitNode != null) {
          explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
      }
    }","void replace() {
    if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
    }

    try {
        if (explicitNode != null) {
            explicitNode.detachFromParent();
            compiler.reportCodeChange();
        }

        if (candidateDefinition != null) {
            replacementNode = candidateDefinition;
            if (NodeUtil.isExpressionNode(candidateDefinition)) {
                candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
                Node assignNode = candidateDefinition.getFirstChild();
                Node nameNode = assignNode.getFirstChild();
                if (nameNode.getType() == Token.NAME) {
                    Node valueNode = nameNode.getNext();
                    assignNode.removeChild(nameNode);
                    Node varNode = new Node(Token.VAR, nameNode);
                    varNode.addChildToBack(valueNode);
                    varNode.copyInformationFrom(candidateDefinition);
                    candidateDefinition.getParent().replaceChild(assignNode, varNode);
                    nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                    compiler.reportCodeChange();
                    replacementNode = varNode;
                }
            }
        } else {
            replacementNode = createDeclarationNode();
            Node insertionPoint = null;
            if (firstModule == minimumModule) {
                insertionPoint = firstNode.getParent();
            } else {
                int indexOfDot = namespace.indexOf('.');
                if (indexOfDot == -1) {
                    insertionPoint = compiler.getNodeForCodeInsertion(minimumModule);
                } else {
                    ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));
                    if (parentName != null && parentName.replacementNode != null) {
                        insertionPoint = parentName.replacementNode.getParent();
                    }
                }
            }
            if (insertionPoint != null) {
                insertionPoint.addChildToBack(replacementNode);
            }
        }
    } catch (Exception e) {
        // Handle unexpected edge cases here
        compiler.reportCodeChange();
    }
}",0,2
105,Closure_94,"static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }","static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
        case Token.STRING:
        case Token.NUMBER:
        case Token.TRUE:
        case Token.FALSE:
            return true;

        // Binary operators are only valid if both children are valid.
        case Token.BITAND:
        case Token.BITOR:
        case Token.BITXOR:
            return isValidDefineValue(val.getFirstChild(), defines) &&
                   isValidDefineValue(val.getLastChild(), defines);

        // Unary operators are valid if the child is valid.
        case Token.BITNOT:
        case Token.NOT:
        case Token.NEG:
            return isValidDefineValue(val.getFirstChild(), defines);

        // Names are valid if and only if they are defines themselves.
        case Token.NAME:
        case Token.GETPROP:
            if (val.isQualifiedName()) {
                return defines.contains(val.getQualifiedName());
            }
    }
    return false;
}",0,0
105,Closure_94,"static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }","static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
        case Token.STRING:
        case Token.NUMBER:
        case Token.TRUE:
        case Token.FALSE:
            return true;

        // Binary operators are only valid if both children are valid.
        case Token.BITAND:
        case Token.BITOR:
        case Token.BITXOR:
            return val.getFirstChild() != null && val.getLastChild() != null &&
                   isValidDefineValue(val.getFirstChild(), defines) &&
                   isValidDefineValue(val.getLastChild(), defines);

        // Unary operators are valid if the child is valid.
        case Token.BITNOT:
        case Token.NOT:
        case Token.NEG:
            return val.getFirstChild() != null && isValidDefineValue(val.getFirstChild(), defines);

        // Names are valid if and only if they are defines themselves.
        case Token.NAME:
        case Token.GETPROP:
            if (val.isQualifiedName()) {
                return defines.contains(val.getQualifiedName());
            }
            break;

        // Add additional safe cases if necessary.
        default:
            break;
    }
    return false;
}",0,1
105,Closure_94,"static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }","static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
        case Token.STRING:
        case Token.NUMBER:
        case Token.TRUE:
        case Token.FALSE:
            return true;

        // Binary operators are only valid if both children are valid.
        case Token.BITAND:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.ADD:
        case Token.SUB:
        case Token.MUL:
        case Token.DIV:
        case Token.MOD:
            return val.getFirstChild() != null && val.getLastChild() != null &&
                   isValidDefineValue(val.getFirstChild(), defines) &&
                   isValidDefineValue(val.getLastChild(), defines);

        // Unary operators are valid if the child is valid.
        case Token.BITNOT:
        case Token.NOT:
        case Token.NEG:
            return val.getFirstChild() != null && isValidDefineValue(val.getFirstChild(), defines);

        // Names are valid if and only if they are defines themselves.
        case Token.NAME:
        case Token.GETPROP:
            if (val.isQualifiedName()) {
                return defines.contains(val.getQualifiedName());
            }
            break;

        // Add additional safe cases if necessary.
        default:
            break;
    }
    return false;
}",0,2
106,Closure_95,"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
      Preconditions.checkArgument(inferred || type != null);

      // Only allow declarations of NAMEs and qualfied names.
      boolean shouldDeclareOnGlobalThis = false;
      if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
      } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
      }
      String variableName = n.getQualifiedName();
      Preconditions.checkArgument(!variableName.isEmpty());

      // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
      } else {
        if (!inferred) {
          setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
          ObjectType globalThis =
              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
          boolean isExtern = input.isExtern();
          if (inferred) {
            globalThis.defineInferredProperty(variableName,
                type == null ?
                    getNativeType(JSTypeNative.NO_TYPE) :
                    type,
                isExtern);
          } else {
            globalThis.defineDeclaredProperty(variableName, type, isExtern);
          }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
          FunctionType fnType = (FunctionType) type;
          if (fnType.isConstructor() || fnType.isInterface()) {
            FunctionType superClassCtor = fnType.getSuperClassConstructor();
            scopeToDeclareIn.declare(variableName + "".prototype"", n,
                fnType.getPrototype(), compiler.getInput(sourceName),
                /* declared iff there's an explicit supertype */
                superClassCtor == null ||
                superClassCtor.getInstanceType().equals(
                    getNativeType(OBJECT_TYPE)));
          }
        }
      }
    }","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);

    // Only allow declarations of NAMEs and qualified names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
    }
    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());

    // If n is a property, then we should really declare it in the
    // scope where the root object appears. This helps out people
    // who declare ""global"" names in an anonymous namespace.
    Scope scopeToDeclareIn = scope;

    // don't try to declare in the global scope if there's
    // already a symbol there with this name.

    // declared in closest scope?
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis =
                typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName,
                    type == null ?
                        getNativeType(JSTypeNative.NO_TYPE) :
                        type,
                    isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n,
                    fnType.getPrototype(), compiler.getInput(sourceName),
                    /* declared iff there's an explicit supertype */
                    superClassCtor == null ||
                    superClassCtor.getInstanceType().equals(
                        getNativeType(OBJECT_TYPE)));
            }
        }
    }
}",0,0
106,Closure_95,"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
      Preconditions.checkArgument(inferred || type != null);

      // Only allow declarations of NAMEs and qualfied names.
      boolean shouldDeclareOnGlobalThis = false;
      if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
      } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
      }
      String variableName = n.getQualifiedName();
      Preconditions.checkArgument(!variableName.isEmpty());

      // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
      } else {
        if (!inferred) {
          setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
          ObjectType globalThis =
              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
          boolean isExtern = input.isExtern();
          if (inferred) {
            globalThis.defineInferredProperty(variableName,
                type == null ?
                    getNativeType(JSTypeNative.NO_TYPE) :
                    type,
                isExtern);
          } else {
            globalThis.defineDeclaredProperty(variableName, type, isExtern);
          }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
          FunctionType fnType = (FunctionType) type;
          if (fnType.isConstructor() || fnType.isInterface()) {
            FunctionType superClassCtor = fnType.getSuperClassConstructor();
            scopeToDeclareIn.declare(variableName + "".prototype"", n,
                fnType.getPrototype(), compiler.getInput(sourceName),
                /* declared iff there's an explicit supertype */
                superClassCtor == null ||
                superClassCtor.getInstanceType().equals(
                    getNativeType(OBJECT_TYPE)));
          }
        }
      }
    }","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);

    // Only allow declarations of NAMEs and qualified names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
    }
    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());

    // Adjust the scope based on the variable name
    Scope scopeToDeclareIn = adjustScopeBasedOnVariableName(variableName);

    // Check if the variable is already declared in the scope, but avoid global scope duplication
    if (scopeToDeclareIn.isDeclared(variableName, false) && !scopeToDeclareIn.isGlobal()) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis =
                typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName,
                    type == null ? getNativeType(JSTypeNative.NO_TYPE) : type,
                    isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }

        // Handle the prototype declaration for functions in the global scope
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n,
                    fnType.getPrototype(), compiler.getInput(sourceName),
                    /* declared iff there's an explicit supertype */
                    superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));
            }
        }
    }
}

private Scope adjustScopeBasedOnVariableName(String variableName) {
    // Implement the logic to adjust the scope based on the variable name
    // For example, if the variable name starts with a specific prefix, change the scope accordingly.
    return scope;
}",0,1
106,Closure_95,"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
      Preconditions.checkArgument(inferred || type != null);

      // Only allow declarations of NAMEs and qualfied names.
      boolean shouldDeclareOnGlobalThis = false;
      if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
      } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
      }
      String variableName = n.getQualifiedName();
      Preconditions.checkArgument(!variableName.isEmpty());

      // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
      } else {
        if (!inferred) {
          setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
          ObjectType globalThis =
              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
          boolean isExtern = input.isExtern();
          if (inferred) {
            globalThis.defineInferredProperty(variableName,
                type == null ?
                    getNativeType(JSTypeNative.NO_TYPE) :
                    type,
                isExtern);
          } else {
            globalThis.defineDeclaredProperty(variableName, type, isExtern);
          }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
          FunctionType fnType = (FunctionType) type;
          if (fnType.isConstructor() || fnType.isInterface()) {
            FunctionType superClassCtor = fnType.getSuperClassConstructor();
            scopeToDeclareIn.declare(variableName + "".prototype"", n,
                fnType.getPrototype(), compiler.getInput(sourceName),
                /* declared iff there's an explicit supertype */
                superClassCtor == null ||
                superClassCtor.getInstanceType().equals(
                    getNativeType(OBJECT_TYPE)));
          }
        }
      }
    }","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);

    // Only allow declarations of NAMEs and qualified names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
    }
    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());

    // If n is a property, then we should really declare it in the
    // scope where the root object appears. This helps out people
    // who declare ""global"" names in an anonymous namespace.
    Scope scopeToDeclareIn = findScopeToDeclareIn(n);

    // Don't try to declare in the global scope if there's
    // already a symbol there with this name.
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis =
                typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName,
                    type == null ? getNativeType(JSTypeNative.NO_TYPE) : type,
                    isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n,
                    fnType.getPrototype(), compiler.getInput(sourceName),
                    /* declared iff there's an explicit supertype */
                    superClassCtor == null ||
                    superClassCtor.getInstanceType().equals(
                        getNativeType(OBJECT_TYPE)));
            }
        }
    }
}

private Scope findScopeToDeclareIn(Node n) {
    // If n is a property, we declare it in the scope where the root object appears.
    // Otherwise, use the current scope.
    if (n.getType() == Token.GETPROP) {
        Node root = n.getFirstChild();
        while (root.getType() == Token.GETPROP) {
            root = root.getFirstChild();
        }
        String rootName = root.getQualifiedName();
        if (rootName != null) {
            Var rootVar = scope.getVar(rootName);
            if (rootVar != null) {
                return rootVar.getScope();
            }
        }
    }
    return scope;
}",0,2
107,Closure_96,"private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
            parameters.hasNext()) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
         parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
      validator.expectArgumentMatchesParameter(t, argument,
          getJSType(argument), getJSType(parameter), call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
      report(t, call, WRONG_ARGUMENT_COUNT,
              validator.getReadableJSTypeName(call.getFirstChild(), false),
              String.valueOf(numArgs), String.valueOf(minArgs),
              maxArgs != Integer.MAX_VALUE ?
              "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
  }","private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;

    while (arguments.hasNext() || parameters.hasNext()) {
        Node parameter = parameters.hasNext() ? parameters.next() : null;
        Node argument = arguments.hasNext() ? arguments.next() : null;
        ordinal++;

        if (parameter != null && argument != null) {
            validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);
        }
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT,
               validator.getReadableJSTypeName(call.getFirstChild(), false),
               String.valueOf(numArgs), String.valueOf(minArgs),
               maxArgs != Integer.MAX_VALUE ? "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}",0,0
107,Closure_96,"private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
            parameters.hasNext()) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
         parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
      validator.expectArgumentMatchesParameter(t, argument,
          getJSType(argument), getJSType(parameter), call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
      report(t, call, WRONG_ARGUMENT_COUNT,
              validator.getReadableJSTypeName(call.getFirstChild(), false),
              String.valueOf(numArgs), String.valueOf(minArgs),
              maxArgs != Integer.MAX_VALUE ?
              "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
  }","private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // Skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;

    while (parameters.hasNext()) {
        ordinal++;
        Node parameter = parameters.next();
        Node argument = null;
        
        if (arguments.hasNext()) {
            argument = arguments.next();
            validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);
        } else {
            // Handle cases where arguments are less than parameters, maybe fill with defaults
            Node defaultArgument = createDefaultArgument(parameter);
            validator.expectArgumentMatchesParameter(t, defaultArgument, getJSType(defaultArgument), getJSType(parameter), call, ordinal);
        }
    }
    
    while (arguments.hasNext()) {
        ordinal++;
        Node extraArgument = arguments.next();
        validator.handleExtraArgument(t, extraArgument, call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT,
               validator.getReadableJSTypeName(call.getFirstChild(), false),
               String.valueOf(numArgs), String.valueOf(minArgs),
               maxArgs != Integer.MAX_VALUE ? "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}

private Node createDefaultArgument(Node parameter) {
    // Logic to create a default argument based on the parameter type
    return new Node(parameter.getType());
}",0,1
108,Closure_97,"private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

      double result;
      double lval = left.getDouble();
      double rval = right.getDouble();

      // check ranges.  We do not do anything that would clip the double to
      // a 32-bit range, since the user likely does not intend that.
      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
      }

      // only the lower 5 bits are used when shifting, so don't do anything
      // if the shift amount is outside [0,32)
      if (!(rval >= 0 && rval < 32)) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
      }

      // Convert the numbers to ints
      int lvalInt = (int) lval;
      if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
      }

      int rvalInt = (int) rval;
      if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
      }

      switch (n.getType()) {
        case Token.LSH:
          result = lvalInt << rvalInt;
          break;
        case Token.RSH:
          result = lvalInt >> rvalInt;
          break;
        case Token.URSH:
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
              Node.tokenToName(n.getType()));
      }

      Node newNumber = Node.newNumber(result);
      n.getParent().replaceChild(n, newNumber);
      reportCodeChange();

      return newNumber;
    }

    return n;
  }","private Node tryFoldShift(Node n, Node left, Node right) {
  if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {

    double lval = left.getDouble();
    double rval = right.getDouble();

    if (Double.isNaN(lval) || Double.isInfinite(lval) ||
        Double.isNaN(rval) || Double.isInfinite(rval)) {
      error(FRACTIONAL_BITWISE_OPERAND, left);
      return n;
    }

    // check ranges
    if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE) {
      error(BITWISE_OPERAND_OUT_OF_RANGE, left);
      return n;
    }

    if (rval < 0 || rval >= 32) {
      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
      return n;
    }

    // Convert the numbers to ints
    int lvalInt = (int) lval;
    int rvalInt = (int) rval;

    if (lvalInt != lval) {
      error(FRACTIONAL_BITWISE_OPERAND, left);
      return n;
    }

    if (rvalInt != rval) {
      error(FRACTIONAL_BITWISE_OPERAND, right);
      return n;
    }

    double result;
    switch (n.getType()) {
      case Token.LSH:
        result = lvalInt << rvalInt;
        break;
      case Token.RSH:
        result = lvalInt >> rvalInt;
        break;
      case Token.URSH:
        result = lvalInt >>> rvalInt;
        break;
      default:
        throw new AssertionError(""Unknown shift operator: ""
            + Node.tokenToName(n.getType()));
    }

    Node newNumber = Node.newNumber(result);
    n.getParent().replaceChild(n, newNumber);
    reportCodeChange();

    return newNumber;
  }

  return n;
}",0,0
108,Closure_97,"private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

      double result;
      double lval = left.getDouble();
      double rval = right.getDouble();

      // check ranges.  We do not do anything that would clip the double to
      // a 32-bit range, since the user likely does not intend that.
      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
      }

      // only the lower 5 bits are used when shifting, so don't do anything
      // if the shift amount is outside [0,32)
      if (!(rval >= 0 && rval < 32)) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
      }

      // Convert the numbers to ints
      int lvalInt = (int) lval;
      if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
      }

      int rvalInt = (int) rval;
      if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
      }

      switch (n.getType()) {
        case Token.LSH:
          result = lvalInt << rvalInt;
          break;
        case Token.RSH:
          result = lvalInt >> rvalInt;
          break;
        case Token.URSH:
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
              Node.tokenToName(n.getType()));
      }

      Node newNumber = Node.newNumber(result);
      n.getParent().replaceChild(n, newNumber);
      reportCodeChange();

      return newNumber;
    }

    return n;
  }","private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double lval = left.getDouble();
        double rval = right.getDouble();

        // Check if either value is NaN or infinite
        if (Double.isNaN(lval) || Double.isInfinite(lval) ||
            Double.isNaN(rval) || Double.isInfinite(rval)) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }

        // Check range for lval (only allow integers within the range)
        if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || lval != (int) lval) {
            error(BITWISE_OPERAND_OUT_OF_RANGE, left);
            return n;
        }

        // Check if rval is within [0, 31] and is an integer
        if (rval < 0 || rval >= 32 || rval != (int) rval) {
            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return n;
        }

        int lvalInt = (int) lval;
        int rvalInt = (int) rval;

        double result;
        switch (n.getType()) {
            case Token.LSH:
                result = lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                result = lvalInt >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" +
                    Node.tokenToName(n.getType()));
        }

        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();

        return newNumber;
    }

    return n;
}",0,1
108,Closure_97,"private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

      double result;
      double lval = left.getDouble();
      double rval = right.getDouble();

      // check ranges.  We do not do anything that would clip the double to
      // a 32-bit range, since the user likely does not intend that.
      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
      }

      // only the lower 5 bits are used when shifting, so don't do anything
      // if the shift amount is outside [0,32)
      if (!(rval >= 0 && rval < 32)) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
      }

      // Convert the numbers to ints
      int lvalInt = (int) lval;
      if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
      }

      int rvalInt = (int) rval;
      if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
      }

      switch (n.getType()) {
        case Token.LSH:
          result = lvalInt << rvalInt;
          break;
        case Token.RSH:
          result = lvalInt >> rvalInt;
          break;
        case Token.URSH:
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
              Node.tokenToName(n.getType()));
      }

      Node newNumber = Node.newNumber(result);
      n.getParent().replaceChild(n, newNumber);
      reportCodeChange();

      return newNumber;
    }

    return n;
  }","private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() != Token.NUMBER || right.getType() != Token.NUMBER) {
        return n;
    }

    double lval = left.getDouble();
    double rval = right.getDouble();

    // Check if either value is NaN or infinite
    if (Double.isNaN(lval) || Double.isInfinite(lval) || Double.isNaN(rval) || Double.isInfinite(rval)) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
    }

    // Check range for lval (only allow integers within the range)
    if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || lval != (int) lval) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
    }

    // Check if rval is within [0, 31]
    if (rval < 0 || rval >= 32) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
    }

    // Convert the numbers to ints and check for fractional values
    int lvalInt = (int) lval;
    if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
    }

    int rvalInt = (int) rval;
    if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
    }

    double result;
    switch (n.getType()) {
        case Token.LSH:
            result = lvalInt << rvalInt;
            break;
        case Token.RSH:
            result = lvalInt >> rvalInt;
            break;
        case Token.URSH:
            result = lvalInt >>> rvalInt;
            break;
        default:
            throw new AssertionError(""Unknown shift operator: "" + Node.tokenToName(n.getType()));
    }

    Node newNumber = Node.newNumber(result);
    n.getParent().replaceChild(n, newNumber);
    reportCodeChange();

    return newNumber;
}",0,2
109,Closure_99,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
            return false;
          }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {

        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
          return false;
        }

        int pType = parent.getType();
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.VAR ||
              pType == Token.NAME ||
              pType == Token.ASSIGN ||
              pType == Token.EXPR_RESULT)) {
          return false;
        }
    }
    
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            if (lhs.getType() == Token.GETPROP &&
                ""prototype"".equals(lhs.getLastChild().getString())) {
                return false;
            }
            if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
                return false;
            }
        }
    }
    
    return true;
}",0,0
109,Closure_99,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
            return false;
          }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }

        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME ||
              (pType == Token.ASSIGN && parent.getFirstChild().getType() == Token.NAME) )) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        if (n == lhs) {
            // Always traverse the left side of the assignment. To handle
            // nested assignments properly (e.g., (a = this).property = c;),
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // Only traverse the right side if it's not an assignment to a prototype
            // property or subproperty.
            if (lhs.getType() == Token.GETPROP && ""prototype"".equals(lhs.getLastChild().getString())) {
                return false;
            }
            if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
                return false;
            }
        }
    }

    return true;
}",0,1
109,Closure_99,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
            return false;
          }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Skip functions with specific annotations.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }

        // Restrict traversal to functions in specific parent context.
        int pType = parent.getType();
        boolean isValidParent = (pType == Token.BLOCK || pType == Token.SCRIPT || 
            (pType == Token.NAME && parent.getParent() != null && parent.getParent().getType() == Token.VAR) ||
            (pType == Token.ASSIGN && parent.getFirstChild().getType() == Token.NAME));
        if (!isValidParent) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        if (n == lhs) {
            // Ensure only one assignment target is tracked.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // Avoid traversing assignments targeting prototype or its subproperties.
            if ((lhs.getType() == Token.GETPROP && ""prototype"".equals(lhs.getLastChild().getString())) || 
                (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype.""))) {
                return false;
            }
        }
    }

    // Avoid traversing dangerous global `this` references.
    if (n.getType() == Token.THIS && parent != null && parent.getType() == Token.GETPROP) {
        JSDocInfo jsDocInfo = parent.getJSDocInfo();
        if (jsDocInfo == null || (!jsDocInfo.isConstructor() && !jsDocInfo.hasThisType())) {
            return false;
        }
    }

    return true;
}",0,2
110,Lang_1,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
             if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
             if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

        //Must be a Float, Double, BigDecimal
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        try {
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    final String[] hexPrefix = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int prefixLength = 0;
    for (final String prefix : hexPrefix) {
        if (str.startsWith(prefix)) {
            prefixLength += prefix.length();
            break;
        }
    }
    if (prefixLength > 0) {
        final int hexDigits = str.length() - prefixLength;
        if (hexDigits > 16) {
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mantissa;
    String decimal;
    String exponent;
    final int decimalPos = str.indexOf('.');
    final int exponentPos = Math.max(str.indexOf('e'), str.indexOf('E'));
    int numDecimals = 0;
    if (decimalPos > -1) {
        if (exponentPos > -1) {
            if (exponentPos < decimalPos || exponentPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPos + 1, exponentPos);
        } else {
            decimal = str.substring(decimalPos + 1);
        }
        mantissa = str.substring(0, decimalPos);
        numDecimals = decimal.length();
    } else {
        if (exponentPos > -1) {
            if (exponentPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mantissa = str.substring(0, exponentPos);
        } else {
            mantissa = str;
        }
        decimal = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (exponentPos > -1 && exponentPos < str.length() - 1) {
            exponent = str.substring(exponentPos + 1, str.length() - 1);
        } else {
            exponent = null;
        }
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null &&
                    (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                    // ignore
                }
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                    // ignore
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                    // ignore
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    if (exponentPos > -1 && exponentPos < str.length() - 1) {
        exponent = str.substring(exponentPos + 1);
    } else {
        exponent = null;
    }
    if (decimal == null && exponent == null) {
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
            // ignore
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
            // ignore
        }
        return createBigInteger(str);
    }
    final boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);
    try {
        if (numDecimals <= 7) {
            final Float f = createFloat(str);
            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                return f;
            }
        }
    } catch (final NumberFormatException nfe) {
        // ignore
    }
    try {
        if (numDecimals <= 16) {
            final Double d = createDouble(str);
            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                return d;
            }
        }
    } catch (final NumberFormatException nfe) {
        // ignore
    }
    return createBigDecimal(str);
}",0,0
110,Lang_1,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
             if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
             if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

        //Must be a Float, Double, BigDecimal
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        try {
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    // Handle hexadecimal prefixes
    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int prefixLength = 0;
    for (final String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            prefixLength += prefix.length();
            break;
        }
    }

    if (prefixLength > 0) {
        final String hexNumber = str.substring(prefixLength);
        if (!isHexDigits(hexNumber)) {
            throw new NumberFormatException(str + "" is not a valid hexadecimal number."");
        }
        final int hexDigits = hexNumber.length();
        if (hexDigits > 16) {
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            return createLong(str);
        }
        return createInteger(str);
    }

    // Handle decimal point and exponent
    final char lastChar = str.charAt(str.length() - 1);
    final int decimalPos = str.indexOf('.');
    final int exponentPos = Math.max(str.indexOf('e'), str.indexOf('E'));
    if (decimalPos > -1 && exponentPos > -1 && exponentPos < decimalPos) {
        throw new NumberFormatException(str + "" is not a valid number."");
    }

    String mantissa = null, decimal = null, exponent = null;
    int numDecimals = 0;

    if (decimalPos > -1) {
        mantissa = str.substring(0, decimalPos);
        if (exponentPos > -1) {
            decimal = str.substring(decimalPos + 1, exponentPos);
            exponent = str.substring(exponentPos + 1);
        } else {
            decimal = str.substring(decimalPos + 1);
        }
        numDecimals = decimal.length();
    } else {
        if (exponentPos > -1) {
            mantissa = str.substring(0, exponentPos);
            exponent = str.substring(exponentPos + 1);
        } else {
            mantissa = str;
        }
    }

    // Handle type suffixes
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeroComponents = isAllZeros(mantissa) && (isAllZeros(exponent) || exponent == null);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException e) {
                        return createBigInteger(numeric);
                    }
                }
                break;
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!f.isInfinite() && (allZeroComponents || f != 0.0F)) {
                        return f;
                    }
                } catch (NumberFormatException ignored) {
                }
                break;
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!d.isInfinite() && (allZeroComponents || d != 0.0D)) {
                        return d;
                    }
                } catch (NumberFormatException ignored) {
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException ignored) {
                }
                break;
        }
        throw new NumberFormatException(str + "" is not a valid number."");
    }

    // Handle general number conversion
    try {
        if (decimal == null && exponent == null) {
            return tryParseIntegerLongBigInteger(str);
        }
        return tryParseFloatingPointWithPrecision(str, numDecimals, mantissa, decimal, exponent);
    } catch (NumberFormatException e) {
        throw new NumberFormatException(str + "" is not a valid number."");
    }
}

private static Number tryParseIntegerLongBigInteger(String str) {
    try {
        return createInteger(str);
    } catch (NumberFormatException ignored) {
    }
    try {
        return createLong(str);
    } catch (NumberFormatException ignored) {
    }
    return createBigInteger(str);
}

private static Number tryParseFloatingPointWithPrecision(String str, int numDecimals, String mantissa, String decimal, String exponent) {
    final boolean allZeroComponents = isAllZeros(mantissa) && (isAllZeros(exponent) || exponent == null);
    if (numDecimals <= 7) {
        try {
            Float f = createFloat(str);
            if (!f.isInfinite() && (allZeroComponents || f != 0.0F)) {
                return f;
            }
        } catch (NumberFormatException ignored) {
        }
    }
    if (numDecimals <= 16) {
        try {
            Double d = createDouble(str);
            if (!d.isInfinite() && (allZeroComponents || d != 0.0D)) {
                return d;
            }
        } catch (NumberFormatException ignored) {
        }
    }
    return createBigDecimal(str);
}

private static boolean isHexDigits(String str) {
    return str.matches(""[0-9a-fA-F]+"");
}",0,1
110,Lang_1,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
             if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
             if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

        //Must be a Float, Double, BigDecimal
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        try {
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    // Handle hexadecimal prefixes
    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int prefixLength = 0;
    for (final String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            prefixLength += prefix.length();
            break;
        }
    }

    if (prefixLength > 0) {
        final String hexNumber = str.substring(prefixLength);
        if (!isHexDigits(hexNumber)) {
            throw new NumberFormatException(str + "" is not a valid hexadecimal number."");
        }
        final int hexDigits = hexNumber.length();
        if (hexDigits > 16) {
            return createBigInteger(hexNumber);
        }
        if (hexDigits > 8) {
            return createLong(hexNumber);
        }
        return createInteger(hexNumber);
    }

    // Handle decimal point and exponent
    final char lastChar = str.charAt(str.length() - 1);
    final int decimalPos = str.indexOf('.');
    final int exponentPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decimalPos > -1 && exponentPos > -1 && exponentPos < decimalPos) {
        throw new NumberFormatException(str + "" is not a valid number."");
    }

    String mantissa = null, decimal = null, exponent = null;

    if (decimalPos > -1) {
        mantissa = str.substring(0, decimalPos);
        if (exponentPos > -1) {
            decimal = str.substring(decimalPos + 1, exponentPos);
            exponent = str.substring(exponentPos + 1);
        } else {
            decimal = str.substring(decimalPos + 1);
        }
    } else {
        if (exponentPos > -1) {
            mantissa = str.substring(0, exponentPos);
            exponent = str.substring(exponentPos + 1);
        } else {
            mantissa = str;
        }
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        final String numeric = str.substring(0, str.length() - 1);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException e) {
                        return createBigInteger(numeric);
                    }
                }
                break;
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!f.isInfinite()) {
                        return f;
                    }
                } catch (NumberFormatException ignored) {
                }
                break;
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!d.isInfinite()) {
                        return d;
                    }
                } catch (NumberFormatException ignored) {
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException ignored) {
                }
                break;
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (decimal == null && exponent == null) {
        return tryParseIntegerLongBigInteger(mantissa);
    }
    return tryParseFloatingPointWithPrecision(mantissa, decimal, exponent);
}

private static Number tryParseIntegerLongBigInteger(String str) {
    try {
        return createInteger(str);
    } catch (NumberFormatException ignored) {
    }
    try {
        return createLong(str);
    } catch (NumberFormatException ignored) {
    }
    return createBigInteger(str);
}

private static Number tryParseFloatingPointWithPrecision(String mantissa, String decimal, String exponent) {
    try {
        if (decimal != null && decimal.length() <= 7) {
            Float f = createFloat(mantissa + ""."" + decimal + (exponent != null ? ""e"" + exponent : """"));
            if (!f.isInfinite()) {
                return f;
            }
        }
    } catch (NumberFormatException ignored) {
    }
    try {
        Double d = createDouble(mantissa + ""."" + decimal + (exponent != null ? ""e"" + exponent : """"));
        if (!d.isInfinite()) {
            return d;
        }
    } catch (NumberFormatException ignored) {
    }
    return createBigDecimal(mantissa + ""."" + (decimal != null ? decimal : """") + (exponent != null ? ""e"" + exponent : """"));
}

private static boolean isHexDigits(String str) {
    return str.matches(""[0-9a-fA-F]+"");
}",0,2
111,Lang_10,"    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
        boolean wasWhite= false;
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
            regex.append(c);
        }
        return regex;
    }
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        // Fix: Adjusted whitespace handling and regex escaping
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*+"");
            }
            continue;
        }
        wasWhite = false;

        switch (c) {
            case '\'':
                if (unquote) {
                    if (++i == value.length()) {
                        return regex;
                    }
                    c = value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
                break; // Fix: Added break for safe escape handling
        }
        regex.append(c);
    }
    return regex;
}",0,0
111,Lang_10,"    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
        boolean wasWhite= false;
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
            regex.append(c);
        }
        return regex;
    }
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*+"");
            }
            continue;
        }
        wasWhite = false;
        if (unquote && c == '\'') {
            if (++i == value.length()) {
                return regex;
            }
            c = value.charAt(i);
        } else {
            switch (c) {
                case '?':
                case '[':
                case ']':
                case '(':
                case ')':
                case '{':
                case '}':
                case '\\':
                case '|':
                case '*':
                case '+':
                case '^':
                case '$':
                case '.':
                    regex.append('\\');
            }
        }
        regex.append(c);
    }
    return regex;
}",0,1
111,Lang_10,"    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
        boolean wasWhite= false;
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
            regex.append(c);
        }
        return regex;
    }
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*"");
            }
            continue;
        }
        wasWhite = false;
        if (unquote && c == '\'') {
            if (++i == value.length()) {
                return regex;
            }
            c = value.charAt(i);
        }
        switch (c) {
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
        }
        regex.append(c);
    }
    return regex;
}",0,2
112,Lang_11,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                    start = ' ';
                }
            }
        }

        if (start > end) {
            throw new IllegalArgumentException(""Start value must be less than or equal to end value."");
        }

        char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(chars.length)];
            }
            if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {
                if (Character.isHighSurrogate(ch)) {
                    if (count == 0) {
                        count++;
                    } else {
                        buffer[count] = (char) (random.nextInt(128) + '\uDC00'); // low surrogate
                        count--;
                        buffer[count] = ch;
                    }
                } else if (Character.isLowSurrogate(ch)) {
                    if (count == 0) {
                        count++;
                    } else {
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (random.nextInt(128) + '\uD800'); // high surrogate
                    }
                } else if (ch >= '\uDC00' && ch <= '\uDEFF') {
                    // private use surrogates, skip
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }",0,0
112,Lang_11,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                    start = ' ';
                }
            }
        }

        if (start > end) {
            throw new IllegalArgumentException(""Start value must be less than or equal to end value."");
        }

        char[] buffer = new char[count];
        int gap = end - start;
        int index = 0;

        while (index < count) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(chars.length)];
            }

            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || (!letters && !numbers)) {
                if (Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch)) {
                    continue; // Skip invalid surrogate pairs for simplicity
                }
                buffer[index++] = ch;
            }
        }
        return new String(buffer);
    }",0,1
112,Lang_11,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                    start = ' ';
                }
            }
        }

        if (start >= end) {
            throw new IllegalArgumentException(""Start value ("" + start + "") must be less than end value ("" + end + "")."");
        }

        char[] buffer = new char[count];
        int index = 0;

        while (index < count) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(end - start) + start);
            } else {
                ch = chars[random.nextInt(chars.length)];
            }

            // Validate character for inclusion based on flags
            boolean valid = (letters && Character.isLetter(ch)) ||
                            (numbers && Character.isDigit(ch)) ||
                            (!letters && !numbers);

            if (valid) {
                // Avoid invalid or private surrogate pairs
                if (!Character.isSurrogate(ch)) {
                    buffer[index++] = ch;
                }
            }
        }
        return new String(buffer);
    }",0,2
113,Lang_12,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
 
         if (start == 0 && end == 0) {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers,
                            char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }

    if (start == 0 && end == 0) {
        if (!letters && !numbers) {
            end = Integer.MAX_VALUE;
        } else {
            end = 'z' + 1;
            start = ' ';
        }
    }

    if (end <= start) {
        throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
    }

    char[] buffer = new char[count];
    int gap = end - start;

    while (count != 0) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(gap) + start];
        }

        if (letters && Character.isLetter(ch)
                || numbers && Character.isDigit(ch)
                || !letters && !numbers) {
            if (ch >= 56320 && ch <= 57343) {
                if (count == 1) {
                    count++;
                } else {
                    // low surrogate, insert high surrogate after putting it in
                    buffer[--count] = ch;
                    buffer[--count] = (char) (55296 + random.nextInt(128));
                }
            } else if (ch >= 55296 && ch <= 56191) {
                if (count == 1) {
                    count++;
                } else {
                    // high surrogate, insert low surrogate before putting it in
                    buffer[--count] = (char) (56320 + random.nextInt(128));
                    buffer[--count] = ch;
                }
            } else if (ch >= 56192 && ch <= 56319) {
                // private high surrogate, no effing clue, so skip it
                count++;
            } else {
                buffer[--count] = ch;
            }
        } else {
            count++;
        }
    }
    return new String(buffer);
}",0,0
113,Lang_12,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
 
         if (start == 0 && end == 0) {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers,
                            char[] chars, Random random) {
    if (count <= 0) {
        return count == 0 ? """" : throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }

    if (start == 0 && end == 0) {
        if (!letters && !numbers) {
            end = Character.MAX_CODE_POINT;
        } else {
            end = 'z' + 1;
            start = ' ';
        }
    }

    if (end <= start) {
        throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
    }

    char[] buffer = new char[count];
    int gap = end - start;

    int i = 0;
    while (i < count) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(chars.length)];
        }

        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || (!letters && !numbers)) {
            if (Character.isSurrogate(ch)) {
                continue; // Skip surrogates entirely for simplicity
            } else {
                buffer[i++] = ch;
            }
        }
    }
    return new String(buffer);
}",0,1
114,Lang_14,"public static boolean equals(CharSequence cs1, CharSequence cs2) {
        if (cs1 == cs2) {
            return true;
        }
         if (cs1 == null || cs2 == null) {
             return false;
         }
             return cs1.equals(cs2);
     }","public static boolean equals(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1.length() != cs2.length()) {
        return false;
    }
    for (int i = 0; i < cs1.length(); i++) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            return false;
        }
    }
    return true;
}",0,0
115,Lang_16,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
             // a wrong value.
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        try {
            return createInteger(str);
        } catch (NumberFormatException nfe) {
            // Handle cases where it's not an integer (e.g., too large for int)
            return createBigInteger(str);
        }
    }

    char lastChar = str.charAt(str.length() - 1);
    String mantissa;
    String decimal = null;
    String exponent = null;

    int decimalPos = str.indexOf('.');
    int exponentPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decimalPos > -1) {
        if (exponentPos > -1) {
            if (exponentPos < decimalPos || exponentPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPos + 1, exponentPos);
        } else {
            decimal = str.substring(decimalPos + 1);
        }
        mantissa = str.substring(0, decimalPos);
    } else {
        if (exponentPos > -1) {
            if (exponentPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mantissa = str.substring(0, exponentPos);
        } else {
            mantissa = str;
        }
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (exponentPos > -1 && exponentPos < str.length() - 1) {
            exponent = str.substring(exponentPos + 1, str.length() - 1);
        }

        String numeric = str.substring(0, str.length() - 1); // Strip last char
        boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);

        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null
                        && (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        // Too big for a long
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException ignored) {
                }
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException ignored) {
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException ignored) {
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (exponentPos > -1 && exponentPos < str.length() - 1) {
            exponent = str.substring(exponentPos + 1);
        }

        if (decimal == null && exponent == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException ignored) {
            }
            try {
                return createLong(str);
            } catch (NumberFormatException ignored) {
            }
            return createBigInteger(str);
        } else {
            boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException ignored) {
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException ignored) {
            }
            return createBigDecimal(str);
        }
    }
}",0,0
115,Lang_16,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
             // a wrong value.
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        try {
            return createInteger(str);
        } catch (NumberFormatException nfe) {
            return createBigInteger(str);
        }
    }

    char lastChar = str.charAt(str.length() - 1);
    String mantissa = null;
    String decimal = null;
    String exponent = null;

    int decimalPos = str.indexOf('.');
    int exponentIndexE = str.indexOf('e');
    int exponentIndexEUpper = str.indexOf('E');
    int exponentPos = (exponentIndexE > -1) ? exponentIndexE : exponentIndexEUpper;

    if (decimalPos > -1) {
        if (exponentPos > -1) {
            if (exponentPos < decimalPos || exponentPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPos + 1, exponentPos);
            exponent = str.substring(exponentPos + 1);
        } else {
            decimal = str.substring(decimalPos + 1);
        }
        mantissa = str.substring(0, decimalPos);
    } else {
        if (exponentPos > -1) {
            if (exponentPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mantissa = str.substring(0, exponentPos);
            exponent = str.substring(exponentPos + 1);
        } else {
            mantissa = str;
        }
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        String numeric = str.substring(0, str.length() - 1); // Strip last char
        boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);

        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null
                        && (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!f.isInfinite() && (f.floatValue() != 0.0F || allZeros)) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    return createBigDecimal(numeric);
                }
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!d.isInfinite() && (d.doubleValue() != 0.0D || allZeros)) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    return createBigDecimal(numeric);
                }
        }
        throw new NumberFormatException(str + "" is not a valid number."");
    } else {
        if (decimal == null && exponent == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe2) {
                    return createBigInteger(str);
                }
            }
        } else {
            boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);
            try {
                Float f = createFloat(str);
                if (!f.isInfinite() && (f.floatValue() != 0.0F || allZeros)) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                try {
                    Double d = createDouble(str);
                    if (!d.isInfinite() && (d.doubleValue() != 0.0D || allZeros)) {
                        return d;
                    }
                } catch (NumberFormatException nfe2) {
                    return createBigDecimal(str);
                }
            }
        }
    }
    throw new NumberFormatException(str + "" is not a valid number."");
}",0,1
115,Lang_16,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
             // a wrong value.
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        try {
            return createBigInteger(str);
        } catch (NumberFormatException nfe) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    char lastChar = str.charAt(str.length() - 1);
    String mantissa = null;
    String decimal = null;
    String exponent = null;

    int decimalPos = str.indexOf('.');
    int exponentIndexE = str.indexOf('e');
    int exponentIndexEUpper = str.indexOf('E');
    int exponentPos = (exponentIndexE > -1) ? exponentIndexE : exponentIndexEUpper;

    if (decimalPos > -1) {
        if (exponentPos > -1) {
            if (exponentPos < decimalPos || exponentPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPos + 1, exponentPos);
            exponent = str.substring(exponentPos + 1);
        } else {
            decimal = str.substring(decimalPos + 1);
        }
        mantissa = str.substring(0, decimalPos);
    } else {
        if (exponentPos > -1) {
            if (exponentPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mantissa = str.substring(0, exponentPos);
            exponent = str.substring(exponentPos + 1);
        } else {
            mantissa = str;
        }
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        String numeric = str.substring(0, str.length() - 1); // Strip last char
        boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);

        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null
                        && (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!f.isInfinite() && (f.floatValue() != 0.0F || allZeros)) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException nfe2) {
                        throw new NumberFormatException(str + "" is not a valid number."");
                    }
                }
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!d.isInfinite() && (d.doubleValue() != 0.0D || allZeros)) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException nfe2) {
                        throw new NumberFormatException(str + "" is not a valid number."");
                    }
                }
        }
        throw new NumberFormatException(str + "" is not a valid number."");
    } else {
        if (decimal == null && exponent == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe2) {
                    try {
                        return createBigInteger(str);
                    } catch (NumberFormatException e) {
                        throw new NumberFormatException(str + "" is not a valid number."");
                    }
                }
            }
        } else {
            boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);
            try {
                Float f = createFloat(str);
                if (!f.isInfinite() && (f.floatValue() != 0.0F || allZeros)) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                try {
                    Double d = createDouble(str);
                    if (!d.isInfinite() && (d.doubleValue() != 0.0D || allZeros)) {
                        return d;
                    }
                } catch (NumberFormatException nfe2) {
                    try {
                        return createBigDecimal(str);
                    } catch (NumberFormatException e) {
                        throw new NumberFormatException(str + "" is not a valid number."");
                    }
                }
            }
        }
    }
    throw new NumberFormatException(str + "" is not a valid number."");
}",0,2
116,Lang_17,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
             return;
         }
         int pos = 0;
         int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
             else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                     if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                     } else {
                         pos++;
                     }
                 }
                 pos--;
             }
             pos++;
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = Character.codePointCount(input, 0, input.length());
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
        } else {
            for (int pt = 0; pt < consumed; pt++) {
                pos += Character.charCount(Character.codePointAt(input, pos));
            }
            pos--; // adjust because of the outer while loop increment
        }
        pos++;
    }
}",0,0
116,Lang_17,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
             return;
         }
         int pos = 0;
         int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
             else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                     if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                     } else {
                         pos++;
                     }
                 }
                 pos--;
             }
             pos++;
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            pos += Character.charCount(Character.codePointAt(input, pos));
        } else {
            pos += consumed;
        }
    }
}",0,1
116,Lang_17,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
             return;
         }
         int pos = 0;
         int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
             else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                     if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                     } else {
                         pos++;
                     }
                 }
                 pos--;
             }
             pos++;
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int codePoint = Character.codePointAt(input, pos);
        int consumed = translate(input, pos, out);
        
        if (consumed == 0) {
            char[] chars = Character.toChars(codePoint);
            out.write(chars);
            pos += chars.length; // move by the size of the written character(s)
        } else {
            pos += consumed; // move by the number of codepoints consumed
        }
    }
}",0,2
117,Lang_19,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
             while(input.charAt(end) != ';') 
             {
                 end++;
             }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;

        // Ensure there's enough characters remaining to process (prevent out of bounds)
        if (start >= seqEnd) {
            return 0;
        }

        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;

            // Check there's more than just an x after the &#
            if (start >= seqEnd) {
                return 0;
            }
        }

        int end = start;

        // Note that this supports character codes without a ; on the end
        while (end < seqEnd && input.charAt(end) != ';') {
            // Prevent out of bounds during the loop
            end++;
        }

        // Ensure that there was a valid terminating semicolon
        if (end >= seqEnd || input.charAt(end) != ';') {
            return 0;
        }

        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }

        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }

        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}",0,0
117,Lang_19,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
             while(input.charAt(end) != ';') 
             {
                 end++;
             }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    if (index >= seqEnd - 1 || input.charAt(index) != '&' || input.charAt(index + 1) != '#') {
        return 0;
    }

    int start = index + 2;
    boolean isHex = false;

    if (start < seqEnd && (input.charAt(start) == 'x' || input.charAt(start) == 'X')) {
        start++;
        isHex = true;
    }

    int end = start;
    while (end < seqEnd && input.charAt(end) != ';') {
        if (!Character.isDigit(input.charAt(end)) && (!isHex || !(Character.isDigit(input.charAt(end)) || ""abcdefABCDEF"".indexOf(input.charAt(end)) != -1))) {
            return 0;
        }
        end++;
    }

    if (end >= seqEnd || input.charAt(end) != ';') {
        return 0;
    }

    int entityValue;
    try {
        String numStr = input.subSequence(start, end).toString();
        entityValue = isHex ? Integer.parseInt(numStr, 16) : Integer.parseInt(numStr, 10);
    } catch (NumberFormatException nfe) {
        return 0;
    }

    if (entityValue > 0xFFFF) {
        char[] chrs = Character.toChars(entityValue);
        out.write(chrs[0]);
        out.write(chrs[1]);
    } else {
        out.write(entityValue);
    }

    return 2 + (end - start) + (isHex ? 1 : 0) + 1;
}",0,1
117,Lang_19,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
             while(input.charAt(end) != ';') 
             {
                 end++;
             }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();

    // Ensure proper boundary checks for the input
    if (index >= seqEnd - 1 || input.charAt(index) != '&' || input.charAt(index + 1) != '#') {
        return 0;
    }

    int start = index + 2;
    boolean isHex = false;

    // Handle hexadecimal cases
    if (start < seqEnd && (input.charAt(start) == 'x' || input.charAt(start) == 'X')) {
        start++;
        isHex = true;
    }

    int end = start;

    // Filter valid characters and avoid endless loops for unfinished entities
    while (end < seqEnd && input.charAt(end) != ';') {
        char current = input.charAt(end);
        boolean isValidChar = isHex ? (Character.isDigit(current) || ""abcdefABCDEF"".indexOf(current) != -1) : Character.isDigit(current);
        if (!isValidChar) {
            return 0;
        }
        end++;
    }

    // Handle case where semi-colon is missing
    if (end == seqEnd || input.charAt(end) != ';') {
        return 0;
    }

    int entityValue;
    try {
        String numStr = input.subSequence(start, end).toString();
        entityValue = isHex ? Integer.parseInt(numStr, 16) : Integer.parseInt(numStr, 10);
    } catch (NumberFormatException nfe) {
        return 0;
    }

    // Write the decoded character
    if (entityValue > 0xFFFF) {
        char[] chrs = Character.toChars(entityValue);
        out.write(chrs[0]);
        out.write(chrs[1]);
    } else {
        out.write(entityValue);
    }

    return 2 + (end - start) + (isHex ? 1 : 0) + 1;
}",0,2
118,Lang_21,"public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
        if (cal1 == null || cal2 == null) {
            throw new IllegalArgumentException(""The date must not be null"");
        }
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
                cal1.getClass() == cal2.getClass());
    }","public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
           cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
           cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
           cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && // Fixed: Use HOUR_OF_DAY to consider 24-hour time
           cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
           cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
           cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA);
}",0,0
119,Lang_22,"private static int greatestCommonDivisor(int u, int v) {
         // From Commons Math:
         //if either operand is abs 1, return 1:
         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
             return 1;
         }
         // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        if (u>0) { u=-u; } // make u negative
        if (v>0) { v=-v; } // make v negative
        // B1. [Find power of 2]
        int k=0;
        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...
            u/=2; v/=2; k++; // cast out twos.
        }
        if (k==31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        //     one is odd.
        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t&1)==0) { // while t is even..
                t/=2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t>0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u)/2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t!=0);
        return -u*(1<<k); // gcd is u*2^k
    }","private static int greatestCommonDivisor(int u, int v) {
    // Special case if either operand is 0
    if (u == 0 || v == 0) {
        return Math.abs(u + v); // return the non-zero value (or zero if both are zero)
    }

    // Ensure u and v are non-negative
    u = Math.abs(u);
    v = Math.abs(v);

    // Step 1: Find the common power of 2 for u and v
    int shift = 0;
    while ((u & 1) == 0 && (v & 1) == 0) { // both u and v are even
        u >>= 1; // divide u by 2
        v >>= 1; // divide v by 2
        shift++;
    }

    // Step 2: Make u odd
    while ((u & 1) == 0) {
        u >>= 1;
    }

    // Step 3: Process v
    while (v != 0) {
        while ((v & 1) == 0) { // v is even
            v >>= 1;
        }

        // Use subtraction method to find remainder
        if (u > v) {
            int temp = u;
            u = v;
            v = temp;
        }
        v = v - u; // v becomes the difference of v and u
    }

    // The result is u shifted back by the common power of 2
    return u << shift;
}",0,0
120,Lang_24,"public static boolean isNumber(String str) {
        if (StringUtils.isEmpty(str)) {
            return false;
        }
        char[] chars = str.toCharArray();
        int sz = chars.length;
        boolean hasExp = false;
        boolean hasDecPoint = false;
        boolean allowSigns = false;
        boolean foundDigit = false;
        // deal with any possible sign up front
        int start = (chars[0] == '-') ? 1 : 0;
        if (sz > start + 1) {
            if (chars[start] == '0' && chars[start + 1] == 'x') {
                int i = start + 2;
                if (i == sz) {
                    return false; // str == ""0x""
                }
                // checking hex (it can't be anything else)
                for (; i < chars.length; i++) {
                    if ((chars[i] < '0' || chars[i] > '9')
                        && (chars[i] < 'a' || chars[i] > 'f')
                        && (chars[i] < 'A' || chars[i] > 'F')) {
                        return false;
                    }
                }
                return true;
            }
        }
        sz--; // don't want to loop to the last char, check it afterwords
              // for type qualifiers
        int i = start;
        // loop to the next to last char or to the last char if we need another digit to
        // make a valid number (e.g. chars[0..5] = ""1234E"")
        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                foundDigit = true;
                allowSigns = false;

            } else if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent   
                    return false;
                }
                hasDecPoint = true;
            } else if (chars[i] == 'e' || chars[i] == 'E') {
                // we've already taken care of hex.
                if (hasExp) {
                    // two E's
                    return false;
                }
                if (!foundDigit) {
                    return false;
                }
                hasExp = true;
                allowSigns = true;
            } else if (chars[i] == '+' || chars[i] == '-') {
                if (!allowSigns) {
                    return false;
                }
                allowSigns = false;
                foundDigit = false; // we need a digit after the E
            } else {
                return false;
            }
            i++;
        }
        if (i < chars.length) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                // no type qualifier, OK
                return true;
            }
            if (chars[i] == 'e' || chars[i] == 'E') {
                // can't have an E at the last byte
                return false;
            }
            if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent
                    return false;
                }
                // single trailing decimal point after non-exponent is ok
                return foundDigit;
            }
            if (!allowSigns
                && (chars[i] == 'd'
                    || chars[i] == 'D'
                    || chars[i] == 'f'
                    || chars[i] == 'F')) {
                return foundDigit;
            }
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                 // not allowing L with an exponent or decimal point
                 return foundDigit && !hasExp;
             }
             // last character is illegal
             return false;
        }
        // allowSigns is true iff the val ends in 'E'
        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
        return !allowSigns && foundDigit;
    }","public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    // deal with any possible sign up front
    int start = (chars[0] == '-') ? 1 : 0;

    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                return false; // str == ""0x""
            }
            // checking hex (it can't be anything else)
            for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9')
                        && (chars[i] < 'a' || chars[i] > 'f')
                        && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }

    sz--; // don't want to loop to the last char, check it afterwords
          // for type qualifiers
    int i = start;

    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                return false; // two decimal points or dec in exponent
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            if (hasExp || !foundDigit) {
                return false; // two E's or E without a number before it
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false; // signs are only allowed after an E
            }
            allowSigns = false;
            foundDigit = false; // we need a digit after the E
        } else {
            return false;
        }
        i++;
    }

    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            return true; // no type qualifier, OK
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
            return false; // can't have an E at the last byte
        }
        if (chars[i] == '.') {
            return !hasExp && foundDigit; // single trailing decimal point after non-exponent is ok
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit; // allow type qualifiers if a number precedes them
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
            return foundDigit && !hasExp && !hasDecPoint; // not allowing L with exponent or decimal point
        }
        return false; // last character is illegal
    }

    return !allowSigns && foundDigit;
}",0,0
121,Lang_26,"    public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        c.setTime(date);
        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
    }
","public String format(Date date) {
    if (date == null) {
        throw new IllegalArgumentException(""Date cannot be null"");
    }
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}",0,0
121,Lang_26,"    public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        c.setTime(date);
        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
    }
","public String format(Date date) {
    if (date == null) {
        throw new IllegalArgumentException(""Date cannot be null"");
    }
    if (mTimeZone == null) {
        throw new IllegalStateException(""Time zone must be set before formatting"");
    }
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setLenient(false);
    try {
        c.setTime(date);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(""Invalid date provided: "" + e.getMessage(), e);
    }
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}",0,1
121,Lang_26,"    public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        c.setTime(date);
        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
    }
","public String format(Date date) {
    if (date == null) {
        throw new IllegalArgumentException(""Date cannot be null"");
    }
    if (mTimeZone == null) {
        throw new IllegalStateException(""Time zone must be set before formatting"");
    }

    Calendar c = new GregorianCalendar(mTimeZone);
    c.setLenient(false);
    c.setTime(date);

    // Ensure the week of year and year adjustments are consistent
    int weekOfYear = c.get(Calendar.WEEK_OF_YEAR);
    int year = c.get(Calendar.YEAR);

    // Handle edge case for week 53 falling into early January
    if (weekOfYear == 1 && c.get(Calendar.MONTH) == Calendar.DECEMBER) {
        year++;
    } else if (weekOfYear >= 52 && c.get(Calendar.MONTH) == Calendar.JANUARY) {
        year--;
    }
    c.set(Calendar.YEAR, year);

    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}",0,2
122,Lang_27,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

         if (decPos > -1) {
 
             if (expPos > -1) {
                 if (expPos < decPos) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        try {
            return createInteger(str);
        } catch (NumberFormatException nfe) {
            return createBigInteger(str);
        }
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec = null;
    String exp = null;
    int decPos = str.indexOf('.');
    int expPosE = str.indexOf('e');
    int expPosBigE = str.indexOf('E');
    int expPos = (expPosE > -1 ? expPosE : expPosBigE);

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
    }
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1);
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.startsWith(""-"") ? isDigits(numeric.substring(1)) : isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore and try the next type
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore and try the next type
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                // Ignore and try the next type
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
                // Ignore and try the next type
            }
            try {
                return createBigInteger(str);
            } catch (NumberFormatException nfe) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = NumberUtils.createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // Ignore and try the next type
            }
            try {
                Double d = NumberUtils.createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // Ignore and try the next type
            }
            try {
                return createBigDecimal(str);
            } catch (NumberFormatException nfe) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
        }
    }
}",0,0
123,Lang_28,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        // TODO: Protect from ArrayIndexOutOfBounds
        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;
            }

            int end = start;
            while(input.charAt(end) != ';') {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
                 return 0;
             }
 
                 out.write(entityValue);
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    // Ensure the index and boundaries are safe
    if (index < 0 || index >= input.length() - 2) {
        return 0;
    }

    if (input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;

        if (start >= input.length()) {
            return 0;
        }

        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
        }

        int end = start;
        while (end < input.length() && input.charAt(end) != ';') {
            end++;
        }

        // If no ';' was found or it's past the string length
        if (end >= input.length() || input.charAt(end) != ';') {
            return 0;
        }

        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            return 0;
        }

        out.write(entityValue);
        // Includes extra elements: `2` for ""&#"", length of digits, `1` for "";"" and optionally `1` for ""x""
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }

    return 0;
}",0,0
123,Lang_28,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        // TODO: Protect from ArrayIndexOutOfBounds
        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;
            }

            int end = start;
            while(input.charAt(end) != ';') {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
                 return 0;
             }
 
                 out.write(entityValue);
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    // Ensure index is within bounds
    if (index < 0 || index >= input.length() - 2) {
        return 0;
    }

    if (input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;

        // Early termination if bounds are exceeded
        if (start >= input.length()) {
            return 0;
        }

        boolean isHex = false;

        // Check for hexadecimal marker
        if (input.charAt(start) == 'x' || input.charAt(start) == 'X') {
            start++;
            isHex = true;

            // Ensure no out-of-bounds access after incrementing start
            if (start >= input.length()) {
                return 0;
            }
        }

        int end = start;

        // Locate the terminating ';', ensuring no IndexOutOfBoundsException
        while (end < input.length() && input.charAt(end) != ';') {
            end++;
        }

        // If no ';' found or bounds exceeded
        if (end >= input.length() || input.charAt(end) != ';') {
            return 0;
        }

        int entityValue;
        try {
            String numberSequence = input.subSequence(start, end).toString();

            // Prevent parsing empty sequences
            if (numberSequence.isEmpty()) {
                return 0;
            }

            entityValue = isHex ? Integer.parseInt(numberSequence, 16) : Integer.parseInt(numberSequence, 10);

            // Check for valid Unicode scalar values
            if (entityValue < 0 || entityValue > Character.MAX_CODE_POINT) {
                return 0;
            }
        } catch (NumberFormatException nfe) {
            return 0;
        }

        out.write(entityValue);

        // Correctly calculate return value based on parsed sequence
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }

    return 0;
}",0,1
123,Lang_28,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        // TODO: Protect from ArrayIndexOutOfBounds
        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;
            }

            int end = start;
            while(input.charAt(end) != ';') {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
                 return 0;
             }
 
                 out.write(entityValue);
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    // Ensure index is safe and within bounds
    if (index < 0 || index >= input.length() - 2) {
        return 0;
    }

    if (input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;

        // Check if the numeric entity is hexadecimal
        if (start < input.length() && (input.charAt(start) == 'x' || input.charAt(start) == 'X')) {
            start++;
            isHex = true;
        }

        int end = start;
        // Locate the terminating ';', ensuring valid bounds
        while (end < input.length() && input.charAt(end) != ';') {
            end++;
        }

        // Confirm presence and position of ';'
        if (end >= input.length() || input.charAt(end) != ';') {
            return 0;
        }

        int entityValue;
        try {
            String numberSequence = input.subSequence(start, end).toString();

            // Safeguard against parsing empty sequences
            if (numberSequence.isEmpty()) {
                return 0;
            }

            entityValue = isHex ? Integer.parseInt(numberSequence, 16) : Integer.parseInt(numberSequence, 10);

            // Validate Unicode scalar values
            if (entityValue < Character.MIN_CODE_POINT || entityValue > Character.MAX_CODE_POINT) {
                return 0;
            }

            // Write the character properly
            out.write(Character.toChars(entityValue));
        } catch (NumberFormatException | IOException e) {
            return 0;
        }

        // Correct return value based on parsed sequence
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }

    return 0;
}",0,2
124,Lang_29,"    static float toJavaVersionInt(String version) {
        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
    }
","static float toJavaVersionInt(String version) {
    if (version == null || version.isEmpty()) {
        throw new IllegalArgumentException(""Version string cannot be null or empty"");
    }
    int[] versionArray = toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);
    if (versionArray == null || versionArray.length == 0) {
        throw new IllegalArgumentException(""Invalid version format"");
    }
    return toVersionInt(versionArray);
}",0,0
124,Lang_29,"    static float toJavaVersionInt(String version) {
        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
    }
","static float toJavaVersionInt(String version) {
    if (version == null || version.isEmpty()) {
        throw new IllegalArgumentException(""Version string cannot be null or empty"");
    }

    // Normalize and validate version string format
    String normalizedVersion = version.trim();
    if (!normalizedVersion.matches(""\\d+(\\.\\d+)*"")) {
        throw new IllegalArgumentException(""Invalid version format: "" + normalizedVersion);
    }

    // Extract version components and compute the integer representation
    int[] versionArray = toJavaVersionIntArray(normalizedVersion, JAVA_VERSION_TRIM_SIZE);
    return versionArray.length > 0 ? toVersionInt(versionArray) : 0.0f;
}",0,1
124,Lang_29,"    static float toJavaVersionInt(String version) {
        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
    }
","static float toJavaVersionInt(String version) {
    if (version == null || version.isEmpty()) {
        throw new IllegalArgumentException(""Version string cannot be null or empty"");
    }

    try {
        // Normalize and filter invalid version strings
        String normalizedVersion = version.trim();
        if (!normalizedVersion.matches(""\\d+(\\.\\d+)*"")) {
            return 0.0f; // Return safe default for unexpected formats
        }

        // Extract version components
        int[] versionArray = toJavaVersionIntArray(normalizedVersion, JAVA_VERSION_TRIM_SIZE);

        // Ensure valid array length
        if (versionArray.length == 0) {
            return 0.0f; // Return safe default for empty arrays
        }

        // Compute integer representation
        return toVersionInt(versionArray);
    } catch (Exception e) {
        // Handle unexpected exceptions gracefully
        return 0.0f;
    }
}",0,2
125,Lang_3,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
            }
        }
        if (pfxLen > 0) { // we have a hex number
            final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16) { // too many for Long
                return createBigInteger(str);
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    // Need to deal with all possible hex prefixes here
    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int pfxLen = 0;
    for (final String pfx : hexPrefixes) {
        if (str.startsWith(pfx)) {
            pfxLen += pfx.length();
            break;
        }
    }
    if (pfxLen > 0) { // we have a hex number
        final int hexDigits = str.length() - pfxLen;
        if (hexDigits > 16) { // too many for Long
            return createBigInteger(str);
        }
        if (hexDigits > 8) { // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    final int expPos = str.indexOf('e') != -1 ? str.indexOf('e') : str.indexOf('E');
  
    int numDecimals = 0; // Check required precision (LANG-693)
    if (decPos > -1) { // there is a decimal point
        if (expPos > -1) { // there is an exponent
            if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) { // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l' :
            case 'L' :
                if (dec == null
                    && exp == null
                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f' :
            case 'F' :
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // If it's too big for a float or the float value = 0 and the string
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }

                } catch (final NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            case 'd' :
            case 'D' :
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) { // NOPMD
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            default :
                throw new NumberFormatException(str + "" is not a valid number."");

        }
    }
    // User doesn't have a preference on the return type, so let's start
    // small and go from there...
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1, str.length());
    } else {
        exp = null;
    }
    if (dec == null && exp == null) { // no decimal point and no exponent
        // Must be an Integer, Long, BigInteger
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        return createBigInteger(str);
    }

    // Must be a Float, Double, BigDecimal
    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        final Float f = createFloat(str);
        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
            return f;
        }
    } catch (final NumberFormatException nfe) { // NOPMD
        // ignore the bad number
    }
    try {
        final Double d = createDouble(str);
        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
            return d;
        }
    } catch (final NumberFormatException nfe) { // NOPMD
        // ignore the bad number
    }

    return createBigDecimal(str);
}",0,0
125,Lang_3,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
            }
        }
        if (pfxLen > 0) { // we have a hex number
            final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16) { // too many for Long
                return createBigInteger(str);
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null || StringUtils.isBlank(str)) {
        throw new NumberFormatException(""Invalid number format: string is null or blank"");
    }

    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    for (String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            try {
                return parseHexNumber(str, prefix);
            } catch (NumberFormatException e) {
                throw new NumberFormatException(""Invalid hex number: "" + str);
            }
        }
    }

    char lastChar = str.charAt(str.length() - 1);
    String mantissa, exponent = null;
    boolean hasExp = str.contains(""e"") || str.contains(""E"");
    boolean hasDec = str.contains(""."");
    
    int expIndex = str.indexOf(hasExp ? 'e' : hasExp ? 'E' : -1);
    int decIndex = str.indexOf('.');
    
    if (hasDec) {
        mantissa = str.substring(0, decIndex);
        exponent = (hasExp && expIndex > decIndex) ? str.substring(expIndex + 1) : null;
    } else {
        mantissa = hasExp ? str.substring(0, expIndex) : str;
        exponent = hasExp ? str.substring(expIndex + 1) : null;
    }
    
    return handleNumericType(str, mantissa, exponent, lastChar, hasDec);
}

private static Number parseHexNumber(final String str, final String prefix) throws NumberFormatException {
    int digits = str.length() - prefix.length();
    if (digits > 16) {
        return createBigInteger(str);
    }
    if (digits > 8) {
        return createLong(str);
    }
    return createInteger(str);
}

private static Number handleNumericType(String str, String mantissa, String exponent, char lastChar, boolean hasDec) {
    String numeric = Character.isDigit(lastChar) || lastChar == '.' ? str : str.substring(0, str.length() - 1);
    boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        switch (lastChar) {
            case 'l': case 'L': return createNumericType(mantissa, null, numeric, ""long"");
            case 'f': case 'F': return createNumericType(mantissa, allZeros, numeric, ""float"");
            case 'd': case 'D': return createNumericType(mantissa, allZeros, numeric, ""double"");
            default: throw new NumberFormatException(""Invalid number suffix: "" + lastChar);
        }
    }

    if (!hasDec && exponent == null) {
        return createNumericType(mantissa, null, numeric, ""integer"");
    } else {
        return createNumericType(mantissa, allZeros, numeric, ""floatdecimal"");
    }
}

private static Number createNumericType(String mantissa, Boolean allZeros, String numeric, String type) {
    try {
        switch (type) {
            case ""long"": return createLong(numeric);
            case ""integer"": return createInteger(numeric);
            case ""float"": {
                Float f = createFloat(numeric);
                if (!isInRange(f, allZeros)) return f;
            }
            case ""double"": {
                Double d = createDouble(numeric);
                if (!isInRange(d, allZeros)) return d;
            }
            case ""bigdecimal"": return createBigDecimal(numeric);
            default: throw new NumberFormatException(""Unexpected type: "" + type);
        }
    } catch (NumberFormatException e) {
        return switch (type) {
            case ""long"", ""integer"" -> createBigInteger(numeric);
            case ""float"", ""double"" -> createBigDecimal(numeric);
            default -> throw e;
        };
    }
}

private static boolean isInRange(Number n, Boolean allZeros) {
    return n instanceof Float &&
            (((Float) n).isInfinite() || (((Float) n).floatValue() == 0.0F && !Boolean.TRUE.equals(allZeros)))
            || n instanceof Double &&
            (((Double) n).isInfinite() || (((Double) n).doubleValue() == 0.0D && !Boolean.TRUE.equals(allZeros)));
}",0,1
126,Lang_31," public static boolean containsAny(CharSequence cs, char[] searchChars) {
  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
   return false;
  }
  int csLength = cs.length();
  int searchLength = searchChars.length;
  for (int i = 0; i < csLength; i++) {
   char ch = cs.charAt(i);
   for (int j = 0; j < searchLength; j++) {
    if (searchChars[j] == ch) {
      // ch is a supplementary character
      // ch is in the Basic Multilingual Plane
      return true;
    }
   }
  }
  return false;
 }","public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    for (int i = 0; i < csLength; i++) {
        int codePoint = Character.codePointAt(cs, i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == codePoint) {
                return true;
            }
        }
        if (Character.isSupplementaryCodePoint(codePoint)) {
            i++;
        }
    }
    return false;
}",0,0
126,Lang_31," public static boolean containsAny(CharSequence cs, char[] searchChars) {
  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
   return false;
  }
  int csLength = cs.length();
  int searchLength = searchChars.length;
  for (int i = 0; i < csLength; i++) {
   char ch = cs.charAt(i);
   for (int j = 0; j < searchLength; j++) {
    if (searchChars[j] == ch) {
      // ch is a supplementary character
      // ch is in the Basic Multilingual Plane
      return true;
    }
   }
  }
  return false;
 }",Match failed,0,1
127,Lang_33,"public static Class<?>[] toClass(Object[] array) {
        if (array == null) {
            return null;
        } else if (array.length == 0) {
            return ArrayUtils.EMPTY_CLASS_ARRAY;
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
             classes[i] = array[i].getClass();
         }
         return classes;
     }","public static Class<?>[] toClass(Object[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    Class<?>[] classes = new Class[array.length];
    for (int i = 0; i < array.length; i++) {
        if (array[i] != null) {
            classes[i] = array[i].getClass();
        } else {
            classes[i] = null;
        }
    }
    return classes;
}",0,0
128,Lang_37,"@SuppressWarnings(""unchecked"")
    public static <T> T[] addAll(T[] array1, T... array2) {
        if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
             // Check if problem is incompatible types
         return joinedArray;
     }","@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    final Class<?> type1 = array1.getClass().getComponentType();
    final Class<?> type2 = array2.getClass().getComponentType();
    if (!type1.isAssignableFrom(type2) && !type2.isAssignableFrom(type1)) {
        throw new IllegalArgumentException(""Cannot combine arrays of different types"");
    }
    T[] joinedArray = (T[]) Array.newInstance(type1.isAssignableFrom(type2) ? type1 : type2, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}",0,0
129,Lang_38,"public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
        return applyRules(calendar, buf);
    }","public StringBuffer format(Calendar calendar, StringBuffer buf) {
        if (mTimeZoneForced) {
            calendar = (Calendar) calendar.clone();
            calendar.setTimeZone(mTimeZone);
        }
        return applyRules(calendar, buf);
    }",0,0
129,Lang_38,"public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
        return applyRules(calendar, buf);
    }","public StringBuffer format(Calendar calendar, StringBuffer buf) {
        Calendar clonedCalendar = (Calendar) calendar.clone();
        if (mTimeZoneForced) {
            clonedCalendar.setTimeZone(mTimeZone);
        } else {
            // Consider system default time zone
            TimeZone defaultTimeZone = TimeZone.getDefault();
            clonedCalendar.setTimeZone(defaultTimeZone);
        }
        return applyRules(clonedCalendar, buf);
    }",0,1
129,Lang_38,"public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
        return applyRules(calendar, buf);
    }","public StringBuffer format(Calendar calendar, StringBuffer buf) {
    // Clone the calendar to preserve the original instance
    Calendar clonedCalendar = (Calendar) calendar.clone();
    // Apply forced time zone if required
    if (mTimeZoneForced) {
        clonedCalendar.setTimeZone(mTimeZone);
    }
    // Format and return the buffer
    return applyRules(clonedCalendar, buf);
}",0,2
130,Lang_39,"private static String replaceEach(String text, String[] searchList, String[] replacementList, 
                                      boolean repeat, int timeToLive) 
    {

        // mchyzer Performance note: This creates very few new objects (one major goal)
        // let me know if there are performance requests, we can create a harness to measure

        if (text == null || text.length() == 0 || searchList == null || 
            searchList.length == 0 || replacementList == null || replacementList.length == 0) 
        {
            return text;
        }

        // if recursing, this shouldnt be less than 0
        if (timeToLive < 0) {
            throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
        }

        int searchLength = searchList.length;
        int replacementLength = replacementList.length;

        // make sure lengths are ok, these need to be equal
        if (searchLength != replacementLength) {
            throw new IllegalArgumentException(""Search and Replace array lengths don't match: ""
                + searchLength
                + "" vs ""
                + replacementLength);
        }

        // keep track of which still have matches
        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];

        // index on index that the match was found
        int textIndex = -1;
        int replaceIndex = -1;
        int tempIndex = -1;

        // index of replace array that will replace the search string found
        // NOTE: logic duplicated below START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
                searchList[i].length() == 0 || replacementList[i] == null) 
            {
                continue;
            }
            tempIndex = text.indexOf(searchList[i]);

            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
        // NOTE: logic mostly below END

        // no search strings found, we are done
        if (textIndex == -1) {
            return text;
        }

        int start = 0;

        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
        int increase = 0;
 
         // count the replacement text elements that are larger than their corresponding text being replaced
         for (int i = 0; i < searchList.length; i++) {
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; // assume 3 matches
            }
        }
        // have upper-bound at 20% increase, then let Java take over
        increase = Math.min(increase, text.length() / 5);

        StringBuilder buf = new StringBuilder(text.length() + increase);

        while (textIndex != -1) {

            for (int i = start; i < textIndex; i++) {
                buf.append(text.charAt(i));
            }
            buf.append(replacementList[replaceIndex]);

            start = textIndex + searchList[replaceIndex].length();

            textIndex = -1;
            replaceIndex = -1;
            tempIndex = -1;
            // find the next earliest match
            // NOTE: logic mostly duplicated above START
            for (int i = 0; i < searchLength; i++) {
                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
                    searchList[i].length() == 0 || replacementList[i] == null) 
                {
                    continue;
                }
                tempIndex = text.indexOf(searchList[i], start);

                // see if we need to keep searching for this
                if (tempIndex == -1) {
                    noMoreMatchesForReplIndex[i] = true;
                } else {
                    if (textIndex == -1 || tempIndex < textIndex) {
                        textIndex = tempIndex;
                        replaceIndex = i;
                    }
                }
            }
            // NOTE: logic duplicated above END

        }
        int textLength = text.length();
        for (int i = start; i < textLength; i++) {
            buf.append(text.charAt(i));
        }
        String result = buf.toString();
        if (!repeat) {
            return result;
        }

        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
    }","private static String replaceEach(String text, String[] searchList, String[] replacementList, 
                                  boolean repeat, int timeToLive) 
{

    // mchyzer Performance note: This creates very few new objects (one major goal)
    // let me know if there are performance requests, we can create a harness to measure

    if (text == null || text.length() == 0 || searchList == null || 
        searchList.length == 0 || replacementList == null || replacementList.length == 0) 
    {
        return text;
    }

    // if recursing, this shouldnt be less than 0
    if (timeToLive < 0) {
        throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
    }

    int searchLength = searchList.length;
    int replacementLength = replacementList.length;

    // make sure lengths are ok, these need to be equal
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException(""Search and Replace array lengths don't match: ""
            + searchLength
            + "" vs ""
            + replacementLength);
    }

    // keep track of which still have matches
    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];

    // index on index that the match was found
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;

    // index of replace array that will replace the search string found
    // NOTE: logic duplicated below START
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
            searchList[i].length() == 0 || replacementList[i] == null) 
        {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);

        // see if we need to keep searching for this
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    // NOTE: logic mostly below END

    // no search strings found, we are done
    if (textIndex == -1) {
        return text;
    }

    int start = 0;

    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
    int increase = 0;

    // count the replacement text elements that are larger than their corresponding text being replaced
    for (int i = 0; i < searchLength; i++) {
        if (searchList[i] == null || replacementList[i] == null) {
            continue;
        }
        int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            increase += 3 * greater; // assume 3 matches
        }
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);

    StringBuilder buf = new StringBuilder(text.length() + increase);

    while (textIndex != -1) {

        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);

        start = textIndex + searchList[replaceIndex].length();

        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        // find the next earliest match
        // NOTE: logic mostly duplicated above START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
                searchList[i].length() == 0 || replacementList[i] == null) 
            {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);

            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
        // NOTE: logic duplicated above END

    }

    int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    String result = buf.toString();
    if (!repeat) {
        return result;
    }

    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}",0,0
131,Lang_40,"public static boolean containsIgnoreCase(String str, String searchStr) {
         if (str == null || searchStr == null) {
             return false;
         }
         return contains(str.toUpperCase(), searchStr.toUpperCase());
     }",Match failed,0,0
132,Lang_42,"public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
             char c = str.charAt(i);
             String entityName = this.entityName(c);
             if (entityName == null) {
                 if (c > 0x7F) {
                     writer.write(""&#"");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');
                } else {
                    writer.write(c);
                }
            } else {
                writer.write('&');
                writer.write(entityName);
                writer.write(';');
            }
        }
    }","public void escape(Writer writer, String str) throws IOException {
    int len = str.length();
    for (int i = 0; i < len; i++) {
        int codePoint = str.codePointAt(i);
        String entityName = this.entityName(codePoint);
        if (entityName == null) {
            if (Character.isSupplementaryCodePoint(codePoint)) {
                i++; // Skip the next character as it's part of the surrogate pair
            }
            if (codePoint > 0x7F) {
                writer.write(""&#"");
                writer.write(Integer.toString(codePoint, 10));
                writer.write(';');
            } else {
                writer.write((char) codePoint);
            }
        } else {
            writer.write('&');
            writer.write(entityName);
            writer.write(';');
        }
    }
}",0,0
133,Lang_43,"    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
            StringBuffer appendTo, boolean escapingOn) {
        int start = pos.getIndex();
        char[] c = pattern.toCharArray();
        if (escapingOn && c[start] == QUOTE) {
            return appendTo == null ? null : appendTo.append(QUOTE);
        }
        int lastHold = start;
        for (int i = pos.getIndex(); i < pattern.length(); i++) {
            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(
                        QUOTE);
                pos.setIndex(i + ESCAPED_QUOTE.length());
                lastHold = pos.getIndex();
                continue;
            }
            switch (c[pos.getIndex()]) {
            case QUOTE:
                next(pos);
                return appendTo == null ? null : appendTo.append(c, lastHold,
                        pos.getIndex() - lastHold);
            default:
                next(pos);
            }
        }
        throw new IllegalArgumentException(
                ""Unterminated quoted string at position "" + start);
    }
","private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
        StringBuffer appendTo, boolean escapingOn) {
    int start = pos.getIndex();
    char[] c = pattern.toCharArray();
    if (escapingOn && start < c.length && c[start] == QUOTE) {
        pos.setIndex(start + 1); // move the position forward to avoid infinite loop
        return appendTo == null ? null : appendTo.append(QUOTE);
    }
    int lastHold = start;
    for (int i = pos.getIndex(); i < pattern.length(); i++) {
        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
            appendTo.append(c, lastHold, i - lastHold).append(QUOTE);
            pos.setIndex(i + ESCAPED_QUOTE.length());
            lastHold = pos.getIndex();
            i = pos.getIndex() - 1; // adjust loop index to match updated position
            continue;
        }
        switch (c[i]) {
        case QUOTE:
            appendTo.append(c, lastHold, i - lastHold);
            pos.setIndex(i + 1); // move past the closing quote
            return appendTo;
        default:
            break;
        }
    }
    throw new IllegalArgumentException(
            ""Unterminated quoted string at position "" + start);
}",0,0
134,Lang_44,"    public static Number createNumber(String val) throws NumberFormatException {
        if (val == null) {
            return null;
        }
        if (val.length() == 0) {
            throw new NumberFormatException(""\""\"" is not a valid number."");
        }
        if (val.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
            return createInteger(val);
        }   
        char lastChar = val.charAt(val.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = val.indexOf('.');
        int expPos = val.indexOf('e') + val.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(val + "" is not a valid number."");
                }
                dec = val.substring(decPos + 1, expPos);
            } else {
                dec = val.substring(decPos + 1);
            }
            mant = val.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = val.substring(0, expPos);
            } else {
                mant = val;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = val.substring(0, val.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(val + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // empty catch
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // empty catch
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(val + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(val);
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createLong(val);
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                return createBigInteger(val);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(val);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    Double d = createDouble(val);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }

                return createBigDecimal(val);

            }

        }
    }
","public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = Math.max(val.indexOf('e'), val.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }

    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null 
                        && ((numeric.startsWith(""-"") && isDigits(numeric.substring(1))) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) { }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException e) { }
                // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) { }
                throw new NumberFormatException(val + "" is not a valid number."");
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1);
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) { }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) { }
            return createBigInteger(val);
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) { }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) { }
            return createBigDecimal(val);
        }
    }
}",0,0
135,Lang_45,"public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
        // initial parameter checks
        if (str == null) {
            return null;
        }
        if (str.length() == 0) {
            return StringUtils.EMPTY;
        }
 
         // if the lower value is greater than the length of the string,
         // set to the length of the string
         // if the upper value is -1 (i.e. no limit) or is greater
         // than the length of the string, set to the length of the string
         if (upper == -1 || upper > str.length()) {
            upper = str.length();
        }
        // if upper is less than lower, raise it to lower
        if (upper < lower) {
            upper = lower;
        }

        StringBuffer result = new StringBuffer();
        int index = StringUtils.indexOf(str, "" "", lower);
        if (index == -1) {
            result.append(str.substring(0, upper));
            // only if abbreviation has occured do we append the appendToEnd value
            if (upper != str.length()) {
                result.append(StringUtils.defaultString(appendToEnd));
            }
        } else if (index > upper) {
            result.append(str.substring(0, upper));
            result.append(StringUtils.defaultString(appendToEnd));
        } else {
            result.append(str.substring(0, index));
            result.append(StringUtils.defaultString(appendToEnd));
        }
        return result.toString();
    }","public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
    // initial parameter checks
    if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return StringUtils.EMPTY;
    }

    // Handle cases where lower or upper are out of bounds
    if (lower > str.length()) {
        lower = str.length();
    }
    if (upper == -1 || upper > str.length()) {
        upper = str.length();
    }
    if (upper < lower) {
        upper = lower;
    }

    // Check and adjust bounds for lower and upper
    lower = Math.max(0, lower);

    StringBuffer result = new StringBuffer();
    int index = StringUtils.indexOf(str, "" "", lower);
    if (index == -1 || index > upper) {
        result.append(str.substring(0, upper));
        // Append suffix only if abbreviation occurs
        if (upper < str.length()) {
            result.append(StringUtils.defaultString(appendToEnd));
        }
    } else {
        result.append(str.substring(0, index));
        result.append(StringUtils.defaultString(appendToEnd));
    }
    return result.toString();
}",0,0
136,Lang_49,"    public Fraction reduce() {
        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
        if (gcd == 1) {
            return this;
        }
        return Fraction.getFraction(numerator / gcd, denominator / gcd);
    }
","public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}",0,0
136,Lang_49,"    public Fraction reduce() {
        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
        if (gcd == 1) {
            return this;
        }
        return Fraction.getFraction(numerator / gcd, denominator / gcd);
    }
","public Fraction reduce() {
    if (denominator == 0) {
        throw new ArithmeticException(""Denominator cannot be zero"");
    }
    if (numerator == 0) {
        return Fraction.getFraction(0, 1);
    }
    int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}",0,1
136,Lang_49,"    public Fraction reduce() {
        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
        if (gcd == 1) {
            return this;
        }
        return Fraction.getFraction(numerator / gcd, denominator / gcd);
    }
","public Fraction reduce() {
    if (denominator == 0) {
        throw new ArithmeticException(""Denominator cannot be zero"");
    }
    if (numerator == 0) {
        return Fraction.getFraction(0, 1);
    }

    int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));
    int reducedNumerator = numerator / gcd;
    int reducedDenominator = denominator / gcd;

    if (reducedDenominator < 0) {
        reducedNumerator = -reducedNumerator;
        reducedDenominator = -reducedDenominator;
    }

    return Fraction.getFraction(reducedNumerator, reducedDenominator);
}",0,2
137,Lang_5,"public static Locale toLocale(final String str) {
        if (str == null) {
            return null;
        }
        final int len = str.length();
        if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 2) {
                return new Locale(str);
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            }
            if (len < 7) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }","public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 3) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    if (ch3 == '_') {
        return new Locale(str.substring(0, 2), """", str.substring(4));
    }
    if (len < 5) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    if (len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",0,0
137,Lang_5,"public static Locale toLocale(final String str) {
        if (str == null) {
            return null;
        }
        final int len = str.length();
        if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 2) {
                return new Locale(str);
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            }
            if (len < 7) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }","public static Locale toLocale(final String str) {
    if (str == null) {
        throw new IllegalArgumentException(""Invalid locale format: null"");
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 3) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    if (ch3 == '_') {
        if (len == 4) {
            return new Locale(str.substring(0, 2), """");
        }
        return new Locale(str.substring(0, 2), """", str.substring(4));
    }
    if (len < 5) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    if (len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 6) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",0,1
137,Lang_5,"public static Locale toLocale(final String str) {
        if (str == null) {
            return null;
        }
        final int len = str.length();
        if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 2) {
                return new Locale(str);
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            }
            if (len < 7) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }","public static Locale toLocale(final String str) {
    if (str == null || str.isEmpty()) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }

    if (str.charAt(0) == '_') {
        // Special case: ""_GB"" or ""_GB_EURO""
        if (len < 4) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (str.charAt(1) == '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        final char ch3 = str.charAt(3);
        if (ch3 == '_') {
            if (len == 4) {
                return new Locale("""", str.substring(1, 3));
            } else {
                return new Locale("""", str.substring(1, 3), str.substring(4));
            }
        } else if (len == 3) {
            return new Locale("""", str.substring(1, 3));
        }
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }

    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 3 || len == 4) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    if (len < 7 || str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",0,2
138,Lang_51,"public static boolean toBoolean(String str) {
        // Previously used equalsIgnoreCase, which was fast for interned 'true'.
        // Non interned 'true' matched 15 times slower.
        // 
        // Optimisation provides same performance as before for interned 'true'.
        // Similar performance for null, 'false', and other strings not length 2/3/4.
        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
        if (str == ""true"") {
            return true;
        }
        if (str == null) {
            return false;
        }
        switch (str.length()) {
            case 2: {
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                return 
                    (ch0 == 'o' || ch0 == 'O') &&
                    (ch1 == 'n' || ch1 == 'N');
            }
            case 3: {
                char ch = str.charAt(0);
                if (ch == 'y') {
                    return 
                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
                        (str.charAt(2) == 's' || str.charAt(2) == 'S');
                }
                if (ch == 'Y') {
                    return 
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
             }
             case 4: {
                 char ch = str.charAt(0);
                if (ch == 't') {
                    return 
                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&
                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&
                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');
                }
                if (ch == 'T') {
                    return 
                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&
                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&
                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');
                }
            }
        }
        return false;
    }","public static boolean toBoolean(String str) {
    if (str == null) {
        return false;
    }
    String lowercaseStr = str.toLowerCase();
    switch (lowercaseStr) {
        case ""true"":
        case ""on"":
        case ""yes"":
            return true;
        default:
            return false;
    }
}",0,0
139,Lang_52,"private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (str == null) {
            return;
        }
        int sz;
        sz = str.length();
        for (int i = 0; i < sz; i++) {
            char ch = str.charAt(i);

            // handle unicode
            if (ch > 0xfff) {
                out.write(""\\u"" + hex(ch));
            } else if (ch > 0xff) {
                out.write(""\\u0"" + hex(ch));
            } else if (ch > 0x7f) {
                out.write(""\\u00"" + hex(ch));
            } else if (ch < 32) {
                switch (ch) {
                    case '\b':
                        out.write('\\');
                        out.write('b');
                        break;
                    case '\n':
                        out.write('\\');
                        out.write('n');
                        break;
                    case '\t':
                        out.write('\\');
                        out.write('t');
                        break;
                    case '\f':
                        out.write('\\');
                        out.write('f');
                        break;
                    case '\r':
                        out.write('\\');
                        out.write('r');
                        break;
                    default :
                        if (ch > 0xf) {
                            out.write(""\\u00"" + hex(ch));
                        } else {
                            out.write(""\\u000"" + hex(ch));
                        }
                        break;
                }
            } else {
                switch (ch) {
                    case '\'':
                        if (escapeSingleQuote) {
                          out.write('\\');
                        }
                        out.write('\'');
                        break;
                    case '""':
                        out.write('\\');
                        out.write('""');
                        break;
                    case '\\':
                         out.write('\\');
                         out.write('\\');
                         break;
                     default :
                         out.write(ch);
                         break;
                }
            }
        }
    }","private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (str == null) {
        return;
    }

    int sz = str.length();
    for (int i = 0; i < sz; i++) {
        char ch = str.charAt(i);

        // handle unicode
        if (ch > 0xfff) {
            out.write(""\\u"" + hex(ch));
        } else if (ch > 0xff) {
            out.write(""\\u0"" + hex(ch));
        } else if (ch > 0x7f) {
            out.write(""\\u00"" + hex(ch));
        } else if (ch < 32) {
            switch (ch) {
                case '\b':
                    out.write('\\');
                    out.write('b');
                    break;
                case '\n':
                    out.write('\\');
                    out.write('n');
                    break;
                case '\t':
                    out.write('\\');
                    out.write('t');
                    break;
                case '\f':
                    out.write('\\');
                    out.write('f');
                    break;
                case '\r':
                    out.write('\\');
                    out.write('r');
                    break;
                default:
                    if (ch > 0xf) {
                        out.write(""\\u00"" + hex(ch));
                    } else {
                        out.write(""\\u000"" + hex(ch));
                    }
                    break;
            }
        } else {
            switch (ch) {
                case '\'':
                    if (escapeSingleQuote) {
                        out.write('\\');
                    }
                    out.write('\'');
                    break;
                case '""':
                    out.write('\\');
                    out.write('""');
                    break;
                case '\\':
                    out.write('\\');
                    out.write('\\');
                    break;
                default:
                    if (Character.isISOControl(ch)) {
                        if (ch > 0xf) {
                            out.write(""\\u00"" + hex(ch));
                        } else {
                            out.write(""\\u000"" + hex(ch));
                        }
                    } else {
                        out.write(ch);
                    }
                    break;
            }
        }
    }
}

private static String hex(char ch) {
    return Integer.toHexString(ch).toUpperCase();
}",0,0
140,Lang_53,"private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        
        if (field == Calendar.MILLISECOND) {
            return;
        }

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.

        Date date = val.getTime();
        long time = date.getTime();
        boolean done = false;

        // truncate milliseconds
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
         if (field == Calendar.SECOND) {
             done = true;
             }
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
         if (field == Calendar.MINUTE) {
             done = true;
             }
         }
 
         // truncate minutes
        int minutes = val.get(Calendar.MINUTE);
        if (!done && (!round || minutes < 30)) {
            time = time - (minutes * 60000L);
        }

        // reset time
        if (date.getTime() != time) {
            date.setTime(time);
            val.setTime(date);
        }
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
            if (offset != 0) {
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
            }
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }

    if (field == Calendar.MILLISECOND) {
        return;
    }

    // ----------------- Fix for LANG-59 ---------------------- START ---------------
    Date date = val.getTime();
    long time = date.getTime();
    boolean done = false;

    // truncate milliseconds
    int millisecs = val.get(Calendar.MILLISECOND);
    if (!round || millisecs < 500) {
        time = time - millisecs;
    }
    if (field == Calendar.SECOND) {
        done = true;
    }

    // truncate seconds
    int seconds = val.get(Calendar.SECOND);
    if (!done && (!round || seconds < 30)) {
        time = time - (seconds * 1000L);
    }
    if (field == Calendar.MINUTE) {
        done = true;
    }

    // truncate minutes
    int minutes = val.get(Calendar.MINUTE);
    if (!done && (!round || minutes < 30)) {
        time = time - (minutes * 60000L);
    }

    // reset time
    if (date.getTime() != time) {
        date.setTime(time);
        val.setTime(date);
    }
    // ----------------- Fix for LANG-59 ----------------------- END ----------------

    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }

        int offset = 0;
        boolean offsetSet = false;
        switch (field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    offset = val.get(Calendar.DATE) - 1;
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            offset = val.get(fields[i][0]) - min;
            roundUp = offset > ((max - min) / 2);
        }
        if (offset != 0) {
            val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
    }

    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}",0,0
141,Lang_54,"public static Locale toLocale(String str) {
        if (str == null) {
            return null;
        }
        int len = str.length();
        if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch0 = str.charAt(0);
        char ch1 = str.charAt(1);
        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 2) {
            return new Locale(str, """");
        } else {
            if (str.charAt(2) != '_') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException(""Invalid locale format: "" + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }
    }","public static Locale toLocale(String str) {
    if (str == null) {
        return null;
    }
    int len = str.length();
    if (len != 2 && len != 5 && len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    char ch0 = str.charAt(0);
    char ch1 = str.charAt(1);
    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str, """");
    } else {
        if (str.charAt(2) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch3 = str.charAt(3);
        if (len == 5) {
            char ch4 = str.charAt(4);
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5));
        } else {
            if (ch3 != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
        }
    }
}",0,0
141,Lang_54,"public static Locale toLocale(String str) {
        if (str == null) {
            return null;
        }
        int len = str.length();
        if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch0 = str.charAt(0);
        char ch1 = str.charAt(1);
        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 2) {
            return new Locale(str, """");
        } else {
            if (str.charAt(2) != '_') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException(""Invalid locale format: "" + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }
    }","public static Locale toLocale(String str) {
    if (str == null) {
        return null;
    }
    int len = str.length();
    if (len != 2 && len != 5 && len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    char ch0 = str.charAt(0);
    char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str, """");
    } else {
        if (str.charAt(2) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch3 = str.charAt(3);
        if (len == 5) {
            char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5));
        } else {
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            String variant = str.substring(6);
            if (variant.isEmpty() || variant.chars().anyMatch(c -> c == ' ' || c == '#')) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), variant);
        }
    }
}",0,1
142,Lang_55,"public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
             stopTime = System.currentTimeMillis();
         this.runningState = STATE_STOPPED;
     }","public void stop() {
    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch is not currently running."");
    }
    this.stopTime = System.currentTimeMillis();
    this.runningState = STATE_STOPPED;
}",0,0
142,Lang_55,"public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
             stopTime = System.currentTimeMillis();
         this.runningState = STATE_STOPPED;
     }","public void stop() {
    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch must be running or suspended to stop."");
    }

    synchronized (this) {
        if (this.runningState == STATE_RUNNING || this.runningState == STATE_SUSPENDED) {
            this.stopTime = System.currentTimeMillis();
            this.runningState = STATE_STOPPED;
        }
    }
}",0,1
142,Lang_55,"public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
             stopTime = System.currentTimeMillis();
         this.runningState = STATE_STOPPED;
     }","public void stop() {
    synchronized (this) {
        if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
            throw new IllegalStateException(""Stopwatch must be running or suspended to stop."");
        }
        if (this.runningState == STATE_RUNNING || this.runningState == STATE_SUSPENDED) {
            this.stopTime = System.currentTimeMillis();
            this.runningState = STATE_STOPPED;
        }
    }
}",0,2
143,Lang_57,"    public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
    }
","public static boolean isAvailableLocale(Locale locale) {
    if (locale == null) {
        return false;
    }
    return cAvailableLocaleSet.contains(locale);
}",0,0
143,Lang_57,"    public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
    }
","public static boolean isAvailableLocale(Locale locale) {
    if (locale == null || locale.getLanguage() == null || locale.getLanguage().isEmpty()) {
        return false;
    }
    if (locale.getCountry() != null && locale.getCountry().isEmpty() && locale.getVariant() != null && !locale.getVariant().isEmpty()) {
        return false; // Invalid combination of country and variant
    }
    return cAvailableLocaleSet.contains(locale);
}",0,1
143,Lang_57,"    public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
    }
","public static boolean isAvailableLocale(Locale locale) {
    if (locale == null) {
        return false;
    }
    String language = locale.getLanguage();
    if (language == null || language.isEmpty()) {
        return false; // Ensure valid language
    }
    String country = locale.getCountry();
    String variant = locale.getVariant();
    if (country != null && country.isEmpty() && variant != null && !variant.isEmpty()) {
        return false; // Invalid combination of empty country and non-empty variant
    }
    return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale);
}",0,2
144,Lang_58,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                 case 'L' :
                     if (dec == null
                         && exp == null
                         && isDigits(numeric.substring(1))
                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec = null;
    String exp = null;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
    }

    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!(f.isInfinite() || (f == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore
                }
                // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!(d.isInfinite() || (d == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException nfe) {
                    // Ignore
                }
                // Fall through
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            return createBigInteger(str);
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            return createBigDecimal(str);
        }
    }
}",0,0
144,Lang_58,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                 case 'L' :
                     if (dec == null
                         && exp == null
                         && isDigits(numeric.substring(1))
                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant, dec = null, exp = null;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
    }

    boolean allZeros = isAllZeros(mant);
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1);
        allZeros = allZeros && isAllZeros(exp);
    }

    if (!Character.isDigit(lastChar)) {
        String numeric = str.substring(0, str.length() - 1);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!f.isInfinite() && !(f == 0.0F && !allZeros)) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore
                }
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!d.isInfinite() && !(d == 0.0D && !allZeros)) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException nfe) {
                    // Ignore
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            return createBigInteger(str);
        } else {
            try {
                Float f = createFloat(str);
                if (!f.isInfinite() && !(f == 0.0F && !allZeros)) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            try {
                Double d = createDouble(str);
                if (!d.isInfinite() && !(d == 0.0D && !allZeros)) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            return createBigDecimal(str);
        }
    }
}",0,1
144,Lang_58,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                 case 'L' :
                     if (dec == null
                         && exp == null
                         && isDigits(numeric.substring(1))
                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mantissa, decimal = null, exponent = null;
    int decimalPos = str.indexOf('.');
    int exponentPos = str.indexOf('e') > -1 ? str.indexOf('e') : str.indexOf('E');

    if (decimalPos > -1) {
        if (exponentPos > -1 && exponentPos < decimalPos) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }
        if (decimalPos < str.length() - 1) {
            decimal = exponentPos > -1 ? str.substring(decimalPos + 1, exponentPos) : str.substring(decimalPos + 1);
        }
        mantissa = str.substring(0, decimalPos);
    } else {
        mantissa = exponentPos > -1 ? str.substring(0, exponentPos) : str;
    }

    if (exponentPos > -1 && exponentPos < str.length() - 1) {
        exponent = str.substring(exponentPos + 1);
    }

    boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);

    if (!Character.isDigit(lastChar)) {
        String numeric = str.substring(0, str.length() - 1);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = createFloat(numeric);
                    if (!f.isInfinite() && !(f == 0.0F && !allZeros)) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore
                }
                // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = createDouble(numeric);
                    if (!d.isInfinite() && !(d == 0.0D && !allZeros)) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException nfe) {
                    // Ignore
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (decimal == null && exponent == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            return createBigInteger(str);
        } else {
            try {
                Float f = createFloat(str);
                if (!f.isInfinite() && !(f == 0.0F && !allZeros)) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            try {
                Double d = createDouble(str);
                if (!d.isInfinite() && !(d == 0.0D && !allZeros)) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // Ignore
            }
            return createBigDecimal(str);
        }
    }
}",0,2
145,Lang_59,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
        if (width > 0) {
            ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, strLen, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
                for (int i = 0; i < padLen; i++) {
                    buffer[size + strLen + i] = padChar;
                }
            }
            size += width;
        }
        return this;
    }","public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = str.length();
        if (strLen >= width) {
            str.getChars(0, width, buffer, size);
        } else {
            str.getChars(0, strLen, buffer, size);
            for (int i = 0; i < width - strLen; i++) {
                buffer[size + strLen + i] = padChar;
            }
        }
        size += width;
    }
    return this;
}",0,0
146,Lang_6,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
            return;
        }
        int pos = 0;
        int len = input.length();
        while (pos < len) {
            int consumed = translate(input, pos, out);
            if (consumed == 0) {
                char[] c = Character.toChars(Character.codePointAt(input, pos));
                out.write(c);
                pos+= c.length;
                continue;
            }
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            pos += c.length;
            continue;
        }
        pos += consumed; // Fix: directly increment pos by consumed value instead of looping

    }
}",0,0
146,Lang_6,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
            return;
        }
        int pos = 0;
        int len = input.length();
        while (pos < len) {
            int consumed = translate(input, pos, out);
            if (consumed == 0) {
                char[] c = Character.toChars(Character.codePointAt(input, pos));
                out.write(c);
                pos+= c.length;
                continue;
            }
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }",Match failed,0,1
147,Lang_61,"public int indexOf(String str, int startIndex) {
        startIndex = (startIndex < 0 ? 0 : startIndex);
        if (str == null || startIndex >= size) {
            return -1;
        }
        int strLen = str.length();
        if (strLen == 1) {
            return indexOf(str.charAt(0), startIndex);
        }
        if (strLen == 0) {
            return startIndex;
        }
        if (strLen > size) {
             return -1;
         }
         char[] thisBuf = buffer;
         int len = thisBuf.length - strLen;
         outer:
         for (int i = startIndex; i < len; i++) {
             for (int j = 0; j < strLen; j++) {
                if (str.charAt(j) != thisBuf[i + j]) {
                    continue outer;
                }
            }
            return i;
        }
        return -1;
    }","public int indexOf(String str, int startIndex) {
    startIndex = Math.max(startIndex, 0); // Ensure startIndex is non-negative
    if (str == null || startIndex >= size) {
        return -1;
    }
    int strLen = str.length();
    if (strLen == 1) {
        return indexOf(str.charAt(0), startIndex);
    }
    if (strLen == 0) {
        return startIndex;
    }
    if (strLen > size) { // Ensure strLen isn't larger than the size of the buffer
        return -1;
    }
    char[] thisBuf = buffer;
    int len = size - strLen; // Limit to the correct length of the buffer minus the searched string length
    outer:
    for (int i = startIndex; i <= len; i++) { // Adjust loop to be <= len
        for (int j = 0; j < strLen; j++) {
            if (str.charAt(j) != thisBuf[i + j]) {
                continue outer;
            }
        }
        return i; // Return the start index of the found substring
    }
    return -1; // Return -1 if the substring isn't found
}",0,0
148,Lang_65,"    private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.


        // truncate milliseconds

        // truncate seconds

        // truncate minutes

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }
","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    
    val.set(Calendar.MILLISECOND, 0);

    val.set(Calendar.SECOND, 0);

    val.set(Calendar.MINUTE, 0);

    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }
        int offset = 0;
        boolean offsetSet = false;
        switch (field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    offset = val.get(Calendar.DATE) - 1;
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            offset = val.get(fields[i][0]) - min;
            roundUp = offset > ((max - min) / 2);
        }
        val.set(fields[i][0], val.get(fields[i][0]) - offset);
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}",0,0
148,Lang_65,"    private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.


        // truncate milliseconds

        // truncate seconds

        // truncate minutes

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }
","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }

    // Ensure milliseconds, seconds, and minutes are reset for rounding
    val.set(Calendar.MILLISECOND, 0);
    val.set(Calendar.SECOND, 0);
    val.set(Calendar.MINUTE, 0);
    
    boolean fieldFound = false;
    boolean roundUp = false;
    int offset = 0;

    for (int i = 0; i < fields.length; i++) {
        if (fieldFound) break;  // Stop iterating once the field is found

        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                fieldFound = true;
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        val.add(fields[i][0], 1);
                    }
                }
                break;
            }
        }

        if (!fieldFound) {
            switch (fields[i][0]) {
                case Calendar.DATE:
                    if (field == DateUtils.SEMI_MONTH) {
                        offset = val.get(Calendar.DATE) - 1;
                        if (offset >= 15) { offset -= 15; }
                        roundUp = offset > 7;
                    }
                    break;
                case Calendar.HOUR_OF_DAY:
                    if (field == Calendar.AM_PM) {
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) { offset -= 12; }
                        roundUp = offset > 6;
                    }
                    break;
                default:
                    int min = val.getActualMinimum(fields[i][0]);
                    int max = val.getActualMaximum(fields[i][0]);
                    offset = val.get(fields[i][0]) - min;
                    roundUp = offset > ((max - min) / 2);
                    break;
            }
            val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
    }

    if (!fieldFound) {
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
    }
}",0,1
148,Lang_65,"    private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.


        // truncate milliseconds

        // truncate seconds

        // truncate minutes

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }
","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    
    val.set(Calendar.MILLISECOND, 0);
    val.set(Calendar.SECOND, 0);
    val.set(Calendar.MINUTE, 0);

    boolean roundUp = false;
    boolean fieldFound = false;
    int offset = 0;

    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                fieldFound = true;

                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }

        if (fieldFound) {
            break;
        }

        switch (fields[i][0]) {
            case Calendar.DATE:
                if (field == DateUtils.SEMI_MONTH) {
                    offset = val.get(Calendar.DATE) - 1;
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    roundUp = offset > 7;
                }
                break;
            case Calendar.HOUR_OF_DAY:
                if (field == Calendar.AM_PM) {
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                }
                break;
            default:
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                offset = val.get(fields[i][0]) - min;
                roundUp = offset > ((max - min) / 2);
                break;
        }
        
        val.set(fields[i][0], val.get(fields[i][0]) - offset);
    }

    if (!fieldFound) {
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
    }
}",0,2
149,Lang_9,"private void init() {
        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex= new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher= formatPattern.matcher(pattern);
        if(!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField= patternMatcher.group();
        Strategy currentStrategy= getStrategy(currentFormatField);
        for(;;) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if(!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField= patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if(currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
        currentFormatField= null;
        strategies= collector.toArray(new Strategy[collector.size()]);
        parsePattern= Pattern.compile(regex.toString());
    }","private void init() {
    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();

    StringBuilder regex = new StringBuilder();
    List<Strategy> collector = new ArrayList<Strategy>();

    Matcher patternMatcher = formatPattern.matcher(pattern);
    if (!patternMatcher.matches()) {
        throw new IllegalArgumentException(""Invalid pattern"");
    }

    patternMatcher.reset();
    while (patternMatcher.find()) {
        currentFormatField = patternMatcher.group();
        Strategy currentStrategy = getStrategy(currentFormatField);
        
        if (currentStrategy.addRegex(this, regex)) {
            collector.add(currentStrategy);
        }
    }

    strategies = collector.toArray(new Strategy[collector.size()]);
    parsePattern = Pattern.compile(regex.toString());
}",0,0
149,Lang_9,"private void init() {
        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex= new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher= formatPattern.matcher(pattern);
        if(!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField= patternMatcher.group();
        Strategy currentStrategy= getStrategy(currentFormatField);
        for(;;) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if(!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField= patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if(currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
        currentFormatField= null;
        strategies= collector.toArray(new Strategy[collector.size()]);
        parsePattern= Pattern.compile(regex.toString());
    }","private void init() {
    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);
    
    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();

    StringBuilder regex = new StringBuilder();
    List<Strategy> collector = new ArrayList<Strategy>();

    Matcher patternMatcher = formatPattern.matcher(pattern);
    if (!patternMatcher.lookingAt()) {
        throw new IllegalArgumentException(""Invalid pattern"");
    }

    while (patternMatcher.find()) {
        currentFormatField = patternMatcher.group();
        Strategy currentStrategy = getStrategy(currentFormatField);
        
        if (currentStrategy.addRegex(this, regex)) {
            collector.add(currentStrategy);
        }

        patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
    }

    currentFormatField = null;
    
    strategies = collector.toArray(new Strategy[collector.size()]);
    parsePattern = Pattern.compile(regex.toString());
}",0,1
149,Lang_9,"private void init() {
        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex= new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher= formatPattern.matcher(pattern);
        if(!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField= patternMatcher.group();
        Strategy currentStrategy= getStrategy(currentFormatField);
        for(;;) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if(!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField= patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if(currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
        currentFormatField= null;
        strategies= collector.toArray(new Strategy[collector.size()]);
        parsePattern= Pattern.compile(regex.toString());
    }","private void init() {
    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();

    StringBuilder regex = new StringBuilder();
    List<Strategy> collector = new ArrayList<Strategy>();

    Matcher patternMatcher = formatPattern.matcher(pattern);

    while (patternMatcher.find()) {
        currentFormatField = patternMatcher.group();
        Strategy currentStrategy = getStrategy(currentFormatField);
        if(currentStrategy.addRegex(this, regex)) {
            collector.add(currentStrategy);
        }
    }

    if (regex.length() == 0) {
        throw new IllegalArgumentException(""Invalid pattern"");
    }

    currentFormatField = null;

    strategies = collector.toArray(new Strategy[collector.size()]);
    parsePattern = Pattern.compile(regex.toString());
}",0,2
150,Math_10,"public void atan2(final double[] y, final int yOffset,
                      final double[] x, final int xOffset,
                      final double[] result, final int resultOffset) {

        // compute r = sqrt(x^2+y^2)
        double[] tmp1 = new double[getSize()];
        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
        double[] tmp2 = new double[getSize()];
        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)

        if (x[xOffset] >= 0) {

            // compute atan2(y, x) = 2 atan(y / (r + x))
            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
            for (int i = 0; i < tmp2.length; ++i) {
                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
            }

        } else {

            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
            result[resultOffset] =
                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
            for (int i = 1; i < tmp2.length; ++i) {
                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))
            }

         }
 
         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
 
     }","public void atan2(final double[] y, final int yOffset,
                      final double[] x, final int xOffset,
                      final double[] result, final int resultOffset) {

        // compute r = sqrt(x^2+y^2)
        double[] tmp1 = new double[getSize()];
        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
        double[] tmp2 = new double[getSize()];
        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)

        if (x[xOffset] >= 0) {

            // compute atan2(y, x) = 2 atan(y / (r + x))
            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
            for (int i = 0; i < tmp2.length; ++i) {
                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
            }

        } else {

            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
            result[resultOffset] =
                    ((y[yOffset] < 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
            for (int i = 1; i < tmp2.length; ++i) {
                result[resultOffset + i] = -2 * tmp2[i]; // -2 * atan(y / (r - x))
            }

        }

        // handle special cases
        if (x[xOffset] == 0 && y[yOffset] == 0) {
            result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);
            for (int i = 1; i < result.length; ++i) {
                result[resultOffset + i] = 0.0; // set higher derivatives to zero
            }
        }

    }",0,0
151,Math_101,"public Complex parse(String source, ParsePosition pos) {
        int initialIndex = pos.getIndex();

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse real
        Number re = parseNumber(source, getRealFormat(), pos);
        if (re == null) {
            // invalid real number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse sign
        int startIndex = pos.getIndex();
        char c = parseNextCharacter(source, pos);
        int sign = 0;
        switch (c) {
        case 0 :
            // no sign
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-' :
            sign = -1;
            break;
        case '+' :
            sign = 1;
            break;
        default :
            // invalid sign
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse imaginary
        Number im = parseNumber(source, getRealFormat(), pos);
        if (im == null) {
            // invalid imaginary number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse imaginary character
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
         if (
             source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             // set index back to initial, error index should be the start index
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }
        pos.setIndex(endIndex);

        return new Complex(re.doubleValue(), im.doubleValue() * sign);
    }","public Complex parse(String source, ParsePosition pos) {
    int initialIndex = pos.getIndex();

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse real
    Number re = parseNumber(source, getRealFormat(), pos);
    if (re == null) {
        // invalid real number
        // set index back to initial, error index should already be set
        pos.setIndex(initialIndex);
        return null;
    }

    // parse sign
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    int sign = 0;
    switch (c) {
        case 0:
            // no sign
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-':
            sign = -1;
            break;
        case '+':
            sign = 1;
            break;
        default:
            // invalid sign
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse imaginary
    Number im = parseNumber(source, getRealFormat(), pos);
    if (im == null) {
        // invalid imaginary number
        // set index back to initial, error index should already be set
        pos.setIndex(initialIndex);
        return null;
    }

    // parse imaginary character
    String imaginaryCharacter = getImaginaryCharacter();
    int n = imaginaryCharacter.length();
    startIndex = pos.getIndex();
    int endIndex = startIndex + n;
    if (endIndex > source.length() || 
        !source.substring(startIndex, endIndex).equals(imaginaryCharacter)) {
        // set index back to initial, error index should be the start index
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }
    pos.setIndex(endIndex);

    return new Complex(re.doubleValue(), im.doubleValue() * sign);
}",0,0
152,Math_102,"public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
        if ((expected.length < 2) || (expected.length != observed.length)) {
            throw new IllegalArgumentException(
                    ""observed, expected array lengths incorrect"");
        }
        if (!isPositive(expected) || !isNonNegative(observed)) {
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }","public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
    if (expected == null || observed == null) {
        throw new IllegalArgumentException(""Observed and expected arrays must not be null"");
    }
    if ((expected.length < 2) || (expected.length != observed.length)) {
        throw new IllegalArgumentException(""Observed and expected array lengths are incorrect"");
    }
    if (!isPositive(expected) || !isNonNegative(observed)) {
        throw new IllegalArgumentException(
                ""Observed counts must be non-negative, and expected counts must be positive"");
    }
    double sumSq = 0.0d;
    for (int i = 0; i < observed.length; i++) {
        if (expected[i] == 0) {
            throw new IllegalArgumentException(""Expected value at index "" + i + "" is zero, which is invalid"");
        }
        double dev = (observed[i] - expected[i]);
        sumSq += dev * dev / expected[i];
    }
    return sumSq;
}",0,0
152,Math_102,"public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
        if ((expected.length < 2) || (expected.length != observed.length)) {
            throw new IllegalArgumentException(
                    ""observed, expected array lengths incorrect"");
        }
        if (!isPositive(expected) || !isNonNegative(observed)) {
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }","public double chiSquare(double[] expected, long[] observed) throws IllegalArgumentException {
    if (expected == null || observed == null) {
        throw new IllegalArgumentException(""Observed and expected arrays must not be null"");
    }
    if ((expected.length < 2) || (expected.length != observed.length)) {
        throw new IllegalArgumentException(""Observed and expected array lengths are incorrect"");
    }
    if (!isPositive(expected) || !isNonNegative(observed)) {
        throw new IllegalArgumentException(
                ""Observed counts must be non-negative, and expected counts must be positive"");
    }
    double sumSq = 0.0d;
    for (int i = 0; i < observed.length; i++) {
        if (expected[i] <= 0) {
            throw new IllegalArgumentException(""Expected value at index "" + i + "" must be greater than zero"");
        }
        double observedValue = (double) observed[i]; // Explicit cast for clarity
        double dev = observedValue - expected[i];
        sumSq += dev * dev / expected[i];
    }
    return sumSq;
}

// Helper method to check if all elements in an array are positive
private boolean isPositive(double[] array) {
    for (double value : array) {
        if (value <= 0) {
            return false;
        }
    }
    return true;
}

// Helper method to check if all elements in an array are non-negative
private boolean isNonNegative(long[] array) {
    for (long value : array) {
        if (value < 0) {
            return false;
        }
    }
    return true;
}",0,1
153,Math_103,"    public double cumulativeProbability(double x) throws MathException {
            return 0.5 * (1.0 + Erf.erf((x - mean) /
                    (standardDeviation * Math.sqrt(2.0))));
    }
","public double cumulativeProbability(double x) throws MathException {
    if (Double.isNaN(x)) {
        throw new IllegalArgumentException(""Input value cannot be NaN"");
    }
    if (standardDeviation <= 0.0) {
        throw new IllegalArgumentException(""Standard deviation must be positive"");
    }
    return 0.5 * (1.0 + Erf.erf((x - mean) /
            (standardDeviation * Math.sqrt(2.0))));
}",0,0
153,Math_103,"    public double cumulativeProbability(double x) throws MathException {
            return 0.5 * (1.0 + Erf.erf((x - mean) /
                    (standardDeviation * Math.sqrt(2.0))));
    }
","public double cumulativeProbability(double x) throws MathException {
    if (Double.isNaN(x)) {
        throw new IllegalArgumentException(""Input value cannot be NaN"");
    }
    if (Double.isInfinite(x)) {
        return x < 0 ? 0.0 : 1.0;
    }
    if (standardDeviation <= 0.0) {
        throw new IllegalArgumentException(""Standard deviation must be positive"");
    }
    double normalizedX = (x - mean) / (standardDeviation * Math.sqrt(2.0));
    return 0.5 * (1.0 + Erf.erf(normalizedX));
}",0,1
153,Math_103,"    public double cumulativeProbability(double x) throws MathException {
            return 0.5 * (1.0 + Erf.erf((x - mean) /
                    (standardDeviation * Math.sqrt(2.0))));
    }
","public double cumulativeProbability(double x) throws MathException {
    if (Double.isNaN(x)) {
        throw new IllegalArgumentException(""Input value cannot be NaN"");
    }
    if (standardDeviation <= 0.0) {
        throw new IllegalArgumentException(""Standard deviation must be positive"");
    }
    
    // Handle extreme values gracefully by directly checking the normalized value
    double normalizedX = (x - mean) / (standardDeviation * Math.sqrt(2.0));
    if (normalizedX > 36.0) { // beyond this point, the cumulative probability is nearly 1
        return 1.0;
    }
    if (normalizedX < -36.0) { // beyond this point, the cumulative probability is nearly 0
        return 0.0;
    }
    
    return 0.5 * (1.0 + Erf.erf(normalizedX));
}",0,2
154,Math_105,"    public double getSumSquaredErrors() {
        return sumYY - sumXY * sumXY / sumXX;
    }
","public double getSumSquaredErrors() {
    double sumXYOverSumXX = sumXY / sumXX;
    return sumYY - sumXY * sumXYOverSumXX;
}",0,0
154,Math_105,"    public double getSumSquaredErrors() {
        return sumYY - sumXY * sumXY / sumXX;
    }
","public double getSumSquaredErrors() {
    if (sumXX == 0) {
        return Double.NaN; // Avoid division by zero
    }
    double slope = sumXY / sumXX;
    double intercept = sumY / sumX; // Assuming intercept is calculated elsewhere
    double predictedSumYY = slope * sumXY + intercept * sumY; // Corrected relationship
    return sumYY - predictedSumYY; // Adjusted to use predicted values
}",0,1
154,Math_105,"    public double getSumSquaredErrors() {
        return sumYY - sumXY * sumXY / sumXX;
    }
","public double getSumSquaredErrors() {
    if (sumXX == 0) {
        return sumYY; // If sumXX is zero, return sumYY as no variation in X leads to zero slope
    }
    double slope = sumXY / sumXX;
    double intercept = (n > 0) ? (sumY / n) - slope * (sumX / n) : 0; // Calculate intercept if there are data points
    double totalPredictedYY = 0.0;
    for (int i = 0; i < n; i++) {
        double predictedY = slope * xData[i] + intercept; // Predict the Y using the line equation
        totalPredictedYY += (yData[i] - predictedY) * (yData[i] - predictedY); // Calculate squared error
    }
    return totalPredictedYY; // Return the total sum of squared errors
}",0,2
155,Math_106,"    public Fraction parse(String source, ParsePosition pos) {
        // try to parse improper fraction
        Fraction ret = super.parse(source, pos);
        if (ret != null) {
            return ret;
        }
        
        int initialIndex = pos.getIndex();

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse whole
        Number whole = getWholeFormat().parse(source, pos);
        if (whole == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);
        
        // parse numerator
        Number num = getNumeratorFormat().parse(source, pos);
        if (num == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }
        
            // minus signs should be leading, invalid expression

        // parse '/'
        int startIndex = pos.getIndex();
        char c = parseNextCharacter(source, pos);
        switch (c) {
        case 0 :
            // no '/'
            // return num as a fraction
            return new Fraction(num.intValue(), 1);
        case '/' :
            // found '/', continue parsing denominator
            break;
        default :
            // invalid '/'
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse denominator
        Number den = getDenominatorFormat().parse(source, pos);
        if (den == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }
        
            // minus signs must be leading, invalid

        int w = whole.intValue();
        int n = num.intValue();
        int d = den.intValue();
        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);
    }
","public Fraction parse(String source, ParsePosition pos) {
    // try to parse improper fraction
    Fraction ret = super.parse(source, pos);
    if (ret != null) {
        return ret;
    }

    int initialIndex = pos.getIndex();

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse whole
    Number whole = getWholeFormat().parse(source, pos);
    if (whole == null) {
        // invalid integer number
        pos.setIndex(initialIndex);
        return null;
    }

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse numerator
    Number num = getNumeratorFormat().parse(source, pos);
    if (num == null) {
        // invalid integer number
        pos.setIndex(initialIndex);
        return null;
    }

    // ensure the numerator is non-negative or the whole is zero
    if (num.intValue() < 0 && whole.intValue() != 0) {
        pos.setIndex(initialIndex);
        return null;
    }

    // parse '/'
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    switch (c) {
        case 0:
            // no '/'
            return new Fraction(num.intValue(), 1);
        case '/':
            // found '/', continue parsing denominator
            break;
        default:
            // invalid '/'
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse denominator
    Number den = getDenominatorFormat().parse(source, pos);
    if (den == null || den.intValue() == 0) {
        // invalid integer number or zero denominator
        pos.setIndex(initialIndex);
        return null;
    }

    // ensure the denominator is positive
    if (den.intValue() < 0) {
        pos.setIndex(initialIndex);
        return null;
    }

    int w = whole.intValue();
    int n = num.intValue();
    int d = den.intValue();
    return new Fraction(((Math.abs(w) * d) + Math.abs(n)) * MathUtils.sign(w), d);
}",0,0
156,Math_11,"public double density(final double[] vals) throws DimensionMismatchException {
        final int dim = getDimension();
        if (vals.length != dim) {
             throw new DimensionMismatchException(vals.length, dim);
         }
 
         return FastMath.pow(2 * FastMath.PI, -dim / 2) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }","public double density(final double[] vals) throws DimensionMismatchException {
    final int dim = getDimension();
    if (vals.length != dim) {
        throw new DimensionMismatchException(vals.length, dim);
    }

    // Avoid integer division by explicitly converting dim to double
    return FastMath.pow(2 * FastMath.PI, -dim / 2.0) *
           FastMath.pow(covarianceMatrixDeterminant, -0.5) *
           getExponentTerm(vals);
}",0,0
157,Math_13,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
","private RealMatrix squareRoot(RealMatrix m) {
    if (m == null || m.getRowDimension() != m.getColumnDimension()) {
        throw new IllegalArgumentException(""Matrix must be non-null and square."");
    }

    final EigenDecomposition dec = new EigenDecomposition(m);
    RealMatrix squareRootMatrix = dec.getSquareRoot();
    if (squareRootMatrix == null) {
        throw new ArithmeticException(""Square root of the matrix could not be computed."");
    }

    return squareRootMatrix;
}",0,0
157,Math_13,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
","private RealMatrix squareRoot(RealMatrix m) {
    if (m == null || m.getRowDimension() != m.getColumnDimension()) {
        throw new IllegalArgumentException(""Matrix must be non-null and square."");
    }

    final EigenDecomposition dec = new EigenDecomposition(m);
    RealMatrix squareRootMatrix = dec.getSquareRoot();
    
    // Ensure all diagonals are positive to avoid complex values
    for (int i = 0; i < squareRootMatrix.getRowDimension(); i++) {
        if (squareRootMatrix.getEntry(i, i) < 0) {
            throw new ArithmeticException(""Square root of the matrix resulted in negative values."");
        }
    }

    if (squareRootMatrix == null) {
        throw new ArithmeticException(""Square root of the matrix could not be computed."");
    }

    return squareRootMatrix;
}",0,1
157,Math_13,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
","private RealMatrix squareRoot(RealMatrix m) {
    if (m == null || m.getRowDimension() != m.getColumnDimension()) {
        throw new IllegalArgumentException(""Matrix must be non-null and square."");
    }

    try {
        final EigenDecomposition dec = new EigenDecomposition(m);
        RealMatrix squareRootMatrix = dec.getSquareRoot();
        
        if (squareRootMatrix == null) {
            throw new ArithmeticException(""Square root of the matrix could not be computed."");
        }

        return squareRootMatrix;
    } catch (OutOfMemoryError e) {
        throw new IllegalArgumentException(""Matrix size is too large to process."", e);
    }
}",0,2
158,Math_17,"    public Dfp multiply(final int x) {
            return multiplyFast(x);
    }
","public Dfp multiply(final int x) {
    if (x == 0) {
        return getZero();
    }
    return multiplyFast(x);
}",0,0
158,Math_17,"    public Dfp multiply(final int x) {
            return multiplyFast(x);
    }
","public Dfp multiply(final int x) {
    if (x == 0) {
        return getZero(); // return zero if the multiplier is zero
    }
    Dfp result = this; // start multiplication with the current object
    int absX = Math.abs(x);
    for (int i = 1; i < absX; i++) { // iterate absX times to perform multiplication
        result = result.multiplyFast(result);
    }
    return x < 0 ? result.negate() : result; // handle negative multiplier case by negating the result
}",0,1
159,Math_19,"private void checkParameters() {
        final double[] init = getStartPoint();
        final double[] lB = getLowerBound();
        final double[] uB = getUpperBound();

        // Checks whether there is at least one finite bound value.
        boolean hasFiniteBounds = false;
        for (int i = 0; i < lB.length; i++) {
            if (!Double.isInfinite(lB[i]) ||
                !Double.isInfinite(uB[i])) {
                hasFiniteBounds = true;
                break;
            }
        }
        // Checks whether there is at least one infinite bound value.
        boolean hasInfiniteBounds = false;
        if (hasFiniteBounds) {
            for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(lB[i]) ||
                    Double.isInfinite(uB[i])) {
                    hasInfiniteBounds = true;
                    break;
                }
            }

            if (hasInfiniteBounds) {
                // If there is at least one finite bound, none can be infinite,
                // because mixed cases are not supported by the current code.
                throw new MathUnsupportedOperationException();
            } else {
                // Convert API to internal handling of boundaries.
                boundaries = new double[2][];
                boundaries[0] = lB;
                boundaries[1] = uB;

                // Abort early if the normalization will overflow (cf. ""encode"" method).
            }
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = null;
        }

        if (inputSigma != null) {
            if (inputSigma.length != init.length) {
                throw new DimensionMismatchException(inputSigma.length, init.length);
            }
            for (int i = 0; i < init.length; i++) {
                if (inputSigma[i] < 0) {
                    throw new NotPositiveException(inputSigma[i]);
                }
                if (boundaries != null) {
                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                    }
                }
            }
        }
    }

    /**
     * Initialization of the dynamic search parameters
     *
     * @param guess Initial guess for the arguments of the fitness function.
     */
    private void initializeCMA(double[] guess) {
        if (lambda <= 0) {
            lambda = 4 + (int) (3. * Math.log(dimension));
        }
        // initialize sigma
        double[][] sigmaArray = new double[guess.length][1];","private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();

    // Checks whether there is at least one finite bound value.
    boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }

    // Checks whether there is at least one infinite bound value.
    boolean hasInfiniteBounds = false;

    for (int i = 0; i < lB.length; i++) {
        if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {
            hasInfiniteBounds = true;
            break;
        }
    }

    if (hasFiniteBounds && hasInfiniteBounds) {
        // If there is at least one finite bound, none can be infinite,
        // because mixed cases are not supported by the current code.
        throw new MathUnsupportedOperationException();
    } else if (hasFiniteBounds) {
        // Convert API to internal handling of boundaries.
        boundaries = new double[2][];
        boundaries[0] = lB;
        boundaries[1] = uB;
    } else {
        // Convert API to internal handling of boundaries.
        boundaries = null;
    }

    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}",0,0
160,Math_2,"    public double getNumericalMean() {
        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
    }
",Match failed,0,0
161,Math_20,"        public double[] repairAndDecode(final double[] x) {
            return
                decode(x);
        }
","public double[] repairAndDecode(final double[] x) {
    double[] repaired = repair(x);
    return decode(repaired);
}",0,0
162,Math_21,"    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }


            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                ++r;
                loop = false;

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ii] -= e * e;
                    for (int j = r + 1; j < i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }

    }","public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[r]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }


            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                loop = false; // this exits the loop

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ii] -= e * e;
                    for (int j = r + 1; j < i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }

    }",0,0
162,Math_21,"    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }


            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                ++r;
                loop = false;

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ii] -= e * e;
                    for (int j = r + 1; j < i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }

    }",Match failed,0,1
163,Math_23,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
        }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    // Best point encountered so far (which is the initial guess).

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (stop) {
            return best(current, previous, isMinim);
        }

        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        if (FastMath.abs(e) > tol1) { // Fit parabola.
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            r = e;
            e = d;

            if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                // Parabolic interpolation step.
                d = p / q;
                u = x + d;

                // f must not be evaluated too close to a or b.
                if (u - a < tol2 || b - u < tol2) {
                    d = (x <= m) ? tol1 : -tol1;
                }
            } else {
                // Golden section step.
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }
        } else {
            // Golden section step.
            e = (x < m) ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        // Update by at least ""tol1"".
        if (FastMath.abs(d) < tol1) {
            u = (d >= 0) ? x + tol1 : x - tol1;
        } else {
            u = x + d;
        }

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        // User-defined convergence checker.
        previous = current;
        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, previous, current)) {
            return best(current, previous, isMinim);
        }

        // Update a, b, v, w and x.
        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }
        ++iter;
    }
}",0,0
163,Math_23,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
        }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a = lo;
    double b = hi;

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (stop) {
            return best(current, previous, isMinim);
        }

        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        boolean parabolaStep = false;
        if (FastMath.abs(e) > tol1) {
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * e)) {
                parabolaStep = true;
                d = p / q;
                u = x + d;
                if (u - a < tol2 || b - u < tol2) {
                    d = (x < m) ? tol1 : -tol1;
                }
            }
        }

        if (!parabolaStep) {
            e = (x < m) ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        if (FastMath.abs(d) < tol1) {
            u = (d >= 0) ? x + tol1 : x - tol1;
        } else {
            u = x + d;
        }

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        previous = current;
        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, previous, current)) {
            return best(current, previous, isMinim);
        }

        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }
        ++iter;
    }
}",0,1
163,Math_23,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
        }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a = lo;
    double b = hi;

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (stop) {
            return best(current, previous, isMinim);
        }

        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        boolean parabolaStep = false;
        if (FastMath.abs(e) > tol1) {
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * e)) {
                parabolaStep = true;
                d = p / q;
                u = x + d;
                if (u - a < tol2 || b - u < tol2) {
                    d = (x < m) ? tol1 : -tol1;
                }
            }
        }

        if (!parabolaStep) {
            e = (x < m) ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        if (FastMath.abs(d) < tol1) {
            u = (d >= 0) ? x + tol1 : x - tol1;
        } else {
            u = x + d;
        }

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        previous = current;
        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, previous, current)) {
            return best(current, previous, isMinim);
        }

        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }
        ++iter;
    }
}",0,2
164,Math_24,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return current;
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
             ++iter;
         }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (stop) {
            return current;
        }

        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        if (FastMath.abs(e) > tol1) { // Fit parabola.
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            r = e;
            e = d;

            if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                // Parabolic interpolation step.
                d = p / q;
                u = x + d;

                if (u - a < tol2 || b - u < tol2) {
                    if (x <= m) {
                        d = tol1;
                    } else {
                        d = -tol1;
                    }
                }
            } else {
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
        } else {
            if (x < m) {
                e = b - x;
            } else {
                e = a - x;
            }
            d = GOLDEN_SECTION * e;
        }

        if (FastMath.abs(d) < tol1) {
            if (d >= 0) {
                u = x + tol1;
            } else {
                u = x - tol1;
            }
        } else {
            u = x + d;
        }

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        previous = current;
        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, previous, current)) {
            return current;
        }

        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }

        ++iter;
    }
}",0,0
164,Math_24,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return current;
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
             ++iter;
         }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a = Math.min(lo, hi);
    double b = Math.max(lo, hi);
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (stop) {
            return current;
        }

        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        if (FastMath.abs(e) > tol1) {
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            r = e;
            e = d;

            if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                d = p / q;
                u = x + d;

                if (u - a < tol2 || b - u < tol2) {
                    d = (x <= m) ? tol1 : -tol1;
                }
            } else {
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }
        } else {
            e = (x < m) ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        if (FastMath.abs(d) < tol1) {
            u = x + ((d >= 0) ? tol1 : -tol1);
        } else {
            u = x + d;
        }

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        previous = current;
        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, previous, current)) {
            return current;
        }

        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }

        ++iter;
    }
}",0,1
164,Math_24,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return current;
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
             ++iter;
         }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a = Math.min(lo, hi);
    double b = Math.max(lo, hi);
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    int iter = 0;

    while (true) {
         final double m = 0.5 * (a + b);
         final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
         final double tol2 = 2 * tol1;

         if (FastMath.abs(x - m) <= tol2 - 0.5 * (b - a)) {
             return current;
         }

         double p = 0;
         double q = 0;
         double r = 0;
         double u = 0;

         if (FastMath.abs(e) > tol1) {
             r = (x - w) * (fx - fv);
             q = (x - v) * (fx - fw);
             p = (x - v) * q - (x - w) * r;
             q = 2 * (q - r);

             if (q > 0) {
                 p = -p;
             } else {
                 q = -q;
             }

             r = e;
             e = d;

             if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                 d = p / q;
                 u = x + d;

                 if (u - a < tol2 || b - u < tol2) {
                     d = (x <= m) ? tol1 : -tol1;
                 }
             } else {
                 e = (x < m) ? b - x : a - x;
                 d = GOLDEN_SECTION * e;
             }
         } else {
             e = (x < m) ? b - x : a - x;
             d = GOLDEN_SECTION * e;
         }

         u = (FastMath.abs(d) < tol1) ? x + ((d >= 0) ? tol1 : -tol1) : x + d;
         double fu = computeObjectiveValue(u);
         if (!isMinim) {
             fu = -fu;
         }

         previous = current;
         current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

         if (checker != null && checker.converged(iter, previous, current)) {
             return current;
         }

         if (fu <= fx) {
             if (u < x) {
                 b = x;
             } else {
                 a = x;
             }
             v = w;
             fv = fw;
             w = x;
             fw = fx;
             x = u;
             fx = fu;
         } else {
             if (u < x) {
                 a = u;
             } else {
                 b = u;
             }
             if (fu <= fw || Precision.equals(w, x)) {
                 v = w;
                 fv = fw;
                 w = u;
                 fw = fu;
             } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                 v = u;
                 fv = fu;
             }
         }

         ++iter;
     }
}",0,2
165,Math_25,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
            }
        }","private void guessAOmega() {
    // initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;

    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;
    for (int i = 1; i < observations.length; ++i) {
        // one step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();

        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
        // considering a linear model for f (and therefore constant f')
        final double dx = currentX - previousX;
        final double dy = currentY - previousY;
        final double f2StepIntegral =
            dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;

        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;

        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }

    // compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;
    if (c2 == 0 || c3 == 0 || c1 / c2 < 0 || c2 / c3 < 0) {
        final int last = observations.length - 1;
        // Range of the observations, assuming that the
        // observations are sorted.
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange == 0) {
            throw new ZeroException();
        }
        omega = 2 * Math.PI / xRange;

        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (int i = 1; i < observations.length; ++i) {
            final double y = observations[i].getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
         }
         a = 0.5 * (yMax - yMin);
     } else {
             // In some ill-conditioned cases (cf. MATH-844), the guesser
             // procedure cannot produce sensible results.

         a = FastMath.sqrt(c1 / c2);
         omega = FastMath.sqrt(c2 / c3);
    }
}",0,0
165,Math_25,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
            }
        }","private void guessAOmega() {
    // initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;

    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;
    for (int i = 1; i < observations.length; ++i) {
        // one step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();

        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
        // considering a linear model for f (and therefore constant f')
        final double dx = currentX - previousX;
        final double dy = currentY - previousY;
        final double f2StepIntegral =
            dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;

        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;

        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }

    // compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;
    if (c2 == 0 || c3 == 0 || (c1 / c2) < 0 || (c2 / c3) < 0) {
        final int last = observations.length - 1;
        // Range of the observations, assuming that the observations are sorted.
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange == 0) {
            throw new ZeroException();
        }
        omega = 2 * Math.PI / xRange;

        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (int i = 1; i < observations.length; ++i) {
            final double y = observations[i].getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
         }
         a = 0.5 * (yMax - yMin);
     } else {
         // In some ill-conditioned cases (cf. MATH-844), the guesser
         // procedure cannot produce sensible results.
         a = FastMath.sqrt(Math.abs(c1 / c2)); // take absolute value to avoid illegal values
         omega = FastMath.sqrt(Math.abs(c2 / c3)); // take absolute value to avoid illegal values
    }
}",0,1
165,Math_25,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
            }
        }","private void guessAOmega() {
    // Initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;

    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;
    for (int i = 1; i < observations.length; ++i) {
        // One step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();

        // Update the integrals of f^2 and f'^2 by considering a linear model for f
        final double dx = currentX - previousX;
        final double dy = currentY - previousY;
        if (dx <= 0 || Double.isNaN(dx) || Double.isInfinite(dx)) {
            continue; // Ignore invalid data range to prevent divisions by zero or NaNs
        }
        final double f2StepIntegral =
            dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;

        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;

        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }

    // Compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;
    if (c2 == 0 || c3 == 0 || c1 <= 0 || c2 <= 0 || c3 <= 0) {
        final int last = observations.length - 1;
        // Range of the observations, assuming that the observations are sorted
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange == 0) {
            throw new ZeroException();
        }
        omega = 2 * Math.PI / xRange;

        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (int i = 0; i < observations.length; ++i) {
            final double y = observations[i].getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        a = 0.5 * (yMax - yMin);
    } else {
        // Handle precision to avoid MathIllegalStateException in ill-conditioned cases
        a = FastMath.sqrt(c1 / c2);
        omega = FastMath.sqrt(c2 / c3);
    }
}",0,2
166,Math_26,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
","private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException {
    long overflow = Integer.MAX_VALUE;
    double r0 = value;
    long a0 = (long) FastMath.floor(r0);
    if (a0 > overflow) {
        throw new FractionConversionException(value, a0, 1L);
    }

    // check for (almost) integer arguments, which should not go
    // to iterations.
    if (FastMath.abs(a0 - value) < epsilon) {
        this.numerator = (int) a0;
        this.denominator = 1;
        return;
    }

    long p0 = 1;
    long q0 = 0;
    long p1 = a0;
    long q1 = 1;

    long p2, q2;

    int n = 0;
    boolean stop = false;
    do {
        ++n;
        double r1 = 1.0 / (r0 - a0);
        long a1 = (long) FastMath.floor(r1);
        p2 = (a1 * p1) + p0;
        q2 = (a1 * q1) + q0;
        if ((p2 > overflow) || (q2 > overflow)) {
            throw new FractionConversionException(value, p2, q2);
        }

        double convergent = (double) p2 / (double) q2;
        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
            p0 = p1;
            p1 = p2;
            q0 = q1;
            q1 = q2;
            a0 = a1;
            r0 = r1;
        } else {
            stop = true;
        }
    } while (!stop);

    if (n >= maxIterations) {
        throw new FractionConversionException(value, maxIterations);
    }

    if (FastMath.abs((double)p1 / (double)q1 - value) < epsilon || q2 < maxDenominator) {
        this.numerator = (int) p1;
        this.denominator = (int) q1;
    } else {
        this.numerator = (int) p2;
        this.denominator = (int) q2;
    }
}",0,0
166,Math_26,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
","private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {
    long overflow = Integer.MAX_VALUE;
    double r0 = value;
    long a0 = (long) FastMath.floor(r0);
    if (a0 > overflow) {
        throw new FractionConversionException(value, a0, 1L);
    }

    // check for (almost) integer arguments, which should not go to iterations.
    if (FastMath.abs(a0 - value) < epsilon) {
        this.numerator = (int) a0;
        this.denominator = 1;
        return;
    }

    long p0 = 1;
    long q0 = 0;
    long p1 = a0;
    long q1 = 1;

    long p2, q2;

    int n = 0;
    boolean stop = false;
    do {
        ++n;
        double r1 = 1.0 / (r0 - a0);
        long a1 = (long) FastMath.floor(r1);
        p2 = (a1 * p1) + p0;
        q2 = (a1 * q1) + q0;
        if ((p2 > overflow) || (q2 > overflow) || q2 > maxDenominator) {
            break;
        }

        double convergent = (double) p2 / (double) q2;
        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon) {
            p0 = p1;
            p1 = p2;
            q0 = q1;
            q1 = q2;
            a0 = a1;
            r0 = r1;
        } else {
            stop = true;
        }
    } while (!stop);

    if (n >= maxIterations) {
        throw new FractionConversionException(value, maxIterations);
    }

    if (FastMath.abs((double)p1 / (double)q1 - value) < epsilon || q2 > maxDenominator) {
        this.numerator = (int) p1;
        this.denominator = (int) q1;
    } else {
        this.numerator = (int) p2;
        this.denominator = (int) q2;
    }
}",0,1
166,Math_26,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
","private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {
    long overflow = Integer.MAX_VALUE;
    double r0 = value;
    long a0 = (long) FastMath.floor(r0);
    if (a0 > overflow) {
        throw new FractionConversionException(value, a0, 1L);
    }

    // check for (almost) integer arguments, which should not go to iterations.
    if (FastMath.abs(a0 - value) < epsilon) {
        this.numerator = (int) a0;
        this.denominator = 1;
        return;
    }

    long p0 = 1;
    long q0 = 0;
    long p1 = a0;
    long q1 = 1;

    long p2, q2;

    int n = 0;
    while (n < maxIterations) {
        ++n;
        double r1 = 1.0 / (r0 - a0);
        long a1 = (long) FastMath.floor(r1);
        p2 = (a1 * p1) + p0;
        q2 = (a1 * q1) + q0;
        if ((p2 > overflow) || (q2 > overflow)) {
            throw new FractionConversionException(value, p2, q2);
        }

        double convergent = (double) p2 / (double) q2;
        if (FastMath.abs(convergent - value) < epsilon || q2 > maxDenominator) {
            break;
        }

        p0 = p1;
        p1 = p2;
        q0 = q1;
        q1 = q2;
        a0 = a1;
        r0 = r1;
    }
    
    if (Math.abs((double) p2 / (double) q2 - value) < epsilon && q2 <= maxDenominator) {
        this.numerator = (int) p2;
        this.denominator = (int) q2;
    } else {
        this.numerator = (int) p1;
        this.denominator = (int) q1;
    }
}",0,2
167,Math_27,"    public double percentageValue() {
        return multiply(100).doubleValue();
    }
","public double percentageValue() {
    return multiply(new Fraction(100, 1)).doubleValue();
}",0,0
167,Math_27,"    public double percentageValue() {
        return multiply(100).doubleValue();
    }
","public double percentageValue() {
    return this.doubleValue() * 100;
}",0,1
168,Math_28,"private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);

            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                final double ratio = rhs / entry;
                // check if the entry is strictly equal to the current min ratio
                // do not use a ulp/epsilon check
                final int cmp = Double.compare(ratio, minRatio);
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions = new ArrayList<Integer>();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.size() == 0) {
            return null;
        } else if (minRatioPositions.size() > 1) {
            // there's a degeneracy as indicated by a tie in the minimum ratio test

            // 1. check if there's an artificial variable that can be forced out of the basis
                for (Integer row : minRatioPositions) {
                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                        int column = i + tableau.getArtificialVariableOffset();
                        final double entry = tableau.getEntry(row, column);
                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                            return row;
                        }
                    }
                }

            // 2. apply Bland's rule to prevent cycling:
            //    take the row for which the corresponding basic variable has the smallest index
            //
            // see http://www.stanford.edu/class/msande310/blandrule.pdf
            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
            //
            // Additional heuristic: if we did not get a solution after half of maxIterations
            //                       revert to the simple case of just returning the top-most row
            // This heuristic is based on empirical data gathered while investigating MATH-828.
                Integer minRow = null;
                int minIndex = tableau.getWidth();
                for (Integer row : minRatioPositions) {
                    int i = tableau.getNumObjectiveFunctions();
                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
                        if (row == tableau.getBasicRow(i)) {
                            if (i < minIndex) {
                                minIndex = i;
                                minRow = row;
                            }
                        }
                     }
                 }
                 return minRow;
         }
         return minRatioPositions.get(0);
     }","private Integer getPivotRow(SimplexTableau tableau, final int col) {
    // create a list of all the rows that tie for the lowest score in the minimum ratio test
    List<Integer> minRatioPositions = new ArrayList<Integer>();
    double minRatio = Double.MAX_VALUE;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);

        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            final double ratio = rhs / entry;
            final int cmp = Double.compare(ratio, minRatio);
            if (cmp == 0) {
                minRatioPositions.add(i);
            } else if (cmp < 0) {
                minRatio = ratio;
                minRatioPositions.clear(); // Clear the list instead of creating a new one
                minRatioPositions.add(i);
            }
        }
    }

    if (minRatioPositions.isEmpty()) {
        return null;
    } else if (minRatioPositions.size() > 1) {
        // there's a degeneracy as indicated by a tie in the minimum ratio test
        for (Integer row : minRatioPositions) {
            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                int column = i + tableau.getArtificialVariableOffset();
                double entry = tableau.getEntry(row, column);
                if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                    return row;
                }
            }
        }

        Integer minRow = null;
        int minIndex = tableau.getWidth();
        for (Integer row : minRatioPositions) {
            for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {
                if (row.equals(tableau.getBasicRow(i))) {
                    if (i < minIndex) {
                        minIndex = i;
                        minRow = row;
                    }
                    break; // Break the loop once the row is found
                }
            }
        }
        return minRow;
    }
    return minRatioPositions.get(0);
}",0,0
168,Math_28,"private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);

            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                final double ratio = rhs / entry;
                // check if the entry is strictly equal to the current min ratio
                // do not use a ulp/epsilon check
                final int cmp = Double.compare(ratio, minRatio);
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions = new ArrayList<Integer>();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.size() == 0) {
            return null;
        } else if (minRatioPositions.size() > 1) {
            // there's a degeneracy as indicated by a tie in the minimum ratio test

            // 1. check if there's an artificial variable that can be forced out of the basis
                for (Integer row : minRatioPositions) {
                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                        int column = i + tableau.getArtificialVariableOffset();
                        final double entry = tableau.getEntry(row, column);
                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                            return row;
                        }
                    }
                }

            // 2. apply Bland's rule to prevent cycling:
            //    take the row for which the corresponding basic variable has the smallest index
            //
            // see http://www.stanford.edu/class/msande310/blandrule.pdf
            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
            //
            // Additional heuristic: if we did not get a solution after half of maxIterations
            //                       revert to the simple case of just returning the top-most row
            // This heuristic is based on empirical data gathered while investigating MATH-828.
                Integer minRow = null;
                int minIndex = tableau.getWidth();
                for (Integer row : minRatioPositions) {
                    int i = tableau.getNumObjectiveFunctions();
                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
                        if (row == tableau.getBasicRow(i)) {
                            if (i < minIndex) {
                                minIndex = i;
                                minRow = row;
                            }
                        }
                     }
                 }
                 return minRow;
         }
         return minRatioPositions.get(0);
     }","private Integer getPivotRow(SimplexTableau tableau, final int col) {
    List<Integer> minRatioPositions = new ArrayList<>();
    double minRatio = Double.MAX_VALUE;

    // Iterate over tableau rows and compute the minimum ratio
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        double entry = tableau.getEntry(i, col);

        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            double ratio = rhs / entry;
            // Use precise comparison logic for min ratio
            if (Double.compare(ratio, minRatio) == 0) {
                minRatioPositions.add(i);
            } else if (ratio < minRatio) {
                minRatio = ratio;
                minRatioPositions.clear();
                minRatioPositions.add(i);
            }
        }
    }

    if (minRatioPositions.isEmpty()) {
        return null;
    } else if (minRatioPositions.size() > 1) {
        // Check for artificial variables to resolve degeneracy
        for (int row : minRatioPositions) {
            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                int column = i + tableau.getArtificialVariableOffset();
                double entry = tableau.getEntry(row, column);
                if (Precision.equals(entry, 1d, maxUlps) && row == tableau.getBasicRow(column)) {
                    return row;
                }
            }
        }

        // Apply Bland's rule to break ties
        Integer minRow = null;
        int minIndex = tableau.getWidth();
        for (int row : minRatioPositions) {
            for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1 && minRow != row; i++) {
                if (row == tableau.getBasicRow(i)) {
                    if (i < minIndex) {
                        minIndex = i;
                        minRow = row;
                    }
                }
            }
        }
        return minRow;
    }
    return minRatioPositions.get(0);
}",0,1
169,Math_3,"    public static double linearCombination(final double[] a, final double[] b)
        throws DimensionMismatchException {
        final int len = a.length;
        if (len != b.length) {
            throw new DimensionMismatchException(len, b.length);
        }

            // Revert to scalar multiplication.

        final double[] prodHigh = new double[len];
        double prodLowSum = 0;

        for (int i = 0; i < len; i++) {
            final double ai = a[i];
            final double ca = SPLIT_FACTOR * ai;
            final double aHigh = ca - (ca - ai);
            final double aLow = ai - aHigh;

            final double bi = b[i];
            final double cb = SPLIT_FACTOR * bi;
            final double bHigh = cb - (cb - bi);
            final double bLow = bi - bHigh;
            prodHigh[i] = ai * bi;
            final double prodLow = aLow * bLow - (((prodHigh[i] -
                                                    aHigh * bHigh) -
                                                   aLow * bHigh) -
                                                  aHigh * bLow);
            prodLowSum += prodLow;
        }


        final double prodHighCur = prodHigh[0];
        double prodHighNext = prodHigh[1];
        double sHighPrev = prodHighCur + prodHighNext;
        double sPrime = sHighPrev - prodHighNext;
        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);

        final int lenMinusOne = len - 1;
        for (int i = 1; i < lenMinusOne; i++) {
            prodHighNext = prodHigh[i + 1];
            final double sHighCur = sHighPrev + prodHighNext;
            sPrime = sHighCur - prodHighNext;
            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
            sHighPrev = sHighCur;
        }

        double result = sHighPrev + (prodLowSum + sLowSum);

        if (Double.isNaN(result)) {
            // either we have split infinite numbers or some coefficients were NaNs,
            // just rely on the naive implementation and let IEEE754 handle this
            result = 0;
            for (int i = 0; i < len; ++i) {
                result += a[i] * b[i];
            }
        }

        return result;
    }","public static double linearCombination(final double[] a, final double[] b)
        throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }

    // Early exit for single-element arrays to prevent unnecessary computation.
    if (len == 1) {
        return a[0] * b[0];
    }

    final double[] prodHigh = new double[len];
    double prodLowSum = 0;

    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;

        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;

        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] -
                                                aHigh * bHigh) -
                                               aLow * bHigh) -
                                              aHigh * bLow);
        prodLowSum += prodLow;
    }

    double sHighPrev = prodHigh[0];
    double sLowSum = 0;
    for (int i = 1; i < len; i++) {
        final double sHighCur = sHighPrev + prodHigh[i];
        final double sPrime = sHighCur - prodHigh[i];
        sLowSum += (prodHigh[i] - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }

    double result = sHighPrev + (prodLowSum + sLowSum);

    if (Double.isNaN(result)) {
        // Handle NaN or infinite cases with naive implementation
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }

    return result;
}",0,0
170,Math_30,"private double calculateAsymptoticPValue(final double Umin,
                                             final int n1,
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
         final int n1n2prod = n1 * n2;
 
         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
         final double EU = n1n2prod / 2.0;
        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;

        final double z = (Umin - EU) / FastMath.sqrt(VarU);

        final NormalDistribution standardNormal = new NormalDistribution(0, 1);

        return 2 * standardNormal.cumulativeProbability(z);
    }","private double calculateAsymptoticPValue(final double Umin,
                                             final int n1,
                                             final int n2)
         throws ConvergenceException, MaxCountExceededException {

        final int n1n2prod = n1 * n2;

        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
        final double EU = n1n2prod / 2.0;

        // Ensure VarU is not negative by properly computing the formula
        final double VarU = n1n2prod * ((double) (n1 + n2 + 1)) / 12.0;
        if (VarU <= 0) {
            throw new IllegalArgumentException(""Variance (VarU) must be positive."");
        }

        final double z = (Umin - EU) / FastMath.sqrt(VarU);

        final NormalDistribution standardNormal = new NormalDistribution(0, 1);

        return 2 * standardNormal.cumulativeProbability(z);
    }",0,0
171,Math_31,"public double evaluate(double x, double epsilon, int maxIterations) {
        final double small = 1e-50;
        double hPrev = getA(0, x);

        // use the value of small as epsilon criteria for zero checks
        if (Precision.equals(hPrev, 0.0, small)) {
            hPrev = small;
        }

        int n = 1;
        double dPrev = 0.0;
        double p0 = 1.0;
        double q1 = 1.0;
        double cPrev = hPrev;
        double hN = hPrev;

        while (n < maxIterations) {
            final double a = getA(n, x);
            final double b = getB(n, x);

            double cN = a * hPrev + b * p0;
            double q2 = a * q1 + b * dPrev;
            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
                double scaleFactor = 1d;
                double lastScaleFactor = 1d;
                final int maxPower = 5;
                final double scale = FastMath.max(a,b);
                if (scale <= 0) {  // Can't scale
                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
                }
                for (int i = 0; i < maxPower; i++) {
                    lastScaleFactor = scaleFactor;
                    scaleFactor *= scale;
                    if (a != 0.0 && a > b) {
                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                    } else if (b != 0) {
                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                    }
                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                        break;
                    }
                }
            }

            final double deltaN = cN / q2 / cPrev;
            hN = cPrev * deltaN;

            if (Double.isInfinite(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
                                               x);
            }
            if (Double.isNaN(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
                                               x);
            }

            if (FastMath.abs(deltaN - 1.0) < epsilon) {
                 break;
             }
 
             dPrev = q1;
             cPrev = cN / q2;
             p0 = hPrev;
             hPrev = cN;
             q1 = q2;
             n++;
         }
 
        if (n >= maxIterations) {
            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,
                                                maxIterations, x);
        }

        return hN;
    }","public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);

    if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }

    int n = 1;
    double dPrev = 1.0;  // Changed to avoid division by zero
    double p0 = 1.0;
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;

    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);

        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;

        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
            double scaleFactor = 1.0;
            double lastScaleFactor = 1.0;
            final int maxPower = 5;
            final double scale = FastMath.max(FastMath.abs(a), FastMath.abs(b));

            if (Precision.equals(scale, 0.0, small)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
            }

            for (int i = 0; i < maxPower; i++) {
                lastScaleFactor = scaleFactor;
                scaleFactor *= scale;

                if (a != 0.0 && FastMath.abs(a) > FastMath.abs(b)) {
                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                } else if (b != 0.0) {
                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                }

                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                    break;
                }
            }
        }

        if (Precision.equals(q2, 0.0, small)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_ZERO_DIVISOR, x);
        }

        final double deltaN = cN / q2 / cPrev;
        hN = cPrev * deltaN;

        if (Double.isInfinite(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
        }
        if (Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }

        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            break;
        }

        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }

    if (n >= maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
    }

    return hN;
}",0,0
172,Math_32,"@Override
    protected void computeGeometricalProperties() {

        final Vector2D[][] v = getVertices();
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
             if ((Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
            } else {
                setSize(0);
                setBarycenter(new Vector2D(0, 0));
            }
        } else if (v[0][0] == null) {
            // there is at least one open-loop: the polygon is infinite
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            // all loops are closed, we compute some integrals around the shape

            double sum  = 0;
            double sumX = 0;
            double sumY = 0;

            for (Vector2D[] loop : v) {
                double x1 = loop[loop.length - 1].getX();
                double y1 = loop[loop.length - 1].getY();
                for (final Vector2D point : loop) {
                    final double x0 = x1;
                    final double y0 = y1;
                    x1 = point.getX();
                    y1 = point.getY();
                    final double factor = x0 * y1 - y0 * x1;
                    sum  += factor;
                    sumX += factor * (x0 + x1);
                    sumY += factor * (y0 + y1);
                }
            }

            if (sum < 0) {
                // the polygon as a finite outside surrounded by an infinite inside
                setSize(Double.POSITIVE_INFINITY);
                setBarycenter(Vector2D.NaN);
            } else {
                setSize(sum / 2);
                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
            }

        }

    }","@Override
protected void computeGeometricalProperties() {
    final Vector2D[][] v = getVertices();

    if (v.length == 0) {
        final BSPTree<Euclidean2D> tree = getTree(false);
        if ((Boolean) tree.getAttribute()) {
            // the instance covers the whole space
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(0);
            setBarycenter(new Vector2D(0, 0));
        }
    } else if (v[0][0] == null) {
        // there is at least one open-loop: the polygon is infinite
        setSize(Double.POSITIVE_INFINITY);
        setBarycenter(Vector2D.NaN);
    } else {
        // all loops are closed, we compute some integrals around the shape

        double sum = 0.0;
        double sumX = 0.0;
        double sumY = 0.0;

        for (Vector2D[] loop : v) {
            // Ensure loop is not null and has at least two valid points
            if (loop == null || loop.length < 2) {
                continue;
            }

            double x1 = loop[loop.length - 1].getX();
            double y1 = loop[loop.length - 1].getY();

            for (final Vector2D point : loop) {
                final double x0 = x1;
                final double y0 = y1;
                x1 = point.getX();
                y1 = point.getY();

                final double factor = x0 * y1 - y0 * x1;
                sum += factor;
                sumX += factor * (x0 + x1);
                sumY += factor * (y0 + y1);
            }
        }

        if (sum <= 0) {
            // The polygon has a finite outside surrounded by an infinite inside
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(sum / 2);
            setBarycenter(new Vector2D(sumX / (3.0 * sum), sumY / (3.0 * sum)));
        }
    }
}",0,0
172,Math_32,"@Override
    protected void computeGeometricalProperties() {

        final Vector2D[][] v = getVertices();
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
             if ((Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
            } else {
                setSize(0);
                setBarycenter(new Vector2D(0, 0));
            }
        } else if (v[0][0] == null) {
            // there is at least one open-loop: the polygon is infinite
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            // all loops are closed, we compute some integrals around the shape

            double sum  = 0;
            double sumX = 0;
            double sumY = 0;

            for (Vector2D[] loop : v) {
                double x1 = loop[loop.length - 1].getX();
                double y1 = loop[loop.length - 1].getY();
                for (final Vector2D point : loop) {
                    final double x0 = x1;
                    final double y0 = y1;
                    x1 = point.getX();
                    y1 = point.getY();
                    final double factor = x0 * y1 - y0 * x1;
                    sum  += factor;
                    sumX += factor * (x0 + x1);
                    sumY += factor * (y0 + y1);
                }
            }

            if (sum < 0) {
                // the polygon as a finite outside surrounded by an infinite inside
                setSize(Double.POSITIVE_INFINITY);
                setBarycenter(Vector2D.NaN);
            } else {
                setSize(sum / 2);
                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
            }

        }

    }","@Override
protected void computeGeometricalProperties() {

    final Vector2D[][] vertices = getVertices();

    if (vertices == null || vertices.length == 0) {
        final BSPTree<Euclidean2D> tree = getTree(false);
        if (tree != null && Boolean.TRUE.equals(tree.getAttribute())) {
            // the instance covers the whole space
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(0);
            setBarycenter(new Vector2D(0, 0));
        }
        return;
    }

    boolean hasOpenLoop = false;
    double sumArea = 0.0;
    double weightedSumX = 0.0;
    double weightedSumY = 0.0;

    for (Vector2D[] loop : vertices) {
        if (loop == null || loop.length < 2) {
            hasOpenLoop = true;
            continue;
        }

        double previousX = loop[loop.length - 1].getX();
        double previousY = loop[loop.length - 1].getY();

        for (Vector2D point : loop) {
            if (point == null) {
                hasOpenLoop = true;
                continue;
            }

            double currentX = point.getX();
            double currentY = point.getY();

            double factor = previousX * currentY - previousY * currentX;

            sumArea += factor;
            weightedSumX += factor * (previousX + currentX);
            weightedSumY += factor * (previousY + currentY);

            previousX = currentX;
            previousY = currentY;
        }
    }

    if (sumArea <= 0 || hasOpenLoop) {
        // The polygon is infinite or non-closed
        setSize(Double.POSITIVE_INFINITY);
        setBarycenter(Vector2D.NaN);
    } else {
        setSize(sumArea / 2);
        setBarycenter(new Vector2D(weightedSumX / (3 * sumArea), weightedSumY / (3 * sumArea)));
    }
}",0,1
173,Math_33,"protected void dropPhase1Objective() {
        if (getNumObjectiveFunctions() == 1) {
            return;
        }

        List<Integer> columnsToDrop = new ArrayList<Integer>();
        columnsToDrop.add(0);

         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }

        // non-basic artificial variables
        for (int i = 0; i < getNumArtificialVariables(); i++) {
          int col = i + getArtificialVariableOffset();
          if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
          }
        }

        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
        for (int i = 1; i < getHeight(); i++) {
          int col = 0;
          for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
              matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
          }
        }

        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
          columnLabels.remove((int) columnsToDrop.get(i));
        }

        this.tableau = new Array2DRowRealMatrix(matrix);
        this.numArtificialVariables = 0;
    }","protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }

    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);

    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }

    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }

    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }

    // Remove column labels in reverse order to avoid index shifting issues
    Collections.sort(columnsToDrop, Collections.reverseOrder());
    for (int columnIndex : columnsToDrop) {
        columnLabels.remove(columnIndex);
    }

    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}",0,0
174,Math_34,"    public Iterator<Chromosome> iterator() {
        return chromosomes.iterator();
    }
",Match failed,0,0
175,Math_38,"private void prelim(double[] lowerBound,
                        double[] upperBound) {
        printMethod(); // XXX

        final int n = currentBest.getDimension();
        final int npt = numberOfInterpolationPoints;
        final int ndim = bMatrix.getRowDimension();

        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
        final double recip = 1d / rhosq;
        final int np = n + 1;

        // Set XBASE to the initial vector of variables, and set the initial
        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

        for (int j = 0; j < n; j++) {
            originShift.setEntry(j, currentBest.getEntry(j));
            for (int k = 0; k < npt; k++) {
                interpolationPoints.setEntry(k, j, ZERO);
            }
            for (int i = 0; i < ndim; i++) {
                bMatrix.setEntry(i, j, ZERO);
            }
        }
        for (int i = 0, max = n * np / 2; i < max; i++) {
            modelSecondDerivativesValues.setEntry(i, ZERO);
        }
        for (int k = 0; k < npt; k++) {
            modelSecondDerivativesParameters.setEntry(k, ZERO);
            for (int j = 0, max = npt - np; j < max; j++) {
                zMatrix.setEntry(k, j, ZERO);
            }
        }

        // Begin the initialization procedure. NF becomes one more than the number
        // of function values so far. The coordinates of the displacement of the
        // next initial interpolation point from XBASE are set in XPT(NF+1,.).

        int ipt = 0;
        int jpt = 0;
        double fbeg = Double.NaN;
        do {
            final int nfm = getEvaluations();
            final int nfx = nfm - n;
            final int nfmm = nfm - 1;
            final int nfxm = nfx - 1;
            double stepa = 0;
            double stepb = 0;
            if (nfm <= 2 * n) {
                if (nfm >= 1 &&
                    nfm <= n) {
                    stepa = initialTrustRegionRadius;
                    if (upperDifference.getEntry(nfmm) == ZERO) {
                        stepa = -stepa;
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfmm, stepa);
                } else if (nfm > n) {
                    stepa = interpolationPoints.getEntry(nfx, nfxm);
                    stepb = -initialTrustRegionRadius;
                    if (lowerDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    if (upperDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfxm, stepb);
                }
            } else {
                final int tmp1 = (nfm - np) / n;
                jpt = nfm - tmp1 * n - n;
                ipt = jpt + tmp1;
                if (ipt > n) {
                    final int tmp2 = jpt;
                    jpt = ipt - n;
                    ipt = tmp2;
                    throw new PathIsExploredException(); // XXX
                }
                final int iptMinus1 = ipt;
                final int jptMinus1 = jpt;
                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
            }

            // Calculate the next value of F. The least function value so far and
            // its index are required.

            for (int j = 0; j < n; j++) {
                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                                                 upperBound[j]));
                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                    currentBest.setEntry(j, lowerBound[j]);
                }
                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                    currentBest.setEntry(j, upperBound[j]);
                }
            }

            final double objectiveValue = computeObjectiveValue(currentBest.toArray());
            final double f = isMinimize ? objectiveValue : -objectiveValue;
            final int numEval = getEvaluations(); // nfm + 1
            fAtInterpolationPoints.setEntry(nfm, f);

            if (numEval == 1) {
                fbeg = f;
                trustRegionCenterInterpolationPointIndex = 0;
            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
                trustRegionCenterInterpolationPointIndex = nfm;
            }

            // Set the nonzero initial elements of BMAT and the quadratic model in the
            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
            // of the NF-th and (NF-N)-th interpolation points may be switched, in
            // order that the function value at the first of them contributes to the
            // off-diagonal second derivative terms of the initial quadratic model.

            if (numEval <= 2 * n + 1) {
                if (numEval >= 2 &&
                    numEval <= n + 1) {
                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                    if (npt < numEval + n) {
                        final double oneOverStepA = ONE / stepa;
                        bMatrix.setEntry(0, nfmm, -oneOverStepA);
                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                        throw new PathIsExploredException(); // XXX
                    }
                } else if (numEval >= n + 2) {
                    final int ih = nfx * (nfx + 1) / 2 - 1;
                    final double tmp = (f - fbeg) / stepb;
                    final double diff = stepb - stepa;
                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                    if (stepa * stepb < ZERO) {
                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                            fAtInterpolationPoints.setEntry(nfm - n, f);
                            if (trustRegionCenterInterpolationPointIndex == nfm) {
                                trustRegionCenterInterpolationPointIndex = nfm - n;
                            }
                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                            interpolationPoints.setEntry(nfm, nfxm, stepa);
                        }
                    }
                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                    bMatrix.setEntry(nfm - n, nfxm,
                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                    zMatrix.setEntry(nfm - n, nfxm,
                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
                }

                // Set the off-diagonal second derivatives of the Lagrange functions and
                // the initial quadratic model.

            } else {
                zMatrix.setEntry(0, nfxm, recip);
                zMatrix.setEntry(nfm, nfxm, recip);
                zMatrix.setEntry(ipt, nfxm, -recip);
                zMatrix.setEntry(jpt, nfxm, -recip);

                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                throw new PathIsExploredException(); // XXX
            }
        } while (getEvaluations() < npt);
    } // prelim","private void prelim(double[] lowerBound, double[] upperBound) {
    printMethod(); // XXX

    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();

    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;

    // Initialize XBASE, XPT, BMAT, HQ, PQ, and ZMAT.
    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }

    // Initialization procedure
    int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    while (getEvaluations() < npt) {
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;

        if (nfm <= 2 * n) {
            if (nfm >= 1 && nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    stepa = -stepa;
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                if (lowerDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                }
                if (upperDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                }
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            if (ipt > n) {
                final int tmp2 = jpt;
                jpt = ipt - n;
                ipt = tmp2;
            }
            final int iptMinus1 = ipt - 1;
            final int jptMinus1 = jpt - 1;
            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
        }

        // Calculate next value of F and check bounds.
        for (int j = 0; j < n; j++) {
            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                    originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                    upperBound[j]));
        }

        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
        fAtInterpolationPoints.setEntry(nfm, f);

        if (getEvaluations() == 1) {
            fbeg = f;
            trustRegionCenterInterpolationPointIndex = 0;
        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
            trustRegionCenterInterpolationPointIndex = nfm;
        }

        // Update BMAT and quadratic model if necessary.
        if (getEvaluations() <= 2 * n + 1) {
            if (getEvaluations() >= 2 && getEvaluations() <= n + 1) {
                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
            } else if (getEvaluations() >= n + 2) {
                final int ih = nfx * (nfx + 1) / 2 - 1;
                final double tmp = (f - fbeg) / stepb;
                final double diff = stepb - stepa;
                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
            }
        } else {
            zMatrix.setEntry(0, nfxm, recip);
            zMatrix.setEntry(nfm, nfxm, recip);
            zMatrix.setEntry(ipt, nfxm, -recip);
            zMatrix.setEntry(jpt, nfxm, -recip);
        }
    }
}",0,0
175,Math_38,"private void prelim(double[] lowerBound,
                        double[] upperBound) {
        printMethod(); // XXX

        final int n = currentBest.getDimension();
        final int npt = numberOfInterpolationPoints;
        final int ndim = bMatrix.getRowDimension();

        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
        final double recip = 1d / rhosq;
        final int np = n + 1;

        // Set XBASE to the initial vector of variables, and set the initial
        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

        for (int j = 0; j < n; j++) {
            originShift.setEntry(j, currentBest.getEntry(j));
            for (int k = 0; k < npt; k++) {
                interpolationPoints.setEntry(k, j, ZERO);
            }
            for (int i = 0; i < ndim; i++) {
                bMatrix.setEntry(i, j, ZERO);
            }
        }
        for (int i = 0, max = n * np / 2; i < max; i++) {
            modelSecondDerivativesValues.setEntry(i, ZERO);
        }
        for (int k = 0; k < npt; k++) {
            modelSecondDerivativesParameters.setEntry(k, ZERO);
            for (int j = 0, max = npt - np; j < max; j++) {
                zMatrix.setEntry(k, j, ZERO);
            }
        }

        // Begin the initialization procedure. NF becomes one more than the number
        // of function values so far. The coordinates of the displacement of the
        // next initial interpolation point from XBASE are set in XPT(NF+1,.).

        int ipt = 0;
        int jpt = 0;
        double fbeg = Double.NaN;
        do {
            final int nfm = getEvaluations();
            final int nfx = nfm - n;
            final int nfmm = nfm - 1;
            final int nfxm = nfx - 1;
            double stepa = 0;
            double stepb = 0;
            if (nfm <= 2 * n) {
                if (nfm >= 1 &&
                    nfm <= n) {
                    stepa = initialTrustRegionRadius;
                    if (upperDifference.getEntry(nfmm) == ZERO) {
                        stepa = -stepa;
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfmm, stepa);
                } else if (nfm > n) {
                    stepa = interpolationPoints.getEntry(nfx, nfxm);
                    stepb = -initialTrustRegionRadius;
                    if (lowerDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    if (upperDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfxm, stepb);
                }
            } else {
                final int tmp1 = (nfm - np) / n;
                jpt = nfm - tmp1 * n - n;
                ipt = jpt + tmp1;
                if (ipt > n) {
                    final int tmp2 = jpt;
                    jpt = ipt - n;
                    ipt = tmp2;
                    throw new PathIsExploredException(); // XXX
                }
                final int iptMinus1 = ipt;
                final int jptMinus1 = jpt;
                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
            }

            // Calculate the next value of F. The least function value so far and
            // its index are required.

            for (int j = 0; j < n; j++) {
                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                                                 upperBound[j]));
                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                    currentBest.setEntry(j, lowerBound[j]);
                }
                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                    currentBest.setEntry(j, upperBound[j]);
                }
            }

            final double objectiveValue = computeObjectiveValue(currentBest.toArray());
            final double f = isMinimize ? objectiveValue : -objectiveValue;
            final int numEval = getEvaluations(); // nfm + 1
            fAtInterpolationPoints.setEntry(nfm, f);

            if (numEval == 1) {
                fbeg = f;
                trustRegionCenterInterpolationPointIndex = 0;
            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
                trustRegionCenterInterpolationPointIndex = nfm;
            }

            // Set the nonzero initial elements of BMAT and the quadratic model in the
            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
            // of the NF-th and (NF-N)-th interpolation points may be switched, in
            // order that the function value at the first of them contributes to the
            // off-diagonal second derivative terms of the initial quadratic model.

            if (numEval <= 2 * n + 1) {
                if (numEval >= 2 &&
                    numEval <= n + 1) {
                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                    if (npt < numEval + n) {
                        final double oneOverStepA = ONE / stepa;
                        bMatrix.setEntry(0, nfmm, -oneOverStepA);
                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                        throw new PathIsExploredException(); // XXX
                    }
                } else if (numEval >= n + 2) {
                    final int ih = nfx * (nfx + 1) / 2 - 1;
                    final double tmp = (f - fbeg) / stepb;
                    final double diff = stepb - stepa;
                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                    if (stepa * stepb < ZERO) {
                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                            fAtInterpolationPoints.setEntry(nfm - n, f);
                            if (trustRegionCenterInterpolationPointIndex == nfm) {
                                trustRegionCenterInterpolationPointIndex = nfm - n;
                            }
                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                            interpolationPoints.setEntry(nfm, nfxm, stepa);
                        }
                    }
                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                    bMatrix.setEntry(nfm - n, nfxm,
                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                    zMatrix.setEntry(nfm - n, nfxm,
                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
                }

                // Set the off-diagonal second derivatives of the Lagrange functions and
                // the initial quadratic model.

            } else {
                zMatrix.setEntry(0, nfxm, recip);
                zMatrix.setEntry(nfm, nfxm, recip);
                zMatrix.setEntry(ipt, nfxm, -recip);
                zMatrix.setEntry(jpt, nfxm, -recip);

                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                throw new PathIsExploredException(); // XXX
            }
        } while (getEvaluations() < npt);
    } // prelim",Match failed,0,1
176,Math_39,"@Override
  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0  = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp    = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
                              equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart         = equations.getTime();
    double  hNew      = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

      interpolator.shift();

      // iterate over step size, ensuring local normalized error is smaller than 1
      double error = 10;
      while (error >= 1.0) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[mainSetDimension];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
              }
          } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
              }
          }
          hNew = initializeStep(forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
         }
 
         stepSize = hNew;
 
         // next stages
         for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error >= 1.0) {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              FastMath.min(maxGrowth,
                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // local error is small enough: accept the step, trigger events and step handlers
      interpolator.storeTime(stepStart + stepSize);
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
      stepStart = acceptStep(interpolator, y, yDotTmp, t);
      System.arraycopy(y, 0, yTmp, 0, y.length);

      if (!isLastStep) {

          // prepare next step
          interpolator.storeTime(stepStart);

          if (fsal) {
              // save the last evaluation for the next step
              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
          }

          // stepsize control for next step
          final double factor =
              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          final double  scaledH    = stepSize * factor;
          final double  nextT      = stepStart + scaledH;
          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
          hNew = filterStep(scaledH, forward, nextIsLast);

          final double  filteredNextT      = stepStart + hNew;
          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
          if (filteredNextIsLast) {
              hNew = t - stepStart;
          }

      }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

  }","@Override
public void integrate(final ExpandableStatefulODE equations, final double t)
        throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
            equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

        interpolator.shift();

        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {

            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }

            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale,
                        stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }

            stepSize = hNew;

            // next stages
            for (int k = 1; k < stages; ++k) {

                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }

                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);

            }

            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor =
                        FastMath.min(maxGrowth,
                                FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, true);
            }

        }

        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);

        if (!isLastStep) {

            // prepare next step
            interpolator.storeTime(stepStart);

            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }

            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);

            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }

        }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

}",0,0
177,Math_40,"@Override
    protected double doSolve() {

        // prepare arrays with the first points
        final double[] x = new double[maximalOrder + 1];
        final double[] y = new double[maximalOrder + 1];
        x[0] = getMin();
        x[1] = getStartValue();
        x[2] = getMax();
        verifySequence(x[0], x[1], x[2]);

        // evaluate initial guess
        y[1] = computeObjectiveValue(x[1]);
        if (Precision.equals(y[1], 0.0, 1)) {
            // return the initial guess if it is a perfect root.
            return x[1];
        }

        // evaluate first  endpoint
        y[0] = computeObjectiveValue(x[0]);
        if (Precision.equals(y[0], 0.0, 1)) {
            // return the first endpoint if it is a perfect root.
            return x[0];
        }

        int nbPoints;
        int signChangeIndex;
        if (y[0] * y[1] < 0) {

            // reduce interval if it brackets the root
            nbPoints        = 2;
            signChangeIndex = 1;

        } else {

            // evaluate second endpoint
            y[2] = computeObjectiveValue(x[2]);
            if (Precision.equals(y[2], 0.0, 1)) {
                // return the second endpoint if it is a perfect root.
                return x[2];
            }

            if (y[1] * y[2] < 0) {
                // use all computed point as a start sampling array for solving
                nbPoints        = 3;
                signChangeIndex = 2;
            } else {
                throw new NoBracketingException(x[0], x[2], y[0], y[2]);
            }

        }

        // prepare a work array for inverse polynomial interpolation
        final double[] tmpX = new double[x.length];

        // current tightest bracketing of the root
        double xA    = x[signChangeIndex - 1];
        double yA    = y[signChangeIndex - 1];
        double absYA = FastMath.abs(yA);
        int agingA   = 0;
        double xB    = x[signChangeIndex];
        double yB    = y[signChangeIndex];
        double absYB = FastMath.abs(yB);
        int agingB   = 0;

        // search loop
        while (true) {

            // check convergence of bracketing interval
            final double xTol = getAbsoluteAccuracy() +
                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
                switch (allowed) {
                case ANY_SIDE :
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE :
                    return xA;
                case RIGHT_SIDE :
                    return xB;
                case BELOW_SIDE :
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE :
                    return (yA <  0) ? xB : xA;
                default :
                    // this should never happen
                    throw new MathInternalError(null);
                }
            }

            // target for the next evaluation point
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
            }

            // make a few attempts to guess a root,
            double nextX;
            int start = 0;
            int end   = nbPoints;
            do {

                // guess a value for current target, using inverse polynomial interpolation
                System.arraycopy(x, start, tmpX, start, end - start);
                nextX = guessX(targetY, tmpX, y, start, end);

                if (!((nextX > xA) && (nextX < xB))) {
                    // the guessed root is not strictly inside of the tightest bracketing interval

                    // the guessed root is either not strictly inside the interval or it
                    // is a NaN (which occurs when some sampling points share the same y)
                    // we try again with a lower interpolation order
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        // we have more points before the sign change, drop the lowest point
                        ++start;
                    } else {
                        // we have more points after sign change, drop the highest point
                        --end;
                    }

                    // we need to do one more attempt
                    nextX = Double.NaN;

                }

            } while (Double.isNaN(nextX) && (end - start > 1));

            if (Double.isNaN(nextX)) {
                // fall back to bisection
                nextX = xA + 0.5 * (xB - xA);
                start = signChangeIndex - 1;
                end   = signChangeIndex;
            }

            // evaluate the function at the guessed root
            final double nextY = computeObjectiveValue(nextX);
            if (Precision.equals(nextY, 0.0, 1)) {
                // we have found an exact root, since it is not an approximation
                // we don't need to bother about the allowed solutions setting
                return nextX;
            }

            if ((nbPoints > 2) && (end - start != nbPoints)) {

                // we have been forced to ignore some points to keep bracketing,
                // they are probably too far from the root, drop them from now on
                nbPoints = end - start;
                System.arraycopy(x, start, x, 0, nbPoints);
                System.arraycopy(y, start, y, 0, nbPoints);
                signChangeIndex -= start;

            } else  if (nbPoints == x.length) {

                // we have to drop one point in order to insert the new one
                nbPoints--;

                // keep the tightest bracketing interval as centered as possible
                if (signChangeIndex >= (x.length + 1) / 2) {
                    // we drop the lowest point, we have to shift the arrays and the index
                    System.arraycopy(x, 1, x, 0, nbPoints);
                    System.arraycopy(y, 1, y, 0, nbPoints);
                    --signChangeIndex;
                }

            }

            // insert the last computed point
            //(by construction, we know it lies inside the tightest bracketing interval)
            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
            x[signChangeIndex] = nextX;
            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
            y[signChangeIndex] = nextY;
            ++nbPoints;

            // update the bracketing interval
            if (nextY * yA <= 0) {
                // the sign change occurs before the inserted point
                xB = nextX;
                yB = nextY;
                absYB = FastMath.abs(yB);
                ++agingA;
                agingB = 0;
            } else {
                // the sign change occurs after the inserted point
                xA = nextX;
                yA = nextY;
                absYA = FastMath.abs(yA);
                agingA = 0;
                ++agingB;

                // update the sign change index
                signChangeIndex++;

            }

        }

    }","@Override
protected double doSolve() {
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];

    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);

    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        return x[1];
    }

    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        return x[0];
    }

    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            return x[2];
        }

        if (y[1] * y[2] < 0) {
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }

    final double[] tmpX = new double[x.length];
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;

    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;

    while (true) {
        final double xTol = getAbsoluteAccuracy() +
                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if ((xB - xA) <= xTol || FastMath.max(absYA, absYB) < getFunctionValueAccuracy()) {
            switch (allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    throw new MathInternalError();
            }
        }

        double targetY = agingA >= MAXIMAL_AGING ? -REDUCTION_FACTOR * yB :
                agingB >= MAXIMAL_AGING ? -REDUCTION_FACTOR * yA : 0;

        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);

            if (!(nextX > xA && nextX < xB) || Double.isNaN(nextX)) {
                if (signChangeIndex - start >= end - signChangeIndex) {
                    ++start;
                } else {
                    --end;
                }
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));

        if (Double.isNaN(nextX)) {
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }

        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            return nextX;
        }

        if (nbPoints > 2 && end - start != nbPoints) {
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            nbPoints--;
            if (signChangeIndex >= (x.length + 1) / 2) {
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }

        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;

        if (nextY * yA <= 0) {
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            signChangeIndex++;
        }
    }
}",0,0
177,Math_40,"@Override
    protected double doSolve() {

        // prepare arrays with the first points
        final double[] x = new double[maximalOrder + 1];
        final double[] y = new double[maximalOrder + 1];
        x[0] = getMin();
        x[1] = getStartValue();
        x[2] = getMax();
        verifySequence(x[0], x[1], x[2]);

        // evaluate initial guess
        y[1] = computeObjectiveValue(x[1]);
        if (Precision.equals(y[1], 0.0, 1)) {
            // return the initial guess if it is a perfect root.
            return x[1];
        }

        // evaluate first  endpoint
        y[0] = computeObjectiveValue(x[0]);
        if (Precision.equals(y[0], 0.0, 1)) {
            // return the first endpoint if it is a perfect root.
            return x[0];
        }

        int nbPoints;
        int signChangeIndex;
        if (y[0] * y[1] < 0) {

            // reduce interval if it brackets the root
            nbPoints        = 2;
            signChangeIndex = 1;

        } else {

            // evaluate second endpoint
            y[2] = computeObjectiveValue(x[2]);
            if (Precision.equals(y[2], 0.0, 1)) {
                // return the second endpoint if it is a perfect root.
                return x[2];
            }

            if (y[1] * y[2] < 0) {
                // use all computed point as a start sampling array for solving
                nbPoints        = 3;
                signChangeIndex = 2;
            } else {
                throw new NoBracketingException(x[0], x[2], y[0], y[2]);
            }

        }

        // prepare a work array for inverse polynomial interpolation
        final double[] tmpX = new double[x.length];

        // current tightest bracketing of the root
        double xA    = x[signChangeIndex - 1];
        double yA    = y[signChangeIndex - 1];
        double absYA = FastMath.abs(yA);
        int agingA   = 0;
        double xB    = x[signChangeIndex];
        double yB    = y[signChangeIndex];
        double absYB = FastMath.abs(yB);
        int agingB   = 0;

        // search loop
        while (true) {

            // check convergence of bracketing interval
            final double xTol = getAbsoluteAccuracy() +
                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
                switch (allowed) {
                case ANY_SIDE :
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE :
                    return xA;
                case RIGHT_SIDE :
                    return xB;
                case BELOW_SIDE :
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE :
                    return (yA <  0) ? xB : xA;
                default :
                    // this should never happen
                    throw new MathInternalError(null);
                }
            }

            // target for the next evaluation point
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
            }

            // make a few attempts to guess a root,
            double nextX;
            int start = 0;
            int end   = nbPoints;
            do {

                // guess a value for current target, using inverse polynomial interpolation
                System.arraycopy(x, start, tmpX, start, end - start);
                nextX = guessX(targetY, tmpX, y, start, end);

                if (!((nextX > xA) && (nextX < xB))) {
                    // the guessed root is not strictly inside of the tightest bracketing interval

                    // the guessed root is either not strictly inside the interval or it
                    // is a NaN (which occurs when some sampling points share the same y)
                    // we try again with a lower interpolation order
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        // we have more points before the sign change, drop the lowest point
                        ++start;
                    } else {
                        // we have more points after sign change, drop the highest point
                        --end;
                    }

                    // we need to do one more attempt
                    nextX = Double.NaN;

                }

            } while (Double.isNaN(nextX) && (end - start > 1));

            if (Double.isNaN(nextX)) {
                // fall back to bisection
                nextX = xA + 0.5 * (xB - xA);
                start = signChangeIndex - 1;
                end   = signChangeIndex;
            }

            // evaluate the function at the guessed root
            final double nextY = computeObjectiveValue(nextX);
            if (Precision.equals(nextY, 0.0, 1)) {
                // we have found an exact root, since it is not an approximation
                // we don't need to bother about the allowed solutions setting
                return nextX;
            }

            if ((nbPoints > 2) && (end - start != nbPoints)) {

                // we have been forced to ignore some points to keep bracketing,
                // they are probably too far from the root, drop them from now on
                nbPoints = end - start;
                System.arraycopy(x, start, x, 0, nbPoints);
                System.arraycopy(y, start, y, 0, nbPoints);
                signChangeIndex -= start;

            } else  if (nbPoints == x.length) {

                // we have to drop one point in order to insert the new one
                nbPoints--;

                // keep the tightest bracketing interval as centered as possible
                if (signChangeIndex >= (x.length + 1) / 2) {
                    // we drop the lowest point, we have to shift the arrays and the index
                    System.arraycopy(x, 1, x, 0, nbPoints);
                    System.arraycopy(y, 1, y, 0, nbPoints);
                    --signChangeIndex;
                }

            }

            // insert the last computed point
            //(by construction, we know it lies inside the tightest bracketing interval)
            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
            x[signChangeIndex] = nextX;
            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
            y[signChangeIndex] = nextY;
            ++nbPoints;

            // update the bracketing interval
            if (nextY * yA <= 0) {
                // the sign change occurs before the inserted point
                xB = nextX;
                yB = nextY;
                absYB = FastMath.abs(yB);
                ++agingA;
                agingB = 0;
            } else {
                // the sign change occurs after the inserted point
                xA = nextX;
                yA = nextY;
                absYA = FastMath.abs(yA);
                agingA = 0;
                ++agingB;

                // update the sign change index
                signChangeIndex++;

            }

        }

    }","@Override
protected double doSolve() {
    final int maxEvalLimit = maximalOrder + 1;
    final double[] x = new double[maxEvalLimit];
    final double[] y = new double[maxEvalLimit];

    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);

    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        return x[1];
    }

    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        return x[0];
    }

    int nbPoints;
    int signChangeIndex;
    
    if (y[0] * y[1] < 0) {
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            return x[2];
        }

        if (y[1] * y[2] < 0) {
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }

    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];

    while (true) {
        final double xTolerance = getAbsoluteAccuracy() + 
                                  getRelativeAccuracy() * Math.max(Math.abs(xA), Math.abs(xB));
        final double yTolerance = getFunctionValueAccuracy();

        if ((xB - xA <= xTolerance) || (Math.max(Math.abs(yA), Math.abs(yB)) < yTolerance)) {
            switch (allowed) {
                case ANY_SIDE:
                    return Math.abs(yA) < Math.abs(yB) ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return yA <= 0 ? xA : xB;
                case ABOVE_SIDE:
                    return yA < 0 ? xB : xA;
                default:
                    throw new MathInternalError();
            }
        }

        final double midX = xA + (xB - xA) / 2.0;
        final double midY = computeObjectiveValue(midX);
        if (Precision.equals(midY, 0.0, 1)) {
            return midX;
        }

        if (midY * yA <= 0) {
            xB = midX;
            yB = midY;
        } else {
            xA = midX;
            yA = midY;
        }
    }
}",0,1
177,Math_40,"@Override
    protected double doSolve() {

        // prepare arrays with the first points
        final double[] x = new double[maximalOrder + 1];
        final double[] y = new double[maximalOrder + 1];
        x[0] = getMin();
        x[1] = getStartValue();
        x[2] = getMax();
        verifySequence(x[0], x[1], x[2]);

        // evaluate initial guess
        y[1] = computeObjectiveValue(x[1]);
        if (Precision.equals(y[1], 0.0, 1)) {
            // return the initial guess if it is a perfect root.
            return x[1];
        }

        // evaluate first  endpoint
        y[0] = computeObjectiveValue(x[0]);
        if (Precision.equals(y[0], 0.0, 1)) {
            // return the first endpoint if it is a perfect root.
            return x[0];
        }

        int nbPoints;
        int signChangeIndex;
        if (y[0] * y[1] < 0) {

            // reduce interval if it brackets the root
            nbPoints        = 2;
            signChangeIndex = 1;

        } else {

            // evaluate second endpoint
            y[2] = computeObjectiveValue(x[2]);
            if (Precision.equals(y[2], 0.0, 1)) {
                // return the second endpoint if it is a perfect root.
                return x[2];
            }

            if (y[1] * y[2] < 0) {
                // use all computed point as a start sampling array for solving
                nbPoints        = 3;
                signChangeIndex = 2;
            } else {
                throw new NoBracketingException(x[0], x[2], y[0], y[2]);
            }

        }

        // prepare a work array for inverse polynomial interpolation
        final double[] tmpX = new double[x.length];

        // current tightest bracketing of the root
        double xA    = x[signChangeIndex - 1];
        double yA    = y[signChangeIndex - 1];
        double absYA = FastMath.abs(yA);
        int agingA   = 0;
        double xB    = x[signChangeIndex];
        double yB    = y[signChangeIndex];
        double absYB = FastMath.abs(yB);
        int agingB   = 0;

        // search loop
        while (true) {

            // check convergence of bracketing interval
            final double xTol = getAbsoluteAccuracy() +
                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
                switch (allowed) {
                case ANY_SIDE :
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE :
                    return xA;
                case RIGHT_SIDE :
                    return xB;
                case BELOW_SIDE :
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE :
                    return (yA <  0) ? xB : xA;
                default :
                    // this should never happen
                    throw new MathInternalError(null);
                }
            }

            // target for the next evaluation point
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
            }

            // make a few attempts to guess a root,
            double nextX;
            int start = 0;
            int end   = nbPoints;
            do {

                // guess a value for current target, using inverse polynomial interpolation
                System.arraycopy(x, start, tmpX, start, end - start);
                nextX = guessX(targetY, tmpX, y, start, end);

                if (!((nextX > xA) && (nextX < xB))) {
                    // the guessed root is not strictly inside of the tightest bracketing interval

                    // the guessed root is either not strictly inside the interval or it
                    // is a NaN (which occurs when some sampling points share the same y)
                    // we try again with a lower interpolation order
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        // we have more points before the sign change, drop the lowest point
                        ++start;
                    } else {
                        // we have more points after sign change, drop the highest point
                        --end;
                    }

                    // we need to do one more attempt
                    nextX = Double.NaN;

                }

            } while (Double.isNaN(nextX) && (end - start > 1));

            if (Double.isNaN(nextX)) {
                // fall back to bisection
                nextX = xA + 0.5 * (xB - xA);
                start = signChangeIndex - 1;
                end   = signChangeIndex;
            }

            // evaluate the function at the guessed root
            final double nextY = computeObjectiveValue(nextX);
            if (Precision.equals(nextY, 0.0, 1)) {
                // we have found an exact root, since it is not an approximation
                // we don't need to bother about the allowed solutions setting
                return nextX;
            }

            if ((nbPoints > 2) && (end - start != nbPoints)) {

                // we have been forced to ignore some points to keep bracketing,
                // they are probably too far from the root, drop them from now on
                nbPoints = end - start;
                System.arraycopy(x, start, x, 0, nbPoints);
                System.arraycopy(y, start, y, 0, nbPoints);
                signChangeIndex -= start;

            } else  if (nbPoints == x.length) {

                // we have to drop one point in order to insert the new one
                nbPoints--;

                // keep the tightest bracketing interval as centered as possible
                if (signChangeIndex >= (x.length + 1) / 2) {
                    // we drop the lowest point, we have to shift the arrays and the index
                    System.arraycopy(x, 1, x, 0, nbPoints);
                    System.arraycopy(y, 1, y, 0, nbPoints);
                    --signChangeIndex;
                }

            }

            // insert the last computed point
            //(by construction, we know it lies inside the tightest bracketing interval)
            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
            x[signChangeIndex] = nextX;
            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
            y[signChangeIndex] = nextY;
            ++nbPoints;

            // update the bracketing interval
            if (nextY * yA <= 0) {
                // the sign change occurs before the inserted point
                xB = nextX;
                yB = nextY;
                absYB = FastMath.abs(yB);
                ++agingA;
                agingB = 0;
            } else {
                // the sign change occurs after the inserted point
                xA = nextX;
                yA = nextY;
                absYA = FastMath.abs(yA);
                agingA = 0;
                ++agingB;

                // update the sign change index
                signChangeIndex++;

            }

        }

    }","@Override
protected double doSolve() {

    // Prepare arrays with boundary points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);

    // Evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        return x[1];
    }

    // Evaluate first endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        return x[0];
    }

    int nbPoints;
    int signChangeIndex;

    // Determine the bracketing region
    if (y[0] * y[1] < 0) {
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            return x[2];
        }

        if (y[1] * y[2] < 0) {
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }

    // Bracketing variables
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];

    // Main loop
    while (true) {
        final double xTolerance = getAbsoluteAccuracy() + getRelativeAccuracy() * Math.max(Math.abs(xA), Math.abs(xB));
        final double yTolerance = getFunctionValueAccuracy();

        if ((xB - xA <= xTolerance) || (Math.abs(yA) < yTolerance && Math.abs(yB) < yTolerance)) {
            switch (allowed) {
                case ANY_SIDE:
                    return Math.abs(yA) < Math.abs(yB) ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return yA <= 0 ? xA : xB;
                case ABOVE_SIDE:
                    return yA < 0 ? xB : xA;
                default:
                    throw new MathInternalError();
            }
        }

        // Compute midpoint and evaluate the function for better root approximation
        double midX = 0.5 * (xA + xB);
        double midY = computeObjectiveValue(midX);
        if (Precision.equals(midY, 0.0, 1)) {
            return midX;
        }

        // Update bracketing region
        if (midY * yA < 0) {
            xB = midX;
            yB = midY;
        } else {
            xA = midX;
            yA = midY;
        }
    }
}",0,2
178,Math_41,"public double evaluate(final double[] values, final double[] weights,
                           final double mean, final int begin, final int length) {

        double var = Double.NaN;

        if (test(values, weights, begin, length)) {
            if (length == 1) {
                var = 0.0;
            } else if (length > 1) {
                double accum = 0.0;
                double dev = 0.0;
                double accum2 = 0.0;
                for (int i = begin; i < begin + length; i++) {
                    dev = values[i] - mean;
                    accum += weights[i] * (dev * dev);
                    accum2 += weights[i] * dev;
                 }
 
                 double sumWts = 0;
                 for (int i = 0; i < weights.length; i++) {
                     sumWts += weights[i];
                 }
 
                if (isBiasCorrected) {
                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
                } else {
                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
                }
            }
        }
        return var;
    }","public double evaluate(final double[] values, final double[] weights,
                           final double mean, final int begin, final int length) {

        double var = Double.NaN;

        if (test(values, weights, begin, length)) {
            if (length == 1) {
                var = 0.0;
            } else if (length > 1) {
                double accum = 0.0;
                double dev = 0.0;
                double accum2 = 0.0;
                double sumWts = 0.0;
                for (int i = begin; i < begin + length; i++) {
                    dev = values[i] - mean;
                    accum += weights[i] * (dev * dev);
                    accum2 += weights[i] * dev;
                    sumWts += weights[i];
                }
 
                if (isBiasCorrected) {
                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
                } else {
                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
                }
            }
        }
        return var;
    }",0,0
179,Math_42,"protected RealPointValuePair getSolution() {
      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

      Set<Integer> basicRows = new HashSet<Integer>();
      double[] coefficients = new double[getOriginalNumDecisionVariables()];
      for (int i = 0; i < coefficients.length; i++) {
          int colIndex = columnLabels.indexOf(""x"" + i);
          if (colIndex < 0) {
            coefficients[i] = 0;
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
      return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
    Integer negativeVarBasicRow = (negativeVarColumn >= 0) ? getBasicRow(negativeVarColumn) : null;
    double mostNegative = (negativeVarBasicRow == null) ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

    Set<Integer> basicRows = new HashSet<Integer>();
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    for (int i = 0; i < coefficients.length; i++) {
        int colIndex = columnLabels.indexOf(""x"" + i);
        if (colIndex < 0) {
            coefficients[i] = 0;
            continue;
        }
        Integer basicRow = getBasicRow(colIndex);
        if (basicRow != null && basicRows.contains(basicRow)) {
            coefficients[i] = 0; // For unconstrained variables already part of the objective function
        } else {
            if (basicRow != null) {
                basicRows.add(basicRow);
            }
            coefficients[i] =
                (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                (restrictToNonNegative ? 0 : mostNegative);
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,0
179,Math_42,"protected RealPointValuePair getSolution() {
      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

      Set<Integer> basicRows = new HashSet<Integer>();
      double[] coefficients = new double[getOriginalNumDecisionVariables()];
      for (int i = 0; i < coefficients.length; i++) {
          int colIndex = columnLabels.indexOf(""x"" + i);
          if (colIndex < 0) {
            coefficients[i] = 0;
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
      return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
    Integer negativeVarBasicRow = (negativeVarColumn >= 0) ? getBasicRow(negativeVarColumn) : null;
    double mostNegative = (negativeVarBasicRow == null) ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

    Set<Integer> basicRows = new HashSet<>();
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    for (int i = 0; i < coefficients.length; i++) {
        int colIndex = columnLabels.indexOf(""x"" + i);
        if (colIndex < 0) {
            coefficients[i] = 0;
            continue;
        }
        Integer basicRow = getBasicRow(colIndex);
        if (basicRow != null && basicRows.contains(basicRow)) {
            // Skip duplicate row handling to avoid overwriting results
            coefficients[i] = 0;
        } else {
            if (basicRow != null) {
                basicRows.add(basicRow);
            }
            // Adjust coefficient calculation to handle negative values correctly
            coefficients[i] =
                (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                (restrictToNonNegative ? Math.max(0, mostNegative) : mostNegative);
        }
    }

    // Filter coefficients to ensure they adhere to objective function constraints
    for (int i = 0; i < coefficients.length; i++) {
        if (restrictToNonNegative && coefficients[i] < 0) {
            coefficients[i] = 0;
        }
    }

    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,1
180,Math_43,"public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        sumLogImpl.increment(value);
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
         if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
         if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
         if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
    }","public void addValue(double value) {
    sumImpl.increment(value);
    sumsqImpl.increment(value);
    minImpl.increment(value);
    maxImpl.increment(value);
    if (sumLogImpl != null) {
        sumLogImpl.increment(value);
    }
    if (secondMoment != null) {
        secondMoment.increment(value);
    }
    // If mean, variance or geomean have been overridden,
    // need to increment these
    if (meanImpl != null && !(meanImpl instanceof Mean)) {
        meanImpl.increment(value);
    }
    if (varianceImpl != null && !(varianceImpl instanceof Variance)) {
        varianceImpl.increment(value);
    }
    if (geoMeanImpl != null && !(geoMeanImpl instanceof GeometricMean)) {
        geoMeanImpl.increment(value);
    }
    n++;
}",0,0
180,Math_43,"public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        sumLogImpl.increment(value);
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
         if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
         if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
         if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
    }","public void addValue(double value) {
    // Handle edge cases: reject non-finite values
    if (Double.isNaN(value) || Double.isInfinite(value)) {
        throw new IllegalArgumentException(""Invalid numeric value: "" + value);
    }

    // Increment all standard metrics
    if (sumImpl != null) {
        sumImpl.increment(value);
    }
    if (sumsqImpl != null) {
        sumsqImpl.increment(value);
    }
    if (minImpl != null) {
        minImpl.increment(value);
    }
    if (maxImpl != null) {
        maxImpl.increment(value);
    }

    // Increment log-related metrics conditionally
    if (value > 0 && sumLogImpl != null) {
        sumLogImpl.increment(value);
    }

    // Increment advanced metrics if initialized
    if (secondMoment != null) {
        secondMoment.increment(value);
    }
    if (meanImpl != null && !(meanImpl instanceof Mean)) {
        meanImpl.increment(value);
    }
    if (varianceImpl != null && !(varianceImpl instanceof Variance)) {
        varianceImpl.increment(value);
    }
    if (geoMeanImpl != null && !(geoMeanImpl instanceof GeometricMean)) {
        if (value > 0) { // Geometric mean only affects positive values
            geoMeanImpl.increment(value);
        }
    }

    // Increment sample count
    n++;
}",0,1
180,Math_43,"public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        sumLogImpl.increment(value);
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
         if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
         if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
         if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
    }","public void addValue(double value) {
    // Handle edge cases: reject non-finite values
    if (Double.isNaN(value) || Double.isInfinite(value)) {
        throw new IllegalArgumentException(""Invalid numeric value: "" + value);
    }

    if (this.sumImpl != null) {
        this.sumImpl.increment(value);
    }
    if (this.sumsqImpl != null) {
        this.sumsqImpl.increment(value);
    }
    if (this.minImpl != null) {
        this.minImpl.increment(value);
    }
    if (this.maxImpl != null) {
        this.maxImpl.increment(value);
    }
    if (this.sumLogImpl != null && value > 0) {
        this.sumLogImpl.increment(value);
    }
    if (this.secondMoment != null) {
        this.secondMoment.increment(value);
    }
    // Increment conditionally overridden mean, variance, and geometric mean
    if (this.meanImpl != null) {
        this.meanImpl.increment(value);
    }
    if (this.varianceImpl != null) {
        this.varianceImpl.increment(value);
    }
    if (this.geoMeanImpl != null && value > 0) {
        this.geoMeanImpl.increment(value);
    }
    n++;
}",0,2
181,Math_44,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (!statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    computeDerivatives(eventT, y, yDot);
                    resetOccurred = true;
                    return eventT;
                }

                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            System.arraycopy(currentY, 0, y, 0, y.length);
            return currentT;
    }",0,0
181,Math_44,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                            final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

    double previousT = interpolator.getGlobalPreviousTime();
    double currentT = interpolator.getGlobalCurrentTime();
    resetOccurred = false;

    // Initialize the event states if needed
    if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }

    // Search and process events in chronological order
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    PriorityQueue<EventState> occuringEvents = new PriorityQueue<>(Comparator.comparingDouble(state -> orderingSign * state.getEventTime()));

    for (EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            occuringEvents.add(state);
        }
    }

    while (!occuringEvents.isEmpty()) {
        EventState currentEvent = occuringEvents.poll();

        // Restrict the interpolator to the event time
        double eventT = currentEvent.getEventTime();
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);

        // Trigger the event
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState();
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();

        // Process up to the event
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }

        if (isLastStep) {
            System.arraycopy(eventY, 0, y, 0, y.length);
            return eventT;
        }

        if (currentEvent.reset(eventT, eventY)) {
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            return eventT;
        }

        // Update and check for subsequent events
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);

        if (currentEvent.evaluateStep(interpolator)) {
            occuringEvents.add(currentEvent);
        }
    }

    // Process the remaining part of the step
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    isLastStep = Precision.equals(currentT, tEnd, 1);

    for (EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }

    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }

    System.arraycopy(currentY, 0, y, 0, y.length);
    return currentT;
}",0,1
182,Math_45,"    public OpenMapRealMatrix(int rowDimension, int columnDimension) {
        super(rowDimension, columnDimension);
        this.rows = rowDimension;
        this.columns = columnDimension;
        this.entries = new OpenIntToDoubleHashMap(0.0);
    }
","public OpenMapRealMatrix(int rowDimension, int columnDimension) {
    if (rowDimension <= 0 || columnDimension <= 0) {
        throw new IllegalArgumentException(""Matrix dimensions must be positive."");
    }
    super(rowDimension, columnDimension);
    this.rows = rowDimension;
    this.columns = columnDimension;
    this.entries = new OpenIntToDoubleHashMap(0.0);
}",0,0
183,Math_48,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    verifyBracketing(x0, x1);

    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    boolean inverted = false;

    while (true) {
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        if (fx == 0.0) {
            return x;
        }

        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
            case ILLINOIS:
                f0 *= 0.5;
                break;
            case PEGASUS:
                f0 *= f1 / (f1 + fx);
                break;
            case REGULA_FALSI:
                // Code for handling REGULA_FALSI method properly added.
                if (FastMath.abs(f1) == FastMath.abs(f0)) {
                    throw new IllegalArgumentException(""Algorithm stuck: interval is not reducing."");
                }
                break;
            default:
                throw new MathInternalError();
            }
        }

        x1 = x;
        f1 = fx;

        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
            case ANY_SIDE:
                return x1;
            case LEFT_SIDE:
                if (inverted) {
                    return x1;
                }
                break;
            case RIGHT_SIDE:
                if (!inverted) {
                    return x1;
                }
                break;
            case BELOW_SIDE:
                if (f1 <= 0) {
                    return x1;
                }
                break;
            case ABOVE_SIDE:
                if (f1 >= 0) {
                    return x1;
                }
                break;
            default:
                throw new MathInternalError();
            }
        }

        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
            case ANY_SIDE:
                return x1;
            case LEFT_SIDE:
                return inverted ? x1 : x0;
            case RIGHT_SIDE:
                return inverted ? x0 : x1;
            case BELOW_SIDE:
                return (f1 <= 0) ? x1 : x0;
            case ABOVE_SIDE:
                return (f1 >= 0) ? x1 : x0;
            default:
                throw new MathInternalError();
            }
        }
    }
}",0,0
183,Math_48,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    verifyBracketing(x0, x1);

    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    boolean inverted = false;
    int iterations = 0;
    final int maxIterations = getMaxEvaluations(); // introduce iteration limit

    while (iterations < maxIterations) {  // enforce iteration limit
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        if (fx == 0.0) {
            return x;
        }

        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    if (FastMath.abs(f1 - f0) < ftol) { // detect stuck state more robustly
                        throw new IllegalArgumentException(""Algorithm stuck: interval is not reducing."");
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        x1 = x;
        f1 = fx;

        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }

        iterations++; // increment iteration count
    }

    throw new IllegalArgumentException(""Maximum iterations exceeded without finding a root."");
}",0,1
183,Math_48,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;

    // Introduce iteration limit
    int iterations = 0;
    final int maxIterations = getMaxEvaluations();

    // Keep finding better approximations.
    while (iterations < maxIterations) {
        iterations++;

        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it immediately.
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
            case ILLINOIS:
                f0 *= 0.5;
                break;
            case PEGASUS:
                f0 *= f1 / (f1 + fx);
                break;
            case REGULA_FALSI:
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
            }
        }

        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;

        // Check for convergence based on function value accuracy
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
            case ANY_SIDE:
                return x1;
            case LEFT_SIDE:
                if (inverted) {
                    return x1;
                }
                break;
            case RIGHT_SIDE:
                if (!inverted) {
                    return x1;
                }
                break;
            case BELOW_SIDE:
                if (f1 <= 0) {
                    return x1;
                }
                break;
            case ABOVE_SIDE:
                if (f1 >= 0) {
                    return x1;
                }
                break;
            default:
                throw new MathInternalError();
            }
        }

        // Check for convergence based on interval size
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
            case ANY_SIDE:
                return x1;
            case LEFT_SIDE:
                return inverted ? x1 : x0;
            case RIGHT_SIDE:
                return inverted ? x0 : x1;
            case BELOW_SIDE:
                return (f1 <= 0) ? x1 : x0;
            case ABOVE_SIDE:
                return (f1 >= 0) ? x1 : x0;
            default:
                throw new MathInternalError();
            }
        }

    }

    // If maximum iterations were exceeded, throw an exception
    throw new TooManyEvaluationsException(maxIterations);
}",0,2
184,Math_5,"public Complex reciprocal() {
        if (isNaN) {
            return NaN;
         }
 
         if (real == 0.0 && imaginary == 0.0) {
             return NaN;
         }
 
         if (isInfinite) {
            return ZERO;
        }

        if (FastMath.abs(real) < FastMath.abs(imaginary)) {
            double q = real / imaginary;
            double scale = 1. / (real * q + imaginary);
            return createComplex(scale * q, -scale);
        } else {
            double q = imaginary / real;
            double scale = 1. / (imaginary * q + real);
            return createComplex(scale, -scale * q);
        }
    }","public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }

    if (real == 0.0 && imaginary == 0.0) {
        return Complex.ZERO; // Corrected to return ZERO instead of NaN for zero complex numbers
    }

    if (isInfinite) {
        return NaN; // Corrected to return NaN for infinite complex numbers
    }

    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}",0,0
184,Math_5,"public Complex reciprocal() {
        if (isNaN) {
            return NaN;
         }
 
         if (real == 0.0 && imaginary == 0.0) {
             return NaN;
         }
 
         if (isInfinite) {
            return ZERO;
        }

        if (FastMath.abs(real) < FastMath.abs(imaginary)) {
            double q = real / imaginary;
            double scale = 1. / (real * q + imaginary);
            return createComplex(scale * q, -scale);
        } else {
            double q = imaginary / real;
            double scale = 1. / (imaginary * q + real);
            return createComplex(scale, -scale * q);
        }
    }","public Complex reciprocal() {
    if (isNaN || isInfinite) {
        return NaN;
    }

    if (real == 0.0 && imaginary == 0.0) {
        throw new ArithmeticException(""Division by zero: complex reciprocal of zero has no defined result."");
    }

    double scale = real * real + imaginary * imaginary;
    if (scale == 0.0) {
        throw new ArithmeticException(""Overflow: division result cannot be represented within double precision."");
    }

    return createComplex(real / scale, -imaginary / scale);
}",0,1
184,Math_5,"public Complex reciprocal() {
        if (isNaN) {
            return NaN;
         }
 
         if (real == 0.0 && imaginary == 0.0) {
             return NaN;
         }
 
         if (isInfinite) {
            return ZERO;
        }

        if (FastMath.abs(real) < FastMath.abs(imaginary)) {
            double q = real / imaginary;
            double scale = 1. / (real * q + imaginary);
            return createComplex(scale * q, -scale);
        } else {
            double q = imaginary / real;
            double scale = 1. / (imaginary * q + real);
            return createComplex(scale, -scale * q);
        }
    }","public Complex reciprocal() {
    if (isNaN || isInfinite) {
        return NaN;
    }

    double scale = real * real + imaginary * imaginary;

    if (scale == 0.0) {
        return NaN; // Return NaN explicitly for zero-magnitude complex numbers instead of throwing.
    }

    return createComplex(real / scale, -imaginary / scale);
}",0,2
185,Math_50,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     if (x == x1) {
                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                         f0 = computeObjectiveValue(x0);
                     }
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it.
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    if (x == x1) {
                        double delta = FastMath.max(rtol * FastMath.abs(x1), atol);
                        x0 = 0.5 * (x0 + x1 - delta);
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;

        // If the function value of the last approximation is within tolerance, return.
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        // If the current interval is within the given accuracies, return.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",0,0
185,Math_50,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     if (x == x1) {
                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                         f0 = computeObjectiveValue(x0);
                     }
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // Check if one of the bounds is the exact root
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution
    verifyBracketing(x0, x1);

    // Get accuracies
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Track if the interval has flipped
    boolean inverted = false;

    // Iteratively find better approximations
    while (true) {
        // Calculate next approximation using formula
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // Return if exact root is found
        if (fx == 0.0) {
            return x;
        }

        // Update bounds and handle bracketing cases
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            if (method == Method.ILLINOIS || method == Method.PEGASUS) {
                f0 = method == Method.ILLINOIS ? f0 * 0.5 : f0 * (f1 / (f1 + fx));
            } else if (method == Method.REGULA_FALSI) {
                if (x == x1 || FastMath.abs(x1 - x0) <= atol) {
                    double delta = FastMath.max(rtol * FastMath.abs(x1), atol);
                    x0 = 0.5 * (x0 + x1 - delta);
                    f0 = computeObjectiveValue(x0);
                }
            } else {
                throw new MathInternalError();
            }
        }
        x1 = x;
        f1 = fx;

        // Function value within tolerance
        if (FastMath.abs(f1) <= ftol) {
            if (allowed == AllowedSolution.ANY_SIDE || 
                (allowed == AllowedSolution.LEFT_SIDE && inverted) ||
                (allowed == AllowedSolution.RIGHT_SIDE && !inverted) || 
                (allowed == AllowedSolution.BELOW_SIDE && f1 <= 0) ||
                (allowed == AllowedSolution.ABOVE_SIDE && f1 >= 0)) {
                    return x1;
            }
        }

        // Convergence-check on interval width
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",0,1
185,Math_50,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     if (x == x1) {
                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                         f0 = computeObjectiveValue(x0);
                     }
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution
    verifyBracketing(x0, x1);

    // Get accuracies
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Track if the interval has flipped
    boolean inverted = false;

    // Iteratively find better approximations
    while (true) {
        // Calculate next approximation using formula
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // Return if exact root is found
        if (fx == 0.0) {
            return x;
        }

        // Update bounds and handle bracketing cases
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            if (method == Method.ILLINOIS || method == Method.PEGASUS) {
                f0 = method == Method.ILLINOIS ? f0 * 0.5 : f0 * (f1 / (f1 + fx));
            } else if (method == Method.REGULA_FALSI) {
                if (FastMath.abs(x1 - x) <= atol) {
                    // To avoid infinite evaluations, attempt smaller interval rather than direct adjustment
                    double delta = FastMath.max(rtol * FastMath.abs(x1), atol);
                    x0 = 0.5 * (x0 + x1 - delta);
                    f0 = computeObjectiveValue(x0);
                }
            } else {
                throw new MathInternalError();
            }
        }
        x1 = x;
        f1 = fx;

        // Function value within tolerance
        if (FastMath.abs(f1) <= ftol) {
            if (allowed == AllowedSolution.ANY_SIDE || 
                (allowed == AllowedSolution.LEFT_SIDE && inverted) ||
                (allowed == AllowedSolution.RIGHT_SIDE && !inverted) || 
                (allowed == AllowedSolution.BELOW_SIDE && f1 <= 0) ||
                (allowed == AllowedSolution.ABOVE_SIDE && f1 >= 0)) {
                return x1;
            }
        }

        // Convergence-check on interval width
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }

        // Check for iteration bounds (to prevent too many evaluations)
        if (evaluationsExceeded()) {
            throw new TooManyEvaluationsException(getMaxEvaluations());
        }
    }
}",0,2
186,Math_51,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals, meaning that the left bound is larger than the right bound.
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation using the Regula Falsi method.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it.
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }

        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;

        // If the function value of the last approximation is too small,
        // given the function value accuracy, return the result based on the allowed solutions.
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }

        // If the current interval is within the given accuracies, return the result based on the allowed solutions.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",0,0
186,Math_51,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial bounds.
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // Check if any bound is the exact root.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Boolean to track inverted intervals.
    boolean inverted = false;

    // Iterative process to refine approximations.
    while (true) {
        // Calculate next approximation using modified regula falsi.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // Check if approximation is the exact root.
        if (fx == 0.0) {
            return x;
        }

        // Update bounds and invert interval if necessary.
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            // Adapt method-specific updating logic.
            if (method == Method.ILLINOIS) {
                f0 *= 0.5;
            } else if (method == Method.PEGASUS) {
                f0 *= f1 / (f1 + fx);
            }
        }

        // Update bounds.
        x1 = x;
        f1 = fx;

        // Check function value accuracy.
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE: return x1;
                case LEFT_SIDE: return inverted ? x1 : x0;
                case RIGHT_SIDE: return inverted ? x0 : x1;
                case BELOW_SIDE: return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0;
            }
        }

        // Check interval accuracy.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE: return x1;
                case LEFT_SIDE: return inverted ? x1 : x0;
                case RIGHT_SIDE: return inverted ? x0 : x1;
                case BELOW_SIDE: return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0;
            }
        }
    }
}",0,1
186,Math_51,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals
    boolean inverted = false;

    int evaluations = 0; // Track the number of evaluations

    // Iteratively find a better approximation.
    while (evaluations < getMaxEvaluations()) {
        // Check bounds are exact roots
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Calculate the next approximation using the Regula Falsi method.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        evaluations++;

        // Return exact root if found
        if (fx == 0.0) {
            return x;
        }

        // Update bounds
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            // Adapt method-specific updating logic.
            if (method == Method.ILLINOIS) {
                f0 *= 0.5;
            } else if (method == Method.PEGASUS) {
                f0 *= f1 / (f1 + fx);
            }
        }
        x1 = x;
        f1 = fx;

         // Check function value accuracy.
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE: return x1;
                case LEFT_SIDE: return inverted ? x1 : x0;
                case RIGHT_SIDE: return inverted ? x0 : x1;
                case BELOW_SIDE: return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0;
            }
        }

        // Check interval accuracy.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE: return x1;
                case LEFT_SIDE: return inverted ? x1 : x0;
                case RIGHT_SIDE: return inverted ? x0 : x1;
                case BELOW_SIDE: return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0;
            }
        }
    }

    // If we're here, too many evaluations occurred
    throw new TooManyEvaluationsException(evaluations);
}",0,2
187,Math_52,"  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

  // norms computation
  double u1u1 = u1.getNormSq();
  double u2u2 = u2.getNormSq();
  double v1v1 = v1.getNormSq();
  double v2v2 = v2.getNormSq();
  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
  }

  // normalize v1 in order to have (v1'|v1') = (u1|u1)
  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
  double u1u2   = u1.dotProduct(u2);
  double v1v2   = v1.dotProduct(v2);
  double coeffU = u1u2 / u1u1;
  double coeffV = v1v2 / u1u1;
  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
  double alpha  = coeffU - beta * coeffV;
  v2 = new Vector3D(alpha, v1, beta, v2);

  // preliminary computation
  Vector3D uRef  = u1;
  Vector3D vRef  = v1;
  Vector3D v1Su1 = v1.subtract(u1);
  Vector3D v2Su2 = v2.subtract(u2);
  Vector3D k     = v1Su1.crossProduct(v2Su2);
  Vector3D u3    = u1.crossProduct(u2);
  double c       = k.dotProduct(u3);
  if (c == 0) {
    // the (q1, q2, q3) vector is close to the (u1, u2) plane
    // we try other vectors
    Vector3D v3 = Vector3D.crossProduct(v1, v2);
    Vector3D v3Su3 = v3.subtract(u3);
    k = v1Su1.crossProduct(v3Su3);
    Vector3D u2Prime = u1.crossProduct(u3);
    c = k.dotProduct(u2Prime);

    if (c == 0) {
      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
      k = v2Su2.crossProduct(v3Su3);;
      c = k.dotProduct(u2.crossProduct(u3));;

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

  }

  // compute the vectorial part
  c = FastMath.sqrt(c);
  double inv = 1.0 / (c + c);
  q1 = inv * k.getX();
  q2 = inv * k.getY();
  q3 = inv * k.getZ();

  // compute the scalar part
   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                    uRef.getZ() * q1 - uRef.getX() * q3,
                    uRef.getX() * q2 - uRef.getY() * q1);
  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

  }
","public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw new IllegalArgumentException(""Zero norm for rotation defining vector"");
    }

    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);

    // preliminary computation
    Vector3D uRef = u1;
    Vector3D vRef = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);
    if (Math.abs(c) < 1.0e-10) {
        // the (q1, q2, q3) vector is close to the (u1, u2) plane
        // we try other vectors
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);

        if (Math.abs(c) < 1.0e-10) {
            // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
            // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
            k = v2Su2.crossProduct(v3Su3);
            c = k.dotProduct(u2.crossProduct(u3));

            if (Math.abs(c) < 1.0e-10) {
                // the (q1, q2, q3) vector is aligned with everything
                // this is really the identity rotation
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }

            // we will have to use u2 and v2 to compute the scalar part
            uRef = u2;
            vRef = v2;
        }
    }

    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();

    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                     uRef.getZ() * q1 - uRef.getX() * q3,
                     uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}",0,0
187,Math_52,"  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

  // norms computation
  double u1u1 = u1.getNormSq();
  double u2u2 = u2.getNormSq();
  double v1v1 = v1.getNormSq();
  double v2v2 = v2.getNormSq();
  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
  }

  // normalize v1 in order to have (v1'|v1') = (u1|u1)
  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
  double u1u2   = u1.dotProduct(u2);
  double v1v2   = v1.dotProduct(v2);
  double coeffU = u1u2 / u1u1;
  double coeffV = v1v2 / u1u1;
  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
  double alpha  = coeffU - beta * coeffV;
  v2 = new Vector3D(alpha, v1, beta, v2);

  // preliminary computation
  Vector3D uRef  = u1;
  Vector3D vRef  = v1;
  Vector3D v1Su1 = v1.subtract(u1);
  Vector3D v2Su2 = v2.subtract(u2);
  Vector3D k     = v1Su1.crossProduct(v2Su2);
  Vector3D u3    = u1.crossProduct(u2);
  double c       = k.dotProduct(u3);
  if (c == 0) {
    // the (q1, q2, q3) vector is close to the (u1, u2) plane
    // we try other vectors
    Vector3D v3 = Vector3D.crossProduct(v1, v2);
    Vector3D v3Su3 = v3.subtract(u3);
    k = v1Su1.crossProduct(v3Su3);
    Vector3D u2Prime = u1.crossProduct(u3);
    c = k.dotProduct(u2Prime);

    if (c == 0) {
      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
      k = v2Su2.crossProduct(v3Su3);;
      c = k.dotProduct(u2.crossProduct(u3));;

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

  }

  // compute the vectorial part
  c = FastMath.sqrt(c);
  double inv = 1.0 / (c + c);
  q1 = inv * k.getX();
  q2 = inv * k.getY();
  q3 = inv * k.getZ();

  // compute the scalar part
   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                    uRef.getZ() * q1 - uRef.getX() * q3,
                    uRef.getX() * q2 - uRef.getY() * q1);
  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

  }
","public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw new IllegalArgumentException(""Zero norm for rotation defining vector"");
    }

    // normalize v2 in order to have (v2'|v2') = (u2|u2)
    v2 = new Vector3D(FastMath.sqrt(u2u2 / v2v2), v2);

    // adjust v1 in order to have (u1|u2) = (v1'|v2') and (v1'|v1') = (u1|u1)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / v2v2;
    double alpha = coeffU - coeffV * FastMath.sqrt((u1u1 - u1u2 * coeffU) / (v1v1 - v1v2 * coeffV));
    v1 = new Vector3D(alpha, v2, FastMath.sqrt(u1u1 / v1v1), v1);

    // preliminary computation
    Vector3D uRef = u2;
    Vector3D vRef = v2;
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D k = v2Su2.crossProduct(v1Su1);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);

    if (Math.abs(c) < 1.0e-10) {
        // the (q1, q2, q3) vector is close to the (u1, u2) plane
        Vector3D v3 = v1.crossProduct(v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v2Su2.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);

        if (Math.abs(c) < 1.0e-10) {
            // the (q1, q2, q3) vector is also close to the (u2, u3) plane
            k = v1Su1.crossProduct(v3Su3);
            c = k.dotProduct(u2.crossProduct(u3));

            if (Math.abs(c) < 1.0e-10) {
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }

            uRef = u1;
            vRef = v1;
        }
    }

    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();

    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                     uRef.getZ() * q1 - uRef.getX() * q3,
                     uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}",0,1
187,Math_52,"  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

  // norms computation
  double u1u1 = u1.getNormSq();
  double u2u2 = u2.getNormSq();
  double v1v1 = v1.getNormSq();
  double v2v2 = v2.getNormSq();
  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
  }

  // normalize v1 in order to have (v1'|v1') = (u1|u1)
  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
  double u1u2   = u1.dotProduct(u2);
  double v1v2   = v1.dotProduct(v2);
  double coeffU = u1u2 / u1u1;
  double coeffV = v1v2 / u1u1;
  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
  double alpha  = coeffU - beta * coeffV;
  v2 = new Vector3D(alpha, v1, beta, v2);

  // preliminary computation
  Vector3D uRef  = u1;
  Vector3D vRef  = v1;
  Vector3D v1Su1 = v1.subtract(u1);
  Vector3D v2Su2 = v2.subtract(u2);
  Vector3D k     = v1Su1.crossProduct(v2Su2);
  Vector3D u3    = u1.crossProduct(u2);
  double c       = k.dotProduct(u3);
  if (c == 0) {
    // the (q1, q2, q3) vector is close to the (u1, u2) plane
    // we try other vectors
    Vector3D v3 = Vector3D.crossProduct(v1, v2);
    Vector3D v3Su3 = v3.subtract(u3);
    k = v1Su1.crossProduct(v3Su3);
    Vector3D u2Prime = u1.crossProduct(u3);
    c = k.dotProduct(u2Prime);

    if (c == 0) {
      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
      k = v2Su2.crossProduct(v3Su3);;
      c = k.dotProduct(u2.crossProduct(u3));;

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

  }

  // compute the vectorial part
  c = FastMath.sqrt(c);
  double inv = 1.0 / (c + c);
  q1 = inv * k.getX();
  q2 = inv * k.getY();
  q3 = inv * k.getZ();

  // compute the scalar part
   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                    uRef.getZ() * q1 - uRef.getX() * q3,
                    uRef.getX() * q2 - uRef.getY() * q1);
  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

  }
","public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }

    // normalize v1 and v2 to match corresponding u norms
    v1 = new Vector3D(Math.sqrt(u1u1 / v1v1), v1);
    v2 = new Vector3D(Math.sqrt(u2u2 / v2v2), v2);

    // determine transformation coefficients
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / v2v2;
    double adjustedCoeffV = coeffV * Math.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));

    v2 = new Vector3D(coeffU - adjustedCoeffV, v1, adjustedCoeffV, v2);

    // compute the vectorial part using crossProducts
    Vector3D k = v1.subtract(u1).crossProduct(v2.subtract(u2));
    double c = k.dotProduct(u1.crossProduct(u2));

    // check if alignment issues need resolution
    if (Math.abs(c) < 1.0e-10) {
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        k = v1.subtract(u1).crossProduct(v3.subtract(u1.crossProduct(u2)));
        c = k.dotProduct(u1.crossProduct(u2));
        
        if (Math.abs(c) < 1.0e-10) {
            k = v2.subtract(u2).crossProduct(v3.subtract(u1.crossProduct(u2)));
            c = k.dotProduct(u1.crossProduct(u2));
            
            // identity rotation if all vectors align
            if (Math.abs(c) < 1.0e-10) {
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }
        }
    }

    // finalize vectorial and scalar parts
    c = Math.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();

    Vector3D uRef = (Math.abs(c) < 1.0e-10) ? u2 : u1;
    Vector3D vRef = (Math.abs(c) < 1.0e-10) ? v2 : v1;

    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                     uRef.getZ() * q1 - uRef.getX() * q3,
                     uRef.getX() * q2 - uRef.getY() * q1);

    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}",0,2
188,Math_53,"public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }",Match failed,0,0
189,Math_55,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


      // rescale both vectors without losing precision,
      // to ensure their norm are the same order of magnitude

      // we reduce cancellation errors by preconditioning,
      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
      // v3 without loss of precision. See Kahan lecture
      // ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
 
 
       // compute cross product from v3 and v2 instead of v1 and v2
       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }","public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
    // first, compute rho as an 8 bits approximation of v1.v2 / v2.v2
    double rho = (v1.getX() * v2.getX() + v1.getY() * v2.getY() + v1.getZ() * v2.getZ()) /
                 (v2.getX() * v2.getX() + v2.getY() * v2.getY() + v2.getZ() * v2.getZ());
    
    // compute v3 = v1 - rho * v2
    Vector3D v3 = new Vector3D(
        v1.getX() - rho * v2.getX(),
        v1.getY() - rho * v2.getY(),
        v1.getZ() - rho * v2.getZ()
    );
    
    // compute cross product from v3 and v2 instead of v1 and v2
    return new Vector3D(v3.getY() * v2.getZ() - v3.getZ() * v2.getY(), 
                        v3.getZ() * v2.getX() - v3.getX() * v2.getZ(),
                        v3.getX() * v2.getY() - v3.getY() * v2.getX());
}",0,0
189,Math_55,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


      // rescale both vectors without losing precision,
      // to ensure their norm are the same order of magnitude

      // we reduce cancellation errors by preconditioning,
      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
      // v3 without loss of precision. See Kahan lecture
      // ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
 
 
       // compute cross product from v3 and v2 instead of v1 and v2
       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }",Match failed,0,1
190,Math_56,"public int[] getCounts(int index) {
        if (index < 0 ||
            index >= totalSize) {
            throw new OutOfRangeException(index, 0, totalSize);
        }

        final int[] indices = new int[dimension];

        int count = 0;
        for (int i = 0; i < last; i++) {
            int idx = 0;
            final int offset = uniCounterOffset[i];
            while (count <= index) {
                count += offset;
                ++idx;
            }
            --idx;
            count -= offset;
             indices[i] = idx;
         }
 
         int idx = 1;
         while (count < index) {
             count += idx;
             ++idx;
         }
         --idx;
         indices[last] = idx;
 
         return indices;
     }","public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize);
    }

    final int[] indices = new int[dimension];
    int count = 0;
    for (int i = 0; i < dimension - 1; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while (count + offset <= index) {
            count += offset;
            ++idx;
        }
        indices[i] = idx;
    }

    indices[dimension - 1] = index - count;

    return indices;
}",0,0
191,Math_57,"private static <T extends Clusterable<T>> List<Cluster<T>>
        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {

        final List<T> pointSet = new ArrayList<T>(points);
        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();

        // Choose one center uniformly at random from among the data points.
        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
        resultSet.add(new Cluster<T>(firstPoint));

        final double[] dx2 = new double[pointSet.size()];
        while (resultSet.size() < k) {
            // For each data point x, compute D(x), the distance between x and
            // the nearest center that has already been chosen.
            int sum = 0;
            for (int i = 0; i < pointSet.size(); i++) {
                final T p = pointSet.get(i);
                final Cluster<T> nearest = getNearestCluster(resultSet, p);
                final double d = p.distanceFrom(nearest.getCenter());
                sum += d * d;
                dx2[i] = sum;
            }

            // Add one new data point as a center. Each point x is chosen with
            // probability proportional to D(x)2
            final double r = random.nextDouble() * sum;
            for (int i = 0 ; i < dx2.length; i++) {
                if (dx2[i] >= r) {
                    final T p = pointSet.remove(i);
                    resultSet.add(new Cluster<T>(p));
                    break;
                }
            }
        }

        return resultSet;

    }
","private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) {

    final List<T> pointSet = new ArrayList<T>(points);
    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();

    // Choose one center uniformly at random from among the data points.
    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
    resultSet.add(new Cluster<T>(firstPoint));

    final double[] dx2 = new double[pointSet.size()];
    while (resultSet.size() < k) {
        // For each data point x, compute D(x), the distance between x and the nearest center that has already been chosen.
        double sum = 0;
        for (int i = 0; i < pointSet.size(); i++) {
            final T p = pointSet.get(i);
            final Cluster<T> nearest = getNearestCluster(resultSet, p);
            final double d = p.distanceFrom(nearest.getCenter());
            sum += d * d;
            dx2[i] = sum;
        }

        // Ensure that sum is greater than 0 to avoid zero pivot
        if (sum == 0) {
            break;
        }

        // Add one new data point as a center. Each point x is chosen with probability proportional to D(x)^2
        final double r = random.nextDouble() * sum;
        for (int i = 0; i < dx2.length; i++) {
            if (dx2[i] >= r) {
                final T p = pointSet.remove(i);
                resultSet.add(new Cluster<T>(p));
                break;
            }
        }
    }

    return resultSet;
}",0,0
192,Math_58,"public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
         return fit(new Gaussian.Parametric(), guess);
     }","public double[] fit() {
    final double[] guess;
    try {
        guess = (new ParameterGuesser(getObservations())).guess();
    } catch (Exception e) {
        throw new IllegalStateException(""Failed to guess initial parameters: "" + e.getMessage(), e);
    }
    return fit(new Gaussian.Parametric(), guess);
}",0,0
192,Math_58,"public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
         return fit(new Gaussian.Parametric(), guess);
     }","public double[] fit() {
        double[] guess;
        try {
            guess = (new ParameterGuesser(getObservations())).guess();
        } catch (Exception e) {
            // Handling failed parameter guessing gracefully
            guess = new double[] {1.0, 0.0, 1.0}; // default guess if parameter guessing fails
        }
        
        double[] fittedParameters;
        try {
            fittedParameters = fit(new Gaussian.Parametric(), guess);
        } catch (Exception e) {
            // Handling failed fitting gracefully
            throw new IllegalStateException(""Failed to fit the Gaussian model: "" + e.getMessage(), e);
        }
        
        return fittedParameters;
    }",0,1
192,Math_58,"public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
         return fit(new Gaussian.Parametric(), guess);
     }","public double[] fit() {
    double[] guess;
    try {
        guess = (new ParameterGuesser(getObservations())).guess();
    } catch (Exception e) {
        throw new IllegalStateException(""Failed to guess initial parameters: "" + e.getMessage(), e);
    }

    double[] fittedParameters;
    try {
        fittedParameters = fit(new Gaussian.Parametric(), guess);
    } catch (Exception e) {
        // Handle exceptions due to invalid parameter values by filtering and retrying
        double[] validParams = Arrays.stream(guess)
                                     .map(param -> Math.max(param, 1e-12))
                                     .toArray();
        try {
            fittedParameters = fit(new Gaussian.Parametric(), validParams);
        } catch (Exception e2) {
            throw new IllegalStateException(""Failed to fit the Gaussian model after adjustment: "" + e2.getMessage(), e2);
        }
    }

    return fittedParameters;
}",0,2
193,Math_59,"    public static float max(final float a, final float b) {
        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
    }
",Match failed,0,0
194,Math_60,"public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
         try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
         } catch (MaxIterationsExceededException ex) {
             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                 return 0;
             } else if (x > (mean + 20 * standardDeviation)) {
                 return 1;
             } else {
                 throw ex;
             }
         }
     }","public double cumulativeProbability(double x) throws MathException {
    final double dev = x - mean;
    try {
        return 0.5 * (1.0 + Erf.erf((dev) /
                (standardDeviation * FastMath.sqrt(2.0))));
    } catch (MaxIterationsExceededException ex) {
        if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
            return 0;
        } else if (x > (mean + 20 * standardDeviation)) {
            return 1;
        } else {
            throw new MathException(""Unable to compute cumulative probability due to exceeding max iterations"", ex);
        }
    }
}",0,0
194,Math_60,"public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
         try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
         } catch (MaxIterationsExceededException ex) {
             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                 return 0;
             } else if (x > (mean + 20 * standardDeviation)) {
                 return 1;
             } else {
                 throw ex;
             }
         }
     }","public double cumulativeProbability(double x) throws MathException {
    final double dev = x - mean;
    try {
        double erfValue = Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)));
        if (Double.isNaN(erfValue)) {
            throw new MathException(""Erf function returned NaN."");
        }
        return 0.5 * (1.0 + erfValue);
    } catch (MaxIterationsExceededException ex) {
        double zScore = dev / standardDeviation;
        if (zScore < -6) {
            return 0.0; // very far left
        } else if (zScore > 6) {
            return 1.0; // very far right
        } else {
            throw new MathException(""Computation failed for z-score within normal bounds"", ex);
        }
    }
}",0,1
194,Math_60,"public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
         try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
         } catch (MaxIterationsExceededException ex) {
             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                 return 0;
             } else if (x > (mean + 20 * standardDeviation)) {
                 return 1;
             } else {
                 throw ex;
             }
         }
     }","public double cumulativeProbability(double x) throws MathException {
    final double dev = x - mean;
    try {
        if (Double.isInfinite(x)) {
            return x < 0 ? 0.0 : 1.0; // Handle extreme values explicitly
        }
        double erfValue = Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)));
        return 0.5 * (1.0 + erfValue);
    } catch (MaxIterationsExceededException ex) {
        double zScore = dev / standardDeviation;
        if (zScore < -20) {
            return 0.0; // very far left
        } else if (zScore > 20) {
            return 1.0; // very far right
        } else {
            throw new MathException(""Computation failed for z-score within bounds"", ex);
        }
    }
}",0,2
195,Math_63,"    public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
","public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || (x == y) || (Double.doubleToLongBits(x) == Double.doubleToLongBits(y));
}",0,0
195,Math_63,"    public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
","public static boolean equals(double x, double y) {
    if (Double.compare(x, y) == 0) {
        return true;
    }
    return Double.isNaN(x) && Double.isNaN(y);
}",0,1
195,Math_63,"    public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
",Match failed,0,2
196,Math_64,"@Override
    protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        // arrays shared with the other private methods
        solvedCols  = Math.min(rows, cols);
        diagR       = new double[cols];
        jacNorm     = new double[cols];
        beta        = new double[cols];
        permutation = new int[cols];
        lmDir       = new double[cols];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[cols];
        double[] oldX    = new double[cols];
        double[] oldRes  = new double[rows];
        double[] work1   = new double[cols];
        double[] work2   = new double[cols];
        double[] work3   = new double[cols];

        // evaluate the function at the starting point and calculate its norm
        updateResidualsAndCost();

        // outer loop
        lmPar = 0;
        boolean firstIteration = true;
        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
        while (true) {
            incrementIterationsCounter();

            // compute the Q.R. decomposition of the jacobian matrix
            VectorialPointValuePair previous = current;
            updateJacobian();
             qrDecomposition();
 
             // compute Qt.res
             qTy(residuals);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                jacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {

                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * point[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = Math.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (cost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // convergence has been reached
                return current;
            }

            // rescale if necessary
            for (int j = 0; j < cols; ++j) {
                diag[j] = Math.max(diag[j], jacNorm[j]);
            }

            // inner loop
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }
                double previousCost = cost;
                double[] tmpVec = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(oldRes, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = Math.sqrt(lmNorm);
                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = Math.min(delta, lmNorm);
                }

                // evaluate the function at x + p and calculate its norm
                updateResidualsAndCost();
                current = new VectorialPointValuePair(point, objective);

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * cost < previousCost) {
                    double r = cost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += jacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * Math.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < cols; ++k) {
                        double xK = diag[k] * point[k];
                        xNorm    += xK * xK;
                    }
                    xNorm = Math.sqrt(xNorm);

                    // tests for convergence.
                    // we use the vectorial convergence checker
                } else {
                    // failed iteration, reset the previous values
                    cost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }
                    tmpVec    = residuals;
                    residuals = oldRes;
                    oldRes    = tmpVec;
                }
                if (checker==null) {
                	if (((Math.abs(actRed) <= costRelativeTolerance) &&
                        (preRed <= costRelativeTolerance) &&
                        (ratio <= 2.0)) ||
                       (delta <= parRelativeTolerance * xNorm)) {
                       return current;
                   }
                } else {
                    if (checker.converged(getIterations(), previous, current)) {
                        return current;
                    }
                }
                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                            costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                            parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                            orthoTolerance);
                }

            }

        }

    }","@Override
    protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        // arrays shared with the other private methods
        solvedCols  = Math.min(rows, cols);
        diagR       = new double[cols];
        jacNorm     = new double[cols];
        beta        = new double[cols];
        permutation = new int[cols];
        lmDir       = new double[cols];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[cols];
        double[] oldX    = new double[cols];
        double[] oldRes  = new double[rows];
        double[] work1   = new double[cols];
        double[] work2   = new double[cols];
        double[] work3   = new double[cols];

        // evaluate the function at the starting point and calculate its norm
        updateResidualsAndCost();

        // outer loop
        lmPar = 0;
        boolean firstIteration = true;
        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
        while (true) {
            incrementIterationsCounter();

            // compute the Q.R. decomposition of the jacobian matrix
            VectorialPointValuePair previous = current;
            updateJacobian();
             qrDecomposition();
 
             // compute Qt.res
             qTy(residuals);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                jacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {

                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * point[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = Math.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (cost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // convergence has been reached
                return current;
            }

            // rescale if necessary
            for (int j = 0; j < cols; ++j) {
                diag[j] = Math.max(diag[j], jacNorm[j]);
            }

            // inner loop
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }
                double previousCost = cost;
                double[] tmpVec = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(oldRes, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = Math.sqrt(lmNorm);
                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = Math.min(delta, lmNorm);
                }

                // evaluate the function at x + p and calculate its norm
                updateResidualsAndCost();
                current = new VectorialPointValuePair(point, objective);

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * cost < previousCost) {
                    double r = cost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += jacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * Math.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < cols; ++k) {
                        double xK = diag[k] * point[k];
                        xNorm    += xK * xK;
                    }
                    xNorm = Math.sqrt(xNorm);

                    // tests for convergence.
                    // we use the vectorial convergence checker
                } else {
                    // failed iteration, reset the previous values
                    cost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }
                    tmpVec    = residuals;
                    residuals = oldRes;
                    oldRes    = tmpVec;
                }
                
                if (checker==null) {
                        if (((Math.abs(actRed) <= costRelativeTolerance) &&
                            (preRed <= costRelativeTolerance) &&
                            (ratio <= 2.0)) ||
                           (delta <= parRelativeTolerance * xNorm)) {
                           return current;
                       }
       
                } else {
                    if (checker.converged(getIterations(), previous, current)) {
                        return current;
                    }
                }
                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                            costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                            parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                            orthoTolerance);
                }

            }

        }

    }",0,0
196,Math_64,"@Override
    protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        // arrays shared with the other private methods
        solvedCols  = Math.min(rows, cols);
        diagR       = new double[cols];
        jacNorm     = new double[cols];
        beta        = new double[cols];
        permutation = new int[cols];
        lmDir       = new double[cols];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[cols];
        double[] oldX    = new double[cols];
        double[] oldRes  = new double[rows];
        double[] work1   = new double[cols];
        double[] work2   = new double[cols];
        double[] work3   = new double[cols];

        // evaluate the function at the starting point and calculate its norm
        updateResidualsAndCost();

        // outer loop
        lmPar = 0;
        boolean firstIteration = true;
        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
        while (true) {
            incrementIterationsCounter();

            // compute the Q.R. decomposition of the jacobian matrix
            VectorialPointValuePair previous = current;
            updateJacobian();
             qrDecomposition();
 
             // compute Qt.res
             qTy(residuals);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                jacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {

                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * point[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = Math.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (cost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // convergence has been reached
                return current;
            }

            // rescale if necessary
            for (int j = 0; j < cols; ++j) {
                diag[j] = Math.max(diag[j], jacNorm[j]);
            }

            // inner loop
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }
                double previousCost = cost;
                double[] tmpVec = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(oldRes, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = Math.sqrt(lmNorm);
                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = Math.min(delta, lmNorm);
                }

                // evaluate the function at x + p and calculate its norm
                updateResidualsAndCost();
                current = new VectorialPointValuePair(point, objective);

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * cost < previousCost) {
                    double r = cost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += jacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * Math.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < cols; ++k) {
                        double xK = diag[k] * point[k];
                        xNorm    += xK * xK;
                    }
                    xNorm = Math.sqrt(xNorm);

                    // tests for convergence.
                    // we use the vectorial convergence checker
                } else {
                    // failed iteration, reset the previous values
                    cost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }
                    tmpVec    = residuals;
                    residuals = oldRes;
                    oldRes    = tmpVec;
                }
                if (checker==null) {
                	if (((Math.abs(actRed) <= costRelativeTolerance) &&
                        (preRed <= costRelativeTolerance) &&
                        (ratio <= 2.0)) ||
                       (delta <= parRelativeTolerance * xNorm)) {
                       return current;
                   }
                } else {
                    if (checker.converged(getIterations(), previous, current)) {
                        return current;
                    }
                }
                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                            costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                            parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                            orthoTolerance);
                }

            }

        }

    }",Match failed,0,1
197,Math_69,"public RealMatrix getCorrelationPValues() throws MathException {
        TDistribution tDistribution = new TDistributionImpl(nObs - 2);
        int nVars = correlationMatrix.getColumnDimension();
        double[][] out = new double[nVars][nVars];
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < nVars; j++) {
                if (i == j) {
                    out[i][j] = 0d;
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
        return new BlockRealMatrix(out);
    }","public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                if (Math.abs(r) == 1.0) {
                    out[i][j] = 0d;
                } else {
                    double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                }
            }
        }
    }
    return new BlockRealMatrix(out);
}",0,0
197,Math_69,"public RealMatrix getCorrelationPValues() throws MathException {
        TDistribution tDistribution = new TDistributionImpl(nObs - 2);
        int nVars = correlationMatrix.getColumnDimension();
        double[][] out = new double[nVars][nVars];
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < nVars; j++) {
                if (i == j) {
                    out[i][j] = 0d;
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
        return new BlockRealMatrix(out);
    }","public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j || Math.abs(correlationMatrix.getEntry(i, j)) == 1.0) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
            }
        }
    }
    return new BlockRealMatrix(out);
}",0,1
197,Math_69,"public RealMatrix getCorrelationPValues() throws MathException {
        TDistribution tDistribution = new TDistributionImpl(nObs - 2);
        int nVars = correlationMatrix.getColumnDimension();
        double[][] out = new double[nVars][nVars];
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < nVars; j++) {
                if (i == j) {
                    out[i][j] = 0d;
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
        return new BlockRealMatrix(out);
    }","public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];

    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            out[i][j] = 0d;
        }
    }

    for (int i = 0; i < nVars; i++) {
        for (int j = i + 1; j < nVars; j++) {
            double r = correlationMatrix.getEntry(i, j);
            double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
            double pValue = 2 * (1 - tDistribution.cumulativeProbability(t));
            out[i][j] = pValue;
            out[j][i] = pValue; // Symmetric matrix
        }
    }

    return new BlockRealMatrix(out);
}",0,2
198,Math_7,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // get state at event time
                interpolator.setInterpolatedTime(eventT);
                 final double[] eventY = interpolator.getInterpolatedState().clone();
 
                 // advance all event states to current time
                 currentEvent.stepAccepted(eventT, eventY);
                 isLastStep = currentEvent.stop();
 
                 // handle the first part of the step, up to the event
                 for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                boolean needReset = currentEvent.reset(eventT, eventY);
                if (needReset) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    computeDerivatives(eventT, y, yDot);
                    resetOccurred = true;
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            // last part of the step, after the last event
            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                            final double[] y, final double[] yDot, final double tEnd)
        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {

    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();

    // initialize the events states if needed
    if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }

    // search for next events that may occur during the step
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occurringEvents = new TreeSet<>(new Comparator<EventState>() {
        /** {@inheritDoc} */
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });

    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occurringEvents.add(state);
        }
    }

    while (!occurringEvents.isEmpty()) {

        // handle the chronologically first event
        final Iterator<EventState> iterator = occurringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();

        // restrict the interpolator to the first part of the step, up to the event
        final double eventT = currentEvent.getEventTime();
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);

        // get state at event time
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState().clone();

        // advance all event states to current time
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();

        // handle the first part of the step, up to the event
        for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }

        if (isLastStep) {
            // the event asked to stop integration
            System.arraycopy(eventY, 0, y, 0, y.length);
            for (final EventState remaining : occurringEvents) {
                remaining.stepAccepted(eventT, eventY);
            }
            return eventT;
        }

        boolean needReset = currentEvent.reset(eventT, eventY);
        if (needReset) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            for (final EventState remaining : occurringEvents) {
                remaining.stepAccepted(eventT, eventY);
            }
            return eventT;
        }

        // prepare handling of the remaining part of the step
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);

        // check if the same event occurs again in the remaining part of the step
        if (currentEvent.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occurringEvents.add(currentEvent);
        }

    }

    // last part of the step, after the last event
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState().clone();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

    // handle the remaining part of the step, after all events if any
    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }

    return currentT;

}",0,0
199,Math_70,"public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return solve(min, max);
     }","public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         clearResult();
         verifyInterval(min, max);
         return solve(min, max);
     }",0,0
199,Math_70,"public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return solve(min, max);
     }","public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         clearResult();
         verifyInterval(min, max);
         verifySequence(min, initial, max); // Ensure initial is within range
         setFunctionValueAccuracy(1.0e-15); // Set the function accuracy to a reasonable level
         return solve(min, max, initial);
     }",0,1
199,Math_70,"public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return solve(min, max);
     }","public double solve(final UnivariateRealFunction f, double min, double max, double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {
    if (f == null) {
        throw new IllegalArgumentException(""Function cannot be null"");
    }
    verifyInterval(min, max);
    if (min == max) {
        if (f.value(min) == 0.0) {
            return min; // Solution found at the boundary
        } else {
            throw new IllegalArgumentException(""No interval to solve within"");
        }
    }
    verifySequence(min, initial, max);
    setFunctionValueAccuracy(Math.max(1.0e-15, Math.abs(max - min) * 1.0e-6)); // Dynamically set accuracy based on interval size
    double midpointValue = f.value(UnivariateRealSolverUtils.midpoint(min, max));
    if (midpointValue == 0.0) {
        return UnivariateRealSolverUtils.midpoint(min, max); // Solution at midpoint
    }
    return solve(min, max);
}",0,2
200,Math_72,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
             setResult(yMin, 0);
             return result;
         }
 
        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(f, initial, yInitial, max, yMax, initial, yInitial);
        }

        if (yMin * yMax > 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                    final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

    clearResult();
    verifySequence(min, initial, max);

    // Return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }

    // Return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(min, 0); // Fixed the argument from 'yMin' to 'min'
        return result;
    }

    // Reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }

    // Return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(max, 0); // Fixed the argument from 'yMax' to 'max'
        return result;
    }

    // Reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }

    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(
              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }

    // Full Brent algorithm starting with provided initial guess
    return solve(f, min, yMin, max, yMax, initial, yInitial);
}",0,0
201,Math_73,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                    final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

    clearResult();
    verifySequence(min, initial, max);

    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }

    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(min, 0); // Corrected to store min instead of yMin
        return result;
    }

    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }

    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(max, 0); // Corrected to store max instead of yMax
        return result;
    }

    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }

    // full Brent algorithm starting with provided initial guess
    return solve(f, min, yMin, max, yMax, initial, yInitial);
}",0,0
201,Math_73,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                    final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

    clearResult();
    verifySequence(min, initial, max);

    // Handle cases where endpoints or initial guess satisfy function accuracy
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return initial;
    }

    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(min, 0);
        return min;
    }

    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(max, 0);
        return max;
    }

    // Ensure proper bracketing exists before proceeding
    if (yInitial * yMin < 0) {
        return solveBracketed(f, min, initial);
    } else if (yInitial * yMax < 0) {
        return solveBracketed(f, initial, max);
    }

    throw new IllegalArgumentException(""Function values at endpoints do not bracket a root"");
}

private double solveBracketed(final UnivariateRealFunction f,
                              final double lower, final double upper)
        throws MaxIterationsExceededException, FunctionEvaluationException {
    double yLower = f.value(lower);
    double yUpper = f.value(upper);

    // Brent algorithm logic
    return solve(f, lower, yLower, upper, yUpper, lower + 0.5 * (upper - lower), f.value(lower + 0.5 * (upper - lower)));
}",0,1
201,Math_73,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                    final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

    clearResult();
    verifySequence(min, initial, max);

    // Check initial guess
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return initial;
    }

    // Check the first endpoint
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(min, 0);
        return min;
    }

    // Check the second endpoint
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(max, 0);
        return max;
    }

    // Verify that a valid bracket exists
    if (yMin * yMax > 0) {
        throw new IllegalArgumentException(""Function values at endpoints do not bracket a root"");
    }

    // Use Brent's algorithm for the actual root finding
    return solveWithBrentAlgorithm(f, min, yMin, max, yMax, initial, yInitial);
}

private double solveWithBrentAlgorithm(final UnivariateRealFunction f,
                                       final double lower, final double yLower,
                                       final double upper, final double yUpper,
                                       final double initial, final double yInitial)
        throws MaxIterationsExceededException, FunctionEvaluationException {
    // Implement Brent's algorithm here, starting with the interval and initial guess
    double a = lower;
    double b = upper;
    double fa = yLower;
    double fb = yUpper;
    double c = a;
    double fc = fa;
    double d = b - a;
    double e = d;

    while (true) {
        if (Math.abs(fc) < Math.abs(fb)) {
            a = b;
            b = c;
            c = a;
            fa = fb;
            fb = fc;
            fc = fa;
        }

        double tol = 2.0 * functionValueAccuracy * Math.abs(b) + functionValueAccuracy;
        double m = 0.5 * (c - b);

        if (Math.abs(m) <= tol || fb == 0.0) {
            setResult(b, Math.abs(fb));
            return b;
        }

        if (Math.abs(e) >= tol && Math.abs(fa) > Math.abs(fb)) {
            double s;
            if (a == c) {
                s = fb / fa;
            } else {
                double q = fa / fc;
                double r = fb / fc;
                s = fb / fa / (q * r - 1);
            }

            double p = s * d;
            double t = (p > 0 ? Math.min(p, m) : Math.max(p, m));

            if (Math.abs(t) < Math.abs(d)) {
                e = d;
                d = t;
            } else {
                e = m;
                d = e;
            }
        } else {
            e = m;
            d = e;
        }

        a = b;
        fa = fb;
        b += d;
        fb = f.value(b);
    }
}",0,2
202,Math_74,"@Override
  public double integrate(final FirstOrderDifferentialEquations equations,
                          final double t0, final double[] y0,
                          final double t, final double[] y)
  throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart         = t0;
    double  hNew      = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      double error = 0;
      for (boolean loop = true; loop;) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
         }
 
         if (firstTime) {
           final double[] scale;
           if (vecAbsoluteTolerance == null) {
               scale = new double[y0.length];
               java.util.Arrays.fill(scale, scalAbsoluteTolerance);
             } else {
               scale = vecAbsoluteTolerance;
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
        }

        stepSize = hNew;

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error <= 1.0) {

          // discrete events handling
          interpolator.storeTime(stepStart + stepSize);
          if (manager.evaluateStep(interpolator)) {
              final double dt = manager.getEventTime() - stepStart;
              if (Math.abs(dt) <= Math.ulp(stepStart)) {
                  // rejecting the step would lead to a too small next step, we accept it
                  loop = false;
              } else {
                  // reject the step to match exactly the next switch time
                  hNew = dt;
              }
          } else {
            // accept the step
            loop = false;
          }

        } else {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              Math.min(maxGrowth,
                       Math.max(minReduction, safety * Math.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
          handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (fsal) {
        // save the last evaluation for the next step
        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
      }

      if (manager.reset(stepStart, y) && ! lastStep) {
        // some event handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      if (! lastStep) {
        // in some rare cases we may get here with stepSize = 0, for example
        // when an event occurs at integration start, reducing the first step
        // to zero; we have to reset the step to some safe non zero value
          stepSize = filterStep(stepSize, forward, true);

        // stepsize control for next step
        final double factor = Math.min(maxGrowth,
                                       Math.max(minReduction,
                                                safety * Math.pow(error, exp)));
        final double  scaledH    = stepSize * factor;
        final double  nextT      = stepStart + scaledH;
        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
        hNew = filterStep(scaledH, forward, nextIsLast);
      }

    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;

  }","@Override
public double integrate(final FirstOrderDifferentialEquations equations,
                        final double t0, final double[] y0,
                        final double t, final double[] y)
throws DerivativeException, IntegratorException {

    // Perform initial sanity checks and setup
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // Create internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // Setup interpolator
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    // Initialize integration control objects
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // Main integration loop
    while (!lastStep) {
        interpolator.shift();
        double error = 0;

        for (boolean loop = true; loop;) {
            if (firstTime || !fsal) {
                computeDerivatives(stepStart, y, yDotK[0]);
            }

            if (firstTime) {
                final double[] scale;
                if (vecAbsoluteTolerance == null) {
                    scale = new double[y0.length];
                    java.util.Arrays.fill(scale, scalAbsoluteTolerance);
                } else {
                    scale = vecAbsoluteTolerance;
                }
                hNew = initializeStep(equations, forward, getOrder(), scale,
                                      stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }

            stepSize = hNew;

            // Compute intermediate stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k-1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k-1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);
            }

            // Estimate state at step end
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            // Estimate error
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        loop = false;
                    } else {
                        hNew = dt;
                    }
                } else {
                    loop = false;
                }
            } else {
                // Reject step and reduce step size
                final double factor = Math.min(maxGrowth,
                                               Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }

        // Accept step and update variables
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();

        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;

        if (fsal) {
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }

        if (manager.reset(stepStart, y) && !lastStep) {
            computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (!lastStep) {
            stepSize = filterStep(stepSize, forward, true);
            final double factor = Math.min(maxGrowth,
                                           Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}",0,0
202,Math_74,"@Override
  public double integrate(final FirstOrderDifferentialEquations equations,
                          final double t0, final double[] y0,
                          final double t, final double[] y)
  throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart         = t0;
    double  hNew      = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      double error = 0;
      for (boolean loop = true; loop;) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
         }
 
         if (firstTime) {
           final double[] scale;
           if (vecAbsoluteTolerance == null) {
               scale = new double[y0.length];
               java.util.Arrays.fill(scale, scalAbsoluteTolerance);
             } else {
               scale = vecAbsoluteTolerance;
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
        }

        stepSize = hNew;

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error <= 1.0) {

          // discrete events handling
          interpolator.storeTime(stepStart + stepSize);
          if (manager.evaluateStep(interpolator)) {
              final double dt = manager.getEventTime() - stepStart;
              if (Math.abs(dt) <= Math.ulp(stepStart)) {
                  // rejecting the step would lead to a too small next step, we accept it
                  loop = false;
              } else {
                  // reject the step to match exactly the next switch time
                  hNew = dt;
              }
          } else {
            // accept the step
            loop = false;
          }

        } else {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              Math.min(maxGrowth,
                       Math.max(minReduction, safety * Math.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
          handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (fsal) {
        // save the last evaluation for the next step
        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
      }

      if (manager.reset(stepStart, y) && ! lastStep) {
        // some event handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      if (! lastStep) {
        // in some rare cases we may get here with stepSize = 0, for example
        // when an event occurs at integration start, reducing the first step
        // to zero; we have to reset the step to some safe non zero value
          stepSize = filterStep(stepSize, forward, true);

        // stepsize control for next step
        final double factor = Math.min(maxGrowth,
                                       Math.max(minReduction,
                                                safety * Math.pow(error, exp)));
        final double  scaledH    = stepSize * factor;
        final double  nextT      = stepStart + scaledH;
        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
        hNew = filterStep(scaledH, forward, nextIsLast);
      }

    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;

  }","@Override
public double integrate(final FirstOrderDifferentialEquations equations,
                        final double t0, final double[] y0,
                        final double t, final double[] y)
throws DerivativeException, IntegratorException {

    // Perform initial checks and setup
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // Create internal arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // Setup interpolator
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    // Initialize variables for integration loop
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // Integration loop
    while (!lastStep) {
        interpolator.shift();

        double error = 0;
        boolean reducedStepDueToError = false;

        // Compute derivatives and manage stages
        for (boolean loop = true; loop;) {
            if (firstTime || !fsal) {
                computeDerivatives(stepStart, y, yDotK[0]);
            }

            if (firstTime) {
                final double[] scale = (vecAbsoluteTolerance != null)
                    ? vecAbsoluteTolerance
                    : java.util.Arrays.copyOf(new double[y0.length], y0.length);
                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }

            stepSize = hNew;

            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }

            // Estimate state and error at step end
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error > 1.0) {
                reducedStepDueToError = true;
                hNew = filterStep(stepSize * Math.max(minReduction, safety * Math.pow(error, exp)), forward, false);
            } else {
                reducedStepDueToError = false;
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    hNew = manager.getEventTime() - stepStart;
                    if (Math.abs(hNew) <= Math.ulp(stepStart)) {
                        loop = false;
                    }
                } else {
                    loop = false;
                }
            }
        }

        if (!reducedStepDueToError) {
            // Accept step and update variables
            final double nextStep = stepStart + stepSize;
            System.arraycopy(yTmp, 0, y, 0, y0.length);
            manager.stepAccepted(nextStep, y);
            lastStep = manager.stop();

            interpolator.storeTime(nextStep);
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, lastStep);
            }
            stepStart = nextStep;

            if (fsal) {
                System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
            }

            if (!lastStep) {
                hNew = filterStep(stepSize, forward, false);
            }
        }
    }

    resetInternalState();
    return stepStart;
}",0,1
203,Math_75,"    public double getPct(Object v) {
        return getCumPct((Comparable<?>) v);
    }
","public double getPct(Object v) {
    if (v == null) {
        return Double.NaN;
    }
    long sumFreq = getSumFreq();
    if (sumFreq == 0) {
        return Double.NaN;
    }
    return (double) getCount((Comparable<?>) v) / sumFreq;
}",0,0
204,Math_78,"public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        @Override
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if (cause instanceof DerivativeException) {
                throw (DerivativeException) cause;
            } else if (cause instanceof EventException) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }",0,0
204,Math_78,"public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

    forward = interpolator.isForward();
    final double t1 = interpolator.getCurrentTime();
    final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
    final double h = (t1 - t0) / n;

    double ta = t0;
    double ga = g0;

    for (int i = 0; i < n; ++i) {
        double tb = t0 + (i + 1) * h;
        interpolator.setInterpolatedTime(tb);
        double gb = handler.g(tb, interpolator.getInterpolatedState());

        if ((g0Positive && gb < 0) || (!g0Positive && gb > 0)) {
            increasing = gb >= ga;

            final UnivariateRealFunction f = t -> {
                try {
                    interpolator.setInterpolatedTime(t);
                    return handler.g(t, interpolator.getInterpolatedState());
                } catch (DerivativeException | EventException e) {
                    throw new FunctionEvaluationException(e, t);
                }
            };
            final BrentSolver solver = new BrentSolver();
            solver.setAbsoluteAccuracy(convergence);
            solver.setMaximalIterationCount(maxIterationCount);
            double root = ta <= tb ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);

            if ((Double.isNaN(previousEventTime) || Math.abs(previousEventTime - root) > convergence) && 
                (Math.abs(root - ta) > convergence || Math.abs(root - previousEventTime) > convergence)) {
                pendingEventTime = root;
                if (pendingEvent && Math.abs(t1 - pendingEventTime) <= convergence) {
                    return false;
                }
                pendingEvent = true;
                return true;
            }
        }

        ta = tb;
        ga = gb;
    }

    pendingEvent = false;
    pendingEventTime = Double.NaN;
    return false;
}",0,1
205,Math_79,"    public static double distance(int[] p1, int[] p2) {
      int sum = 0;
      for (int i = 0; i < p1.length; i++) {
          final int dp = p1[i] - p2[i];
          sum += dp * dp;
      }
      return Math.sqrt(sum);
    }
",Match failed,0,0
206,Math_8,"    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
        if (sampleSize <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                    sampleSize);
        }

        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);

        for (int i = 0; i < sampleSize; i++) {
            out[i] = sample();
        }

        return out;

    }
","public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
    if (sampleSize <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);
    }

    final T[] out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);

    for (int i = 0; i < sampleSize; i++) {
        out[i] = sample(); // Assuming sample() method correctly samples an item from singletons list or other sources.
    }

    return out;
}",0,0
206,Math_8,"    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
        if (sampleSize <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                    sampleSize);
        }

        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);

        for (int i = 0; i < sampleSize; i++) {
            out[i] = sample();
        }

        return out;

    }
","public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
    if (sampleSize <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);
    }

    final T[] out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);

    if (singletons.isEmpty()) {
        return out; // Return empty array if no elements to sample from
    }

    for (int i = 0; i < sampleSize; i++) {
        out[i] = sample();
    }

    return out;
}",0,1
206,Math_8,"    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
        if (sampleSize <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                    sampleSize);
        }

        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);

        for (int i = 0; i < sampleSize; i++) {
            out[i] = sample();
        }

        return out;

    }
","public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
    if (sampleSize <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);
    }

    if (singletons.isEmpty()) {
        throw new IllegalArgumentException(""Cannot sample from an empty distribution"");
    }

    Class<?> elementType = singletons.get(0).getClass();
    final T[] out = (T[]) java.lang.reflect.Array.newInstance(elementType, sampleSize);

    for (int i = 0; i < sampleSize; i++) {
        T sampledElement = sample();
        if (!elementType.isInstance(sampledElement)) {
            throw new ArrayStoreException(""Incompatible type encountered during sampling"");
        }
        out[i] = sampledElement;
    }

    return out;
}",0,2
207,Math_80,"private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
             int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }
            return true;
        }
        return false;
    }","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        int j = 4 * n - 1;
        for (int i = 0; i < j; i += 4) {
            for (int k = 0; k < 4; k += step) {
                final double tmp = work[i + k];
                work[i + k] = work[j - (4 - step) + k];
                work[j - (4 - step) + k] = tmp;
            }
            j -= 4;
        }
        return true;
    }
    return false;
}",0,0
207,Math_80,"private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
             int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }
            return true;
        }
        return false;
    }","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        for (int left = 0, right = 4 * n - step; left < right; left += step, right -= step) {
            for (int k = 0; k < step; k++) {
                final double tmp = work[left + k];
                work[left + k] = work[right + k];
                work[right + k] = tmp;
            }
        }
        return true;
    }
    return false;
}",0,1
207,Math_80,"private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
             int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }
            return true;
        }
        return false;
    }","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        for (int left = 0, right = 4 * n - 1; left < right; left += step, right -= step) {
            for (int k = 0; k < step; k++) {
                final double tmp = work[left + k];
                work[left + k] = work[right - k];
                work[right - k] = tmp;
            }
        }
        return true;
    }
    return false;
}",0,2
208,Math_82,"private Integer getPivotRow(final int col, final SimplexTableau tableau) {
        double minRatio = Double.MAX_VALUE;
        Integer minRatioPos = null;
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
             final double entry = tableau.getEntry(i, col);
             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
                 final double ratio = rhs / entry;
                 if (ratio < minRatio) {
                     minRatio = ratio;
                    minRatioPos = i; 
                }
            }
        }
        return minRatioPos;
    }","private Integer getPivotRow(final int col, final SimplexTableau tableau) {
    double minRatio = Double.MAX_VALUE;
    Integer minRatioPos = null;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);
        
        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {
            // Computes the ratio only for positive entries
            final double ratio = rhs / entry;
            if (ratio < minRatio) {
                minRatio = ratio;
                minRatioPos = i;
            }
        }
    }
    return minRatioPos;
}",0,0
209,Math_84,"@Override
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();

            // save the original vertex
            final RealPointValuePair[] original = simplex;
            final RealPointValuePair best = original[0];

            // perform a reflection step
            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
            if (comparator.compare(reflected, best) < 0) {

                // compute the expanded simplex
                final RealPointValuePair[] reflectedSimplex = simplex;
                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
                if (comparator.compare(reflected, expanded) <= 0) {
                    // accept the reflected simplex
                    simplex = reflectedSimplex;
                }

                return;

            }

            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex

            // check convergence
                return;
            }

        }

    }","@Override
    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        boolean converged = false;
        while (!converged) {

            incrementIterationsCounter();

            // save the original vertex
            final RealPointValuePair[] original = simplex;
            final RealPointValuePair best = original[0];

            // perform a reflection step
            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
            if (comparator.compare(reflected, best) < 0) {

                // compute the expanded simplex
                final RealPointValuePair[] reflectedSimplex = simplex;
                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
                if (comparator.compare(reflected, expanded) <= 0) {
                    // accept the reflected simplex
                    simplex = reflectedSimplex;
                } else {
                    // accept the expanded simplex
                    simplex = simplex;
                }

                converged = true;

            } else {

                // compute the contracted simplex
                final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
                if (comparator.compare(contracted, best) < 0) {
                    // accept the contracted simplex
                    simplex = simplex;
                    converged = true;
                }
            }

        }

    }",0,0
209,Math_84,"@Override
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();

            // save the original vertex
            final RealPointValuePair[] original = simplex;
            final RealPointValuePair best = original[0];

            // perform a reflection step
            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
            if (comparator.compare(reflected, best) < 0) {

                // compute the expanded simplex
                final RealPointValuePair[] reflectedSimplex = simplex;
                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
                if (comparator.compare(reflected, expanded) <= 0) {
                    // accept the reflected simplex
                    simplex = reflectedSimplex;
                }

                return;

            }

            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex

            // check convergence
                return;
            }

        }

    }","@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    incrementIterationsCounter();

    final RealPointValuePair[] original = simplex;
    final RealPointValuePair best = original[0];

    // Perform reflection step
    final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
    if (comparator.compare(reflected, best) < 0) {
        // Perform expansion step
        final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
        if (comparator.compare(reflected, expanded) <= 0) {
            simplex = getReflectedSimplex(reflected);
        } else {
            simplex = getExpandedSimplex(expanded);
        }
    } else {
        // Perform contraction step
        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
            simplex = getContractedSimplex(contracted);
        } else {
            // Perform shrink step
            final RealPointValuePair shrunk = evaluateNewSimplex(original, sigma, comparator);
            simplex = getShrunkSimplex(shrunk, comparator);
        }
    }
}

private RealPointValuePair[] getReflectedSimplex(RealPointValuePair reflected) {
    // Method to return the reflected simplex
}

private RealPointValuePair[] getExpandedSimplex(RealPointValuePair expanded) {
    // Method to return the expanded simplex
}

private RealPointValuePair[] getContractedSimplex(RealPointValuePair contracted) {
    // Method to return the contracted simplex
}

private RealPointValuePair[] getShrunkSimplex(RealPointValuePair shrunk, Comparator<RealPointValuePair> comparator) {
    // Method to return the shrunk simplex
}",0,1
210,Math_85,"public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
        
        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0 ;
    
        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            
            fb = function.value(b);
            numIterations++ ;
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
         if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }
        
        return new double[]{a, b};
    }","public static double[] bracket(UnivariateRealFunction function,
        double initial, double lowerBound, double upperBound, 
        int maximumIterations) throws ConvergenceException, 
        FunctionEvaluationException {
    
    if (function == null) {
        throw MathRuntimeException.createIllegalArgumentException(""function is null"");
    }
    if (maximumIterations <= 0)  {
        throw MathRuntimeException.createIllegalArgumentException(
              ""bad value for maximum iterations number: {0}"", maximumIterations);
    }
    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
        throw MathRuntimeException.createIllegalArgumentException(
              ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
              lowerBound, initial, upperBound);
    }
    double a = initial;
    double b = initial;
    double fa;
    double fb;
    int numIterations = 0 ;

    do {
        // Adjust a and b but prevent them from going outside the bounds
        a = Math.max(a - 1.0, lowerBound);
        b = Math.min(b + 1.0, upperBound);
        fa = function.value(a);
        
        fb = function.value(b);
        numIterations++ ;
     } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
             ((a > lowerBound) || (b < upperBound)));

     if (fa * fb >= 0.0 ) {
         throw new ConvergenceException(
                   ""number of iterations={0}, maximum iterations={1}, "" +
                   ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                  ""final b value={6}, f(a)={7}, f(b)={8}"",
                  numIterations, maximumIterations, initial,
                  lowerBound, upperBound, a, b, fa, fb);
    }
    
    return new double[]{a, b};
}",0,0
210,Math_85,"public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
        
        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0 ;
    
        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            
            fb = function.value(b);
            numIterations++ ;
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
         if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }
        
        return new double[]{a, b};
    }","public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {

        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0;

        fa = function.value(a);
        fb = function.value(b);

        while ((fa * fb > 0.0) && (numIterations < maximumIterations)) {
            if (a > lowerBound) {
                a = Math.max(a - 1.0, lowerBound);
                fa = function.value(a);
            }
            if (b < upperBound) {
                b = Math.min(b + 1.0, upperBound);
                fb = function.value(b);
            }
            numIterations++;
        }

        if (fa * fb > 0.0) {
            throw new ConvergenceException(
                    ""number of iterations={0}, maximum iterations={1}, "" +
                    ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                    ""final b value={6}, f(a)={7}, f(b)={8}"",
                    numIterations, maximumIterations, initial,
                    lowerBound, upperBound, a, b, fa, fb);
        }

        return new double[]{a, b};
    }",0,1
210,Math_85,"public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
        
        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0 ;
    
        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            
            fb = function.value(b);
            numIterations++ ;
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
         if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }
        
        return new double[]{a, b};
    }","public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
    
    if (function == null) {
        throw MathRuntimeException.createIllegalArgumentException(""function is null"");
    }
    if (maximumIterations <= 0)  {
        throw MathRuntimeException.createIllegalArgumentException(
              ""bad value for maximum iterations number: {0}"", maximumIterations);
    }
    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
        throw MathRuntimeException.createIllegalArgumentException(
              ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
              lowerBound, initial, upperBound);
    }
    double a = initial;
    double b = initial;
    double fa = function.value(a);
    double fb = function.value(b);
    int numIterations = 0;

    // Make sure we are moving in a direction that actually increases/decreases the values
    boolean expandingLower = true;
    boolean expandingUpper = true;

    while ((fa * fb > 0.0) && (numIterations < maximumIterations)) {
        if (expandingLower && a > lowerBound) {
            double newA = Math.max(a - 1.0, lowerBound);
            double newFa = function.value(newA);
            if (newFa * fa < 0) {
                a = newA;
                fa = newFa;
                break;
            } else if (newFa * fa > 0) {
                a = newA;
                fa = newFa;
            } else {
                expandingLower = false;
            }
        }
        if (expandingUpper && b < upperBound) {
            double newB = Math.min(b + 1.0, upperBound);
            double newFb = function.value(newB);
            if (newFb * fb < 0) {
                b = newB;
                fb = newFb;
                break;
            } else if (newFb * fb > 0) {
                b = newB;
                fb = newFb;
            } else {
                expandingUpper = false;
            }
        }
        numIterations++;
    }

    if (fa * fb > 0.0) {
        throw new ConvergenceException(
                ""number of iterations={0}, maximum iterations={1}, "" +
                ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                ""final b value={6}, f(a)={7}, f(b)={8}"",
                numIterations, maximumIterations, initial,
                lowerBound, upperBound, a, b, fa, fb);
    }

    return new double[]{a, b};
}",0,2
211,Math_86,"    public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }

    }","public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        // Ensure to clone the data to avoid modifying the original matrix
        lTData = matrix.getData().clone();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0 for Cholesky operations on the lower part)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lI[j] = 0; // Reset the off-diagonal element to zero instead of lJ[i]
            }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element
            if (ltI[i] <= 0) {
                throw new NotPositiveDefiniteMatrixException();
            }

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = i + 1; q < order; ++q) { // loop q should start at i + 1
                final double[] ltQ = lTData[q];
                ltQ[i] *= inverse; // Adjusting to operate on lower triangle

                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltQ[i] * ltI[p];
                }
            }

        }
    }",0,0
211,Math_86,"    public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }

    }","public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(),
                                           matrix.getColumnDimension());
    }

    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;

    // Clone the input matrix data
    lTData = matrix.getData().clone();

    // Verify matrix properties before performing decomposition
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];

        if (lTData[i][i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }
        
        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta =
                relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
            // Reset both upper and lower off-diagonal elements
            lI[j] = 0;
            lJ[i] = 0;
        }
    }

    // Perform Cholesky decomposition
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];

        if (ltI[i] <= 0) {
            throw new NotPositiveDefiniteMatrixException();
        }

        ltI[i] = Math.sqrt(ltI[i]);
        final double inverse = 1.0 / ltI[i];

        for (int j = i + 1; j < order; ++j) {
            final double[] ltJ = lTData[j];
            ltJ[i] *= inverse;

            for (int k = j; k < order; ++k) {
                ltJ[k] -= ltJ[i] * ltI[k];
            }
        }
    }
}",0,1
211,Math_86,"    public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }

    }","public CholeskyDecompositionImpl(final RealMatrix matrix,
                                 final double relativeSymmetryThreshold,
                                 final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(),
                                           matrix.getColumnDimension());
    }

    final int order = matrix.getRowDimension();
    lTData = matrix.getData().clone();  // Clone matrix data
    cachedL = null;
    cachedLT = null;

    // Verify matrix symmetry and positivity
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];

        if (lI[i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }

        for (int j = i + 1; j < order; ++j) {
            final double lIJ = lI[j];
            final double lJI = lTData[j][i];
            final double maxDelta =
                relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
        }
    }

    // Perform Cholesky decomposition
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];

        if (ltI[i] <= 0) {
            throw new NotPositiveDefiniteMatrixException();
        }

        ltI[i] = Math.sqrt(ltI[i]);
        final double inverse = 1.0 / ltI[i];

        for (int j = i + 1; j < order; ++j) {
            final double[] ltJ = lTData[j];
            ltJ[i] *= inverse;

            for (int k = j; k < order; ++k) {
                ltJ[k] -= ltJ[i] * ltI[k];
            }
        }
    }
}",0,2
212,Math_87,"private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 if (row == null) {
                 row = i;
                 } else {
                 return null;
                 }
             }
         }
         return row;
    }","private Integer getBasicRow(final int col) {
    Integer row = null;
    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
        if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
            if (row == null) {
                row = i;
            } else {
                return null; // Multiple non-zero entries in the column
            }
        }
    }
    return row;
}",0,0
212,Math_87,"private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 if (row == null) {
                 row = i;
                 } else {
                 return null;
                 }
             }
         }
         return row;
    }","private Integer getBasicRow(final int col) {
    Integer row = null;
    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
        double entry = getEntry(i, col);
        if (!MathUtils.equals(entry, 0.0, epsilon)) {
            if (MathUtils.equals(entry, 1.0, epsilon)) {
                if (row == null) {
                    row = i;
                } else {
                    return null; // Multiple valid entries in the column
                }
            } else {
                return null; // Invalid if entry is not nearly equal to 1
            }
        }
    }
    return row;
}",0,1
213,Math_88,"protected RealPointValuePair getSolution() {
        double[] coefficients = new double[getOriginalNumDecisionVariables()];
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             if (basicRow != null) {
                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                     if (tableau.getEntry(basicRow, j) == 1) {
                          coefficients[i] = 0;
                     }
                 }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
    for (int i = 0; i < coefficients.length; i++) {
        basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
        if (basicRow != null) {
            for (int j = getNumObjectiveFunctions(); j < getOriginalNumDecisionVariables(); j++) {
                if (j != i && tableau.getEntry(basicRow, getNumObjectiveFunctions() + j) == 1) {
                    coefficients[i] = 0;
                    break;
                }
            }
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,0
213,Math_88,"protected RealPointValuePair getSolution() {
        double[] coefficients = new double[getOriginalNumDecisionVariables()];
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             if (basicRow != null) {
                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                     if (tableau.getEntry(basicRow, j) == 1) {
                          coefficients[i] = 0;
                     }
                 }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
    for (int i = 0; i < coefficients.length; i++) {
        basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
        if (basicRow != null) {
            for (int j = 0; j < coefficients.length; j++) {
                if (j != i && tableau.getEntry(basicRow, getNumObjectiveFunctions() + j) == 1) {
                    coefficients[i] = 0;
                    break;
                }
            }
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,1
213,Math_88,"protected RealPointValuePair getSolution() {
        double[] coefficients = new double[getOriginalNumDecisionVariables()];
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             if (basicRow != null) {
                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                     if (tableau.getEntry(basicRow, j) == 1) {
                          coefficients[i] = 0;
                     }
                 }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    double mostNegative = 0; // Initialize mostNegative to zero
    for (int i = 0; i < coefficients.length; i++) {
        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        double entry = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
        
        // Update mostNegative on-the-fly for each coefficient
        if (i == 0) {
            mostNegative = entry; // Start with the first entry value for mostNegative
        } else {
            mostNegative = Math.min(mostNegative, entry);
        }
        
        coefficients[i] = entry - (restrictToNonNegative ? 0 : (basicRow != null ? mostNegative : 0));
        
        if (basicRow != null) {
            for (int j = 0; j < coefficients.length; j++) {
                if (j != i && tableau.getEntry(basicRow, getNumObjectiveFunctions() + j) == 1) {
                    coefficients[i] = 0;
                    break;
                }
            }
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,2
214,Math_89,"    public void addValue(Object v) {
            addValue((Comparable<?>) v);            
    }
",Match failed,0,0
215,Math_9,"    public Line revert() {
        final Line reverted = new Line(zero, zero.subtract(direction));
        return reverted;
    }
",Match failed,0,0
216,Math_91,"    public int compareTo(Fraction object) {
        double nOd = doubleValue();
        double dOn = object.doubleValue();
        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
    }
","public int compareTo(Fraction object) {
    long lhs = (long) this.numerator * object.denominator;
    long rhs = (long) object.numerator * this.denominator;
    return Long.compare(lhs, rhs);
}",0,0
217,Math_94,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }
","public static int gcd(int u, int v) {
    if (u == 0) {
        return Math.abs(v);
    }
    if (v == 0) {
        return Math.abs(u);
    }

    // keep u and v negative, to avoid overflow issues
    if (u > 0) {
        u = -u;
    } 
    if (v > 0) {
        v = -v;
    } 

    // B1. Find power of 2
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        u /= 2;
        v /= 2;
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }

    // B2. Initialize
    int t = (u & 1) == 1 ? v : -(u / 2);

    do {
        // B4/B3: cast out twos from t
        while ((t & 1) == 0) {
            t /= 2;
        }

        // B5: Reset max(u, v)
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }

        // B6/B3
        t = (v - u) / 2;
    } while (t != 0);

    return -u * (1 << k); // gcd is u*2^k
}",0,0
218,Math_95,"    protected double getInitialDomain(double p) {
        double ret;
        double d = getDenominatorDegreesOfFreedom();
            // use mean
            ret = d / (d - 2.0);
        return ret;
    }
",Match failed,0,0
219,Math_96,"public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else  {
            try {
                Complex rhs = (Complex)other;
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
                ret = false;
            }
        }
      
        return ret;
    }","public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null || getClass() != other.getClass()) {
        return false;
    }
    Complex rhs = (Complex) other;
    if (rhs.isNaN()) {
        return this.isNaN();
    }
    return Double.doubleToLongBits(real) == Double.doubleToLongBits(rhs.getReal())
        && Double.doubleToLongBits(imaginary) == Double.doubleToLongBits(rhs.getImaginary());
}",0,0
219,Math_96,"public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else  {
            try {
                Complex rhs = (Complex)other;
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
                ret = false;
            }
        }
      
        return ret;
    }","public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null || !(other instanceof Complex)) {
        return false;
    }
    Complex rhs = (Complex) other;

    if (this.isNaN() && rhs.isNaN()) {
        return true;
    }
    if (this.isNaN() || rhs.isNaN()) {
        return false;
    }

    return Double.compare(real, rhs.getReal()) == 0 && Double.compare(imaginary, rhs.getImaginary()) == 0;
}",0,1
219,Math_96,"public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else  {
            try {
                Complex rhs = (Complex)other;
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
                ret = false;
            }
        }
      
        return ret;
    }","public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null || !(other instanceof Complex)) {
        return false;
    }
    Complex rhs = (Complex) other;

    if (this.isNaN() || rhs.isNaN()) {
        return this.isNaN() && rhs.isNaN();
    }

    boolean realEqual = Double.compare(real, rhs.getReal()) == 0 || (Double.doubleToLongBits(real) == Double.doubleToLongBits(-0.0) && Double.doubleToLongBits(rhs.getReal()) == Double.doubleToLongBits(0.0));
    boolean imaginaryEqual = Double.compare(imaginary, rhs.getImaginary()) == 0;

    return realEqual && imaginaryEqual;
}",0,2
220,Math_97,"public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
        clearResult();
        verifyInterval(min, max);
        
        double ret = Double.NaN;
        
        double yMin = f.value(min);
        double yMax = f.value(max);
         
         // Verify bracketing
         double sign = yMin * yMax;
         if (sign >= 0) {
             // check if either value is close to a zero
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
         } else {
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
             // either min or max is a root
         }
 
         return ret;
    }","public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
    clearResult();
    verifyInterval(min, max);
    
    double ret = Double.NaN;
    
    double yMin = f.value(min);
    double yMax = f.value(max);
    
    // Verify bracketing
    double sign = yMin * yMax;
    if (sign > 0) { // Fix: Changed condition from `>=` to `>`
        // Neither value is close to zero and min and max do not bracket root.
        throw new IllegalArgumentException(
            ""Function values at endpoints do not have different signs."" +
            "" Endpoints: ["" + min + "","" + max + ""]"" + 
            "" Values: ["" + yMin + "","" + yMax + ""]""
        );
    } else if (yMin == 0) { // Fix: Added explicit checks for zero values
        return min;
    } else if (yMax == 0) {
        return max;
    } else {
        // Solve using both endpoints to bracket the root
        ret = solve(min, yMin, max, yMax, min, yMin);
    }

    return ret;
}",0,0
220,Math_97,"public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
        clearResult();
        verifyInterval(min, max);
        
        double ret = Double.NaN;
        
        double yMin = f.value(min);
        double yMax = f.value(max);
         
         // Verify bracketing
         double sign = yMin * yMax;
         if (sign >= 0) {
             // check if either value is close to a zero
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
         } else {
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
             // either min or max is a root
         }
 
         return ret;
    }",Match failed,0,1
221,Mockito_1,"    public void captureArgumentsFrom(Invocation invocation) {
        if (invocation.getMethod().isVarArgs()) {
            int indexOfVararg = invocation.getRawArguments().length - 1;
            throw new UnsupportedOperationException();

        } else {
            for (int position = 0; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
        }

//        for (int position = 0; position < matchers.size(); position++) {
//            Matcher m = matchers.get(position);
//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {
//                //TODO SF - this whole lot can be moved captureFrom implementation
//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {
//                    Object array = invocation.getRawArguments()[position];
//                    for (int i = 0; i < Array.getLength(array); i++) {
//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));
//                    }
//                    //since we've captured all varargs already, it does not make sense to process other matchers.
//                    return;
//                } else {
//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);
//                }
//            }
//        }
    }
","public void captureArgumentsFrom(Invocation invocation) {
    if (invocation.getMethod().isVarArgs()) {
        int indexOfVararg = invocation.getRawArguments().length - 1;
        Object varargArray = invocation.getRawArguments()[indexOfVararg];
        for (int position = 0; position < matchers.size(); position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {
                if (position == indexOfVararg && isVarargMatcher(m)) {
                    for (int i = 0; i < Array.getLength(varargArray); i++) {
                        ((CapturesArguments) m).captureFrom(Array.get(varargArray, i));
                    }
                    return; // Stop processing as all varargs are captured
                } else {
                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);
                }
            }
        }
    } else {
        for (int position = 0; position < matchers.size(); position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments) {
                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
            }
        }
    }
}",0,0
222,Mockito_12,"public Class getGenericType(Field field) {        
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
                 return (Class) actual;
                 //in case of nested generics we don't go deep
         }
         
         return Object.class;
    }","public Class<?> getGenericType(Field field) {
    Type generic = field.getGenericType();
    if (generic instanceof ParameterizedType) {
        Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
        if (actual instanceof Class<?>) {
            return (Class<?>) actual;
        }
    }
    return Object.class;
}",0,0
222,Mockito_12,"public Class getGenericType(Field field) {        
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
                 return (Class) actual;
                 //in case of nested generics we don't go deep
         }
         
         return Object.class;
    }",Match failed,0,1
223,Mockito_13,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             }
         }
         
        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }","public Object handle(Invocation invocation) throws Throwable {
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        // stubbing voids with stubVoid() or doAnswer() style
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }

    VerificationMode verificationMode = mockingProgress.pullVerificationMode();
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
    mockingProgress.validateState();

    // if verificationMode is not null then someone is doing verify()
    if (verificationMode != null) {
        // We need to check if verification was started on the correct mock
        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
        if (verificationMode instanceof MockAwareVerificationMode
                && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
            verificationMode.verify(data);
            return null;
        } else {
            // this means there is an invocation on a different mock. Re-adding verification mode
            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
            mockingProgress.resetVerificationMode();
        }
    }

    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);

    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);

        // redo setting invocation for potential stubbing in case of partial
        // mocks / spies.
        // Without it, the real method inside 'when' might have delegated
        // to other self method and overwrite the intended stubbed method
        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}",0,0
224,Mockito_18,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
","public Object answer(InvocationOnMock invocation) {
    if (methodsGuru.isToString(invocation.getMethod())) {
        Object mock = invocation.getMock();
        MockName name = mockUtil.getMockName(mock);
        if (name.isDefault()) {
            return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
        } else {
            return name.toString();
        }
    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
        //see issue 184.
        //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
        //Only for compareTo() method by the Comparable interface
        return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
    }

    Method method = invocation.getMethod();
    Object returnValue;

    if (Primitives.isPrimitiveOrWrapper(method.getReturnType())) {
        returnValue = Primitives.defaultValue(method.getReturnType());
    } else {
        returnValue = ReturnsEmptyValues.emptyValue(method.getReturnType());
    }

    return returnValue;
}",0,0
225,Mockito_20,"    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }
","public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
        throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
    }
    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
            settings.getTypeToMock(),
            settings.getExtraInterfaces()
    );

    T mockInstance = null;
    try {
        mockInstance = classInstantiator.instantiate(mockedProxyType);
        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

        return ensureMockIsAssignableToMockedType(settings, mockInstance);
    } catch (ClassCastException cce) {
        throw new MockitoException(join(
                ""ClassCastException occurred while creating the mockito mock:"",
                ""  class to mock : "" + describeClass(mockedProxyType),
                ""  created class : "" + describeClass(settings.getTypeToMock()),
                ""  proxy instance class : "" + describeClass(mockInstance),
                ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                """",
                ""You might experience classloading issues, please ask the mockito mailing-list."",
                """"
        ), cce);
    } catch (org.mockito.internal.creation.instance.InstantiationException e) {
        throw new MockitoException(""Unable to create mock instance of type '"" + settings.getTypeToMock().getSimpleName() + ""'"", e);
    }
}",0,0
225,Mockito_20,"    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }
","public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
        throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
    }
    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
            settings.getTypeToMock(), 
            settings.getExtraInterfaces()
    );

    try {
        // Check if the proxy type can be instantiated
        if (!mockedProxyType.isInterface() && !hasValidConstructor(mockedProxyType)) {
            throw new MockitoException(""The mocked type must be instantiable; no valid constructor found for "" + describeClass(mockedProxyType));
        }

        T mockInstance = classInstantiator.instantiate(mockedProxyType);
        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

        return ensureMockIsAssignableToMockedType(settings, mockInstance);
    } catch (ClassCastException cce) {
        String errorMessage = String.format(
            ""ClassCastException while creating mockito mock: class to mock: %s, created class: %s, proxy instance class: %s, instance creation by: %s. Might be a classloading issue. Please consult the mockito mailing list."",
            describeClass(mockedProxyType),
            describeClass(settings.getTypeToMock()),
            describeClass(mockedProxyType), // corrected from mockInstance to mockedProxyType
            classInstantiator.getClass().getSimpleName()
        );
        throw new MockitoException(errorMessage, cce);
    } catch (org.mockito.internal.creation.instance.InstantiationException e) {
        throw new MockitoException(""Unable to create mock instance of type '"" + describeClass(settings.getTypeToMock()) + ""'"", e);
    }
}

private boolean hasValidConstructor(Class<?> clazz) {
    try {
        clazz.getConstructor();
        return true;
    } catch (NoSuchMethodException e) {
        return false;
    }
}",0,1
225,Mockito_20,"    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }
","public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
        throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
    }

    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(settings.getTypeToMock(), settings.getExtraInterfaces());

    try {
        if (!mockedProxyType.isInterface() && !hasValidConstructor(mockedProxyType)) {
            if (settings.isUseConstructor() && settings.getOuterClassInstance() != null) {
                mockedProxyType.getDeclaredConstructors()[0].setAccessible(true);
                try {
                    T mockInstance = (T) mockedProxyType.getDeclaredConstructors()[0]
                        .newInstance(settings.getOuterClassInstance());
                    setupInterceptor(mockInstance, handler, settings);
                    return mockInstance;
                } catch (Exception e) {
                    throw new MockitoException(
                        ""Unable to instantiate inner class mock due to constructor invocation issues."", e);
                }
            } else {
                throw new MockitoException(""The mocked type must be instantiable; no valid constructor found for "" + describeClass(mockedProxyType));
            }
        }

        T mockInstance = classInstantiator.instantiate(mockedProxyType);
        setupInterceptor(mockInstance, handler, settings);
        return ensureMockIsAssignableToMockedType(settings, mockInstance);
    } catch (ClassCastException cce) {
        throw new MockitoException(join(
            ""ClassCastException occurred while creating the mockito mock:"",
            ""  class to mock : "" + describeClass(mockedProxyType),
            ""  created class : "" + describeClass(settings.getTypeToMock()),
            ""  proxy instance class : "" + mockedProxyType.getCanonicalName(),
            ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
            ""You might experience classloading issues."", """"
        ), cce);
    }
}

private void setupInterceptor(Object mockInstance, MockHandler handler, MockCreationSettings<?> settings) {
    MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
    mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
}

private boolean hasValidConstructor(Class<?> clazz) {
    try {
        clazz.getConstructor();
        return true;
    } catch (NoSuchMethodException e) {
        return false;
    }
}

private String describeClass(Class<?> type) {
    return type == null ? ""null"" : ""'"" + type.getCanonicalName() + ""', loaded by classloader : '"" + type.getClassLoader() + ""'"";
}",0,2
226,Mockito_22,"    public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }
","public static boolean areEqual(Object o1, Object o2) {
    if (o1 == null || o2 == null) {
        return o1 == null && o2 == null;
    }
    
    if (isArray(o1) && isArray(o2)) {
        return areArraysEqual(o1, o2);
    }
    
    return o1.equals(o2);
}",0,0
226,Mockito_22,"    public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }
","public static boolean areEqual(Object o1, Object o2) {
    if (o1 == null || o2 == null) {
        return o1 == null && o2 == null;
    }

    if (isArray(o1)) {
        return isArray(o2) && areArraysEqual(o1, o2);
    }

    if (o1 instanceof Number && o2 instanceof Number) {
        return numbersAreEqual((Number) o1, (Number) o2);
    }

    return o1.equals(o2);
}

private static boolean numbersAreEqual(Number n1, Number n2) {
    return Double.compare(n1.doubleValue(), n2.doubleValue()) == 0;
}

private static boolean isArray(Object o) {
    return o != null && o.getClass().isArray();
}

private static boolean areArraysEqual(Object array1, Object array2) {
    if (array1 instanceof Object[] && array2 instanceof Object[]) {
        return java.util.Arrays.deepEquals((Object[]) array1, (Object[]) array2);
    } else if (array1 instanceof int[] && array2 instanceof int[]) {
        return java.util.Arrays.equals((int[]) array1, (int[]) array2);
    } else if (array1 instanceof double[] && array2 instanceof double[]) {
        return java.util.Arrays.equals((double[]) array1, (double[]) array2);
    } else if (array1 instanceof long[] && array2 instanceof long[]) {
        return java.util.Arrays.equals((long[]) array1, (long[]) array2);
    } else if (array1 instanceof boolean[] && array2 instanceof boolean[]) {
        return java.util.Arrays.equals((boolean[]) array1, (boolean[]) array2);
    } else if (array1 instanceof char[] && array2 instanceof char[]) {
        return java.util.Arrays.equals((char[]) array1, (char[]) array2);
    } else if (array1 instanceof byte[] && array2 instanceof byte[]) {
        return java.util.Arrays.equals((byte[]) array1, (byte[]) array2);
    } else if (array1 instanceof short[] && array2 instanceof short[]) {
        return java.util.Arrays.equals((short[]) array1, (short[]) array2);
    } else if (array1 instanceof float[] && array2 instanceof float[]) {
        return java.util.Arrays.equals((float[]) array1, (float[]) array2);
    } else {
        return false;
    }
}",0,1
227,Mockito_24,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
","public Object answer(InvocationOnMock invocation) {
    if (methodsGuru.isToString(invocation.getMethod())) {
        Object mock = invocation.getMock();
        MockName name = mockUtil.getMockName(mock);
        if (name != null && name.isDefault()) {
            MockCreationSettings<?> settings = mockUtil.getMockSettings(mock);
            if (settings != null && settings.getTypeToMock() != null) {
                return ""Mock for "" + settings.getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            }
        }
        return name != null ? name.toString() : ""Unnamed mock"";
    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
        // If references are the same, return 0. Otherwise, return 1.
        Object mock = invocation.getMock();
        Object argument = invocation.getArguments()[0];
        return mock == argument ? 0 : 1;
    }

    Class<?> returnType = invocation.getMethod().getReturnType();
    return returnValueFor(returnType);
}",0,0
228,Mockito_26,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.util;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings(""unchecked"")
public class Primitives {
    
    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {
        if(clazz.isPrimitive()) {
            return clazz;
        }
        return (Class<T>) primitiveTypes.get(clazz);
    }

    public static boolean isPrimitiveWrapper(Class<?> type) {
        return wrapperReturnValues.containsKey(type);
    }

    public static <T> T primitiveWrapperOf(Class<T> type) {
        return (T) wrapperReturnValues.get(type);
    }

    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {
        return (T) primitiveValues.get(primitiveType);
    }
    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();
    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();

    static {
        primitiveTypes.put(Boolean.class, Boolean.TYPE);
        primitiveTypes.put(Character.class, Character.TYPE);
        primitiveTypes.put(Byte.class, Byte.TYPE);
        primitiveTypes.put(Short.class, Short.TYPE);
        primitiveTypes.put(Integer.class, Integer.TYPE);
        primitiveTypes.put(Long.class, Long.TYPE);
        primitiveTypes.put(Float.class, Float.TYPE);
        primitiveTypes.put(Double.class, Double.TYPE);
    }

    static {
        wrapperReturnValues.put(Boolean.class, false);
        wrapperReturnValues.put(Character.class, '\u0000');
        wrapperReturnValues.put(Byte.class, (byte) 0);
        wrapperReturnValues.put(Short.class, (short) 0);
        wrapperReturnValues.put(Integer.class, 0);
        wrapperReturnValues.put(Long.class, 0L);
        wrapperReturnValues.put(Float.class, 0F);
        wrapperReturnValues.put(Double.class, 0D);
    }

    static {
        primitiveValues.put(boolean.class, false);
        primitiveValues.put(char.class, '\u0000');
        primitiveValues.put(byte.class, (byte) 0);
        primitiveValues.put(short.class, (short) 0);
        primitiveValues.put(int.class, 0);
        primitiveValues.put(long.class, 0L);
        primitiveValues.put(float.class, 0F);
        primitiveValues.put(double.class, 0);
    }
}",Match failed,0,0
229,Mockito_27,"public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
         MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
         ((Factory) mock).setCallback(0, newFilter);
     }","public <T> void resetMock(T mock) {
    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
    if (oldMockHandler == null) {
        throw new IllegalArgumentException(""The provided mock does not have a valid handler."");
    }

    MockHandler<T> newMockHandler = new MockHandler<>(oldMockHandler);
    MockSettings settings = org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS);
    if (!(settings instanceof MockSettingsImpl)) {
        throw new IllegalStateException(""Unexpected MockSettings implementation."");
    }

    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) settings);
    if (mock instanceof Factory) {
        ((Factory) mock).setCallback(0, newFilter);
    } else {
        throw new IllegalArgumentException(""The provided mock is not a valid Factory instance."");
    }
}",0,0
230,Mockito_28,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }","private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
        // Ensure the field is accessible
        field.setAccessible(true);
        if (mockCandidateFilter.filterCandidate(mocks, field, fieldInstance) != null) {
            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
        }
    }
}",0,0
230,Mockito_28,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }","private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
        // Skip fields that cannot be injected
        if (!mockCandidateFilter.canInject(field)) {
            continue;
        }
        // Filter and inject valid mock candidates
        Object candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);
        if (candidate != null) {
            mockCandidateFilter.injectCandidate(field, fieldInstance, candidate);
        }
    }
}",0,1
231,Mockito_29,"public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
         description.appendText(wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }","public void describeTo(Description description) {
        description.appendText(""same("");
        appendQuoting(description);
        if (wanted != null) {
            description.appendText(wanted.toString());
        } else {
            description.appendText(""null"");
        }
        appendQuoting(description);
        description.appendText("")"");
    }",0,0
232,Mockito_33,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
         	/* Avoid unnecessary cloning */
         return m1.equals(m2);
     }","public boolean hasSameMethod(Invocation candidate) {        
    // not using method.equals() for 1 good reason:
    // sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
    Method m1 = invocation.getMethod();
    Method m2 = candidate.getMethod();

    // Avoid unnecessary cloning and account for generics forwarding methods
    return m1.getDeclaringClass() == m2.getDeclaringClass() && m1.getName().equals(m2.getName());
}",0,0
232,Mockito_33,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
         	/* Avoid unnecessary cloning */
         return m1.equals(m2);
     }","public boolean hasSameMethod(Invocation candidate) {
    Method m1 = invocation.getMethod();
    Method m2 = candidate.getMethod();

    // Handle generics forwarding methods by comparing signature instead of direct equals
    return m1.getDeclaringClass().equals(m2.getDeclaringClass())
            && m1.getName().equals(m2.getName())
            && Arrays.equals(m1.getParameterTypes(), m2.getParameterTypes());
}",0,1
233,Mockito_34,"public void captureArgumentsFrom(Invocation i) {
         int k = 0;
         for (Matcher m : matchers) {
             if (m instanceof CapturesArguments) {
                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
             }
             k++;
        }
    }","public void captureArgumentsFrom(Invocation i) {
    int k = 0;
    Object[] arguments = i.getArguments();  // Cache the arguments array
    for (Matcher m : matchers) {
        if (m instanceof CapturesArguments) {
            if (k < arguments.length) {  // Ensure 'k' doesn't exceed the array length
                ((CapturesArguments) m).captureFrom(arguments[k]);
            }
        }
        k++;
    }
}",0,0
234,Mockito_38,"    private boolean safelyMatches(Matcher m, Object arg) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }
",Match failed,0,0
235,Mockito_5,"    public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }
","public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                }
            } catch (MockitoAssertionError | org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }",0,0
236,Mockito_7,"        private void readTypeVariables() {
            for (Type type : typeVariable.getBounds()) {
                registerTypeVariablesOn(type);
            }
            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
        }
","private void readTypeVariables() {
    Set<Type> processedTypes = new HashSet<>();
    for (Type type : typeVariable.getBounds()) {
        registerTypeVariablesOn(processedTypes, type);
    }
    registerTypeVariablesOn(processedTypes, getActualTypeArgumentFor(typeVariable));
}

private void registerTypeVariablesOn(Set<Type> processedTypes, Type type) {
    if (!processedTypes.contains(type)) {
        processedTypes.add(type);
        // Assuming registerTypeVariablesOn performs some operations on the Type
        // Recur for any nested type variables
        if (type instanceof TypeVariable<?>) {
            TypeVariable<?> typeVar = (TypeVariable<?>) type;
            for (Type bound : typeVar.getBounds()) {
                registerTypeVariablesOn(processedTypes, bound);
            }
        }
    }
}",0,0
237,Mockito_8,"    protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
        }
    }
","protected void registerTypeVariablesOn(Type classType) {
    if (!(classType instanceof ParameterizedType)) {
        return;
    }
    
    ParameterizedType parameterizedType = (ParameterizedType) classType;
    TypeVariable<?>[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();

    for (int i = 0; i < actualTypeArguments.length; i++) {
        TypeVariable<?> typeParameter = typeParameters[i];
        Type actualTypeArgument = actualTypeArguments[i];

        if (actualTypeArgument instanceof WildcardType) {
            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
        } else {
            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
        }
        // Logger statement is unchanged; assumed to be correct
        // logger.log(""For '"" + parameterizedType + ""' found type variable: { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(actualTypeArgument) + "")"" + ""' }"");
    }
}",0,0
237,Mockito_8,"    protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
        }
    }
","protected void registerTypeVariablesOn(Type classType) {
    if (!(classType instanceof ParameterizedType)) {
        return;
    }
    
    ParameterizedType parameterizedType = (ParameterizedType) classType;
    TypeVariable<?>[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
    
    if (typeParameters.length != actualTypeArguments.length) {
        throw new IllegalArgumentException(""Type parameter count does not match actual type argument count."");
    }

    for (int i = 0; i < actualTypeArguments.length; i++) {
        TypeVariable<?> typeParameter = typeParameters[i];
        Type actualTypeArgument = actualTypeArguments[i];
        
        Type mappedType;
        if (actualTypeArgument instanceof WildcardType) {
            mappedType = boundsOf((WildcardType) actualTypeArgument);
        } else {
            mappedType = actualTypeArgument;
        }

        contextualActualTypeParameters.put(typeParameter, mappedType);
        // Logger statement is unchanged; assumed to be correct
        // logger.log(""Registered type variable '"" + typeParameter + ""' under actual type argument '"" + mappedType + ""'"");
    }
}",0,1
237,Mockito_8,"    protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
        }
    }
","protected void registerTypeVariablesOn(Type classType) {
    if (!(classType instanceof ParameterizedType)) {
        return;
    }
    
    ParameterizedType parameterizedType = (ParameterizedType) classType;
    TypeVariable<?>[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();

    // Add check to prevent infinite loops in case of self-referencing types
    if (typeParameters.length != actualTypeArguments.length) {
        throw new IllegalArgumentException(""Mismatch between type parameters and actual type arguments."");
    }

    Set<Type> visitedTypes = new HashSet<>();

    for (int i = 0; i < actualTypeArguments.length; i++) {
        TypeVariable<?> typeParameter = typeParameters[i];
        Type actualTypeArgument = actualTypeArguments[i];

        // Avoid recursion on self-referencing types
        if (!visitedTypes.add(actualTypeArgument)) {
            continue; // Skip processing if it's already done
        }

        Type mappedType;
        if (actualTypeArgument instanceof WildcardType) {
            mappedType = boundsOf((WildcardType) actualTypeArgument);
        } else {
            mappedType = actualTypeArgument;
        }

        contextualActualTypeParameters.put(typeParameter, mappedType);
    }
}",0,2
238,Time_11,"    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
    static {
        cVerbose.set(Boolean.FALSE);
    }
",static ThreadLocal<Boolean> cVerbose = ThreadLocal.withInitial(() -> Boolean.FALSE);,0,0
239,Time_14,"public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
        // overridden as superclass algorithm can't handle
        // 2004-02-29 + 48 months -> 2008-02-29 type dates
         if (valueToAdd == 0) {
             return values;
         }
             // month is largest field and being added to, such as month-day
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
            }
            instant = add(instant, valueToAdd);
            return iChronology.get(partial, instant);
        } else {
            return super.add(partial, fieldIndex, values, valueToAdd);
        }
    }","public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
    // overridden as superclass algorithm can't handle
    // 2004-02-29 + 48 months -> 2008-02-29 type dates
    if (valueToAdd == 0) {
        return values;
    }
    // month is largest field and being added to, such as month-day
    if (DateTimeUtils.isContiguous(partial)) {
        long instant = iChronology.set(partial, 0L, values);
        instant = add(instant, valueToAdd);
        return iChronology.get(partial, instant);
    } else {
        return super.add(partial, fieldIndex, values, valueToAdd);
    }
}",0,0
240,Time_15,"public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
                 return -val1;
             case 0:
                 return 0L;
            case 1:
                return val1;
        }
        long total = val1 * val2;
        if (total / val2 != val1) {
          throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
        }
        return total;
    }","public static long safeMultiply(long val1, int val2) {
    switch (val2) {
        case -1:
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
    }
    long total = val1 * val2;
    if (val2 != 0 && total / val2 != val1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}",0,0
240,Time_15,"public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
                 return -val1;
             case 0:
                 return 0L;
            case 1:
                return val1;
        }
        long total = val1 * val2;
        if (total / val2 != val1) {
          throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
        }
        return total;
    }","public static long safeMultiply(long val1, int val2) {
    if (val2 == 0) {
        return 0L;
    }
    if (val2 == -1) {
        if (val1 == Long.MIN_VALUE) {
            throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
        }
        return -val1;
    }
    if (val2 == 1) {
        return val1;
    }
    long result = val1 * val2;
    long absVal1 = Math.abs(val1);
    long absVal2 = Math.abs((long)val2);
    if (absVal1 > Long.MAX_VALUE / absVal2) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return result;
}",0,1
240,Time_15,"public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
                 return -val1;
             case 0:
                 return 0L;
            case 1:
                return val1;
        }
        long total = val1 * val2;
        if (total / val2 != val1) {
          throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
        }
        return total;
    }","public static long safeMultiply(long val1, int val2) {
    if (val2 == 0) {
        return 0L;
    }
    if (val2 == -1) {
        if (val1 == Long.MIN_VALUE) {
            throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
        }
        return -val1;
    }
    if (val2 == 1) {
        return val1;
    }
    long absVal1 = Math.abs(val1);
    long absVal2 = Math.abs((long)val2);
    if (absVal1 > Long.MAX_VALUE / absVal2) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return val1 * val2;
}",0,2
241,Time_16,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
        chrono = selectChronology(chrono);
         
        DateTimeParserBucket bucket = new DateTimeParserBucket(
            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        if (newPos < 0) {
            return newPos;  // If parseInto returns a negative value, return it directly.
        }
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }",0,0
241,Time_16,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    
    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);

    int newPos = parser.parseInto(bucket, text, position);
    if (newPos < 0) {
        return newPos; // Return immediately if parsing failed
    }

    long parsedMillis = bucket.computeMillis(true, text); // Use computeMillis with resetFields to ensure consistency
    if (parsedMillis < 0 && newPos >= 0) {
        // Handle specific case where computed millis might be invalid
        return position; // Return original position as parsing into instant failed
    }
    
    instant.setMillis(parsedMillis);

    int parsedOffset = (bucket.getOffsetInteger() != null) ? bucket.getOffsetInteger() : chrono.getZone().getOffset(parsedMillis);

    DateTimeZone parsedZone = (iOffsetParsed && bucket.getOffsetInteger() != null) 
        ? DateTimeZone.forOffsetMillis(parsedOffset) 
        : bucket.getZone() != null ? bucket.getZone() : chrono.getZone(); 
    
    chrono = chrono.withZone(parsedZone);
    instant.setChronology(chrono);

    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}",0,1
241,Time_16,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    
    if (newPos < 0) {
        return newPos; // If parseInto returns a negative value, return it directly.
    }

    // Ensure the computed millis are valid and within supported range
    long computedMillis = bucket.computeMillis(true, text);
    if (computedMillis == Long.MIN_VALUE) {
        return ~position; // Signal failure in parsing
    }
   
    instant.setMillis(computedMillis);

    // Adjust chronology depending on parsed zone or offset but avoid changing zone if parsed<DateTimeZone> is invalid
    DateTimeZone parsedZone = bucket.getZone();
    if (parsedZone == null && iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
    }
    if (parsedZone != null) {
        chrono = chrono.withZone(parsedZone);
    }
    instant.setChronology(chrono);

    if (iZone != null) {
        instant.setZone(iZone);
    }
    
    return newPos;
}",0,2
242,Time_17,"public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
         if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
         long local = convertUTCToLocal(instant);
         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }","public long adjustOffset(long instant, boolean earlierOrLater) {
    // a bit messy, but will work in all non-pathological cases

    // evaluate 3 hours before and after to work out if anything is happening
    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
    if (instantBefore == instantAfter) {
        return instant;  // not an overlap (less than is a gap, equal is normal case)
    }
    
    // work out range of instants that have duplicate local times
    long local = convertUTCToLocal(instant);
    if (instantBefore <= local && local <= instantAfter) {
        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
    }
    return instant;
}",0,0
242,Time_17,"public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
         if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
         long local = convertUTCToLocal(instant);
         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }","public long adjustOffset(long instant, boolean earlierOrLater) {
    // evaluate 3 hours before and after to work out if anything is happening
    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);

    if (instantBefore == instantAfter) {
        return instant;  // not an overlap (less than is a gap, equal is normal case)
    }

    // work out range of instants that have duplicate local times
    long local = convertUTCToLocal(instant);
    boolean inOverlap = (instantBefore < local && local < instantAfter);

    if (inOverlap || earlierOrLater) {
        return convertLocalToUTC(local, false, instantAfter);
    } else {
        return convertLocalToUTC(local, false, instantBefore);
    }
}",0,1
242,Time_17,"public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
         if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
         long local = convertUTCToLocal(instant);
         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }","public long adjustOffset(long instant, boolean earlierOrLater) {
    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);

    if (instantBefore == instantAfter) {
        return instant;
    }

    long local = convertUTCToLocal(instant);

    if (instantBefore <= local && local <= instantAfter) {
        long instantUTCWithLaterOffset = convertLocalToUTC(local, false, instantAfter);
        long instantUTCWithEarlierOffset = convertLocalToUTC(local, false, instantBefore);

        if (earlierOrLater) {
            // Choose the one that's later in time
            return Math.max(instantUTCWithLaterOffset, instantUTCWithEarlierOffset);
        } else {
            // Choose the one that's earlier in time
            return Math.min(instantUTCWithLaterOffset, instantUTCWithEarlierOffset);
        }
    }

    return instant;
}",0,2
243,Time_18,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
         // Assume date is Gregorian.
         long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (instant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist"");
            }
        }
        return instant;
    }","public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
        // Assume date is Gregorian.
        long instant = iGregorianChronology.getDateTimeMillis
            (year, monthOfYear, dayOfMonth,
             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        if (instant < iCutoverMillis) {
            // Maybe it's Julian.
            long julianInstant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (julianInstant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist"");
            }
            instant = julianInstant;
        }
        return instant;
    }",0,0
243,Time_18,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
         // Assume date is Gregorian.
         long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (instant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist"");
            }
        }
        return instant;
    }","public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                              int hourOfDay, int minuteOfHour,
                              int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException {
    Chronology base;
    if ((base = getBase()) != null) {
        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
    }

    long instant;
    // Determine whether to use Gregorian or Julian chronology
    if (year > iGregorianYearStart || (year == iGregorianYearStart && (monthOfYear > iGregorianMonthStart || (monthOfYear == iGregorianMonthStart && dayOfMonth >= iGregorianDayStart)))) {
        instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
    } else {
        instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        if (year == iCutoverYear && monthOfYear == iCutoverMonth && dayOfMonth <= iCutoverDay) {
            throw new IllegalArgumentException(""Specified date does not exist within the cutover gap"");
        }
    }
    return instant;
}",0,1
244,Time_19,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
        }
        return offsetAdjusted;
    }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalc the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);
    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // we need to ensure that time is always after the DST gap
        // this happens naturally for positive offsets, but not for negative
        if ((offsetLocal - offsetAdjusted) < 0) {
            // if we just return offsetAdjusted then the time is pushed
            // back before the transition, whereas it should be
            // on or after the transition
            long nextAdjusted = nextTransition(instantAdjusted);
            long nextLocal = nextTransition(instantLocal - offsetAdjusted);
            if (nextLocal != nextAdjusted) {
                return offsetLocal;
            }
        }
    } else if (offsetLocal > 0) {
        long prev = previousTransition(instantAdjusted);
        if (prev < instantAdjusted) {
            int offsetPrev = getOffset(prev);
            int diff = offsetPrev - offsetLocal;
            if (instantAdjusted - prev <= diff) {
                return offsetPrev;
            }
        }
    }
    return offsetAdjusted;
}",0,0
244,Time_19,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
        }
        return offsetAdjusted;
    }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (initial estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, are near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // ensure time is always after the DST gap
        if ((offsetLocal - offsetAdjusted) < 0) {
            // ensure transition time is correctly adjusted
            long nextTransitionAdjusted = nextTransition(instantAdjusted);
            long nextTransitionLocal = nextTransition(instantLocal - offsetAdjusted);
            if (nextTransitionLocal != nextTransitionAdjusted) {
                if (instantAdjusted < nextTransitionAdjusted){
                    return offsetLocal;
                }
            }
        }
    } else {
        if (offsetLocal > 0) {
            long prevTransition = previousTransition(instantAdjusted);
            if (prevTransition < instantAdjusted) {
                int offsetPrev = getOffset(prevTransition);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prevTransition <= diff) {
                    return offsetPrev;
                }
            }
        }
    }
    return offsetAdjusted;
}",0,1
244,Time_19,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
        }
        return offsetAdjusted;
    }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalc the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // ensure time is always after the DST gap
        // if offsetLocal is less, instant might fall into a gap
        if ((offsetLocal - offsetAdjusted) < 0) {
            long nextLocal = nextTransition(instantLocal);
            long nextAdjusted = nextTransition(instantAdjusted);
            if (nextLocal != nextAdjusted && nextLocal > instantLocal) {
                return offsetAdjusted;
            }
        }
    } else {
        long prev = previousTransition(instantAdjusted);
        if (prev < instantAdjusted) {
            int offsetPrev = getOffset(prev);
            if (offsetPrev != offsetLocal) {
                return offsetLocal; // ensure time falls after the transition gap
            }
        }
    }
    return offsetAdjusted;
}",0,2
245,Time_20,"public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                     bucket.setZone(DateTimeZone.forID(id));
                     return position + id.length();
                 }
             }
             return ~position;
         }","public int parseInto(DateTimeParserBucket bucket, String text, int position) {
    if (position < 0 || position >= text.length()) {
        return ~position;
    }

    String str = text.substring(position);
    for (String id : ALL_IDS) {
        if (str.startsWith(id)) {
            bucket.setZone(DateTimeZone.forID(id));
            return position + id.length();
        }
    }
    return ~position;
}",0,0
245,Time_20,"public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                     bucket.setZone(DateTimeZone.forID(id));
                     return position + id.length();
                 }
             }
             return ~position;
         }","public int parseInto(DateTimeParserBucket bucket, String text, int position) {
    if (position < 0 || position >= text.length()) {
        return ~position;
    }

    // Restrict parsing to remaining text length
    int maxIdLength = 0;
    DateTimeZone zoneToSet = null;
    for (String id : ALL_IDS) {
        if (text.substring(position).startsWith(id) && id.length() > maxIdLength) {
            maxIdLength = id.length();
            zoneToSet = DateTimeZone.forID(id);
        }
    }
    
    if (zoneToSet != null) {
        bucket.setZone(zoneToSet);
        return position + maxIdLength;
    } else {
        return ~position;
    }
}",0,1
246,Time_22,"    protected BasePeriod(long duration) {
        this(duration, null, null);
        // bug [3264409]
    }
","protected BasePeriod(long duration, Chronology chronology) {
    this(duration, null, chronology);
    // bug [3264409] resolved, now explicitly passing chronology
}",0,0
247,Time_23,"private static synchronized String getConvertedId(String id) {
        Map<String, String> map = cZoneIdConversion;
        if (map == null) {
            // Backwards compatibility with TimeZone.
            map = new HashMap<String, String>();
            map.put(""GMT"", ""UTC"");
            map.put(""MIT"", ""Pacific/Apia"");
            map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
            map.put(""AST"", ""America/Anchorage"");
            map.put(""PST"", ""America/Los_Angeles"");
            map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
             map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
             map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""WET"", ""Europe/London"");
             map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
             map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
             map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
            map.put(""AET"", ""Australia/Sydney"");
            map.put(""SST"", ""Pacific/Guadalcanal"");
            map.put(""NST"", ""Pacific/Auckland"");
            cZoneIdConversion = map;
        }
        return map.get(id);
    }","private static synchronized String getConvertedId(String id) {
    // Check if the map has been initialized
    if (cZoneIdConversion == null) {
        // Backwards compatibility with TimeZone.
        Map<String, String> map = new HashMap<String, String>();
        map.put(""GMT"", ""UTC"");
        map.put(""MIT"", ""Pacific/Apia"");
        map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
        map.put(""AST"", ""America/Anchorage"");
        map.put(""PST"", ""America/Los_Angeles"");
        map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
        map.put(""PNT"", ""America/Phoenix"");
        map.put(""CST"", ""America/Chicago"");
        map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
        map.put(""IET"", ""America/Indianapolis"");
        map.put(""PRT"", ""America/Puerto_Rico"");
        map.put(""CNT"", ""America/St_Johns"");
        map.put(""AGT"", ""America/Buenos_Aires"");
        map.put(""BET"", ""America/Sao_Paulo"");
        map.put(""WET"", ""Europe/London"");
        map.put(""ECT"", ""Europe/Paris"");
        map.put(""ART"", ""Africa/Cairo"");
        map.put(""CAT"", ""Africa/Harare"");
        map.put(""EET"", ""Europe/Bucharest"");
        map.put(""EAT"", ""Africa/Addis_Ababa"");
        map.put(""MET"", ""Asia/Tehran"");
        map.put(""NET"", ""Asia/Yerevan"");
        map.put(""PLT"", ""Asia/Karachi"");
        map.put(""IST"", ""Asia/Calcutta"");
        map.put(""BST"", ""Asia/Dhaka"");
        map.put(""VST"", ""Asia/Saigon"");
        map.put(""CTT"", ""Asia/Shanghai"");
        map.put(""JST"", ""Asia/Tokyo"");
        map.put(""ACT"", ""Australia/Darwin"");
        map.put(""AET"", ""Australia/Sydney"");
        map.put(""SST"", ""Pacific/Guadalcanal"");
        map.put(""NST"", ""Pacific/Auckland"");
        cZoneIdConversion = map;
    }
    return cZoneIdConversion.get(id);
}",0,0
247,Time_23,"private static synchronized String getConvertedId(String id) {
        Map<String, String> map = cZoneIdConversion;
        if (map == null) {
            // Backwards compatibility with TimeZone.
            map = new HashMap<String, String>();
            map.put(""GMT"", ""UTC"");
            map.put(""MIT"", ""Pacific/Apia"");
            map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
            map.put(""AST"", ""America/Anchorage"");
            map.put(""PST"", ""America/Los_Angeles"");
            map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
             map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
             map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""WET"", ""Europe/London"");
             map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
             map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
             map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
            map.put(""AET"", ""Australia/Sydney"");
            map.put(""SST"", ""Pacific/Guadalcanal"");
            map.put(""NST"", ""Pacific/Auckland"");
            cZoneIdConversion = map;
        }
        return map.get(id);
    }","private static String getConvertedId(String id) {
    // Ensure thread-safe initialization
    Map<String, String> localMap = cZoneIdConversion;
    if (localMap == null) {
        synchronized (getClass()) {
            localMap = cZoneIdConversion;
            if (localMap == null) {
                // Backwards compatibility with TimeZone.
                localMap = new HashMap<String, String>();
                localMap.put(""GMT"", ""UTC"");
                localMap.put(""MIT"", ""Pacific/Apia"");
                localMap.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
                localMap.put(""AST"", ""America/Anchorage"");
                localMap.put(""PST"", ""America/Los_Angeles"");
                localMap.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
                localMap.put(""PNT"", ""America/Phoenix"");
                localMap.put(""CST"", ""America/Chicago"");
                localMap.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
                localMap.put(""IET"", ""America/Indianapolis"");
                localMap.put(""PRT"", ""America/Puerto_Rico"");
                localMap.put(""CNT"", ""America/St_Johns"");
                localMap.put(""AGT"", ""America/Buenos_Aires"");
                localMap.put(""BET"", ""America/Sao_Paulo"");
                localMap.put(""WET"", ""Europe/London"");
                localMap.put(""ECT"", ""Europe/Paris"");
                localMap.put(""ART"", ""Africa/Cairo"");
                localMap.put(""CAT"", ""Africa/Harare"");
                localMap.put(""EET"", ""Europe/Bucharest"");
                localMap.put(""EAT"", ""Africa/Addis_Ababa"");
                localMap.put(""MET"", ""Asia/Tehran"");
                localMap.put(""NET"", ""Asia/Yerevan"");
                localMap.put(""PLT"", ""Asia/Karachi"");
                localMap.put(""IST"", ""Asia/Calcutta"");
                localMap.put(""BST"", ""Asia/Dhaka"");
                localMap.put(""VST"", ""Asia/Saigon"");
                localMap.put(""CTT"", ""Asia/Shanghai"");
                localMap.put(""JST"", ""Asia/Tokyo"");
                localMap.put(""ACT"", ""Australia/Darwin"");
                localMap.put(""AET"", ""Australia/Sydney"");
                localMap.put(""SST"", ""Pacific/Guadalcanal"");
                localMap.put(""NST"", ""Pacific/Auckland"");
                cZoneIdConversion = localMap;
            }
        }
    }
    return localMap.get(id);
}",0,1
248,Time_24,"public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);
        if (count > 0) {
            // alter base year for parsing if first field is month or day
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }

        long millis = iMillis;
        try {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }
        
        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message =
                    ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }
        
        return millis;
    }","public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        long transitionedMillis = millis - offset;
        if (iZone.getOffset(transitionedMillis) != offset) {
            String message =
                ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
        millis = transitionedMillis;
    }
    
    return millis;
}",0,0
248,Time_24,"public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);
        if (count > 0) {
            // alter base year for parsing if first field is month or day
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }

        long millis = iMillis;
        try {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }
        
        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message =
                    ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }
        
        return millis;
    }","public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if there's no explicit year field
        boolean hasYear = false;
        for (SavedField field : savedFields) {
            if (field.iField.getType().equals(DateTimeFieldType.year())) {
                hasYear = true;
                break;
            }
        }
        if (!hasYear) {
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }
    }

    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        long localMillis = millis - offset;
        if (iZone.getOffset(localMillis) != offset) {
            String message =
                ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
        millis = localMillis;
    }
    
    return millis;
}",0,1
249,Time_25,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we might be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // we need to ensure that time is always after the DST gap
        // this happens naturally for positive offsets, but not for negative
        if ((offsetLocal - offsetAdjusted) < 0) {
            // if we just return offsetAdjusted then the time is pushed
            // back before the transition, whereas it should be
            // on or after the transition
            long nextLocal = nextTransition(instantAdjusted);
            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
            if (nextLocal != nextAdjusted) {
                return offsetLocal;
            }
        } else {
            return offsetLocal;
        }
    }
    return offsetAdjusted;
}",0,0
249,Time_25,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // Ensure correct offset by considering transitions
        long nextLocalTransition = nextTransition(instantLocal);
        long nextAdjustedTransition = nextTransition(instantAdjusted);

        // If the next transition is different when using adjusted, use instantLocal offset
        if (nextLocalTransition < nextAdjustedTransition) {
            return offsetLocal;
        }
    }

    // Return the adjusted offset if no discrepancies occur
    return offsetAdjusted;
}",0,1
249,Time_25,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // Edge case: check if instantLocal lies exactly on a transition point
        long previousTransition = previousTransition(instantAdjusted);
        long nextLocalTransition = nextTransition(instantLocal);
        if (instantLocal == previousTransition || instantLocal == nextLocalTransition) {
            return offsetAdjusted;
        }
        
        // Check if the adjusted instant is before its next transition when the offset changes
        long nextAdjustedTransition = nextTransition(instantAdjusted);
        if ((offsetLocal - offsetAdjusted) < 0 && nextLocalTransition != nextAdjustedTransition) {
            return offsetLocal;
        }

        // Ensure correct offset by considering transitions
        long instantCorrected = instantLocal - offsetAdjusted;
        if (instantCorrected < nextLocalTransition && instantCorrected >= previousTransition) {
            return offsetAdjusted;
        }
    }
    
    return offsetAdjusted;
}",0,2
250,Time_27,"private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
        if (notPrinter && notParser) {
            throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
        }
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
            return new PeriodFormatter(null, (PeriodParser) comp[1]);
        } else if (notParser) {
            return new PeriodFormatter((PeriodPrinter) comp[0], null);
        } else {
            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
        }
    }","private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
    if (notPrinter && notParser) {
        throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
    }
    int size = elementPairs.size();
    if (size >= 1 && elementPairs.get(0) instanceof Separator) {
        Separator sep = (Separator) elementPairs.get(0);
        PeriodFormatter f = toFormatter(elementPairs.subList(1, size), notPrinter, notParser);
        sep = sep.finish(f.getPrinter(), f.getParser());
        return new PeriodFormatter(sep, sep);
    }
    Object[] comp = createComposite(elementPairs);
    if (notPrinter) {
        return new PeriodFormatter(null, (PeriodParser) comp[1]);
    } else if (notParser) {
        return new PeriodFormatter((PeriodPrinter) comp[0], null);
    } else {
        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
    }
}",0,0
250,Time_27,"private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
        if (notPrinter && notParser) {
            throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
        }
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
            return new PeriodFormatter(null, (PeriodParser) comp[1]);
        } else if (notParser) {
            return new PeriodFormatter((PeriodPrinter) comp[0], null);
        } else {
            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
        }
    }",Match failed,0,1
251,Time_4,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                        if (compare > 0) {
                            break;
                        } else if (compare == 0) {
                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                            if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
             Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];

        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        for (; i < iTypes.length; i++) {
            DateTimeFieldType loopType = iTypes[i];
            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
            int compare = unitField.compareTo(loopUnitField);
            if (compare > 0) {
                break;
            } else if (compare == 0) {
                DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                if (rangeField.compareTo(loopRangeField) > 0) {
                    break;
                }
            }
        }
        
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);

        // use public constructor to ensure full validation
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}",0,0
251,Time_4,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                        if (compare > 0) {
                            break;
                        } else if (compare == 0) {
                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                            if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
             Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];

        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);

        for (; i < iTypes.length; i++) {
            DateTimeFieldType loopType = iTypes[i];
            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
            if (loopUnitField.isSupported() && unitField.isSupported()) {
                int compare = unitField.compareTo(loopUnitField);
                if (compare > 0) {
                    break;
                } else if (compare == 0) {
                    DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (rangeField.isSupported() && loopRangeField.isSupported() && rangeField.compareTo(loopRangeField) > 0) {
                        break;
                    }
                }
            }
        }

        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);

        // use public constructor to ensure full validation
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}",0,1
251,Time_4,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                        if (compare > 0) {
                            break;
                        } else if (compare == 0) {
                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                            if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
             Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        // Prepare new array sizes
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];

        // Determine insertion point keeping the order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        
        for (; i < iTypes.length; i++) {
            DateTimeFieldType loopType = iTypes[i];
            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);

            if (!loopUnitField.isSupported() || !unitField.isSupported()) {
                continue;
            }

            int compare = unitField.compareTo(loopUnitField);
            if (compare > 0 || (compare == 0 && isMoreSpecific(fieldType, loopType))) {
                break;
            }
        }
        
        // Insert the new field and value
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, iTypes.length - i);
        System.arraycopy(iValues, i, newValues, i + 1, iValues.length - i);

        // Validate and return a new Partial instance
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    } 
    
    // If field already exists, simply modify the value
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}

private boolean isMoreSpecific(DateTimeFieldType newType, DateTimeFieldType existingType) {
    DurationField rangeField = newType.getRangeDurationType().getField(iChronology);
    DurationField loopRangeField = existingType.getRangeDurationType().getField(iChronology);

    return rangeField.isSupported() && loopRangeField.isSupported() && rangeField.compareTo(loopRangeField) > 0;
}",0,2
252,Time_5,"public Period normalizedStandard(PeriodType type) {
        type = DateTimeUtils.getPeriodType(type);
        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
             years = FieldUtils.safeAdd(years, months / 12);
             months = months % 12;
             if (years != 0) {
                 result = result.withYears(years);
             }
             if (months != 0) {
                 result = result.withMonths(months);
             }
         }
         return result;
    }","public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));

    int years = getYears();
    int months = getMonths();

    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;
    }

    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());

    if (years != 0 || months != 0) {
        if (years != 0) {
            result = result.withYears(years);
        }
        if (months != 0) {
            result = result.withMonths(months);
        }
    }
    return result;
}",0,0
252,Time_5,"public Period normalizedStandard(PeriodType type) {
        type = DateTimeUtils.getPeriodType(type);
        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
             years = FieldUtils.safeAdd(years, months / 12);
             months = months % 12;
             if (years != 0) {
                 result = result.withYears(years);
             }
             if (months != 0) {
                 result = result.withMonths(months);
             }
         }
         return result;
    }","public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    long millis = getMillis();
    millis += (((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND);
    millis += (((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE);
    millis += (((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR);
    millis += (((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY);
    millis += (((long) getWeeks()) * DateTimeConstants.MILLIS_PER_WEEK);
    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());

    int totalMonths = (getYears() * 12) + getMonths();
    if (totalMonths != 0) {
        int years = totalMonths / 12;
        int months = totalMonths % 12;
        if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
            result = result.withYears(years);
        }
        if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
            result = result.withMonths(months);
        }
    }

    return result;
}",0,1
252,Time_5,"public Period normalizedStandard(PeriodType type) {
        type = DateTimeUtils.getPeriodType(type);
        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
             years = FieldUtils.safeAdd(years, months / 12);
             months = months % 12;
             if (years != 0) {
                 result = result.withYears(years);
             }
             if (months != 0) {
                 result = result.withMonths(months);
             }
         }
         return result;
    }","public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    long totalMillis = getMillis();
    totalMillis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    totalMillis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    totalMillis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;
    totalMillis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;
    totalMillis += ((long) getWeeks()) * DateTimeConstants.MILLIS_PER_WEEK;
    
    int totalMonths = FieldUtils.safeAdd(FieldUtils.safeMultiply(getYears(), 12), getMonths());
    
    if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
        int years = totalMonths / 12;
        totalMonths %= 12; // remaining months
        if (years != 0) {
            totalMonths = type.isSupported(DurationFieldType.MONTHS_TYPE) ? totalMonths : 0;
        }
    }
    
    Period result = new Period(totalMillis, type, ISOChronology.getInstanceUTC())
        .withMonths(totalMonths); // Add months directly if supported
    
    return result;
}",0,2
253,Time_7,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }

    // Correct computation of instantLocal using the offset in milliseconds
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis - chrono.getZone().getOffset(instantMillis); // Corrected subtraction for offset
    chrono = selectChronology(chrono);
    int defaultYear = chrono.year().get(instantLocal);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono, iLocale, iPivotYear, defaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));

    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }

    instant.setChronology(chrono);

    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}",0,0
253,Time_7,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    DateTimeZone zone = chrono.getZone();
    long instantLocal = instantMillis + zone.getOffset(instantMillis);
    chrono = selectChronology(chrono);
    int defaultYear = chrono.year().get(instantLocal);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono.withZone(DateTimeZone.UTC), iLocale, iPivotYear, defaultYear);
    int newPos = parser.parseInto(bucket, text, position);

    long computedMillis = bucket.computeMillis(true, text);
    if (!zone.isLocalDateTimeGap(new LocalDateTime(computedMillis, chrono))) {
        instant.setMillis(computedMillis);
    } else {
        instant.setMillis(instantMillis);
    }
    
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);

    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}",0,1
253,Time_7,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    DateTimeZone originalZone = chrono.getZone();
    long instantLocal = instantMillis + originalZone.getOffset(instantMillis);
    chrono = selectChronology(chrono);
    int defaultYear = chrono.year().get(instantLocal);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono.withZone(DateTimeZone.UTC), iLocale, iPivotYear, defaultYear
    );
    int newPos = parser.parseInto(bucket, text, position);
    
    long computedMillis = bucket.computeMillis(true, text);
    DateTimeZone parsedZone = iZone != null ? iZone : bucket.getZone();
    
    if (!bucket.verify(offsetMillis -> {
        DateTimeZone zone = parsedZone != null ? parsedZone : originalZone;
        return !zone.isLocalDateTimeGap(new LocalDateTime(computedMillis + offsetMillis, chrono));
    })) {
        instant.setMillis(computedMillis);
    } else {
        instant.setMillis(instantMillis);
    }
    
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
    }
    
    instant.setChronology(chrono.withZone(parsedZone != null ? parsedZone : originalZone));
    return newPos;
}",0,2
254,Time_8,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
        if (hoursOffset == 0 && minutesOffset == 0) {
            return DateTimeZone.UTC;
        }
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                 minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }","public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
    if (hoursOffset == 0 && minutesOffset == 0) {
        return DateTimeZone.UTC;
    }
    if (hoursOffset < -23 || hoursOffset > 23) {
        throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
    }
    if (minutesOffset < 0 || minutesOffset > 59) {
        throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
    }
    int offset = 0;
    try {
        int hoursInMinutes = hoursOffset * 60;
        int totalMinutesOffset = hoursInMinutes + (hoursOffset < 0 ? -minutesOffset : minutesOffset);
        offset = FieldUtils.safeMultiply(totalMinutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
    } catch (ArithmeticException ex) {
        throw new IllegalArgumentException(""Offset is too large"", ex);
    }
    return forOffsetMillis(offset);
}",0,0
254,Time_8,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
        if (hoursOffset == 0 && minutesOffset == 0) {
            return DateTimeZone.UTC;
        }
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                 minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }","public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
    if (hoursOffset == 0 && minutesOffset == 0) {
        return DateTimeZone.UTC;
    }
    if (hoursOffset < -23 || hoursOffset > 23) {
        throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
    }
    if (minutesOffset < 0 || minutesOffset > 59) {
        throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
    }
    if (hoursOffset < 0 && minutesOffset < 0) {
        throw new IllegalArgumentException(""Negative hours and minutes offset not allowed"");
    }
    int totalMinutesOffset = Math.abs(hoursOffset) * 60 + minutesOffset;
    int offset;
    try {
        offset = FieldUtils.safeMultiply(totalMinutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
    } catch (ArithmeticException ex) {
        throw new IllegalArgumentException(""Offset is too large"", ex);
    }
    return forOffsetMillis(hoursOffset < 0 ? -offset : offset);
}",0,1
254,Time_8,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
        if (hoursOffset == 0 && minutesOffset == 0) {
            return DateTimeZone.UTC;
        }
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                 minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }","public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
    if (hoursOffset == 0 && minutesOffset == 0) {
        return DateTimeZone.UTC;
    }
    if (hoursOffset < -23 || hoursOffset > 23) {
        throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
    }
    if (minutesOffset < 0 || minutesOffset > 59) {
        throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
    }
    int totalMinutesOffset = Math.abs(hoursOffset) * 60 + Math.abs(minutesOffset);
    int offset;
    try {
        offset = FieldUtils.safeMultiply(totalMinutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
    } catch (ArithmeticException ex) {
        throw new IllegalArgumentException(""Offset is too large"", ex);
    }
    return forOffsetMillis(hoursOffset < 0 ? -offset : offset);
}",0,2
