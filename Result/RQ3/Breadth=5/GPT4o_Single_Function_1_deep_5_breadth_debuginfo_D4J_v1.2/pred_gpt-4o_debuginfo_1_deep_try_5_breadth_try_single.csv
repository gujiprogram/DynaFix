ID,slug,bug,fix,width_attempt,iteration
0,Chart_1,"public LegendItemCollection getLegendItems() {
        LegendItemCollection result = new LegendItemCollection();
        if (this.plot == null) {
            return result;
         }
         int index = this.plot.getIndexOf(this);
         CategoryDataset dataset = this.plot.getDataset(index);
         if (dataset != null) {
             return result;
         }
         int seriesCount = dataset.getRowCount();
        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {
            for (int i = 0; i < seriesCount; i++) {
                if (isSeriesVisibleInLegend(i)) {
                    LegendItem item = getLegendItem(index, i);
                    if (item != null) {
                        result.add(item);
                    }
                }
            }
        }
        else {
            for (int i = seriesCount - 1; i >= 0; i--) {
                if (isSeriesVisibleInLegend(i)) {
                    LegendItem item = getLegendItem(index, i);
                    if (item != null) {
                        result.add(item);
                    }
                }
            }
        }
        return result;
    }","public LegendItemCollection getLegendItems() {
    LegendItemCollection result = new LegendItemCollection();
    if (this.plot == null) {
        return result;
    }
    int index = this.plot.getIndexOf(this);
    CategoryDataset dataset = this.plot.getDataset(index);
    if (dataset == null) { // Fixed condition to correctly check for null dataset
        return result;
    }
    int seriesCount = dataset.getRowCount();
    if (this.plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {
        for (int i = 0; i < seriesCount; i++) {
            if (isSeriesVisibleInLegend(i)) {
                LegendItem item = getLegendItem(index, i);
                if (item != null) {
                    result.add(item);
                }
            }
        }
    } else {
        for (int i = seriesCount - 1; i >= 0; i--) {
            if (isSeriesVisibleInLegend(i)) {
                LegendItem item = getLegendItem(index, i);
                if (item != null) {
                    result.add(item);
                }
            }
        }
    }
    return result;
}",0,0
1,Chart_10,"    public String generateToolTipFragment(String toolTipText) {
        return "" title=\"""" + toolTipText
            + ""\"" alt=\""\"""";
    }
","public String generateToolTipFragment(String toolTipText) {
    return "" title=\"""" + toolTipText.replace(""\"""", ""&quot;"")
        + ""\"" alt=\""\"""";
}",0,0
2,Chart_11,"public static boolean equal(GeneralPath p1, GeneralPath p2) {
        if (p1 == null) {
            return (p2 == null);
        }
        if (p2 == null) {
            return false;
        }
        if (p1.getWindingRule() != p2.getWindingRule()) {
             return false;
         }
         PathIterator iterator1 = p1.getPathIterator(null);
         PathIterator iterator2 = p1.getPathIterator(null);
         double[] d1 = new double[6];
         double[] d2 = new double[6];
         boolean done = iterator1.isDone() && iterator2.isDone();
        while (!done) {
            if (iterator1.isDone() != iterator2.isDone()) {
                return false;
            }
            int seg1 = iterator1.currentSegment(d1);
            int seg2 = iterator2.currentSegment(d2);
            if (seg1 != seg2) {
                return false;
            }
            if (!Arrays.equals(d1, d2)) {
                return false;
            }
            iterator1.next();
            iterator2.next();
            done = iterator1.isDone() && iterator2.isDone();
        }
        return true;
    }","public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p2.getPathIterator(null); // Fixed: iterator2 should be initialized with p2 not p1
    double[] d1 = new double[6];
    double[] d2 = new double[6];

    while (!iterator1.isDone() || !iterator2.isDone()) { // Fixed: Correct condition for iteration
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
    }
    return true;
}",0,0
3,Chart_12,"    public MultiplePiePlot(CategoryDataset dataset) {
        super();
        this.dataset = dataset;
        PiePlot piePlot = new PiePlot(null);
        this.pieChart = new JFreeChart(piePlot);
        this.pieChart.removeLegend();
        this.dataExtractOrder = TableOrder.BY_COLUMN;
        this.pieChart.setBackgroundPaint(null);
        TextTitle seriesTitle = new TextTitle(""Series Title"",
                new Font(""SansSerif"", Font.BOLD, 12));
        seriesTitle.setPosition(RectangleEdge.BOTTOM);
        this.pieChart.setTitle(seriesTitle);
        this.aggregatedItemsKey = ""Other"";
        this.aggregatedItemsPaint = Color.lightGray;
        this.sectionPaints = new HashMap();
    }
","public MultiplePiePlot(CategoryDataset dataset) {
    super();
    this.dataset = dataset;
    PiePlot piePlot = new PiePlot(null);
    this.pieChart = new JFreeChart(piePlot);
    this.pieChart.removeLegend();
    this.dataExtractOrder = TableOrder.BY_COLUMN;
    this.pieChart.setBackgroundPaint(Color.white); // Fixed null background paint to default color
    TextTitle seriesTitle = new TextTitle(""Series Title"",
            new Font(""SansSerif"", Font.BOLD, 12));
    seriesTitle.setPosition(RectangleEdge.BOTTOM);
    this.pieChart.setTitle(seriesTitle);
    this.aggregatedItemsKey = ""Other"";
    this.aggregatedItemsPaint = Color.lightGray;
    this.sectionPaints = new HashMap<>();
}",0,0
3,Chart_12,"    public MultiplePiePlot(CategoryDataset dataset) {
        super();
        this.dataset = dataset;
        PiePlot piePlot = new PiePlot(null);
        this.pieChart = new JFreeChart(piePlot);
        this.pieChart.removeLegend();
        this.dataExtractOrder = TableOrder.BY_COLUMN;
        this.pieChart.setBackgroundPaint(null);
        TextTitle seriesTitle = new TextTitle(""Series Title"",
                new Font(""SansSerif"", Font.BOLD, 12));
        seriesTitle.setPosition(RectangleEdge.BOTTOM);
        this.pieChart.setTitle(seriesTitle);
        this.aggregatedItemsKey = ""Other"";
        this.aggregatedItemsPaint = Color.lightGray;
        this.sectionPaints = new HashMap();
    }
","public MultiplePiePlot(CategoryDataset dataset) {
    super();
    this.dataset = dataset;
    PiePlot piePlot = new PiePlot(new DefaultPieDataset()); // Fix: Use a non-null dataset for PiePlot
    this.pieChart = new JFreeChart(piePlot);
    this.pieChart.removeLegend();
    this.dataExtractOrder = TableOrder.BY_COLUMN;
    this.pieChart.setBackgroundPaint(Color.WHITE); // Fix: Set a valid default background paint
    TextTitle seriesTitle = new TextTitle(""Series Title"",
            new Font(""SansSerif"", Font.BOLD, 12));
    seriesTitle.setPosition(RectangleEdge.BOTTOM);
    this.pieChart.setTitle(seriesTitle);
    this.aggregatedItemsKey = ""Other"";
    this.aggregatedItemsPaint = Color.LIGHT_GRAY;
    this.sectionPaints = new HashMap<>();
}",1,0
3,Chart_12,"    public MultiplePiePlot(CategoryDataset dataset) {
        super();
        this.dataset = dataset;
        PiePlot piePlot = new PiePlot(null);
        this.pieChart = new JFreeChart(piePlot);
        this.pieChart.removeLegend();
        this.dataExtractOrder = TableOrder.BY_COLUMN;
        this.pieChart.setBackgroundPaint(null);
        TextTitle seriesTitle = new TextTitle(""Series Title"",
                new Font(""SansSerif"", Font.BOLD, 12));
        seriesTitle.setPosition(RectangleEdge.BOTTOM);
        this.pieChart.setTitle(seriesTitle);
        this.aggregatedItemsKey = ""Other"";
        this.aggregatedItemsPaint = Color.lightGray;
        this.sectionPaints = new HashMap();
    }
","public MultiplePiePlot(CategoryDataset dataset) {
    super();
    this.dataset = dataset;
    PiePlot piePlot = (dataset != null && !dataset.getRowKeys().isEmpty()) 
        ? new PiePlot(dataset) 
        : new PiePlot(new DefaultPieDataset()); // Fix: Default to non-empty dataset for PiePlot
    this.pieChart = new JFreeChart(piePlot);
    this.pieChart.removeLegend();
    this.dataExtractOrder = TableOrder.BY_COLUMN;
    this.pieChart.setBackgroundPaint(Color.white); // Fix: Use a valid default background paint
    TextTitle seriesTitle = new TextTitle(""Series Title"",
            new Font(""SansSerif"", Font.BOLD, 12));
    seriesTitle.setPosition(RectangleEdge.BOTTOM);
    this.pieChart.setTitle(seriesTitle);
    this.aggregatedItemsKey = ""Other"";
    this.aggregatedItemsPaint = Color.lightGray;
    this.sectionPaints = new HashMap<>();
}",2,0
3,Chart_12,"    public MultiplePiePlot(CategoryDataset dataset) {
        super();
        this.dataset = dataset;
        PiePlot piePlot = new PiePlot(null);
        this.pieChart = new JFreeChart(piePlot);
        this.pieChart.removeLegend();
        this.dataExtractOrder = TableOrder.BY_COLUMN;
        this.pieChart.setBackgroundPaint(null);
        TextTitle seriesTitle = new TextTitle(""Series Title"",
                new Font(""SansSerif"", Font.BOLD, 12));
        seriesTitle.setPosition(RectangleEdge.BOTTOM);
        this.pieChart.setTitle(seriesTitle);
        this.aggregatedItemsKey = ""Other"";
        this.aggregatedItemsPaint = Color.lightGray;
        this.sectionPaints = new HashMap();
    }
","public MultiplePiePlot(CategoryDataset dataset) {
    super();
    this.dataset = dataset;
    PiePlot piePlot;
    
    // Fix: Ensure the dataset passed is valid before initializing PiePlot
    if (dataset != null && dataset.getRowCount() > 0 && dataset.getColumnCount() > 0) {
        piePlot = new PiePlot(dataset);
    } else {
        piePlot = new PiePlot(new DefaultPieDataset());
    }

    this.pieChart = new JFreeChart(piePlot);
    this.pieChart.removeLegend();
    this.dataExtractOrder = TableOrder.BY_COLUMN;

    // Fix: Provide a default non-null paint
    this.pieChart.setBackgroundPaint(Color.WHITE);
    
    TextTitle seriesTitle = new TextTitle(""Series Title"",
            new Font(""SansSerif"", Font.BOLD, 12));
    seriesTitle.setPosition(RectangleEdge.BOTTOM);
    this.pieChart.setTitle(seriesTitle);

    this.aggregatedItemsKey = ""Other"";
    this.aggregatedItemsPaint = Color.LIGHT_GRAY;
    this.sectionPaints = new HashMap<>();
}",3,0
3,Chart_12,"    public MultiplePiePlot(CategoryDataset dataset) {
        super();
        this.dataset = dataset;
        PiePlot piePlot = new PiePlot(null);
        this.pieChart = new JFreeChart(piePlot);
        this.pieChart.removeLegend();
        this.dataExtractOrder = TableOrder.BY_COLUMN;
        this.pieChart.setBackgroundPaint(null);
        TextTitle seriesTitle = new TextTitle(""Series Title"",
                new Font(""SansSerif"", Font.BOLD, 12));
        seriesTitle.setPosition(RectangleEdge.BOTTOM);
        this.pieChart.setTitle(seriesTitle);
        this.aggregatedItemsKey = ""Other"";
        this.aggregatedItemsPaint = Color.lightGray;
        this.sectionPaints = new HashMap();
    }
","public MultiplePiePlot(CategoryDataset dataset) {
    super();
    this.dataset = dataset;

    // Fix: Handle dataset validity and initialize PiePlot if dataset is valid; fallback to a default PiePlot
    PiePlot piePlot = (dataset != null && dataset.getRowCount() > 0 && dataset.getColumnCount() > 0) 
        ? new PiePlot(dataset)
        : new PiePlot(new DefaultPieDataset());
    
    this.pieChart = new JFreeChart(piePlot);
    this.pieChart.removeLegend();

    // Fix: Use a default valid color instead of null for background paint
    this.pieChart.setBackgroundPaint(Color.WHITE);

    TextTitle seriesTitle = new TextTitle(""Series Title"", new Font(""SansSerif"", Font.BOLD, 12));
    seriesTitle.setPosition(RectangleEdge.BOTTOM);
    this.pieChart.setTitle(seriesTitle);
    
    this.aggregatedItemsKey = ""Other"";
    this.aggregatedItemsPaint = Color.LIGHT_GRAY;
    this.sectionPaints = new HashMap<>();
}",4,0
4,Chart_13,"protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                               RectangleConstraint constraint) {
        double[] w = new double[5];
        double[] h = new double[5];
        w[0] = constraint.getWidth();
        if (this.topBlock != null) {
            RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0,
                    new Range(0.0, constraint.getHeight()),
                    LengthConstraintType.RANGE);
            Size2D size = this.topBlock.arrange(g2, c1);
            h[0] = size.height;
        }
        w[1] = w[0];
        if (this.bottomBlock != null) {
            RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0, new Range(0.0,
                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
            Size2D size = this.bottomBlock.arrange(g2, c2);
            h[1] = size.height;
        }
        h[2] = constraint.getHeight() - h[1] - h[0];
        if (this.leftBlock != null) {
            RectangleConstraint c3 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth()),
                    LengthConstraintType.RANGE, h[2], null,
                    LengthConstraintType.FIXED);
            Size2D size = this.leftBlock.arrange(g2, c3);
            w[2] = size.width;
        }
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                     new Range(0.0, constraint.getWidth() - w[2]),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
            w[3] = size.width;
        }
        h[4] = h[2];
        w[4] = constraint.getWidth() - w[3] - w[2];
        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
        if (this.centerBlock != null) {
            this.centerBlock.arrange(g2, c5);
        }

        if (this.topBlock != null) {
            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],
                    h[0]));
        }
        if (this.bottomBlock != null) {
            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],
                    w[1], h[1]));
        }
        if (this.leftBlock != null) {
            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
                    h[2]));
        }
        if (this.rightBlock != null) {
            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],
                    w[3], h[3]));
        }
        if (this.centerBlock != null) {
            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],
                    h[4]));
        }
        return new Size2D(constraint.getWidth(), constraint.getHeight());
    }","protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                           RectangleConstraint constraint) {
    double[] w = new double[5];
    double[] h = new double[5];

    w[0] = constraint.getWidth();
    h[4] = constraint.getHeight();

    if (this.topBlock != null) {
        RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                LengthConstraintType.FIXED, 0.0,
                new Range(0.0, h[4]), LengthConstraintType.RANGE);
        Size2D size = this.topBlock.arrange(g2, c1);
        h[0] = size.height;
        h[4] -= h[0];
    }

    w[1] = w[0];
    if (this.bottomBlock != null) {
        RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                LengthConstraintType.FIXED, 0.0,
                new Range(0.0, h[4]), LengthConstraintType.RANGE);
        Size2D size = this.bottomBlock.arrange(g2, c2);
        h[1] = size.height;
        h[4] -= h[1];
    }

    if (h[4] < 0) {
        throw new IllegalArgumentException(""Height constraint is negative."");
    }

    w[4] = w[0];
    if (this.leftBlock != null) {
        RectangleConstraint c3 = new RectangleConstraint(0.0,
                new Range(0.0, w[4]), LengthConstraintType.RANGE,
                h[4], null, LengthConstraintType.FIXED);
        Size2D size = this.leftBlock.arrange(g2, c3);
        w[2] = size.width;
        w[4] -= w[2];
    }

    if (this.rightBlock != null) {
        RectangleConstraint c4 = new RectangleConstraint(0.0,
                new Range(0.0, w[4]), LengthConstraintType.RANGE,
                h[4], null, LengthConstraintType.FIXED);
        Size2D size = this.rightBlock.arrange(g2, c4);
        w[3] = size.width;
        w[4] -= w[3];
    }

    if (w[4] < 0) {
        throw new IllegalArgumentException(""Width constraint is negative."");
    }

    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
    if (this.centerBlock != null) {
        this.centerBlock.arrange(g2, c5);
    }

    if (this.topBlock != null) {
        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0]));
    }
    if (this.bottomBlock != null) {
        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[4], w[1], h[1]));
    }
    if (this.leftBlock != null) {
        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[4]));
    }
    if (this.rightBlock != null) {
        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[4]));
    }
    if (this.centerBlock != null) {
        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4]));
    }
    return new Size2D(constraint.getWidth(), constraint.getHeight());
}",0,0
4,Chart_13,"protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                               RectangleConstraint constraint) {
        double[] w = new double[5];
        double[] h = new double[5];
        w[0] = constraint.getWidth();
        if (this.topBlock != null) {
            RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0,
                    new Range(0.0, constraint.getHeight()),
                    LengthConstraintType.RANGE);
            Size2D size = this.topBlock.arrange(g2, c1);
            h[0] = size.height;
        }
        w[1] = w[0];
        if (this.bottomBlock != null) {
            RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0, new Range(0.0,
                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
            Size2D size = this.bottomBlock.arrange(g2, c2);
            h[1] = size.height;
        }
        h[2] = constraint.getHeight() - h[1] - h[0];
        if (this.leftBlock != null) {
            RectangleConstraint c3 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth()),
                    LengthConstraintType.RANGE, h[2], null,
                    LengthConstraintType.FIXED);
            Size2D size = this.leftBlock.arrange(g2, c3);
            w[2] = size.width;
        }
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                     new Range(0.0, constraint.getWidth() - w[2]),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
            w[3] = size.width;
        }
        h[4] = h[2];
        w[4] = constraint.getWidth() - w[3] - w[2];
        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
        if (this.centerBlock != null) {
            this.centerBlock.arrange(g2, c5);
        }

        if (this.topBlock != null) {
            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],
                    h[0]));
        }
        if (this.bottomBlock != null) {
            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],
                    w[1], h[1]));
        }
        if (this.leftBlock != null) {
            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
                    h[2]));
        }
        if (this.rightBlock != null) {
            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],
                    w[3], h[3]));
        }
        if (this.centerBlock != null) {
            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],
                    h[4]));
        }
        return new Size2D(constraint.getWidth(), constraint.getHeight());
    }","protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                           RectangleConstraint constraint) {
    double[] w = new double[5];
    double[] h = new double[5];

    w[0] = constraint.getWidth();
    h[4] = constraint.getHeight();

    if (this.topBlock != null) {
        RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                LengthConstraintType.FIXED, 0.0, new Range(0.0, h[4]), 
                LengthConstraintType.RANGE);
        Size2D size = this.topBlock.arrange(g2, c1);
        h[0] = size.height;
        if (h[0] > h[4]) {
            throw new IllegalArgumentException(""Height constraint violated by topBlock."");
        }
        h[4] -= h[0];
    }

    w[1] = w[0];
    if (this.bottomBlock != null) {
        RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                LengthConstraintType.FIXED, 0.0, new Range(0.0, h[4]), 
                LengthConstraintType.RANGE);
        Size2D size = this.bottomBlock.arrange(g2, c2);
        h[1] = size.height;
        if (h[1] > h[4]) {
            throw new IllegalArgumentException(""Height constraint violated by bottomBlock."");
        }
        h[4] -= h[1];
    }

    if (h[4] < 0) {
        throw new IllegalArgumentException(""Negative height remaining after arranging blocks."");
    }

    w[4] = w[0];
    if (this.leftBlock != null) {
        RectangleConstraint c3 = new RectangleConstraint(0.0,
                new Range(0.0, w[4]), LengthConstraintType.RANGE, h[4], null, 
                LengthConstraintType.FIXED);
        Size2D size = this.leftBlock.arrange(g2, c3);
        w[2] = size.width;
        if (w[2] > w[4]) {
            throw new IllegalArgumentException(""Width constraint violated by leftBlock."");
        }
        w[4] -= w[2];
    }

    if (this.rightBlock != null) {
        RectangleConstraint c4 = new RectangleConstraint(0.0,
                new Range(0.0, w[4]), LengthConstraintType.RANGE, h[4], null, 
                LengthConstraintType.FIXED);
        Size2D size = this.rightBlock.arrange(g2, c4);
        w[3] = size.width;
        if (w[3] > w[4]) {
            throw new IllegalArgumentException(""Width constraint violated by rightBlock."");
        }
        w[4] -= w[3];
    }

    if (w[4] < 0) {
        throw new IllegalArgumentException(""Negative width remaining after arranging blocks."");
    }

    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
    if (this.centerBlock != null) {
        this.centerBlock.arrange(g2, c5);
    }

    if (this.topBlock != null) {
        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0]));
    }
    if (this.bottomBlock != null) {
        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[4], w[1], h[1]));
    }
    if (this.leftBlock != null) {
        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[4]));
    }
    if (this.rightBlock != null) {
        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[4]));
    }
    if (this.centerBlock != null) {
        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4]));
    }
    return new Size2D(constraint.getWidth(), constraint.getHeight());
}",1,0
4,Chart_13,"protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                               RectangleConstraint constraint) {
        double[] w = new double[5];
        double[] h = new double[5];
        w[0] = constraint.getWidth();
        if (this.topBlock != null) {
            RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0,
                    new Range(0.0, constraint.getHeight()),
                    LengthConstraintType.RANGE);
            Size2D size = this.topBlock.arrange(g2, c1);
            h[0] = size.height;
        }
        w[1] = w[0];
        if (this.bottomBlock != null) {
            RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0, new Range(0.0,
                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
            Size2D size = this.bottomBlock.arrange(g2, c2);
            h[1] = size.height;
        }
        h[2] = constraint.getHeight() - h[1] - h[0];
        if (this.leftBlock != null) {
            RectangleConstraint c3 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth()),
                    LengthConstraintType.RANGE, h[2], null,
                    LengthConstraintType.FIXED);
            Size2D size = this.leftBlock.arrange(g2, c3);
            w[2] = size.width;
        }
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                     new Range(0.0, constraint.getWidth() - w[2]),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
            w[3] = size.width;
        }
        h[4] = h[2];
        w[4] = constraint.getWidth() - w[3] - w[2];
        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
        if (this.centerBlock != null) {
            this.centerBlock.arrange(g2, c5);
        }

        if (this.topBlock != null) {
            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],
                    h[0]));
        }
        if (this.bottomBlock != null) {
            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],
                    w[1], h[1]));
        }
        if (this.leftBlock != null) {
            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
                    h[2]));
        }
        if (this.rightBlock != null) {
            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],
                    w[3], h[3]));
        }
        if (this.centerBlock != null) {
            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],
                    h[4]));
        }
        return new Size2D(constraint.getWidth(), constraint.getHeight());
    }","protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                           RectangleConstraint constraint) {
    double[] w = new double[5];
    double[] h = new double[5];
    w[0] = constraint.getWidth();
    h[4] = constraint.getHeight();

    if (this.topBlock != null) {
        RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                LengthConstraintType.FIXED, 0.0,
                new Range(0.0, h[4]), LengthConstraintType.RANGE);
        Size2D size = this.topBlock.arrange(g2, c1);
        h[0] = size.height;
        h[4] -= h[0];
        if (h[4] < 0) {
            throw new IllegalArgumentException(""Height constraint violated by topBlock."");
        }
    }

    w[1] = w[0];
    if (this.bottomBlock != null) {
        RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                LengthConstraintType.FIXED, 0.0,
                new Range(0.0, h[4]), LengthConstraintType.RANGE);
        Size2D size = this.bottomBlock.arrange(g2, c2);
        h[1] = size.height;
        h[4] -= h[1];
        if (h[4] < 0) {
            throw new IllegalArgumentException(""Height constraint violated by bottomBlock."");
        }
    }

    w[4] = w[0];
    if (this.leftBlock != null) {
        RectangleConstraint c3 = new RectangleConstraint(0.0,
                new Range(0.0, w[4]), LengthConstraintType.RANGE,
                h[4], null, LengthConstraintType.FIXED);
        Size2D size = this.leftBlock.arrange(g2, c3);
        w[2] = size.width;
        w[4] -= w[2];
        if (w[4] < 0) {
            throw new IllegalArgumentException(""Width constraint violated by leftBlock."");
        }
    }

    if (this.rightBlock != null) {
        RectangleConstraint c4 = new RectangleConstraint(0.0,
                new Range(0.0, w[4]), LengthConstraintType.RANGE,
                h[4], null, LengthConstraintType.FIXED);
        Size2D size = this.rightBlock.arrange(g2, c4);
        w[3] = size.width;
        w[4] -= w[3];
        if (w[4] < 0) {
            throw new IllegalArgumentException(""Width constraint violated by rightBlock."");
        }
    }

    if (w[4] < 0 || h[4] < 0) {
        throw new IllegalArgumentException(""Remaining width or height is invalid."");
    }

    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
    if (this.centerBlock != null) {
        this.centerBlock.arrange(g2, c5);
    }

    if (this.topBlock != null) {
        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0]));
    }
    if (this.bottomBlock != null) {
        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[4], w[1], h[1]));
    }
    if (this.leftBlock != null) {
        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[4]));
    }
    if (this.rightBlock != null) {
        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[4]));
    }
    if (this.centerBlock != null) {
        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4]));
    }

    return new Size2D(constraint.getWidth(), constraint.getHeight());
}",2,0
4,Chart_13,"protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                               RectangleConstraint constraint) {
        double[] w = new double[5];
        double[] h = new double[5];
        w[0] = constraint.getWidth();
        if (this.topBlock != null) {
            RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0,
                    new Range(0.0, constraint.getHeight()),
                    LengthConstraintType.RANGE);
            Size2D size = this.topBlock.arrange(g2, c1);
            h[0] = size.height;
        }
        w[1] = w[0];
        if (this.bottomBlock != null) {
            RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0, new Range(0.0,
                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
            Size2D size = this.bottomBlock.arrange(g2, c2);
            h[1] = size.height;
        }
        h[2] = constraint.getHeight() - h[1] - h[0];
        if (this.leftBlock != null) {
            RectangleConstraint c3 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth()),
                    LengthConstraintType.RANGE, h[2], null,
                    LengthConstraintType.FIXED);
            Size2D size = this.leftBlock.arrange(g2, c3);
            w[2] = size.width;
        }
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                     new Range(0.0, constraint.getWidth() - w[2]),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
            w[3] = size.width;
        }
        h[4] = h[2];
        w[4] = constraint.getWidth() - w[3] - w[2];
        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
        if (this.centerBlock != null) {
            this.centerBlock.arrange(g2, c5);
        }

        if (this.topBlock != null) {
            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],
                    h[0]));
        }
        if (this.bottomBlock != null) {
            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],
                    w[1], h[1]));
        }
        if (this.leftBlock != null) {
            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
                    h[2]));
        }
        if (this.rightBlock != null) {
            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],
                    w[3], h[3]));
        }
        if (this.centerBlock != null) {
            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],
                    h[4]));
        }
        return new Size2D(constraint.getWidth(), constraint.getHeight());
    }","protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                           RectangleConstraint constraint) {
    double remainingWidth = constraint.getWidth();
    double remainingHeight = constraint.getHeight();

    double topHeight = 0, bottomHeight = 0, leftWidth = 0, rightWidth = 0;

    if (this.topBlock != null) {
        RectangleConstraint topConstraint = new RectangleConstraint(remainingWidth, null,
                LengthConstraintType.FIXED, 0.0, new Range(0.0, remainingHeight), LengthConstraintType.RANGE);
        Size2D topSize = this.topBlock.arrange(g2, topConstraint);
        topHeight = topSize.height;
        remainingHeight -= topHeight;
    }

    if (this.bottomBlock != null) {
        RectangleConstraint bottomConstraint = new RectangleConstraint(remainingWidth, null,
                LengthConstraintType.FIXED, 0.0, new Range(0.0, remainingHeight), LengthConstraintType.RANGE);
        Size2D bottomSize = this.bottomBlock.arrange(g2, bottomConstraint);
        bottomHeight = bottomSize.height;
        remainingHeight -= bottomHeight;
    }

    if (remainingHeight < 0) {
        throw new IllegalArgumentException(""Remaining height is invalid after arranging top and bottom blocks."");
    }

    if (this.leftBlock != null) {
        RectangleConstraint leftConstraint = new RectangleConstraint(0.0,
                new Range(0.0, remainingWidth), LengthConstraintType.RANGE, remainingHeight, null,
                LengthConstraintType.FIXED);
        Size2D leftSize = this.leftBlock.arrange(g2, leftConstraint);
        leftWidth = leftSize.width;
        remainingWidth -= leftWidth;
    }

    if (this.rightBlock != null) {
        RectangleConstraint rightConstraint = new RectangleConstraint(0.0,
                new Range(0.0, remainingWidth), LengthConstraintType.RANGE, remainingHeight, null,
                LengthConstraintType.FIXED);
        Size2D rightSize = this.rightBlock.arrange(g2, rightConstraint);
        rightWidth = rightSize.width;
        remainingWidth -= rightWidth;
    }

    if (remainingWidth < 0) {
        throw new IllegalArgumentException(""Remaining width is invalid after arranging left and right blocks."");
    }

    RectangleConstraint centerConstraint = new RectangleConstraint(remainingWidth, remainingHeight);
    if (this.centerBlock != null) {
        this.centerBlock.arrange(g2, centerConstraint);
    }

    if (this.topBlock != null) {
        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, constraint.getWidth(), topHeight));
    }
    if (this.bottomBlock != null) {
        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, topHeight + remainingHeight,
                constraint.getWidth(), bottomHeight));
    }
    if (this.leftBlock != null) {
        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, topHeight, leftWidth, remainingHeight));
    }
    if (this.rightBlock != null) {
        this.rightBlock.setBounds(new Rectangle2D.Double(leftWidth + remainingWidth, topHeight,
                rightWidth, remainingHeight));
    }
    if (this.centerBlock != null) {
        this.centerBlock.setBounds(new Rectangle2D.Double(leftWidth, topHeight, remainingWidth, remainingHeight));
    }

    return new Size2D(constraint.getWidth(), constraint.getHeight());
}",3,0
4,Chart_13,"protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                               RectangleConstraint constraint) {
        double[] w = new double[5];
        double[] h = new double[5];
        w[0] = constraint.getWidth();
        if (this.topBlock != null) {
            RectangleConstraint c1 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0,
                    new Range(0.0, constraint.getHeight()),
                    LengthConstraintType.RANGE);
            Size2D size = this.topBlock.arrange(g2, c1);
            h[0] = size.height;
        }
        w[1] = w[0];
        if (this.bottomBlock != null) {
            RectangleConstraint c2 = new RectangleConstraint(w[0], null,
                    LengthConstraintType.FIXED, 0.0, new Range(0.0,
                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
            Size2D size = this.bottomBlock.arrange(g2, c2);
            h[1] = size.height;
        }
        h[2] = constraint.getHeight() - h[1] - h[0];
        if (this.leftBlock != null) {
            RectangleConstraint c3 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth()),
                    LengthConstraintType.RANGE, h[2], null,
                    LengthConstraintType.FIXED);
            Size2D size = this.leftBlock.arrange(g2, c3);
            w[2] = size.width;
        }
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                     new Range(0.0, constraint.getWidth() - w[2]),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
            w[3] = size.width;
        }
        h[4] = h[2];
        w[4] = constraint.getWidth() - w[3] - w[2];
        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
        if (this.centerBlock != null) {
            this.centerBlock.arrange(g2, c5);
        }

        if (this.topBlock != null) {
            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],
                    h[0]));
        }
        if (this.bottomBlock != null) {
            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],
                    w[1], h[1]));
        }
        if (this.leftBlock != null) {
            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
                    h[2]));
        }
        if (this.rightBlock != null) {
            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],
                    w[3], h[3]));
        }
        if (this.centerBlock != null) {
            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],
                    h[4]));
        }
        return new Size2D(constraint.getWidth(), constraint.getHeight());
    }","protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
                           RectangleConstraint constraint) {
    double totalWidth = constraint.getWidth();
    double totalHeight = constraint.getHeight();

    double topHeight = 0, bottomHeight = 0, leftWidth = 0, rightWidth = 0, centerWidth = totalWidth, centerHeight = totalHeight;

    // Top block arrangement
    if (this.topBlock != null) {
        RectangleConstraint topConstraint = new RectangleConstraint(totalWidth, null,
                LengthConstraintType.FIXED, 0.0, new Range(0.0, totalHeight), LengthConstraintType.RANGE);
        Size2D topSize = this.topBlock.arrange(g2, topConstraint);
        topHeight = topSize.getHeight();
        centerHeight -= topHeight;
        if (centerHeight < 0) {
            throw new IllegalArgumentException(""Height constraint violated after topBlock arrangement."");
        }
    }

    // Bottom block arrangement
    if (this.bottomBlock != null) {
        RectangleConstraint bottomConstraint = new RectangleConstraint(totalWidth, null,
                LengthConstraintType.FIXED, 0.0, new Range(0.0, centerHeight), LengthConstraintType.RANGE);
        Size2D bottomSize = this.bottomBlock.arrange(g2, bottomConstraint);
        bottomHeight = bottomSize.getHeight();
        centerHeight -= bottomHeight;
        if (centerHeight < 0) {
            throw new IllegalArgumentException(""Height constraint violated after bottomBlock arrangement."");
        }
    }

    // Left block arrangement
    if (this.leftBlock != null) {
        RectangleConstraint leftConstraint = new RectangleConstraint(0.0, new Range(0.0, centerWidth),
                LengthConstraintType.RANGE, centerHeight, null, LengthConstraintType.FIXED);
        Size2D leftSize = this.leftBlock.arrange(g2, leftConstraint);
        leftWidth = leftSize.getWidth();
        centerWidth -= leftWidth;
        if (centerWidth < 0) {
            throw new IllegalArgumentException(""Width constraint violated after leftBlock arrangement."");
        }
    }

    // Right block arrangement
    if (this.rightBlock != null) {
        RectangleConstraint rightConstraint = new RectangleConstraint(0.0, new Range(0.0, centerWidth),
                LengthConstraintType.RANGE, centerHeight, null, LengthConstraintType.FIXED);
        Size2D rightSize = this.rightBlock.arrange(g2, rightConstraint);
        rightWidth = rightSize.getWidth();
        centerWidth -= rightWidth;
        if (centerWidth < 0) {
            throw new IllegalArgumentException(""Width constraint violated after rightBlock arrangement."");
        }
    }

    // Center block arrangement
    RectangleConstraint centerConstraint = new RectangleConstraint(centerWidth, centerHeight);
    if (this.centerBlock != null) {
        this.centerBlock.arrange(g2, centerConstraint);
    }

    // Set bounds for all blocks
    if (this.topBlock != null) {
        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, totalWidth, topHeight));
    }
    if (this.bottomBlock != null) {
        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, topHeight + centerHeight, totalWidth, bottomHeight));
    }
    if (this.leftBlock != null) {
        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, topHeight, leftWidth, centerHeight));
    }
    if (this.rightBlock != null) {
        this.rightBlock.setBounds(new Rectangle2D.Double(leftWidth + centerWidth, topHeight, rightWidth, centerHeight));
    }
    if (this.centerBlock != null) {
        this.centerBlock.setBounds(new Rectangle2D.Double(leftWidth, topHeight, centerWidth, centerHeight));
    }

    return new Size2D(totalWidth, totalHeight);
}",4,0
5,Chart_17,"    public Object clone() throws CloneNotSupportedException {
        Object clone = createCopy(0, getItemCount() - 1);
        return clone;
    }
","public Object clone() throws CloneNotSupportedException {
    int itemCount = getItemCount();
    if (itemCount == 0) {
        return createCopy(0, 0); // Handle empty data case safely
    }
    return createCopy(0, itemCount - 1);
}",0,0
6,Chart_20,"    public ValueMarker(double value, Paint paint, Stroke stroke, 
                       Paint outlinePaint, Stroke outlineStroke, float alpha) {
        super(paint, stroke, paint, stroke, alpha);
        this.value = value;
    }
","public ValueMarker(double value, Paint paint, Stroke stroke, 
                   Paint outlinePaint, Stroke outlineStroke, float alpha) {
    super(paint, stroke, outlinePaint, outlineStroke, alpha);
    this.value = value;
}",0,0
7,Chart_24,"public Paint getPaint(double value) {
         double v = Math.max(value, this.lowerBound);
         v = Math.min(v, this.upperBound);
         int g = (int) ((value - this.lowerBound) / (this.upperBound 
                 - this.lowerBound) * 255.0);
         return new Color(g, g, g);
     }",Match failed,0,0
7,Chart_24,"public Paint getPaint(double value) {
         double v = Math.max(value, this.lowerBound);
         v = Math.min(v, this.upperBound);
         int g = (int) ((value - this.lowerBound) / (this.upperBound 
                 - this.lowerBound) * 255.0);
         return new Color(g, g, g);
     }","public Paint getPaint(double value) {
    double v = Math.max(value, this.lowerBound);
    v = Math.min(v, this.upperBound);
    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0);
    if (g < 0) {
        g = 0; // Ensure g is non-negative
    } else if (g > 255) {
        g = 255; // Ensure g is within the maximum value
    }
    return new Color(g, g, g);
}",1,0
8,Chart_26,"    protected AxisState drawLabel(String label, Graphics2D g2, 
            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, 
            AxisState state, PlotRenderingInfo plotState) {

        // it is unlikely that 'state' will be null, but check anyway...
        if (state == null) {
            throw new IllegalArgumentException(""Null 'state' argument."");
        }
        
        if ((label == null) || (label.equals(""""))) {
            return state;
        }

        Font font = getLabelFont();
        RectangleInsets insets = getLabelInsets();
        g2.setFont(font);
        g2.setPaint(getLabelPaint());
        FontMetrics fm = g2.getFontMetrics();
        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);
        Shape hotspot = null;
        
        if (edge == RectangleEdge.TOP) {
            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle(), labelBounds.getCenterX(), 
                    labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) dataArea.getCenterX();
            float labely = (float) (state.getCursor() - insets.getBottom() 
                    - h / 2.0);
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorUp(insets.getTop() + labelBounds.getHeight() 
                    + insets.getBottom());
        }
        else if (edge == RectangleEdge.BOTTOM) {
            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle(), labelBounds.getCenterX(), 
                    labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) dataArea.getCenterX();
            float labely = (float) (state.getCursor() + insets.getTop() 
                    + h / 2.0);
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorDown(insets.getTop() + labelBounds.getHeight() 
                    + insets.getBottom());
        }
        else if (edge == RectangleEdge.LEFT) {
            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), 
                    labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) (state.getCursor() - insets.getRight() 
                    - w / 2.0);
            float labely = (float) dataArea.getCenterY();
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, 
                    TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() 
                    + insets.getRight());
        }
        else if (edge == RectangleEdge.RIGHT) {

            AffineTransform t = AffineTransform.getRotateInstance(
                    getLabelAngle() + Math.PI / 2.0, 
                    labelBounds.getCenterX(), labelBounds.getCenterY());
            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
            labelBounds = rotatedLabelBounds.getBounds2D();
            float w = (float) labelBounds.getWidth();
            float h = (float) labelBounds.getHeight();
            float labelx = (float) (state.getCursor() 
                            + insets.getLeft() + w / 2.0);
            float labely = (float) (dataArea.getY() + dataArea.getHeight() 
                    / 2.0);
            TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, 
                    TextAnchor.CENTER);
            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                    labely - h / 2.0f, w, h);
            state.cursorRight(insets.getLeft() + labelBounds.getWidth() 
                    + insets.getRight());

        }
        if (plotState != null && hotspot != null) {
            ChartRenderingInfo owner = plotState.getOwner();
                EntityCollection entities = owner.getEntityCollection();
                if (entities != null) {
                    entities.add(new AxisLabelEntity(this, hotspot, 
                            this.labelToolTip, this.labelURL));
                }
        }
        return state;

    }
","protected AxisState drawLabel(String label, Graphics2D g2, 
        Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, 
        AxisState state, PlotRenderingInfo plotState) {

    // it is unlikely that 'state' will be null, but check anyway...
    if (state == null) {
        throw new IllegalArgumentException(""Null 'state' argument."");
    }
    
    if ((label == null) || label.isEmpty()) {
        return state;
    }

    Font font = getLabelFont();
    RectangleInsets insets = getLabelInsets();
    g2.setFont(font);
    g2.setPaint(getLabelPaint());
    FontMetrics fm = g2.getFontMetrics();
    Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);

    if (labelBounds == null) {
        return state; // Ensure robustness against unexpected null bounds.
    }

    Shape hotspot = null;

    if (edge == RectangleEdge.TOP) {
        AffineTransform t = AffineTransform.getRotateInstance(
                getLabelAngle(), labelBounds.getCenterX(), 
                labelBounds.getCenterY());
        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
        labelBounds = rotatedLabelBounds.getBounds2D();
        float w = (float) labelBounds.getWidth();
        float h = (float) labelBounds.getHeight();
        float labelx = (float) dataArea.getCenterX();
        float labely = (float) (state.getCursor() - insets.getBottom() - h / 2.0);
        TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                labely - h / 2.0f, w, h);
        state.cursorUp(insets.getTop() + labelBounds.getHeight() 
                + insets.getBottom());
    } else if (edge == RectangleEdge.BOTTOM) {
        AffineTransform t = AffineTransform.getRotateInstance(
                getLabelAngle(), labelBounds.getCenterX(), 
                labelBounds.getCenterY());
        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
        labelBounds = rotatedLabelBounds.getBounds2D();
        float w = (float) labelBounds.getWidth();
        float h = (float) labelBounds.getHeight();
        float labelx = (float) dataArea.getCenterX();
        float labely = (float) (state.getCursor() + insets.getTop() + h / 2.0);
        TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);
        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                labely - h / 2.0f, w, h);
        state.cursorDown(insets.getTop() + labelBounds.getHeight() 
                + insets.getBottom());
    } else if (edge == RectangleEdge.LEFT) {
        AffineTransform t = AffineTransform.getRotateInstance(
                getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), 
                labelBounds.getCenterY());
        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
        labelBounds = rotatedLabelBounds.getBounds2D();
        float w = (float) labelBounds.getWidth();
        float h = (float) labelBounds.getHeight();
        float labelx = (float) (state.getCursor() - insets.getRight() - w / 2.0);
        float labely = (float) dataArea.getCenterY();
        TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, 
                TextAnchor.CENTER);
        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                labely - h / 2.0f, w, h);
        state.cursorLeft(insets.getLeft() + labelBounds.getWidth() 
                + insets.getRight());
    } else if (edge == RectangleEdge.RIGHT) {
        AffineTransform t = AffineTransform.getRotateInstance(
                getLabelAngle() + Math.PI / 2.0, 
                labelBounds.getCenterX(), labelBounds.getCenterY());
        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);
        labelBounds = rotatedLabelBounds.getBounds2D();
        float w = (float) labelBounds.getWidth();
        float h = (float) labelBounds.getHeight();
        float labelx = (float) (state.getCursor() + insets.getLeft() + w / 2.0);
        float labely = (float) (dataArea.getY() + dataArea.getHeight() / 2.0);
        TextUtilities.drawRotatedString(label, g2, labelx, labely, 
                TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, 
                TextAnchor.CENTER);
        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, 
                labely - h / 2.0f, w, h);
        state.cursorRight(insets.getLeft() + labelBounds.getWidth() 
                + insets.getRight());
    }

    if (plotState != null && hotspot != null) {
        ChartRenderingInfo owner = plotState.getOwner();
        if (owner != null) { // Ensure owner isn't null
            EntityCollection entities = owner.getEntityCollection();
            if (entities != null) {
                entities.add(new AxisLabelEntity(this, hotspot, 
                        this.labelToolTip, this.labelURL));
            }
        }
    }
    return state;
}",0,0
9,Chart_3,"public TimeSeries createCopy(int start, int end)
            throws CloneNotSupportedException {
        if (start < 0) {
            throw new IllegalArgumentException(""Requires start >= 0."");
        }
        if (end < start) {
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
                TimeSeriesDataItem item
                        = (TimeSeriesDataItem) this.data.get(index);
                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
                try {
                    copy.add(clone);
                }
                catch (SeriesException e) {
                    e.printStackTrace();
                }
            }
        }
        return copy;
    }","public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {
    if (start < 0) {
        throw new IllegalArgumentException(""Requires start >= 0."");
    }
    if (end < start || end >= this.data.size()) {
        throw new IllegalArgumentException(""Requires start <= end and end < data.size()."");
    }
    TimeSeries copy = (TimeSeries) super.clone();
    copy.data = new java.util.ArrayList<>();
    for (int index = start; index <= end; index++) {
        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);
        TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
        try {
            copy.add(clone);
        } catch (SeriesException e) {
            throw new RuntimeException(""Error adding cloned item to series copy"", e);
        }
    }
    return copy;
}",0,0
9,Chart_3,"public TimeSeries createCopy(int start, int end)
            throws CloneNotSupportedException {
        if (start < 0) {
            throw new IllegalArgumentException(""Requires start >= 0."");
        }
        if (end < start) {
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
                TimeSeriesDataItem item
                        = (TimeSeriesDataItem) this.data.get(index);
                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
                try {
                    copy.add(clone);
                }
                catch (SeriesException e) {
                    e.printStackTrace();
                }
            }
        }
        return copy;
    }","public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {
    if (start < 0) {
        throw new IllegalArgumentException(""Requires start >= 0."");
    }
    if (end < start || end >= this.data.size()) {
        throw new IllegalArgumentException(""Requires start <= end and end < data.size()."");
    }
    TimeSeries copy = (TimeSeries) super.clone();
    copy.data = new java.util.ArrayList<>();
    int index = start;
    while (index <= end) {
        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);
        TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
        copy.add(clone, false); // Bypass event propagation for clones
        index++;
    }
    return copy;
}",1,0
9,Chart_3,"public TimeSeries createCopy(int start, int end)
            throws CloneNotSupportedException {
        if (start < 0) {
            throw new IllegalArgumentException(""Requires start >= 0."");
        }
        if (end < start) {
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
                TimeSeriesDataItem item
                        = (TimeSeriesDataItem) this.data.get(index);
                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
                try {
                    copy.add(clone);
                }
                catch (SeriesException e) {
                    e.printStackTrace();
                }
            }
        }
        return copy;
    }","public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {
    if (start < 0) {
        throw new IllegalArgumentException(""Requires start >= 0."");
    }
    if (end < start || end >= this.data.size()) {
        throw new IllegalArgumentException(""Requires start <= end and end < data.size()."");
    }
    TimeSeries copy = (TimeSeries) super.clone();
    copy.data = new java.util.ArrayList<>();
    if (this.data.size() > 0) {
        for (int index = start; index <= end; index++) {
            TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);
            TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
            addClonedItem(copy, clone); // Perform addition using a helper method
        }
    }
    return copy;
}

private void addClonedItem(TimeSeries seriesCopy, TimeSeriesDataItem clonedItem) {
    try {
        seriesCopy.add(clonedItem, false); // Bypass event propagation
    } catch (SeriesException e) {
        throw new RuntimeException(""Error adding cloned item to series copy"", e);
    }
}",2,0
9,Chart_3,"public TimeSeries createCopy(int start, int end)
            throws CloneNotSupportedException {
        if (start < 0) {
            throw new IllegalArgumentException(""Requires start >= 0."");
        }
        if (end < start) {
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
                TimeSeriesDataItem item
                        = (TimeSeriesDataItem) this.data.get(index);
                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
                try {
                    copy.add(clone);
                }
                catch (SeriesException e) {
                    e.printStackTrace();
                }
            }
        }
        return copy;
    }","public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {
    if (start < 0) {
        throw new IllegalArgumentException(""Requires start >= 0."");
    }
    if (end < start || end >= this.data.size()) {
        throw new IllegalArgumentException(""Requires start <= end and end < data.size()."");
    }
    TimeSeries copy = (TimeSeries) super.clone();
    copy.data = new java.util.ArrayList<>();
    
    // Ensure accurate deep copying by recalculating the value for cloned items
    for (int index = start; index <= end; index++) {
        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);
        TimeSeriesDataItem clone = new TimeSeriesDataItem(item.getPeriod(), item.getValue());
        try {
            copy.add(clone);
        } catch (SeriesException e) {
            throw new RuntimeException(""Error adding cloned item to series copy"", e);
        }
    }
    return copy;
}",3,0
9,Chart_3,"public TimeSeries createCopy(int start, int end)
            throws CloneNotSupportedException {
        if (start < 0) {
            throw new IllegalArgumentException(""Requires start >= 0."");
        }
        if (end < start) {
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
                TimeSeriesDataItem item
                        = (TimeSeriesDataItem) this.data.get(index);
                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
                try {
                    copy.add(clone);
                }
                catch (SeriesException e) {
                    e.printStackTrace();
                }
            }
        }
        return copy;
    }","public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {
    if (start < 0) {
        throw new IllegalArgumentException(""Requires start >= 0."");
    }
    if (end < start || end >= this.data.size()) {
        throw new IllegalArgumentException(""Requires start <= end and end < data.size()."");
    }
    TimeSeries copy = (TimeSeries) super.clone();
    copy.data = new java.util.ArrayList<>();
    for (int index = start; index <= end; index++) {
        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);
        TimeSeriesDataItem clone = new TimeSeriesDataItem(item.getPeriod(), item.getValue().doubleValue()); // Explicitly recreating data
        try {
            copy.add(clone, false); // Ensure no propagation of events during the copy
        } catch (SeriesException e) {
            throw new RuntimeException(""Error adding cloned item to series copy"", e);
        }
    }
    return copy;
}",4,0
10,Chart_4,"    public Range getDataRange(ValueAxis axis) {

        Range result = null;
        List mappedDatasets = new ArrayList();
        List includedAnnotations = new ArrayList();
        boolean isDomainAxis = true;

        // is it a domain axis?
        int domainIndex = getDomainAxisIndex(axis);
        if (domainIndex >= 0) {
            isDomainAxis = true;
            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(
                    new Integer(domainIndex)));
            if (domainIndex == 0) {
                // grab the plot's annotations
                Iterator iterator = this.annotations.iterator();
                while (iterator.hasNext()) {
                    XYAnnotation annotation = (XYAnnotation) iterator.next();
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }

        // or is it a range axis?
        int rangeIndex = getRangeAxisIndex(axis);
        if (rangeIndex >= 0) {
            isDomainAxis = false;
            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(
                    new Integer(rangeIndex)));
            if (rangeIndex == 0) {
                Iterator iterator = this.annotations.iterator();
                while (iterator.hasNext()) {
                    XYAnnotation annotation = (XYAnnotation) iterator.next();
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }

        // iterate through the datasets that map to the axis and get the union
        // of the ranges.
        Iterator iterator = mappedDatasets.iterator();
        while (iterator.hasNext()) {
            XYDataset d = (XYDataset) iterator.next();
            if (d != null) {
                XYItemRenderer r = getRendererForDataset(d);
                if (isDomainAxis) {
                    if (r != null) {
                        result = Range.combine(result, r.findDomainBounds(d));
                    }
                    else {
                        result = Range.combine(result,
                                DatasetUtilities.findDomainBounds(d));
                    }
                }
                else {
                    if (r != null) {
                        result = Range.combine(result, r.findRangeBounds(d));
                    }
                    else {
                        result = Range.combine(result,
                                DatasetUtilities.findRangeBounds(d));
                    }
                }
                
                    Collection c = r.getAnnotations();
                    Iterator i = c.iterator();
                    while (i.hasNext()) {
                        XYAnnotation a = (XYAnnotation) i.next();
                        if (a instanceof XYAnnotationBoundsInfo) {
                            includedAnnotations.add(a);
                        }
                    }
            }
        }

        Iterator it = includedAnnotations.iterator();
        while (it.hasNext()) {
            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();
            if (xyabi.getIncludeInDataBounds()) {
                if (isDomainAxis) {
                    result = Range.combine(result, xyabi.getXRange());
                }
                else {
                    result = Range.combine(result, xyabi.getYRange());
                }
            }
        }

        return result;

    }","public Range getDataRange(ValueAxis axis) {
    Range result = null;
    List mappedDatasets = new ArrayList();
    List includedAnnotations = new ArrayList();
    boolean isDomainAxis = true;

    // Ensure axis is not null to avoid NullPointerException
    if (axis == null) {
        throw new IllegalArgumentException(""Null 'axis' argument."");
    }

    // Determine if it is a domain axis
    int domainIndex = getDomainAxisIndex(axis);
    if (domainIndex >= 0) {
        isDomainAxis = true;
        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(new Integer(domainIndex)));
        if (domainIndex == 0) {
            // Include the plot's annotations
            if (this.annotations != null) {
                Iterator iterator = this.annotations.iterator();
                while (iterator.hasNext()) {
                    XYAnnotation annotation = (XYAnnotation) iterator.next();
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }
    }

    // Or determine if it is a range axis
    int rangeIndex = getRangeAxisIndex(axis);
    if (rangeIndex >= 0) {
        isDomainAxis = false;
        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(new Integer(rangeIndex)));
        if (rangeIndex == 0) {
            if (this.annotations != null) {
                Iterator iterator = this.annotations.iterator();
                while (iterator.hasNext()) {
                    XYAnnotation annotation = (XYAnnotation) iterator.next();
                    if (annotation instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(annotation);
                    }
                }
            }
        }
    }

    // Iterate through the datasets that map to the axis and get the union of the ranges
    Iterator iterator = mappedDatasets.iterator();
    while (iterator.hasNext()) {
        XYDataset d = (XYDataset) iterator.next();
        if (d != null) {
            XYItemRenderer r = getRendererForDataset(d);
            if (isDomainAxis) {
                if (r != null) {
                    result = Range.combine(result, r.findDomainBounds(d));
                } else {
                    result = Range.combine(result, DatasetUtilities.findDomainBounds(d));
                }
            } else {
                if (r != null) {
                    result = Range.combine(result, r.findRangeBounds(d));
                } else {
                    result = Range.combine(result, DatasetUtilities.findRangeBounds(d));
                }
            }
            
            if (r != null) { // Ensure renderer is not null before accessing annotations
                Collection c = r.getAnnotations();
                Iterator i = c.iterator();
                while (i.hasNext()) {
                    XYAnnotation a = (XYAnnotation) i.next();
                    if (a instanceof XYAnnotationBoundsInfo) {
                        includedAnnotations.add(a);
                    }
                }
            }
        }
    }

    // Include annotations in the data bounds
    Iterator it = includedAnnotations.iterator();
    while (it.hasNext()) {
        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();
        if (xyabi.getIncludeInDataBounds()) {
            if (isDomainAxis) {
                result = Range.combine(result, xyabi.getXRange());
            } else {
                result = Range.combine(result, xyabi.getYRange());
            }
        }
    }

    return result;
}",0,0
11,Chart_5,"public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
         if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
            }
            catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
        else {
            // if the series is sorted, the negative index is a result from
            // Collections.binarySearch() and tells us where to insert the
            // new item...otherwise it will be just -1 and we should just
            // append the value to the list...
            if (this.autoSort) {
                this.data.add(-index - 1, new XYDataItem(x, y));
            }
            else {
                this.data.add(new XYDataItem(x, y));
            }
            // check if this addition will exceed the maximum item count...
            if (getItemCount() > this.maximumItemCount) {
                this.data.remove(0);
            }
        }
        fireSeriesChanged();
        return overwritten;
    }","public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }

    XYDataItem overwritten = null;
    int index = indexOf(x);

    if (index >= 0 && !this.allowDuplicateXValues) {
        XYDataItem existing = (XYDataItem) this.data.get(index);
        try {
            overwritten = (XYDataItem) existing.clone();
        } catch (CloneNotSupportedException e) {
            throw new SeriesException(""Couldn't clone XYDataItem!"");
        }
        existing.setY(y);
    } else {
        XYDataItem newItem = new XYDataItem(x, y);
        if (index < 0) {
            index = -index - 1;
        }
        
        if (this.autoSort) {
            this.data.add(index, newItem);
        } else {
            this.data.add(newItem);
        }

        if (getItemCount() > this.maximumItemCount) {
            this.data.remove(0);
        }
    }
    fireSeriesChanged();
    return overwritten;
}",0,0
11,Chart_5,"public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
         if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
            }
            catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
        else {
            // if the series is sorted, the negative index is a result from
            // Collections.binarySearch() and tells us where to insert the
            // new item...otherwise it will be just -1 and we should just
            // append the value to the list...
            if (this.autoSort) {
                this.data.add(-index - 1, new XYDataItem(x, y));
            }
            else {
                this.data.add(new XYDataItem(x, y));
            }
            // check if this addition will exceed the maximum item count...
            if (getItemCount() > this.maximumItemCount) {
                this.data.remove(0);
            }
        }
        fireSeriesChanged();
        return overwritten;
    }","public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }

    XYDataItem overwritten = null;
    int index = indexOf(x);

    if (index >= 0) {
        if (!this.allowDuplicateXValues) {
            XYDataItem existing = (XYDataItem) this.data.get(index);
            try {
                overwritten = (XYDataItem) existing.clone();
            } catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        } else {
            this.data.add(index + 1, new XYDataItem(x, y));
        }
    } else {
        XYDataItem newItem = new XYDataItem(x, y);
        if (this.autoSort) {
            index = -(index + 1);
            this.data.add(index, newItem);
        } else {
            this.data.add(newItem);
        }

        if (getItemCount() > this.maximumItemCount) {
            this.data.remove(0);
        }
    }
    fireSeriesChanged();
    return overwritten;
}",1,0
11,Chart_5,"public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
         if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
            }
            catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
        else {
            // if the series is sorted, the negative index is a result from
            // Collections.binarySearch() and tells us where to insert the
            // new item...otherwise it will be just -1 and we should just
            // append the value to the list...
            if (this.autoSort) {
                this.data.add(-index - 1, new XYDataItem(x, y));
            }
            else {
                this.data.add(new XYDataItem(x, y));
            }
            // check if this addition will exceed the maximum item count...
            if (getItemCount() > this.maximumItemCount) {
                this.data.remove(0);
            }
        }
        fireSeriesChanged();
        return overwritten;
    }","public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }

    XYDataItem overwritten = null;
    int index = indexOf(x);

    if (index >= 0) {
        // Update existing value
        XYDataItem existing = (XYDataItem) this.data.get(index);
        try {
            overwritten = (XYDataItem) existing.clone();
        } catch (CloneNotSupportedException e) {
            throw new SeriesException(""Couldn't clone XYDataItem!"");
        }
        existing.setY(y);
    } else {
        // Ensure positive index for insertion
        int insertIndex = this.autoSort ? -(index + 1) : this.data.size();

        // Prevent IndexOutOfBoundsException by validating insertIndex
        if (insertIndex < 0 || insertIndex > this.data.size()) {
            insertIndex = this.data.size();
        }

        // Add new value
        this.data.add(insertIndex, new XYDataItem(x, y));

        // Check maximum item count
        if (getItemCount() > this.maximumItemCount) {
            this.data.remove(0);
        }
    }

    fireSeriesChanged();
    return overwritten;
}",2,0
11,Chart_5,"public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
         if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
            }
            catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
        else {
            // if the series is sorted, the negative index is a result from
            // Collections.binarySearch() and tells us where to insert the
            // new item...otherwise it will be just -1 and we should just
            // append the value to the list...
            if (this.autoSort) {
                this.data.add(-index - 1, new XYDataItem(x, y));
            }
            else {
                this.data.add(new XYDataItem(x, y));
            }
            // check if this addition will exceed the maximum item count...
            if (getItemCount() > this.maximumItemCount) {
                this.data.remove(0);
            }
        }
        fireSeriesChanged();
        return overwritten;
    }","public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }

    XYDataItem overwritten = null;
    int index = indexOf(x);

    if (index >= 0 && !this.allowDuplicateXValues) {
        XYDataItem existing = (XYDataItem) this.data.get(index);
        try {
            overwritten = (XYDataItem) existing.clone();
        } catch (CloneNotSupportedException e) {
            throw new SeriesException(""Couldn't clone XYDataItem!"");
        }
        existing.setY(y);
    } else {
        int insertIndex = index >= 0 ? index + 1 : this.autoSort ? -index - 1 : this.data.size();

        if (insertIndex < 0) {
            insertIndex = 0; // Prevent negative index issues
        } else if (insertIndex > this.data.size()) {
            insertIndex = this.data.size(); // Prevent out-of-bounds index issues
        }

        this.data.add(insertIndex, new XYDataItem(x, y));

        if (getItemCount() > this.maximumItemCount) {
            this.data.remove(0);
        }
    }

    fireSeriesChanged();
    return overwritten;
}",3,0
11,Chart_5,"public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
         if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
            }
            catch (CloneNotSupportedException e) {
                throw new SeriesException(""Couldn't clone XYDataItem!"");
            }
            existing.setY(y);
        }
        else {
            // if the series is sorted, the negative index is a result from
            // Collections.binarySearch() and tells us where to insert the
            // new item...otherwise it will be just -1 and we should just
            // append the value to the list...
            if (this.autoSort) {
                this.data.add(-index - 1, new XYDataItem(x, y));
            }
            else {
                this.data.add(new XYDataItem(x, y));
            }
            // check if this addition will exceed the maximum item count...
            if (getItemCount() > this.maximumItemCount) {
                this.data.remove(0);
            }
        }
        fireSeriesChanged();
        return overwritten;
    }","public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }

    XYDataItem overwritten = null;
    int index = indexOf(x);

    if (index >= 0 && !this.allowDuplicateXValues) {
        XYDataItem existing = this.data.get(index);
        try {
            overwritten = existing.clone();
        } catch (CloneNotSupportedException e) {
            throw new SeriesException(""Couldn't clone XYDataItem!"");
        }
        existing.setY(y);
    } else {
        // Calculate insertion point and handle index bounds explicitly
        int insertIndex = index >= 0 ? index + 1 : (this.autoSort ? (-index - 1) : this.data.size());
        insertIndex = Math.max(0, Math.min(insertIndex, this.data.size())); // Ensure valid index
        
        XYDataItem newItem = new XYDataItem(x, y);
        this.data.add(insertIndex, newItem);

        // Enforce maximum item count
        if (getItemCount() > this.maximumItemCount) {
            this.data.remove(0);
        }
    }

    fireSeriesChanged();
    return overwritten;
}",4,0
12,Chart_6,"public boolean equals(Object obj) {

        if (obj == this) {
            return true;
        }
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }","public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj == null || !(obj instanceof ShapeList)) {
        return false;
    }
    ShapeList other = (ShapeList) obj;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0; i < size(); i++) {
        if (!ObjectUtilities.equal(get(i), other.get(i))) {
            return false;
        }
    }
    return true;
}",0,0
12,Chart_6,"public boolean equals(Object obj) {

        if (obj == this) {
            return true;
        }
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }","public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj == null || !(obj instanceof ShapeList)) {
        return false;
    }
    ShapeList other = (ShapeList) obj;
    int size = size();
    int otherSize = other.size();
    if (size != otherSize) {
        return false;
    }
    for (int i = 0; i < size; i++) {
        if (!ObjectUtilities.equal(get(i), other.get(i))) {
            return false;
        }
    }
    return true;
}",1,0
12,Chart_6,"public boolean equals(Object obj) {

        if (obj == this) {
            return true;
        }
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }","public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj == null || !(obj instanceof ShapeList)) {
        return false;
    }
    ShapeList other = (ShapeList) obj;
    return Objects.equals(this.size(), other.size()) && super.equals(obj);
}",2,0
12,Chart_6,"public boolean equals(Object obj) {

        if (obj == this) {
            return true;
        }
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }","public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj == null || !(obj instanceof ShapeList)) {
        return false;
    }
    ShapeList other = (ShapeList) obj;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0; i < size(); i++) {
        if (!ObjectUtilities.equal(get(i), other.get(i))) {
            return false;
        }
    }
    return true;
}",3,0
12,Chart_6,"public boolean equals(Object obj) {

        if (obj == this) {
            return true;
        }
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }","public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj == null || !(obj instanceof ShapeList)) {
        return false;
    }
    ShapeList other = (ShapeList) obj;

    // Check if size matches before proceeding
    if (this.size() != other.size()) {
        return false;
    }

    // Compare elements individually for equality
    for (int i = 0; i < this.size(); i++) {
        if (!ObjectUtilities.equal(this.get(i), other.get(i))) {
            return false;
        }
    }

    return true;
}",4,0
13,Chart_7,"private void updateBounds(TimePeriod period, int index) {
        
        long start = period.getStart().getTime();
        long end = period.getEnd().getTime();
        long middle = start + ((end - start) / 2);

        if (this.minStartIndex >= 0) {
            long minStart = getDataItem(this.minStartIndex).getPeriod()
                .getStart().getTime();
            if (start < minStart) {
                this.minStartIndex = index;           
            }
        }
        else {
            this.minStartIndex = index;
        }
        
        if (this.maxStartIndex >= 0) {
            long maxStart = getDataItem(this.maxStartIndex).getPeriod()
                .getStart().getTime();
            if (start > maxStart) {
                this.maxStartIndex = index;           
            }
        }
        else {
            this.maxStartIndex = index;
        }
        
        if (this.minMiddleIndex >= 0) {
            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                .getTime();
            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                .getTime();
            long minMiddle = s + (e - s) / 2;
            if (middle < minMiddle) {
                this.minMiddleIndex = index;           
            }
        }
        else {
            this.minMiddleIndex = index;
        }
        
        if (this.maxMiddleIndex >= 0) {
            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                .getTime();
            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                .getTime();
            long maxMiddle = s + (e - s) / 2;
            if (middle > maxMiddle) {
                this.maxMiddleIndex = index;           
            }
        }
        else {
            this.maxMiddleIndex = index;
        }
        
        if (this.minEndIndex >= 0) {
            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()
                .getTime();
            if (end < minEnd) {
                this.minEndIndex = index;           
            }
        }
        else {
            this.minEndIndex = index;
        }
       
        if (this.maxEndIndex >= 0) {
            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()
                .getTime();
            if (end > maxEnd) {
                this.maxEndIndex = index;           
            }
        }
        else {
            this.maxEndIndex = index;
        }
        
    }","private void updateBounds(TimePeriod period, int index) {
    long start = period.getStart().getTime();
    long end = period.getEnd().getTime();
    long middle = start + ((end - start) / 2);

    // Update min start index
    if (this.minStartIndex >= 0) {
        long minStart = getDataItem(this.minStartIndex).getPeriod().getStart().getTime();
        if (start < minStart) {
            this.minStartIndex = index;
        }
    } else {
        this.minStartIndex = index;
    }

    // Update max start index
    if (this.maxStartIndex >= 0) {
        long maxStart = getDataItem(this.maxStartIndex).getPeriod().getStart().getTime();
        if (start > maxStart) {
            this.maxStartIndex = index;
        }
    } else {
        this.maxStartIndex = index;
    }

    // Update min middle index
    if (this.minMiddleIndex >= 0) {
        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime();
        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime();
        long minMiddle = s + ((e - s) / 2);
        if (middle < minMiddle) {
            this.minMiddleIndex = index;
        }
    } else {
        this.minMiddleIndex = index;
    }

    // Update max middle index
    if (this.maxMiddleIndex >= 0) {
        long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime();
        long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd().getTime();
        long maxMiddle = s + ((e - s) / 2);
        if (middle > maxMiddle) {
            this.maxMiddleIndex = index;
        }
    } else {
        this.maxMiddleIndex = index;
    }

    // Update min end index
    if (this.minEndIndex >= 0) {
        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd().getTime();
        if (end < minEnd) {
            this.minEndIndex = index;
        }
    } else {
        this.minEndIndex = index;
    }

    // Update max end index
    if (this.maxEndIndex >= 0) {
        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd().getTime();
        if (end > maxEnd) {
            this.maxEndIndex = index;
        }
    } else {
        this.maxEndIndex = index;
    }
}",0,0
14,Chart_8,"    public Week(Date time, TimeZone zone) {
        // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
    }
","public Week(Date time, TimeZone zone) {
    if (time == null) {
        throw new IllegalArgumentException(""Null 'time' argument."");
    }
    if (zone == null) {
        throw new IllegalArgumentException(""Null 'zone' argument."");
    }
    // Use proper timezone and locale handling
    Calendar calendar = Calendar.getInstance(zone, Locale.getDefault());
    calendar.setTime(time);
    int tempWeek = calendar.get(Calendar.WEEK_OF_YEAR);
    int yyyy = calendar.get(Calendar.YEAR);

    this.week = tempWeek;
    this.year = yyyy;
    peg(calendar);
}",0,0
14,Chart_8,"    public Week(Date time, TimeZone zone) {
        // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
    }
","public Week(Date time, TimeZone zone) {
    if (time == null || zone == null) {
        throw new IllegalArgumentException(""Null argument(s) provided."");
    }

    Calendar calendar = Calendar.getInstance(zone, Locale.getDefault());
    calendar.setTime(time);
    
    this.year = calendar.get(Calendar.YEAR);

    // Use ISO standard rule to determine week numbers
    calendar.setMinimalDaysInFirstWeek(4);
    calendar.setFirstDayOfWeek(Calendar.MONDAY);

    this.week = calendar.get(Calendar.WEEK_OF_YEAR);
    peg(calendar);
}",1,0
14,Chart_8,"    public Week(Date time, TimeZone zone) {
        // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
    }
","public Week(Date time, TimeZone zone) {
    if (time == null) {
        throw new IllegalArgumentException(""Null 'time' argument."");
    }
    if (zone == null) {
        throw new IllegalArgumentException(""Null 'zone' argument."");
    }

    Calendar calendar = Calendar.getInstance(zone, Locale.getDefault());
    calendar.setTime(time);

    // Adjust to the standard ISO week definition
    calendar.setMinimalDaysInFirstWeek(4);
    calendar.setFirstDayOfWeek(Calendar.MONDAY);

    int tempWeek = calendar.get(Calendar.WEEK_OF_YEAR);
    int yyyy = calendar.get(Calendar.YEAR);

    // Check if week belongs to the previous year
    if (tempWeek == 1 && calendar.get(Calendar.MONTH) == Calendar.DECEMBER) {
        yyyy++;
    }

    // Check if week belongs to the next year
    if (tempWeek >= 52 && calendar.get(Calendar.MONTH) == Calendar.JANUARY) {
        yyyy--;
    }

    this.week = tempWeek;
    this.year = yyyy;
    peg(calendar);
}",2,0
14,Chart_8,"    public Week(Date time, TimeZone zone) {
        // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
    }
","public Week(Date time, TimeZone zone) {
    if (time == null || zone == null) {
        throw new IllegalArgumentException(""Null argument(s) provided."");
    }

    Calendar calendar = Calendar.getInstance(zone, Locale.getDefault());
    calendar.setTime(time);

    // Adjust to ISO standard for week determination
    calendar.setMinimalDaysInFirstWeek(4);
    calendar.setFirstDayOfWeek(Calendar.MONDAY);

    this.week = calendar.get(Calendar.WEEK_OF_YEAR);
    this.year = calendar.get(Calendar.YEAR);
    
    // Handle special case when the week is the first of the year but includes previous year's days
    if (week == 1 && calendar.get(Calendar.MONTH) == Calendar.DECEMBER) {
        year++;
    }

    // Adjust for cases in which week number falls into the last week's threshold but in next year
    if (week >= 52 && calendar.get(Calendar.MONTH) == Calendar.JANUARY) {
        year--;
    }
    peg(calendar);
}",3,0
14,Chart_8,"    public Week(Date time, TimeZone zone) {
        // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
    }
","public Week(Date time, TimeZone zone) {
    if (time == null) {
        throw new IllegalArgumentException(""Null 'time' argument."");
    }
    if (zone == null) {
        throw new IllegalArgumentException(""Null 'zone' argument."");
    }

    Calendar calendar = Calendar.getInstance(zone, Locale.getDefault());
    calendar.setTime(time);

    // Enforce ISO-8601 week rules
    calendar.setMinimalDaysInFirstWeek(4);
    calendar.setFirstDayOfWeek(Calendar.MONDAY);

    int tempWeek = calendar.get(Calendar.WEEK_OF_YEAR);
    int yyyy = calendar.get(Calendar.YEAR);

    // Handle boundary weeks spanning between years
    int month = calendar.get(Calendar.MONTH);
    if (tempWeek == 1 && month == Calendar.DECEMBER) {
        yyyy++;
    } else if (tempWeek >= 52 && month == Calendar.JANUARY) {
        yyyy--;
    }

    this.week = tempWeek;
    this.year = yyyy;

    // Ensure first and last milliseconds are calculated based on the calendar
    peg(calendar);
}",4,0
15,Chart_9,"public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

        if (start == null) {
            throw new IllegalArgumentException(""Null 'start' argument."");
        }
        if (end == null) {
            throw new IllegalArgumentException(""Null 'end' argument."");
        }
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(
                    ""Requires start on or before end."");
        }
        boolean emptyRange = false;
        int startIndex = getIndex(start);
        if (startIndex < 0) {
            startIndex = -(startIndex + 1);
            if (startIndex == this.data.size()) {
                emptyRange = true;  // start is after last data item
            }
        }
        int endIndex = getIndex(end);
        if (endIndex < 0) {             // end period is not in original series
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
         if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
            TimeSeries copy = (TimeSeries) super.clone();
            copy.data = new java.util.ArrayList();
            return copy;
        }
        else {
            return createCopy(startIndex, endIndex);
        }

    }","public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

    if (start == null) {
        throw new IllegalArgumentException(""Null 'start' argument."");
    }
    if (end == null) {
        throw new IllegalArgumentException(""Null 'end' argument."");
    }
    if (start.compareTo(end) > 0) {
        throw new IllegalArgumentException(""Requires start on or before end."");
    }

    boolean emptyRange = false;
    int startIndex = getIndex(start);
    if (startIndex < 0) {
        startIndex = -(startIndex + 1);
        if (startIndex >= this.data.size()) {
            emptyRange = true; // start is after last data item
        }
    }

    int endIndex = getIndex(end);
    if (endIndex < 0) {
        endIndex = -(endIndex + 1);
        endIndex = endIndex - 1; // last item BEFORE end
        if (endIndex < 0) {
            emptyRange = true; // end is before first data item
        }
    }

    if (emptyRange || (startIndex > endIndex)) { // check invalid range
        TimeSeries copy = (TimeSeries) super.clone();
        copy.data = new java.util.ArrayList<>();
        return copy;
    } else {
        return createCopy(startIndex, endIndex);
    }
}",0,0
15,Chart_9,"public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

        if (start == null) {
            throw new IllegalArgumentException(""Null 'start' argument."");
        }
        if (end == null) {
            throw new IllegalArgumentException(""Null 'end' argument."");
        }
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(
                    ""Requires start on or before end."");
        }
        boolean emptyRange = false;
        int startIndex = getIndex(start);
        if (startIndex < 0) {
            startIndex = -(startIndex + 1);
            if (startIndex == this.data.size()) {
                emptyRange = true;  // start is after last data item
            }
        }
        int endIndex = getIndex(end);
        if (endIndex < 0) {             // end period is not in original series
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
         if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
            TimeSeries copy = (TimeSeries) super.clone();
            copy.data = new java.util.ArrayList();
            return copy;
        }
        else {
            return createCopy(startIndex, endIndex);
        }

    }","public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

    if (start == null || end == null) {
        throw new IllegalArgumentException(""Null argument."");
    }

    int startIndex = getIndex(start);
    if (startIndex < 0) {
        startIndex = -(startIndex + 1);
    }

    int endIndex = getIndex(end);
    if (endIndex < 0) {
        endIndex = -(endIndex + 1);
        endIndex = endIndex - 1;
    }

    if (startIndex <= endIndex && startIndex < this.data.size() && endIndex >= 0) {
        return createCopy(startIndex, endIndex);
    }

    TimeSeries copy = (TimeSeries) super.clone();
    copy.data = new ArrayList<>();
    return copy;
}",1,0
15,Chart_9,"public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

        if (start == null) {
            throw new IllegalArgumentException(""Null 'start' argument."");
        }
        if (end == null) {
            throw new IllegalArgumentException(""Null 'end' argument."");
        }
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(
                    ""Requires start on or before end."");
        }
        boolean emptyRange = false;
        int startIndex = getIndex(start);
        if (startIndex < 0) {
            startIndex = -(startIndex + 1);
            if (startIndex == this.data.size()) {
                emptyRange = true;  // start is after last data item
            }
        }
        int endIndex = getIndex(end);
        if (endIndex < 0) {             // end period is not in original series
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
         if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
            TimeSeries copy = (TimeSeries) super.clone();
            copy.data = new java.util.ArrayList();
            return copy;
        }
        else {
            return createCopy(startIndex, endIndex);
        }

    }","public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

    if (start == null) {
        throw new IllegalArgumentException(""Null 'start' argument."");
    }
    if (end == null) {
        throw new IllegalArgumentException(""Null 'end' argument."");
    }
    if (start.compareTo(end) > 0) {
        throw new IllegalArgumentException(""Requires start on or before end."");
    }

    int startIndex = getIndex(start);
    int endIndex = getIndex(end);

    if (startIndex < 0) {
        startIndex = -(startIndex + 1);
    }
    if (endIndex < 0) {
        endIndex = -(endIndex + 1) - 1;
    }

    if (startIndex < 0 || startIndex >= this.data.size() || endIndex < startIndex) {
        TimeSeries copy = (TimeSeries) super.clone();
        copy.data = new ArrayList<>();
        return copy;
    } else {
        return createCopy(Math.max(0, startIndex), endIndex);
    }
}",2,0
15,Chart_9,"public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

        if (start == null) {
            throw new IllegalArgumentException(""Null 'start' argument."");
        }
        if (end == null) {
            throw new IllegalArgumentException(""Null 'end' argument."");
        }
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(
                    ""Requires start on or before end."");
        }
        boolean emptyRange = false;
        int startIndex = getIndex(start);
        if (startIndex < 0) {
            startIndex = -(startIndex + 1);
            if (startIndex == this.data.size()) {
                emptyRange = true;  // start is after last data item
            }
        }
        int endIndex = getIndex(end);
        if (endIndex < 0) {             // end period is not in original series
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
         if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
            TimeSeries copy = (TimeSeries) super.clone();
            copy.data = new java.util.ArrayList();
            return copy;
        }
        else {
            return createCopy(startIndex, endIndex);
        }

    }","public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

    if (start == null) {
        throw new IllegalArgumentException(""Null 'start' argument."");
    }
    if (end == null) {
        throw new IllegalArgumentException(""Null 'end' argument."");
    }
    if (start.compareTo(end) > 0) {
        throw new IllegalArgumentException(""Requires start on or before end."");
    }

    int startIndex = getIndex(start);
    int endIndex = getIndex(end);

    if (startIndex < 0) {
        startIndex = -(startIndex + 1);
    }
    if (endIndex < 0) {
        endIndex = -(endIndex + 1) - 1;
    }

    if (startIndex > endIndex || startIndex >= this.data.size() || endIndex < 0) {
        TimeSeries copy = (TimeSeries) super.clone();
        copy.data = new ArrayList<>();
        return copy;
    } else {
        return createCopy(startIndex, Math.min(endIndex, this.data.size() - 1));
    }
}",3,0
15,Chart_9,"public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

        if (start == null) {
            throw new IllegalArgumentException(""Null 'start' argument."");
        }
        if (end == null) {
            throw new IllegalArgumentException(""Null 'end' argument."");
        }
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(
                    ""Requires start on or before end."");
        }
        boolean emptyRange = false;
        int startIndex = getIndex(start);
        if (startIndex < 0) {
            startIndex = -(startIndex + 1);
            if (startIndex == this.data.size()) {
                emptyRange = true;  // start is after last data item
            }
        }
        int endIndex = getIndex(end);
        if (endIndex < 0) {             // end period is not in original series
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
         if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
            TimeSeries copy = (TimeSeries) super.clone();
            copy.data = new java.util.ArrayList();
            return copy;
        }
        else {
            return createCopy(startIndex, endIndex);
        }

    }","public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
        throws CloneNotSupportedException {

    if (start == null) {
        throw new IllegalArgumentException(""Null 'start' argument."");
    }
    if (end == null) {
        throw new IllegalArgumentException(""Null 'end' argument."");
    }
    if (start.compareTo(end) > 0) {
        throw new IllegalArgumentException(""Requires start on or before end."");
    }

    int startIndex = getIndex(start);
    if (startIndex < 0) {
        startIndex = -(startIndex + 1);
    }
    if (startIndex >= this.data.size()) {
        startIndex = this.data.size(); // Clamp startIndex to end of data
    }

    int endIndex = getIndex(end);
    if (endIndex < 0) {
        endIndex = -(endIndex + 1) - 1;
    }
    if (endIndex < 0) {
        endIndex = -1; // Clamp endIndex to start of data
    }

    if (startIndex > endIndex || startIndex == this.data.size() || endIndex < 0) {
        TimeSeries copy = (TimeSeries) super.clone();
        copy.data = new ArrayList<>();
        return copy;
    } else {
        return createCopy(startIndex, endIndex);
    }
}",4,0
16,Closure_1,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
      // The parameters object literal setters can not be removed.
      return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
      // Strip unreferenced args off the end of the function declaration.
      Node lastArg;
      while ((lastArg = argList.getLastChild()) != null) {
        Var var = fnScope.getVar(lastArg.getString());
        if (!referenced.contains(var)) {
          argList.removeChild(lastArg);
          compiler.reportCodeChange();
        } else {
          break;
        }
      }
    } else {
      callSiteOptimizer.optimize(fnScope, referenced);
    }
  }","private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
    // is removing globals, then it's OK to remove unused function args.
    //
    // See http://code.google.com/p/closure-compiler/issues/detail?id=253

    Node function = fnScope.getRootNode();

    Preconditions.checkState(function.isFunction());
    if (function.getParent() != null && NodeUtil.isGetOrSetKey(function.getParent())) {
        // The parameters object literal setters can not be removed.
        return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer != null
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
        // Strip unreferenced args off the end of the function declaration.
        Node lastArg;
        while ((lastArg = argList.getLastChild()) != null) {
            Var var = fnScope.getVar(lastArg.getString());
            if (var == null || !referenced.contains(var)) {
                argList.removeChild(lastArg);
                compiler.reportCodeChange();
            } else {
                break;
            }
        }
    } else if (callSiteOptimizer != null) {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}",0,0
16,Closure_1,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
      // The parameters object literal setters can not be removed.
      return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
      // Strip unreferenced args off the end of the function declaration.
      Node lastArg;
      while ((lastArg = argList.getLastChild()) != null) {
        Var var = fnScope.getVar(lastArg.getString());
        if (!referenced.contains(var)) {
          argList.removeChild(lastArg);
          compiler.reportCodeChange();
        } else {
          break;
        }
      }
    } else {
      callSiteOptimizer.optimize(fnScope, referenced);
    }
  }","private void removeUnreferencedFunctionArgs(Scope fnScope) {
    Node function = fnScope.getRootNode();
    Preconditions.checkState(function.isFunction());
    if (function.getParent() != null && NodeUtil.isGetOrSetKey(function.getParent())) {
        return;
    }

    Node argList = getFunctionArgList(function);
    boolean canModifyCallers = modifyCallSites && callSiteOptimizer != null
            && callSiteOptimizer.canModifyCallers(function);

    if (!canModifyCallers) {
        // Remove unreferenced args by scanning the entire argument list for unused ones
        Node currentArg = argList.getFirstChild();
        while (currentArg != null) {
            Node nextArg = currentArg.getNext();
            Var var = fnScope.getVar(currentArg.getString());
            if (var == null || !referenced.contains(var)) {
                argList.removeChild(currentArg);
                compiler.reportCodeChange();
            }
            currentArg = nextArg;
        }
    } else {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}",1,0
16,Closure_1,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
      // The parameters object literal setters can not be removed.
      return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
      // Strip unreferenced args off the end of the function declaration.
      Node lastArg;
      while ((lastArg = argList.getLastChild()) != null) {
        Var var = fnScope.getVar(lastArg.getString());
        if (!referenced.contains(var)) {
          argList.removeChild(lastArg);
          compiler.reportCodeChange();
        } else {
          break;
        }
      }
    } else {
      callSiteOptimizer.optimize(fnScope, referenced);
    }
  }","private void removeUnreferencedFunctionArgs(Scope fnScope) {
    Node function = fnScope.getRootNode();
    Preconditions.checkState(function.isFunction());
    if (function.getParent() != null && NodeUtil.isGetOrSetKey(function.getParent())) {
        return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites && callSiteOptimizer != null && callSiteOptimizer.canModifyCallers(function);

    if (!modifyCallers) {
        // Use a reversed iterator to track all arguments, and stop when a referenced argument is encountered.
        List<Node> args = new ArrayList<>();
        for (Node current = argList.getFirstChild(); current != null; current = current.getNext()) {
            args.add(current);
        }

        for (int i = args.size() - 1; i >= 0; i--) {
            Node arg = args.get(i);
            Var var = fnScope.getVar(arg.getString());
            if (var == null || !referenced.contains(var)) {
                argList.removeChild(arg);
                compiler.reportCodeChange();
            } else {
                break;
            }
        }
    } else {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}",2,0
16,Closure_1,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
      // The parameters object literal setters can not be removed.
      return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
      // Strip unreferenced args off the end of the function declaration.
      Node lastArg;
      while ((lastArg = argList.getLastChild()) != null) {
        Var var = fnScope.getVar(lastArg.getString());
        if (!referenced.contains(var)) {
          argList.removeChild(lastArg);
          compiler.reportCodeChange();
        } else {
          break;
        }
      }
    } else {
      callSiteOptimizer.optimize(fnScope, referenced);
    }
  }","private void removeUnreferencedFunctionArgs(Scope fnScope) {
    Node function = fnScope.getRootNode();
    Preconditions.checkState(function.isFunction());
    if (function.getParent() != null && NodeUtil.isGetOrSetKey(function.getParent())) {
        return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites && callSiteOptimizer != null && callSiteOptimizer.canModifyCallers(function);

    if (!modifyCallers) {
        // Track unreferenced arguments directly using a flag and remove them
        Node currentArg = argList.getFirstChild();
        boolean encounteredReferencedArg = false;

        while (currentArg != null) {
            Node nextArg = currentArg.getNext();
            Var var = fnScope.getVar(currentArg.getString());

            if (!encounteredReferencedArg) {
                if (var == null || !referenced.contains(var)) {
                    argList.removeChild(currentArg);
                    compiler.reportCodeChange();
                } else {
                    encounteredReferencedArg = true; // Stop removing args after encountering a used one
                }
            }
            currentArg = nextArg;
        }
    } else {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}",3,0
16,Closure_1,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // Notice that removing unreferenced function args breaks
    // Function.prototype.length. In advanced mode, we don't really care
    // about this: we consider ""length"" the equivalent of reflecting on
    // the function's lexical source.
    //
    // Rather than create a new option for this, we assume that if the user
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
      // The parameters object literal setters can not be removed.
      return;
    }

    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites
        && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
      // Strip unreferenced args off the end of the function declaration.
      Node lastArg;
      while ((lastArg = argList.getLastChild()) != null) {
        Var var = fnScope.getVar(lastArg.getString());
        if (!referenced.contains(var)) {
          argList.removeChild(lastArg);
          compiler.reportCodeChange();
        } else {
          break;
        }
      }
    } else {
      callSiteOptimizer.optimize(fnScope, referenced);
    }
  }","private void removeUnreferencedFunctionArgs(Scope fnScope) {
    Node function = fnScope.getRootNode();
    Preconditions.checkState(function.isFunction());
    if (function.getParent() != null && NodeUtil.isGetOrSetKey(function.getParent())) {
        return;
    }

    Node argList = getFunctionArgList(function);
    boolean canModifyCallers = modifyCallSites && callSiteOptimizer != null && callSiteOptimizer.canModifyCallers(function);

    if (!canModifyCallers) {
        // Identify the unused arguments, keeping track of encountered used arguments to stop early if remaining items are not referenced.
        Set<Node> unusedArgs = new HashSet<>();
        Node currentArg = argList.getFirstChild();
        boolean hasReferencedArg = false;
        while (currentArg != null) {
            Var var = fnScope.getVar(currentArg.getString());
            if (var == null || !referenced.contains(var)) {
                unusedArgs.add(currentArg);
            } else {
                hasReferencedArg = true;
                break;  // Stop early if a referenced argument is encountered.
            }
            currentArg = currentArg.getNext();
        }
        // Remove identified unused arguments in a single iteration.
        for (Node arg : unusedArgs) {
            argList.removeChild(arg);
            compiler.reportCodeChange();
        }
    } else {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}",4,0
17,Closure_10,"static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
  }","static boolean mayBeString(Node n, boolean recurse) {
    if (n == null) {
        return false;
    }
    if (recurse) {
        return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
    } else {
        return mayBeStringHelper(n);
    }
}

// Fixed Method 2 (inside allResultsMatch)
static boolean allResultsMatch(Node n, Predicate<Node> p) {
    if (n == null || p == null) {
        return false;
    }
    switch (n.getType()) {
        case Token.ASSIGN:
        case Token.COMMA:
            return allResultsMatch(n.getLastChild(), p);
        case Token.AND:
        case Token.OR:
            return allResultsMatch(n.getFirstChild(), p)
                && allResultsMatch(n.getLastChild(), p);
        case Token.HOOK:
            Node child1 = n.getFirstChild().getNext();
            Node child2 = n.getLastChild();
            return child1 != null && child2 != null 
                && allResultsMatch(child1, p) 
                && allResultsMatch(child2, p);
        default:
            return p.apply(n);
    }
}

// Fixed Method 3 (inside mayBeStringHelper)
static boolean mayBeStringHelper(Node n) {
    if (n == null) {
        return false;
    }
    // Original logic implementation (unchanged from source code)
    return MAY_BE_STRING_PREDICATE.apply(n);
}",0,0
17,Closure_10,"static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
  }",Match failed,1,0
17,Closure_10,"static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
  }",Match failed,2,0
17,Closure_10,"static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
  }",Match failed,3,0
17,Closure_10,"static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
  }",Match failed,4,0
18,Closure_101,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
     if (flags.process_closure_primitives) {
       options.closurePass = true;
     }
 
     initOptionsFromFlags(options);
     return options;
   }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    
    // Ensure compilation level is properly set
    CompilationLevel level = flags.compilation_level;
    if (level != null) {
        level.setOptionsForCompilationLevel(options);
        if (flags.debug && level != null) {
            level.setDebugOptionsForCompilationLevel(options);
        }
    }
    
    // Ensure warning level is properly set
    WarningLevel wLevel = flags.warning_level;
    if (wLevel != null) {
        wLevel.setOptionsForWarningLevel(options);
    }
    
    // Apply formatting options if available
    if (flags.formatting != null) {
        for (FormattingOption formattingOption : flags.formatting) {
            formattingOption.applyToOptions(options);
        }
    }
    
    // Enable closure primitives if the flag is set
    if (flags.process_closure_primitives) {
        options.closurePass = true;
    }
    
    // Initialize other options from flags
    initOptionsFromFlags(options);
    return options;
}",0,0
18,Closure_101,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
     if (flags.process_closure_primitives) {
       options.closurePass = true;
     }
 
     initOptionsFromFlags(options);
     return options;
   }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());

    // Ensure valid compilation level
    if (flags.compilation_level != null) {
        CompilationLevel level = flags.compilation_level;
        level.setOptionsForCompilationLevel(options);
        if (flags.debug) {
            level.setDebugOptionsForCompilationLevel(options);
        }
    } else {
        throw new IllegalArgumentException(""Compilation level cannot be null."");
    }

    // Ensure valid warning level
    if (flags.warning_level != null) {
        WarningLevel wLevel = flags.warning_level;
        wLevel.setOptionsForWarningLevel(options);
    } else {
        throw new IllegalArgumentException(""Warning level cannot be null."");
    }

    // Process formatting options safely
    if (flags.formatting != null && !flags.formatting.isEmpty()) {
        for (FormattingOption formattingOption : flags.formatting) {
            formattingOption.applyToOptions(options);
        }
    }

    // Handle closure primitives flag
    if (flags.process_closure_primitives != null && flags.process_closure_primitives) {
        options.closurePass = true;
    }

    // Apply additional initialization
    initOptionsFromFlags(options);
    return options;
}",1,0
18,Closure_101,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
     if (flags.process_closure_primitives) {
       options.closurePass = true;
     }
 
     initOptionsFromFlags(options);
     return options;
   }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());

    // Handle compilation level safely
    if (flags.compilation_level != null) {
        CompilationLevel level = flags.compilation_level;
        level.setOptionsForCompilationLevel(options);
        if (flags.debug) {
            level.setDebugOptionsForCompilationLevel(options);
        }
    }

    // Apply warning level settings
    if (flags.warning_level != null) {
        flags.warning_level.setOptionsForWarningLevel(options);
    }

    // Process formatting options with a fallback
    if (flags.formatting != null && !flags.formatting.isEmpty()) {
        for (FormattingOption formattingOption : flags.formatting) {
            try {
                formattingOption.applyToOptions(options);
            } catch (Exception e) {
                // Ignore formatting option errors
            }
        }
    }

    // Process closure primitives flag
    options.closurePass = Boolean.TRUE.equals(flags.process_closure_primitives);

    // Initialize remaining options
    initOptionsFromFlags(options);
    return options;
}",2,0
19,Closure_102,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }","@Override
public void process(Node externs, Node root) {
    if (externs == null || root == null) {
        throw new IllegalArgumentException(""Externs and root nodes cannot be null"");
    }
    
    NodeTraversal.traverse(compiler, root, this);
    
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        try {
            t.traverseRoots(externs, root);
        } catch (Exception e) {
            throw new RuntimeException(""Error traversing roots for unique name making"", e);
        }
    }
    
    try {
        removeDuplicateDeclarations(root);
        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
    } catch (Exception e) {
        throw new RuntimeException(""Error during propagation of constant annotations or duplicate removal"", e);
    }
}",0,0
19,Closure_102,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }","@Override
public void process(Node externs, Node root) {
    // Validate input nodes to ensure they are properly initialized
    if (externs == null || root == null) {
        throw new IllegalArgumentException(""Externs and root cannot be null"");
    }

    // Traverse the root node
    NodeTraversal.traverse(compiler, root, this);

    // If local names should be unique, apply the renaming logic
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }

    // Add a condition to check if the root node has duplicates before removal
    if (hasDuplicateDeclarations(root)) {
        removeDuplicateDeclarations(root);
    }

    // Propagate constant annotations
    PropogateConstantAnnotations propagationPass = new PropogateConstantAnnotations(compiler, assertOnChange);
    propagationPass.process(externs, root);
}

// Helper method to check for duplicate declarations
private boolean hasDuplicateDeclarations(Node root) {
    Callback tickler = new ScopeTicklingCallback();
    ScopeCreator scopeCreator = new SyntacticScopeCreator(compiler, new DuplicateDeclarationHandler());
    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);

    // Use a flag to track duplicate declarations during traversal
    boolean[] hasDuplicates = new boolean[]{false};
    t.traverse(root, (node) -> {
        if (node.isVar() && duplicatesExist(node)) {
            hasDuplicates[0] = true;
        }
    });

    return hasDuplicates[0];
}

// Method to determine if duplicates exist for a specific node
private boolean duplicatesExist(Node node) {
    // Logic to detect duplicate VAR declarations
    return compiler.getSymbolTable().getSymbols(node.getString()).size() > 1;
}",1,0
19,Closure_102,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }","@Override
public void process(Node externs, Node root) {
    if (externs == null || root == null || compiler == null) {
        throw new IllegalArgumentException(""Externs, root nodes, and compiler cannot be null."");
    }

    // Traverse the root node first to normalize the AST
    try {
        NodeTraversal.traverse(compiler, root, this);
    } catch (Exception e) {
        throw new RuntimeException(""Error during root node traversal"", e);
    }

    // Apply unique name transformation conditionally
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        try {
            MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
            NodeTraversal t = new NodeTraversal(compiler, renamer);
            t.traverseRoots(externs, root);
        } catch (Exception e) {
            throw new RuntimeException(""Error traversing roots for unique name making"", e);
        }
    }

    // Handle duplicate declarations during traversal
    try {
        NodeTraversal.traverse(compiler, root, (node, parent) -> {
            if (node.isVar() && parent.hasChildren() && hasDuplicateSibling(node, parent)) {
                removeDuplicateDeclarations(root);
            }
        });
    } catch (Exception e) {
        throw new RuntimeException(""Error while removing duplicate declarations"", e);
    }

    // Propagate constant annotations after ensuring duplicates are removed
    try {
        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
    } catch (Exception e) {
        throw new RuntimeException(""Error during propagation of constant annotations"", e);
    }
}

// Helper method to check if a node has duplicate siblings
private boolean hasDuplicateSibling(Node node, Node parent) {
    String varName = node.getString();
    for (Node sibling : parent.children()) {
        if (sibling != node && sibling.isVar() && sibling.getString().equals(varName)) {
            return true;
        }
    }
    return false;
}",2,0
19,Closure_102,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }","@Override
public void process(Node externs, Node root) {
    if (externs == null || root == null) {
        throw new IllegalArgumentException(""Externs and root cannot be null"");
    }

    NodeTraversal.traverse(compiler, root, (node, parent) -> {
        // Additional step: Normalize before performing existing operations.
        if (node.isScript()) {
            NodeTraversal.traverse(compiler, node, this);
        }
    });

    // Ensure duplicate declarations are pre-processed separately.
    preprocessDuplicateDeclarations(root);

    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }

    // Second pass for removing duplicates after renaming logic.
    removeDuplicateDeclarations(root);

    try {
        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
    } catch (Exception e) {
        throw new RuntimeException(""Error during propagation of constant annotations"", e);
    }
}

// Helper method to preprocess duplicate declarations
private void preprocessDuplicateDeclarations(Node root) {
    NodeTraversal.traverse(
        compiler,
        root,
        (node, parent) -> {
            if (node.isVar() && parent.hasChildren()) {
                for (Node sibling : parent.children()) {
                    if (sibling != node && sibling.isVar() && sibling.getString().equals(node.getString())) {
                        parent.removeChild(sibling);
                    }
                }
            }
        });
}",3,0
19,Closure_102,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }","@Override
public void process(Node externs, Node root) {
    if (externs == null || root == null) {
        throw new IllegalArgumentException(""Externs and root nodes cannot be null"");
    }
    
    // Normalize AST before traversal
    normalizeAst(root);
    
    // First traversal pass
    NodeTraversal.traverse(compiler, root, this);
    
    // Unique name making with additional validation
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    
    // Remove duplicates conditionally based on traversal feedback
    if (hasDuplicateVars(root)) {
        removeDuplicateDeclarations(root);
    }
    
    // Propagate constant annotations with a safety check
    if (externs.hasChildren()) {
        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
    }
}

// Helper for normalization
private void normalizeAst(Node root) {
    NodeTraversal.traverse(compiler, root, (node, parent) -> {
        if (node.isScript()) {
            node.normalizeInstructions();
        }
    });
}

// Helper for checking duplicate VARs
private boolean hasDuplicateVars(Node root) {
    final boolean[] hasDuplicates = new boolean[] { false };
    NodeTraversal.traverse(compiler, root, (node, parent) -> {
        if (node.isVar() && parent.hasChildren()) {
            for (Node sibling : parent.children()) {
                if (sibling != node && sibling.isVar() && sibling.getString().equals(node.getString())) {
                    hasDuplicates[0] = true;
                }
            }
        }
    });
    return hasDuplicates[0];
}",4,0
20,Closure_104,"JSType meet(JSType that) {
    UnionTypeBuilder builder = new UnionTypeBuilder(registry);
    for (JSType alternate : alternates) {
      if (alternate.isSubtype(that)) {
        builder.addAlternate(alternate);
      }
    }

    if (that instanceof UnionType) {
      for (JSType otherAlternate : ((UnionType) that).alternates) {
        if (otherAlternate.isSubtype(this)) {
          builder.addAlternate(otherAlternate);
        }
      }
    } else if (that.isSubtype(this)) {
       builder.addAlternate(that);
     }
     JSType result = builder.build();
     if (result != null) {
       return result;
     } else if (this.isObject() && that.isObject()) {
       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    } else {
      return getNativeType(JSTypeNative.NO_TYPE);
    }
  }","JSType meet(JSType that) {
    UnionTypeBuilder builder = new UnionTypeBuilder(registry);
    for (JSType alternate : alternates) {
        if (alternate.isSubtype(that)) {
            builder.addAlternate(alternate);
        }
    }

    if (that instanceof UnionType) {
        for (JSType otherAlternate : ((UnionType) that).alternates) {
            if (otherAlternate.isSubtype(this)) {
                builder.addAlternate(otherAlternate);
            }
        }
    } else if (that.isSubtype(this)) {
        builder.addAlternate(that);
    }

    JSType result = builder.build();
    if (result != null && result != getNativeType(JSTypeNative.NO_TYPE)) {
        return result;
    } else if (this.isObject() && that.isObject()) {
        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    } else {
        return getNativeType(JSTypeNative.NO_TYPE);
    }
}",0,0
21,Closure_105,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
         if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
         if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
           sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        functionName == null || !functionName.getString().equals(""join"")) {
      return;
    }

    String joinString = NodeUtil.getStringValue(right);
    if (joinString == null) {
      return;
    }

    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getStringValue(elem));
        } else {
            if (sb.length() > 0) {
                // + 2 for the quotes.
                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(Node.newString(sb.toString()));
                sb = new StringBuilder();
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }

    if (sb.length() > 0) {
        // + 2 for the quotes.
        foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += Math.max(arrayFoldedChildren.size() - 1, 0);

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            parent.replaceChild(n, emptyStringNode);
            break;

        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                // If the Node is not a string literal, ensure that
                // it is coerced to a string.
                Node replacement = new Node(Token.ADD,
                    Node.newString(""""), foldedStringNode);
                foldedStringNode = replacement;
            }
            parent.replaceChild(n, foldedStringNode);
            break;

        default:
            // Check if no folding could actually be performed.
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += InlineCostEstimator.getCost(right);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            break;
    }
    t.getCompiler().reportCodeChange();
}",0,0
21,Closure_105,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
         if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
         if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
           sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) || functionName == null || !functionName.getString().equals(""join"")) {
        return;
    }

    String joinString = NodeUtil.getStringValue(right);
    if (joinString == null) {
        return;
    }

    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    Node previousStringNode = null;

    // Merge adjacent String nodes into one.
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            if (previousStringNode == null) {
                previousStringNode = elem;
            } else {
                String mergedString = NodeUtil.getStringValue(previousStringNode) + joinString + NodeUtil.getStringValue(elem);
                previousStringNode = Node.newString(mergedString);
            }
        } else {
            if (previousStringNode != null) {
                foldedSize += NodeUtil.getStringValue(previousStringNode).length() + 2; // +2 for quotes
                arrayFoldedChildren.add(previousStringNode);
                previousStringNode = null;
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }

    if (previousStringNode != null) {
        foldedSize += NodeUtil.getStringValue(previousStringNode).length() + 2; // +2 for quotes
        arrayFoldedChildren.add(previousStringNode);
    }

    // Add overhead for commas.
    foldedSize += Math.max(arrayFoldedChildren.size() - 1, 0);

    int originalSize = InlineCostEstimator.getCost(n);
    if (foldedSize > originalSize) {
        return;
    }

    switch (arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            parent.replaceChild(n, emptyStringNode);
            break;

        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                foldedStringNode = new Node(Token.ADD, Node.newString(""""), foldedStringNode);
            }
            parent.replaceChild(n, foldedStringNode);
            break;

        default:
            arrayNode.detachChildren();
            for (Node child : arrayFoldedChildren) {
                arrayNode.addChildToBack(child);
            }
            break;
    }

    t.getCompiler().reportCodeChange();
}",1,0
21,Closure_105,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
         if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
         if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
           sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if (arrayNode.getType() != Token.ARRAYLIT || functionName == null || !""join"".equals(functionName.getString())) {
        return;
    }

    String joinString = NodeUtil.getStringValue(right);
    if (joinString == null || joinString.isEmpty()) {
        return;
    }

    List<Node> arrayFoldedChildren = new LinkedList<>();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    String lastString = null;

    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            String currentString = NodeUtil.getStringValue(elem);
            if (lastString != null) {
                lastString += joinString + currentString;
            } else {
                lastString = currentString;
            }
        } else {
            if (lastString != null) {
                foldedSize += lastString.length() + 2; // For quotes
                arrayFoldedChildren.add(Node.newString(lastString));
                lastString = null;
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }
    if (lastString != null) {
        foldedSize += lastString.length() + 2; // For quotes
        arrayFoldedChildren.add(Node.newString(lastString));
    }

    foldedSize += Math.max(arrayFoldedChildren.size() - 1, 0); // For commas

    int originalSize = InlineCostEstimator.getCost(n);
    if (foldedSize > originalSize) {
        return;
    }

    switch (arrayFoldedChildren.size()) {
        case 0:
            parent.replaceChild(n, Node.newString(""""));
            break;

        case 1:
            Node singleChild = arrayFoldedChildren.get(0);
            if (singleChild.getType() != Token.STRING) {
                singleChild = new Node(Token.ADD, Node.newString(""""), singleChild);
            }
            parent.replaceChild(n, singleChild);
            break;

        default:
            arrayNode.detachChildren();
            for (Node child : arrayFoldedChildren) {
                arrayNode.addChildToBack(child);
            }
            break;
    }
    t.getCompiler().reportCodeChange();
}",2,0
21,Closure_105,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
         if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
         if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
           sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if (arrayNode.getType() != Token.ARRAYLIT || functionName == null || !""join"".equals(functionName.getString())) {
        return;
    }

    String joinString = NodeUtil.getStringValue(right);
    if (joinString == null || joinString.isEmpty()) {
        return;
    }

    List<Node> arrayFoldedChildren = new LinkedList<>();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();

    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            // Merge continuous immutable strings into a single node
            Node newStringNode = Node.newString(NodeUtil.getStringValue(elem) + joinString);
            foldedSize += newStringNode.getString().length() + 2; // +2 for quotes
            arrayFoldedChildren.add(newStringNode);
        } else {
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }

    foldedSize += Math.max(arrayFoldedChildren.size() - 1, 0); // For commas

    int originalSize = InlineCostEstimator.getCost(n);
    if (foldedSize > originalSize) {
        return;
    }

    switch (arrayFoldedChildren.size()) {
        case 0:
            parent.replaceChild(n, Node.newString(""""));
            break;

        case 1:
            Node singleChild = arrayFoldedChildren.get(0);
            if (singleChild.getType() != Token.STRING) {
                singleChild = new Node(Token.ADD, Node.newString(""""), singleChild);
            }
            parent.replaceChild(n, singleChild);
            break;

        default:
            arrayNode.detachChildren();
            for (Node child : arrayFoldedChildren) {
                arrayNode.addChildToBack(child);
            }
            break;
    }
    t.getCompiler().reportCodeChange();
}",3,0
21,Closure_105,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
                         Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
      return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return;
    }
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
         if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
         if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
           sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
      }
      elem = elem.getNext();
    }

    if (sb.length() > 0) {
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        parent.replaceChild(n, emptyStringNode);
        break;

      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString(""""), foldedStringNode);
          foldedStringNode = replacement;
        }
        parent.replaceChild(n, foldedStringNode);
        break;

      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += InlineCostEstimator.getCost(right);
        if (foldedSize > originalSize) {
          return;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        break;
    }
    t.getCompiler().reportCodeChange();
  }","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }

    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();

    if (arrayNode.getType() != Token.ARRAYLIT || functionName == null || !""join"".equals(functionName.getString())) {
        return;
    }

    String joinString = NodeUtil.getStringValue(right);
    if (joinString == null) {
        return;
    }

    List<Node> arrayFoldedChildren = new LinkedList<>();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            Node newStringNode = NodeUtil.foldImmutableString(elem, joinString);
            foldedSize += newStringNode.getString().length() + 2; // +2 for quotes
            arrayFoldedChildren.add(newStringNode);
        } else {
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }

    foldedSize += Math.max(arrayFoldedChildren.size() - 1, 0); // For commas

    int originalSize = InlineCostEstimator.getCost(n);
    if (foldedSize > originalSize) {
        return;
    }

    switch (arrayFoldedChildren.size()) {
        case 0:
            parent.replaceChild(n, Node.newString(""""));
            break;

        case 1:
            Node singleChild = arrayFoldedChildren.get(0);
            if (singleChild.getType() != Token.STRING) {
                singleChild = new Node(Token.ADD, Node.newString(""""), singleChild);
            }
            parent.replaceChild(n, singleChild);
            break;

        default:
            arrayNode.detachChildren();
            for (Node child : arrayFoldedChildren) {
                arrayNode.addChildToBack(child);
            }
            break;
    }
    t.getCompiler().reportCodeChange();
}",4,0
22,Closure_107,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
      options.setCodingConvention(new JqueryCodingConvention());
    } else {
      options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
      level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
      options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (!flags.translationsFile.isEmpty()) {
      try {
        options.messageBundle = new XtbMessageBundle(
            new FileInputStream(flags.translationsFile),
            flags.translationsProject);
      } catch (IOException e) {
        throw new RuntimeException(""Reading XTB file"", e);
      }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
      // translations file, they might reasonably try to write their own
      // implementation of goog.getMsg that makes the substitution at
      // run-time.
      //
      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
  }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    
    // Set coding convention
    if (flags.processJqueryPrimitives) {
        options.setCodingConvention(new JqueryCodingConvention());
    } else {
        options.setCodingConvention(new ClosureCodingConvention());
    }

    // Set extra annotations
    options.setExtraAnnotationNames(flags.extraAnnotationName);

    // Set options for compilation level
    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    // Set debug options if debug flag is true
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }

    // Set type-based optimization options
    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }

    // Generate exports
    if (flags.generateExports) {
        options.setGenerateExports(flags.generateExports);
    }

    // Set warning level options
    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);

    // Apply formatting options
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }

    // Set closure and jQuery pass options
    options.closurePass = flags.processClosurePrimitives;
    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS.equals(level) &&
        flags.processJqueryPrimitives;

    // Set Angular pass option
    options.angularPass = flags.angularPass;

    // Handle translations file
    if (flags.translationsFile != null && !flags.translationsFile.isEmpty()) {
        try (FileInputStream fis = new FileInputStream(flags.translationsFile)) {
            options.messageBundle = new XtbMessageBundle(fis, flags.translationsProject);
        } catch (IOException e) {
            throw new RuntimeException(""Error reading XTB file: "" + flags.translationsFile, e);
        }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS.equals(level)) {
        // In ADVANCED mode, inline goog.getMsg and suppress i18n warnings
        options.messageBundle = new EmptyMessageBundle();
    }

    return options;
}",0,0
22,Closure_107,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
      options.setCodingConvention(new JqueryCodingConvention());
    } else {
      options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
      level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
      options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (!flags.translationsFile.isEmpty()) {
      try {
        options.messageBundle = new XtbMessageBundle(
            new FileInputStream(flags.translationsFile),
            flags.translationsProject);
      } catch (IOException e) {
        throw new RuntimeException(""Reading XTB file"", e);
      }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
      // translations file, they might reasonably try to write their own
      // implementation of goog.getMsg that makes the substitution at
      // run-time.
      //
      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
  }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();

    // Handle coding convention setup based on primitives flag
    options.setCodingConvention(flags.processJqueryPrimitives
        ? new JqueryCodingConvention()
        : new ClosureCodingConvention());

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    // Set options based on debug flag
    if (flags.debug) {
        options.setCheckTypes(true); // Enables type checking for better debugging.
        level.setDebugOptionsForCompilationLevel(options);
    } else {
        options.setCheckTypes(false); // Disables type checking when debug flag is false.
    }

    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
        options.setGenerateExports(flags.generateExports);
    }

    WarningLevel warningLevel = flags.warningLevel;
    warningLevel.setOptionsForWarningLevel(options);

    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;
    options.angularPass = flags.angularPass;

    // Handle the translations file logic more robustly
    if (flags.translationsFile != null && !flags.translationsFile.isEmpty()) {
        try (FileInputStream fis = new FileInputStream(flags.translationsFile)) {
            options.messageBundle = new XtbMessageBundle(fis, flags.translationsProject);
            options.setWarningLevel(false); // Suppress translation-related warnings, if specified.
        } catch (IOException e) {
            throw new IllegalArgumentException(""Error reading XTB file: "" + flags.translationsFile, e);
        }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS.equals(level)) {
        options.messageBundle = new EmptyMessageBundle();
        options.setWarningLevel(true); // Enable warnings since no translations file is provided.
    }

    return options;
}",1,0
22,Closure_107,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
      options.setCodingConvention(new JqueryCodingConvention());
    } else {
      options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
      level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
      options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (!flags.translationsFile.isEmpty()) {
      try {
        options.messageBundle = new XtbMessageBundle(
            new FileInputStream(flags.translationsFile),
            flags.translationsProject);
      } catch (IOException e) {
        throw new RuntimeException(""Reading XTB file"", e);
      }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
      // translations file, they might reasonably try to write their own
      // implementation of goog.getMsg that makes the substitution at
      // run-time.
      //
      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
  }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();

    // Set coding convention based on flags
    options.setCodingConvention(flags.processJqueryPrimitives
        ? new JqueryCodingConvention()
        : new ClosureCodingConvention());

    // Extra annotations
    options.setExtraAnnotationNames(flags.extraAnnotationName);

    // Compile level options
    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    // Adjust debug options
    if (flags.debug) {
        options.setCheckTypes(true);
        level.setDebugOptionsForCompilationLevel(options);
    }

    // Type optimization
    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }

    // Export generation
    if (flags.generateExports) {
        options.setGenerateExports(flags.generateExports);
    }

    // Set warning levels
    WarningLevel warningLevel = flags.warningLevel;
    warningLevel.setOptionsForWarningLevel(options);

    // Use formatting options
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }

    // Various pass settings
    options.closurePass = flags.processClosurePrimitives;
    options.angularPass = flags.angularPass;
    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level && flags.processJqueryPrimitives;

    // Modified translation file handling logic
    if (flags.translationsFile != null && !flags.translationsFile.isEmpty()) {
        try (FileInputStream fis = new FileInputStream(flags.translationsFile)) {
            options.messageBundle = new XtbMessageBundle(fis, flags.translationsProject);
        } catch (IOException e) {
            options.messageBundle = new EmptyMessageBundle(); // Default to empty bundle on exception.
        }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
        options.messageBundle = new EmptyMessageBundle(); // Inline goog.getMsg and suppress i18n warnings.
    }

    return options;
}",2,0
22,Closure_107,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
      options.setCodingConvention(new JqueryCodingConvention());
    } else {
      options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
      level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
      options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (!flags.translationsFile.isEmpty()) {
      try {
        options.messageBundle = new XtbMessageBundle(
            new FileInputStream(flags.translationsFile),
            flags.translationsProject);
      } catch (IOException e) {
        throw new RuntimeException(""Reading XTB file"", e);
      }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
      // translations file, they might reasonably try to write their own
      // implementation of goog.getMsg that makes the substitution at
      // run-time.
      //
      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
  }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();

    // Handle coding convention setup based on primitives flag
    options.setCodingConvention(flags.processJqueryPrimitives
        ? new JqueryCodingConvention()
        : new ClosureCodingConvention());

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    // Set options based on debug flag
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
        options.setGenerateExports(flags.generateExports);
    }

    WarningLevel warningLevel = flags.warningLevel;
    warningLevel.setOptionsForWarningLevel(options);

    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;
    options.angularPass = flags.angularPass;
    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level && flags.processJqueryPrimitives;

    // Adjust translation file handling logic with fallback
    if (flags.translationsFile != null && !flags.translationsFile.isEmpty()) {
        try (FileInputStream fis = new FileInputStream(flags.translationsFile)) {
            options.messageBundle = new XtbMessageBundle(fis, flags.translationsProject);
        } catch (IOException e) {
            options.messageBundle = new EmptyMessageBundle(); // Fallback to empty bundle for errors.
        }
    } else {
        options.messageBundle = CompilationLevel.ADVANCED_OPTIMIZATIONS == level 
            ? new EmptyMessageBundle() 
            : null; // Assign the proper fallback for messageBundle.
    }

    return options;
}",3,0
22,Closure_107,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
      options.setCodingConvention(new JqueryCodingConvention());
    } else {
      options.setCodingConvention(new ClosureCodingConvention());
    }

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
      level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
      options.setGenerateExports(flags.generateExports);
    }

    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;

    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
        flags.processJqueryPrimitives;

    options.angularPass = flags.angularPass;

    if (!flags.translationsFile.isEmpty()) {
      try {
        options.messageBundle = new XtbMessageBundle(
            new FileInputStream(flags.translationsFile),
            flags.translationsProject);
      } catch (IOException e) {
        throw new RuntimeException(""Reading XTB file"", e);
      }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
      // translations file, they might reasonably try to write their own
      // implementation of goog.getMsg that makes the substitution at
      // run-time.
      //
      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
  }","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();

    // Set the coding convention
    options.setCodingConvention(flags.processJqueryPrimitives 
        ? new JqueryCodingConvention() 
        : new ClosureCodingConvention()
    );

    options.setExtraAnnotationNames(flags.extraAnnotationName);

    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);

    if (flags.debug) {
        options.setCheckTypes(true); // Explicitly enable type checking for better debugging insights.
        level.setDebugOptionsForCompilationLevel(options);
    }

    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }

    if (flags.generateExports) {
        options.setGenerateExports(flags.generateExports);
    }

    WarningLevel warningLevel = flags.warningLevel;
    warningLevel.setOptionsForWarningLevel(options);

    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }

    options.closurePass = flags.processClosurePrimitives;
    options.angularPass = flags.angularPass;

    // Additional direct check for ADVANCED_OPTIMIZATIONS in jqueryPass evaluation.
    options.jqueryPass = flags.processJqueryPrimitives 
        && CompilationLevel.ADVANCED_OPTIMIZATIONS.equals(level);

    // Handle the translations file more robustly
    if (flags.translationsFile != null && !flags.translationsFile.isEmpty()) {
        try (FileInputStream fis = new FileInputStream(flags.translationsFile)) {
            options.messageBundle = new XtbMessageBundle(fis, flags.translationsProject);
        } catch (IOException e) {
            options.messageBundle = new EmptyMessageBundle(); // Default to an empty bundle in case of failure.
        }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS.equals(level)) {
        options.messageBundle = new EmptyMessageBundle(); // Inline goog.getMsg and suppress i18n warnings.
    } else {
        options.messageBundle = null; // For non-ADVANCED levels, explicitly set messageBundle to null.
    }

    return options;
}",4,0
23,Closure_109,"  private Node parseContextTypeExpression(JsDocToken token) {
          return parseTypeName(token);
  }
","private Node parseContextTypeExpression(JsDocToken token) {
    if (token == JsDocToken.QMARK || token == JsDocToken.STAR) {
        return Node.newString(token.name());
    }
    return parseTypeName(token);
}",0,0
23,Closure_109,"  private Node parseContextTypeExpression(JsDocToken token) {
          return parseTypeName(token);
  }
","private Node parseContextTypeExpression(JsDocToken token) {
    if (token == JsDocToken.QMARK) {
        return Node.newString(""?"");
    } else if (token == JsDocToken.STAR) {
        return Node.newString(""*"");
    }
    return parseTypeName(token);
}",1,0
23,Closure_109,"  private Node parseContextTypeExpression(JsDocToken token) {
          return parseTypeName(token);
  }
","private Node parseContextTypeExpression(JsDocToken token) {
    Node node = null;
    switch (token) {
        case QMARK:
            node = Node.newString(""?"");
            break;
        case STAR:
            node = Node.newString(""*"");
            break;
        default:
            node = parseTypeName(token);
            break;
    }
    return node;
}",2,0
23,Closure_109,"  private Node parseContextTypeExpression(JsDocToken token) {
          return parseTypeName(token);
  }
","private Node parseContextTypeExpression(JsDocToken token) {
    if (token == JsDocToken.QMARK || token == JsDocToken.STAR) {
        return Node.newString(token == JsDocToken.QMARK ? ""?"" : ""*"");
    }
    if (token == JsDocToken.LBRACE) {
        return parseTopLevelTypeExpression(token);
    }
    return parseTypeName(token);
}",3,0
23,Closure_109,"  private Node parseContextTypeExpression(JsDocToken token) {
          return parseTypeName(token);
  }
","private Node parseContextTypeExpression(JsDocToken token) {
    if (token == JsDocToken.QMARK || token == JsDocToken.STAR) {
        return Node.newString(token == JsDocToken.QMARK ? ""optional"" : ""any"");
    } else if (token == JsDocToken.LBRACE || token == JsDocToken.RBRACE) {
        return parseTopLevelTypeExpression(token);
    } else {
        return parseTypeName(token);
    }
}",4,0
24,Closure_11,"private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    // Lots of types can appear on the left, a call to a void function can
    // never be on the left. getPropertyType will decide what is acceptable
    // and what isn't.
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
     } else if (n.getJSType() != null && parent.isAssign()) {
       return;
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
  }",Match failed,0,0
24,Closure_11,"private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    // Lots of types can appear on the left, a call to a void function can
    // never be on the left. getPropertyType will decide what is acceptable
    // and what isn't.
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
     } else if (n.getJSType() != null && parent.isAssign()) {
       return;
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
  }","private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);

    if (childType.isDict()) {
        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
    } else {
        // Ensuring property access is checked regardless of assignment context
        if (validator.expectNotNullOrUndefined(t, n, childType,
            ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
            checkPropertyAccess(childType, property.getString(), t, n);
        }
    }
    ensureTyped(t, n);
}",1,0
25,Closure_111,"        protected JSType caseTopType(JSType topType) {
          return topType;
        }
",Match failed,0,0
25,Closure_111,"        protected JSType caseTopType(JSType topType) {
          return topType;
        }
",Match failed,1,0
25,Closure_111,"        protected JSType caseTopType(JSType topType) {
          return topType;
        }
","protected JSType caseTopType(JSType topType) {
    if (topType.toString().equals(""Array"")) {
        return JSType.getArrayType();
    }
    return topType;
}",2,0
25,Closure_111,"        protected JSType caseTopType(JSType topType) {
          return topType;
        }
","protected JSType caseTopType(JSType topType) {
    if (topType.isObject()) {
        return JSType.OBJECT_TYPE; // Return predefined constant representing ObjectType if it's an object
    }
    return topType;
}",3,0
25,Closure_111,"        protected JSType caseTopType(JSType topType) {
          return topType;
        }
","protected JSType caseTopType(JSType topType) {
    if (topType instanceof ComplexType) {
        return topType.simplify(); // Apply logic to handle complex types
    }
    return topType;
}",4,0
26,Closure_112,"    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()
        .getTemplateKeys();
    if (keys.isEmpty()) {
      return false;
    }
","public boolean hasTemplateKeys() {
    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
    return !keys.isEmpty();
}",0,0
26,Closure_112,"    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()
        .getTemplateKeys();
    if (keys.isEmpty()) {
      return false;
    }
","public boolean hasTemplateKeys() {
    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
    if (keys == null) {
        return false;
    }
    return !keys.isEmpty();
}",1,0
26,Closure_112,"    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()
        .getTemplateKeys();
    if (keys.isEmpty()) {
      return false;
    }
","public boolean hasTemplateKeys() {
    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
    return keys != null && !keys.isEmpty();
}",2,0
26,Closure_112,"    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()
        .getTemplateKeys();
    if (keys.isEmpty()) {
      return false;
    }
","public boolean hasTemplateKeys() {
    final ImmutableList<TemplateType> keys;
    try {
        keys = fnType.getTemplateTypeMap().getTemplateKeys();
        return !keys.isEmpty();
    } catch (NullPointerException e) {
        return false;
    }
}",3,0
26,Closure_112,"    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()
        .getTemplateKeys();
    if (keys.isEmpty()) {
      return false;
    }
","public boolean hasTemplateKeys() {
    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
    if (keys != null && keys.size() > 0) {
        return true;
    }
    return false;
}",4,0
27,Closure_113,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
      String ns = arg.getString();
      ProvidedName provided = providedNames.get(ns);
      if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
      } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
          compiler.report(
              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                  providedModule.getName(),
                  module.getName()));
        }
      }

      maybeAddToSymbolTable(left);
      maybeAddStringNodeToSymbolTable(arg);

      // Requires should be removed before further processing.
      // Some clients run closure pass multiple times, first with
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
       if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
    }
  }","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
        String ns = arg.getString();
        ProvidedName provided = providedNames.get(ns);
        if (provided == null || !provided.isExplicitlyProvided()) {
            unrecognizedRequires.add(
                new UnrecognizedRequire(n, ns, t.getSourceName()));
        } else {
            JSModule providedModule = provided.explicitModule;

            // This must be non-null, because there was an explicit provide.
            Preconditions.checkNotNull(providedModule);

            JSModule module = t.getModule();
            if (moduleGraph != null &&
                module != providedModule &&
                !moduleGraph.dependsOn(module, providedModule)) {
                compiler.report(
                    t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                        providedModule.getName(),
                        module.getName()));
            }
        }

        maybeAddToSymbolTable(left);
        maybeAddStringNodeToSymbolTable(arg);

        // Requires should be removed before further processing.
        if (provided == null || !provided.isExplicitlyProvided()) {
            parent.detachFromParent();
            compiler.reportCodeChange();
        }
    }
}",0,0
27,Closure_113,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
      String ns = arg.getString();
      ProvidedName provided = providedNames.get(ns);
      if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
      } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
          compiler.report(
              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                  providedModule.getName(),
                  module.getName()));
        }
      }

      maybeAddToSymbolTable(left);
      maybeAddStringNodeToSymbolTable(arg);

      // Requires should be removed before further processing.
      // Some clients run closure pass multiple times, first with
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
       if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
    }
  }","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
        String ns = arg.getString();
        ProvidedName provided = providedNames.get(ns);
        if (provided == null || !provided.isExplicitlyProvided()) {
            unrecognizedRequires.add(
                new UnrecognizedRequire(n, ns, t.getSourceName()));
        } else {
            JSModule providedModule = provided.explicitModule;

            // Preconditions that make sure the provided module is accessible
            if (providedModule != null) {
                JSModule module = t.getModule();
                if (moduleGraph != null &&
                    !module.equals(providedModule) &&
                    !moduleGraph.dependsOn(module, providedModule)) {
                    compiler.report(
                        t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                            providedModule.getName(),
                            module.getName()));
                }
            }
        }

        maybeAddToSymbolTable(left);
        maybeAddStringNodeToSymbolTable(arg);

        // Requires should be conditionally removed before further processing.
        if ((provided == null || !provided.isExplicitlyProvided()) && someCondition) {
            parent.detachFromParent();
            compiler.reportCodeChange();
        }
    }
}",1,0
27,Closure_113,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
      String ns = arg.getString();
      ProvidedName provided = providedNames.get(ns);
      if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
      } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
          compiler.report(
              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                  providedModule.getName(),
                  module.getName()));
        }
      }

      maybeAddToSymbolTable(left);
      maybeAddStringNodeToSymbolTable(arg);

      // Requires should be removed before further processing.
      // Some clients run closure pass multiple times, first with
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
       if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
    }
  }","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
        String ns = arg.getString();
        ProvidedName provided = providedNames.get(ns);
        if (provided == null || !provided.isExplicitlyProvided()) {
            unrecognizedRequires.add(
                new UnrecognizedRequire(n, ns, t.getSourceName()));
        } else {
            JSModule providedModule = provided.explicitModule;
            
            Preconditions.checkNotNull(providedModule);

            JSModule module = t.getModule();
            // Remove requirement only if module graph is correctly configured.
            if (moduleGraph != null &&
                module != providedModule &&
                !moduleGraph.dependsOn(module, providedModule)) {
                compiler.report(
                    t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                        providedModule.getName(),
                        module.getName()));
            } else {
                parent.detachFromParent();
                compiler.reportCodeChange();
            }
        }

        maybeAddToSymbolTable(left);
        maybeAddStringNodeToSymbolTable(arg);
    }
}",2,0
27,Closure_113,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
      String ns = arg.getString();
      ProvidedName provided = providedNames.get(ns);
      if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
      } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
          compiler.report(
              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                  providedModule.getName(),
                  module.getName()));
        }
      }

      maybeAddToSymbolTable(left);
      maybeAddStringNodeToSymbolTable(arg);

      // Requires should be removed before further processing.
      // Some clients run closure pass multiple times, first with
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
       if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
    }
  }","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
        String ns = arg.getString();
        ProvidedName provided = providedNames.get(ns);
        boolean isExplicitlyProvided = provided != null && provided.isExplicitlyProvided();
        
        if (!isExplicitlyProvided) {
            unrecognizedRequires.add(
                new UnrecognizedRequire(n, ns, t.getSourceName()));
        }

        // Update module processing based on provided flag
        JSModule module = t.getModule();
        if (moduleGraph != null && isExplicitlyProvided) {
            JSModule providedModule = provided.explicitModule;

            if (providedModule != null) {
                if (module != providedModule &&
                    !moduleGraph.dependsOn(module, providedModule)) {
                    compiler.report(
                        t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                            providedModule.getName(),
                            module.getName()));
                }
            }
        }

        maybeAddToSymbolTable(left);
        maybeAddStringNodeToSymbolTable(arg);

        // Preserve requirements based on processing conditions
        if (!isExplicitlyProvided) {
            parent.detachFromParent();
            compiler.reportCodeChange();
        }
    }
}",3,0
27,Closure_113,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
      String ns = arg.getString();
      ProvidedName provided = providedNames.get(ns);
      if (provided == null || !provided.isExplicitlyProvided()) {
        unrecognizedRequires.add(
            new UnrecognizedRequire(n, ns, t.getSourceName()));
      } else {
        JSModule providedModule = provided.explicitModule;

        // This must be non-null, because there was an explicit provide.
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
          compiler.report(
              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                  providedModule.getName(),
                  module.getName()));
        }
      }

      maybeAddToSymbolTable(left);
      maybeAddStringNodeToSymbolTable(arg);

      // Requires should be removed before further processing.
      // Some clients run closure pass multiple times, first with
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
       if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
    }
  }","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
        String ns = arg.getString();
        ProvidedName provided = providedNames.get(ns);
        if (provided == null || !provided.isExplicitlyProvided()) {
            unrecognizedRequires.add(
                new UnrecognizedRequire(n, ns, t.getSourceName()));
            // Do not remove the require call if unrecognized
            return;
        }
        
        JSModule providedModule = provided.explicitModule;
        Preconditions.checkNotNull(providedModule);

        JSModule module = t.getModule();
        if (moduleGraph != null &&
            module != providedModule &&
            !moduleGraph.dependsOn(module, providedModule)) {
            compiler.report(
                t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
                    providedModule.getName(),
                    module.getName()));
            // Ensure requirements are preserved if there is a dependency issue
            return;
        }

        maybeAddToSymbolTable(left);
        maybeAddStringNodeToSymbolTable(arg);

        // Detach require after validating all conditions
        parent.detachFromParent();
        compiler.reportCodeChange();
    }
}",4,0
28,Closure_114,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
      Node nameNode = n.getFirstChild();
      Node parent = n.getParent();
      NameInformation ns = createNameInformation(t, nameNode);
      if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
          // Patch for assignments that appear in the init,
          // condition or iteration part of a FOR loop.  Without
          // this change, all 3 of those parts try to claim the for
          // loop as their dependency scope.  The last assignment in
          // those three fields wins, which can result in incorrect
          // reference edges between referenced and assigned variables.
          //
          // TODO(user) revisit the dependency scope calculation
          // logic.
          if (parent.getFirstChild().getNext() != n) {
            recordDepScope(recordNode, ns);
           } else {
             recordDepScope(nameNode, ns);
           }
         } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
          // caller expression, but it could be nested deeper in the caller and
          // we would still get a bug.
          // See testAssignWithCall2 for an example of this.
          recordDepScope(recordNode, ns);
        }
      }
    }","private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    Node nameNode = n.getFirstChild();
    Node parent = n.getParent();
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // Patch for assignments that appear in the init,
            // condition or iteration part of a FOR loop.  Without
            // this change, all 3 of those parts try to claim the for
            // loop as their dependency scope.  The last assignment in
            // those three fields wins, which can result in incorrect
            // reference edges between referenced and assigned variables.
            //
            // TODO(user) revisit the dependency scope calculation
            // logic.
            if (!parent.getFirstChild().equals(n)) { // Fix condition to check for init part
                recordDepScope(recordNode, ns);
            } else {
                recordDepScope(nameNode, ns);
            }
        } else {
            // The rhs of the assignment is the caller, so it's used by the
            // context. Don't associate it w/ the lhs.
            // FYI: this fixes only the specific case where the assignment is the
            // caller expression, but it could be nested deeper in the caller and
            // we would still get a bug.
            // See testAssignWithCall2 for an example of this.
            recordDepScope(recordNode, ns);
        }
    }
}",0,0
28,Closure_114,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
      Node nameNode = n.getFirstChild();
      Node parent = n.getParent();
      NameInformation ns = createNameInformation(t, nameNode);
      if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
          // Patch for assignments that appear in the init,
          // condition or iteration part of a FOR loop.  Without
          // this change, all 3 of those parts try to claim the for
          // loop as their dependency scope.  The last assignment in
          // those three fields wins, which can result in incorrect
          // reference edges between referenced and assigned variables.
          //
          // TODO(user) revisit the dependency scope calculation
          // logic.
          if (parent.getFirstChild().getNext() != n) {
            recordDepScope(recordNode, ns);
           } else {
             recordDepScope(nameNode, ns);
           }
         } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
          // caller expression, but it could be nested deeper in the caller and
          // we would still get a bug.
          // See testAssignWithCall2 for an example of this.
          recordDepScope(recordNode, ns);
        }
      }
    }","private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    Node nameNode = n.getFirstChild();
    Node parent = n.getParent();
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // Specifically check for the init part of FOR loop to handle
            // correctly
            if (NodeUtil.isInitPartOfFor(parent, n)) {
                recordDepScope(nameNode, ns);
            } else {
                recordDepScope(recordNode, ns);
            }
        } else {
            // Correctly register dependency scope for non-FOR context
            recordDepScope(recordNode, ns);
        }
    }
}",1,0
28,Closure_114,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
      Node nameNode = n.getFirstChild();
      Node parent = n.getParent();
      NameInformation ns = createNameInformation(t, nameNode);
      if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
          // Patch for assignments that appear in the init,
          // condition or iteration part of a FOR loop.  Without
          // this change, all 3 of those parts try to claim the for
          // loop as their dependency scope.  The last assignment in
          // those three fields wins, which can result in incorrect
          // reference edges between referenced and assigned variables.
          //
          // TODO(user) revisit the dependency scope calculation
          // logic.
          if (parent.getFirstChild().getNext() != n) {
            recordDepScope(recordNode, ns);
           } else {
             recordDepScope(nameNode, ns);
           }
         } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
          // caller expression, but it could be nested deeper in the caller and
          // we would still get a bug.
          // See testAssignWithCall2 for an example of this.
          recordDepScope(recordNode, ns);
        }
      }
    }","private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    Node nameNode = n.getFirstChild();
    Node parent = n.getParent();
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // Only handle the init part of FOR loop separately to resolve incorrect scope association.
            if (parent.getFirstChild() == n) {
                recordDepScope(nameNode, ns);
            } else {
                recordDepScope(recordNode, ns);
            }
        } else {
            // Adjust scope association by using both nodes
            recordDepScope(recordNode, ns);
            recordDepScope(nameNode, ns);
        }
    }
}",2,0
28,Closure_114,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
      Node nameNode = n.getFirstChild();
      Node parent = n.getParent();
      NameInformation ns = createNameInformation(t, nameNode);
      if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
          // Patch for assignments that appear in the init,
          // condition or iteration part of a FOR loop.  Without
          // this change, all 3 of those parts try to claim the for
          // loop as their dependency scope.  The last assignment in
          // those three fields wins, which can result in incorrect
          // reference edges between referenced and assigned variables.
          //
          // TODO(user) revisit the dependency scope calculation
          // logic.
          if (parent.getFirstChild().getNext() != n) {
            recordDepScope(recordNode, ns);
           } else {
             recordDepScope(nameNode, ns);
           }
         } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
          // caller expression, but it could be nested deeper in the caller and
          // we would still get a bug.
          // See testAssignWithCall2 for an example of this.
          recordDepScope(recordNode, ns);
        }
      }
    }","private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    Node nameNode = n.getFirstChild();
    Node parent = n.getParent();
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // Refined the logic to correctly identify the init, condition,
            // and iteration parts of the FOR loop by checking for each specifically.
            if (parent.getFirstChild() == n || parent.getFirstChild().getNext() == n) {
                recordDepScope(nameNode, ns); // Specifically handle the init part
            } else {
                recordDepScope(recordNode, ns);
            }
        } else {
            // Updated the logic to register dependency scope correctly
            // by associating with the record node only once and accounting for nested calls.
            recordDepScope(recordNode, ns);
        }
    }
}",3,0
28,Closure_114,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
      Node nameNode = n.getFirstChild();
      Node parent = n.getParent();
      NameInformation ns = createNameInformation(t, nameNode);
      if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
          // Patch for assignments that appear in the init,
          // condition or iteration part of a FOR loop.  Without
          // this change, all 3 of those parts try to claim the for
          // loop as their dependency scope.  The last assignment in
          // those three fields wins, which can result in incorrect
          // reference edges between referenced and assigned variables.
          //
          // TODO(user) revisit the dependency scope calculation
          // logic.
          if (parent.getFirstChild().getNext() != n) {
            recordDepScope(recordNode, ns);
           } else {
             recordDepScope(nameNode, ns);
           }
         } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
          // caller expression, but it could be nested deeper in the caller and
          // we would still get a bug.
          // See testAssignWithCall2 for an example of this.
          recordDepScope(recordNode, ns);
        }
      }
    }","private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    Node nameNode = n.getFirstChild();
    Node parent = n.getParent();
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // Check all parts of the FOR loop: init (firstChild), condition (secondChild), iteration (thirdChild)
            if (parent.getFirstChild() == n) {
                recordDepScope(nameNode, ns);
            } else if (parent.getFirstChild().getNext() == n || parent.getFirstChild().getNext().getNext() == n) {
                recordDepScope(recordNode, ns);
            }
        } else {
            // Handle assignments outside of FOR loop correctly
            recordDepScope(recordNode, ns);
        }
    }
}",4,0
29,Closure_115,"private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
             return CanInlineResult.NO;
           }
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }","private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else if (NodeUtil.isFunctionObjectApply(callNode)) {
        return CanInlineResult.NO;
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
       // For each named parameter check if a mutable argument use more than once.
       if (fnParam != null) {
         if (cArg != null) {
           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
             return CanInlineResult.NO;
           }
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }",0,0
29,Closure_115,"private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
             return CanInlineResult.NO;
           }
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }","private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasComplexSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasComplexSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild());
      }
    }

    Node cArg = callNode.getFirstChild().getNext();

    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
      if (fnParam != null) {
        if (cArg != null) {
          if (hasComplexSideEffects && NodeUtil.canBeSideEffected(cArg)) {
            return CanInlineResult.NO;
          }
          if (NodeUtil.mayEffectMutableState(cArg)
              && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }
        fnParam = fnParam.getNext();
      }

      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    boolean containsConditional = NodeUtil.containsConditional(callNode);
    return containsConditional ? CanInlineResult.NO : CanInlineResult.YES;
  }",1,0
29,Closure_115,"private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
             return CanInlineResult.NO;
           }
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }","private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }
  
    Node block = fnNode.getLastChild();
  
    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    
    Node cArg = callNode.getFirstChild().getNext();
  
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }
  
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
      if (cArg != null) {
        if (NodeUtil.mayEffectMutableState(cArg, compiler)
            && fnParam != null
            && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
      if (fnParam != null) {
        fnParam = fnParam.getNext();
      }
    }
  
    return CanInlineResult.YES;
  }",2,0
29,Closure_115,"private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
             return CanInlineResult.NO;
           }
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }","private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();
    boolean hasSideEffects = false;

    if (block.hasChildren()) {
        Preconditions.checkState(block.hasOneChild());
        Node stmt = block.getFirstChild();
        if (stmt.isReturn()) {
            hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
        }
    }

    Node cArg = callNode.getFirstChild().getNext();
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }

    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        if (fnParam != null) {
            if (cArg != null) {
                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
                    return CanInlineResult.NO;
                }
                if (NodeUtil.mayEffectMutableState(cArg, compiler) &&
                    NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            fnParam = fnParam.getNext();
        }
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }

    return CanInlineResult.YES;
}",3,0
29,Closure_115,"private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
             return CanInlineResult.NO;
           }
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }

        // Move to the next name.
        fnParam = fnParam.getNext();
      }

      // For every call argument check for side-effects, even if there
      // isn't a named parameter to match.
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }","private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();

    boolean hasSideEffects = false;
    if (block.hasChildren() && block.hasOneChild()) {
        Node stmt = block.getFirstChild();
        if (stmt.isReturn()) {
            hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
        }
    }

    Node cArg = callNode.getFirstChild().getNext();

    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }

    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (fnParam != null || cArg != null) {
        if (fnParam != null) {
            if (cArg != null) {
                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
                    return CanInlineResult.NO;
                }
                if (NodeUtil.mayEffectMutableState(cArg, compiler)
                        && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            fnParam = fnParam.getNext();
        }

        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }

    boolean modifiesParameters = NodeUtil.anyParametersModified(fnNode, callNode);
    if (modifiesParameters) {
        return CanInlineResult.NO;
    }

    return CanInlineResult.YES;
}",4,0
30,Closure_117,"String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
      ObjectType objectType = getJSType(n.getFirstChild()).dereference();
      if (objectType != null) {
        String propName = n.getLastChild().getString();
        if (objectType.getConstructor() != null &&
            objectType.getConstructor().isInterface()) {
          objectType = FunctionType.getTopDefiningInterface(
              objectType, propName);
        } else {
          // classes
          while (objectType != null && !objectType.hasOwnProperty(propName)) {
            objectType = objectType.getImplicitPrototype();
          }
        }

        // Don't show complex function names or anonymous types.
        // Instead, try to get a human-readable type name.
        if (objectType != null &&
            (objectType.getConstructor() != null ||
             objectType.isFunctionPrototypeType())) {
          return objectType.toString() + ""."" + propName;
        }
      }
    }

    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
      return qualifiedName;
    } else if (type.isFunctionType()) {
      // Don't show complex function names.
      return ""function"";
    } else {
      return type.toString();
    }
  }","String getReadableJSTypeName(Node n, boolean dereference) {
    // The best type name is the actual type name.
  
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            if (objectType.getConstructor() != null &&
                objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(
                    objectType, propName);
            } else {
                // classes
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }

            if (objectType != null &&
                (objectType.getConstructor() != null ||
                 objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }

    JSType type = getJSType(n);
    if (type == null) {
        return ""unknown"";
    }

    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }

    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }

    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        return ""function"";
    } else {
        return type.toString();
    }
}",0,0
30,Closure_117,"String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
      ObjectType objectType = getJSType(n.getFirstChild()).dereference();
      if (objectType != null) {
        String propName = n.getLastChild().getString();
        if (objectType.getConstructor() != null &&
            objectType.getConstructor().isInterface()) {
          objectType = FunctionType.getTopDefiningInterface(
              objectType, propName);
        } else {
          // classes
          while (objectType != null && !objectType.hasOwnProperty(propName)) {
            objectType = objectType.getImplicitPrototype();
          }
        }

        // Don't show complex function names or anonymous types.
        // Instead, try to get a human-readable type name.
        if (objectType != null &&
            (objectType.getConstructor() != null ||
             objectType.isFunctionPrototypeType())) {
          return objectType.toString() + ""."" + propName;
        }
      }
    }

    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
      return qualifiedName;
    } else if (type.isFunctionType()) {
      // Don't show complex function names.
      return ""function"";
    } else {
      return type.toString();
    }
  }","String getReadableJSTypeName(Node n, boolean dereference) {
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            while (objectType != null) {
                if (objectType.hasOwnProperty(propName)) {
                    break;
                }
                objectType = objectType.getImplicitPrototype();
            }
            if (objectType != null) {
                JSType constructorType = objectType.getConstructor();
                if (constructorType instanceof FunctionType && ((FunctionType) constructorType).isInterface()) {
                    return FunctionType.getTopDefiningInterface(objectType, propName).toString() + ""."" + propName;
                } else {
                    return objectType.toString() + ""."" + propName;
                }
            }
        }
    }

    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }

    if (type.isFunctionPrototypeType() || 
        (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }

    String qualifiedName = n.getQualifiedName();
    return qualifiedName != null ? qualifiedName : (type.isFunctionType() ? ""function"" : type.toString());
}",1,0
30,Closure_117,"String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
      ObjectType objectType = getJSType(n.getFirstChild()).dereference();
      if (objectType != null) {
        String propName = n.getLastChild().getString();
        if (objectType.getConstructor() != null &&
            objectType.getConstructor().isInterface()) {
          objectType = FunctionType.getTopDefiningInterface(
              objectType, propName);
        } else {
          // classes
          while (objectType != null && !objectType.hasOwnProperty(propName)) {
            objectType = objectType.getImplicitPrototype();
          }
        }

        // Don't show complex function names or anonymous types.
        // Instead, try to get a human-readable type name.
        if (objectType != null &&
            (objectType.getConstructor() != null ||
             objectType.isFunctionPrototypeType())) {
          return objectType.toString() + ""."" + propName;
        }
      }
    }

    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
      return qualifiedName;
    } else if (type.isFunctionType()) {
      // Don't show complex function names.
      return ""function"";
    } else {
      return type.toString();
    }
  }","String getReadableJSTypeName(Node n, boolean dereference) {
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            ObjectType topDefiningInterface = FunctionType.getTopDefiningInterface(objectType, propName);
            if (topDefiningInterface != null) {
                objectType = topDefiningInterface;
            } else {
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }

            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }

    JSType type = getJSType(n);
    if (type == null) {
        return ""unknown"";
    }
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        return ""function"";
    } else {
        return type.toString();
    }
}",2,0
30,Closure_117,"String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
      ObjectType objectType = getJSType(n.getFirstChild()).dereference();
      if (objectType != null) {
        String propName = n.getLastChild().getString();
        if (objectType.getConstructor() != null &&
            objectType.getConstructor().isInterface()) {
          objectType = FunctionType.getTopDefiningInterface(
              objectType, propName);
        } else {
          // classes
          while (objectType != null && !objectType.hasOwnProperty(propName)) {
            objectType = objectType.getImplicitPrototype();
          }
        }

        // Don't show complex function names or anonymous types.
        // Instead, try to get a human-readable type name.
        if (objectType != null &&
            (objectType.getConstructor() != null ||
             objectType.isFunctionPrototypeType())) {
          return objectType.toString() + ""."" + propName;
        }
      }
    }

    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
      return qualifiedName;
    } else if (type.isFunctionType()) {
      // Don't show complex function names.
      return ""function"";
    } else {
      return type.toString();
    }
  }","String getReadableJSTypeName(Node n, boolean dereference) {
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            while (objectType != null && !objectType.hasOwnProperty(propName)) {
                objectType = objectType.getImplicitPrototype();
            }

            if (objectType != null) {
                if (objectType.getConstructor() != null) {
                    JSType constructorType = objectType.getConstructor();
                    if (constructorType instanceof FunctionType && ((FunctionType) constructorType).isInterface()) {
                        objectType = FunctionType.getTopDefiningInterface(objectType, propName);
                    }
                }

                return objectType.toString() + ""."" + propName;
            }
        }
    }

    JSType type = getJSType(n);
    if (type == null) {
        return ""unknown"";
    }
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    return qualifiedName != null ? qualifiedName : (type.isFunctionType() ? ""function"" : type.toString());
}",3,0
30,Closure_117,"String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
      ObjectType objectType = getJSType(n.getFirstChild()).dereference();
      if (objectType != null) {
        String propName = n.getLastChild().getString();
        if (objectType.getConstructor() != null &&
            objectType.getConstructor().isInterface()) {
          objectType = FunctionType.getTopDefiningInterface(
              objectType, propName);
        } else {
          // classes
          while (objectType != null && !objectType.hasOwnProperty(propName)) {
            objectType = objectType.getImplicitPrototype();
          }
        }

        // Don't show complex function names or anonymous types.
        // Instead, try to get a human-readable type name.
        if (objectType != null &&
            (objectType.getConstructor() != null ||
             objectType.isFunctionPrototypeType())) {
          return objectType.toString() + ""."" + propName;
        }
      }
    }

    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
      return qualifiedName;
    } else if (type.isFunctionType()) {
      // Don't show complex function names.
      return ""function"";
    } else {
      return type.toString();
    }
  }","String getReadableJSTypeName(Node n, boolean dereference) {
    // The best type name is the actual type name.
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            ObjectType originalType = objectType;
            
            // classes and interfaces
            while (objectType != null && !objectType.hasOwnProperty(propName)) {
                objectType = objectType.getImplicitPrototype();
            }

            if (objectType != null) {
                if (originalType.getConstructor() != null && originalType.getConstructor().isInterface()) {
                    objectType = FunctionType.getTopDefiningInterface(originalType, propName);
                }
                return objectType.toString() + ""."" + propName;
            }
        }
    }

    JSType type = getJSType(n);
    if (type == null) {
        return ""unknown"";
    }
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        return ""function"";
    } else {
        return type.toString();
    }
}",4,0
31,Closure_118,"private void handleObjectLit(NodeTraversal t, Node n) {
      for (Node child = n.getFirstChild();
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
          // TODO(user): It doesn't look like the user can do much in this
          // case right now.
          if (propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(
                t.getSourceName(), child, propertiesToErrorFor.get(name),
                Warnings.INVALIDATION, name,
                (type == null ? ""null"" : type.toString()), n.toString(), """"));
          }
        }
      }
    }","private void handleObjectLit(NodeTraversal t, Node n) {
    for (Node child = n.getFirstChild();
         child != null;
         child = child.getNext()) {
        // Maybe STRING, GET, SET
        
        // We should never see a mix of numbers and strings.
        if (!child.isString()) {
            continue;
        }

        String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
            // TODO:user: It doesn't look like the user can do much in this
            // case right now.
            if (propertiesToErrorFor.containsKey(name)) {
                compiler.report(JSError.make(
                    t.getSourceName(), child, propertiesToErrorFor.get(name),
                    Warnings.INVALIDATION, name,
                    (type == null ? ""null"" : type.toString()), n.toString(), """"));
            }
        }
    }
}",0,0
31,Closure_118,"private void handleObjectLit(NodeTraversal t, Node n) {
      for (Node child = n.getFirstChild();
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
          // TODO(user): It doesn't look like the user can do much in this
          // case right now.
          if (propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(
                t.getSourceName(), child, propertiesToErrorFor.get(name),
                Warnings.INVALIDATION, name,
                (type == null ? ""null"" : type.toString()), n.toString(), """"));
          }
        }
      }
    }","private void handleObjectLit(NodeTraversal t, Node n) {
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        // Check if node is a string, else skip it
        if (child.isString()) {
            String name = child.getString();
            T type = typeSystem.getType(getScope(), n, name);
            
            Property prop = getProperty(name);
            if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) {
                // Report an error if necessary
                if (propertiesToErrorFor.containsKey(name)) {
                    compiler.report(JSError.make(
                        t.getSourceName(), child, propertiesToErrorFor.get(name),
                        Warnings.INVALIDATION, name,
                        (type == null ? ""null"" : type.toString()), n.toString(), """"));
                }
            }
        }
    }
}",1,0
31,Closure_118,"private void handleObjectLit(NodeTraversal t, Node n) {
      for (Node child = n.getFirstChild();
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
          // TODO(user): It doesn't look like the user can do much in this
          // case right now.
          if (propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(
                t.getSourceName(), child, propertiesToErrorFor.get(name),
                Warnings.INVALIDATION, name,
                (type == null ? ""null"" : type.toString()), n.toString(), """"));
          }
        }
      }
    }","private void handleObjectLit(NodeTraversal t, Node n) {
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        // Ensure we only process string nodes
        if (child.isString()) {
            String name = child.getString();
            T type = typeSystem.getType(getScope(), n, name);

            // Ensure type is not null before proceeding
            if (type != null) {
                Property prop = getProperty(name);
                if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) {
                    // Log a compiler error if necessary
                    if (propertiesToErrorFor.containsKey(name)) {
                        compiler.report(JSError.make(t.getSourceName(), child,
                            propertiesToErrorFor.get(name), Warnings.INVALIDATION,
                            name, type.toString(), n.toString(), """"));
                    }
                }
            } else {
                // Handle case where type is null, possibly logging or setting a default
                // (Adjust this part based on logical requirements beyond simple null check)
                compiler.report(JSError.make(t.getSourceName(), child,
                    Warnings.INVALIDATION, name, ""null"", n.toString(), """"));
            }
        }
    }
}",2,0
31,Closure_118,"private void handleObjectLit(NodeTraversal t, Node n) {
      for (Node child = n.getFirstChild();
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
          // TODO(user): It doesn't look like the user can do much in this
          // case right now.
          if (propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(
                t.getSourceName(), child, propertiesToErrorFor.get(name),
                Warnings.INVALIDATION, name,
                (type == null ? ""null"" : type.toString()), n.toString(), """"));
          }
        }
      }
    }","private void handleObjectLit(NodeTraversal t, Node n) {
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        // Validate if the child is a STRING, GET, or SET node
        if (child.isString() || child.isGetProp() || child.isSetProp()) {
            String name = child.getString();
            T type = typeSystem.getType(getScope(), n, name);

            // Only process if the type is valid for renaming
            if (type != null) {
                Property prop = getProperty(name);
                boolean renamed = processProperty(t, prop, type, child);
                if (!renamed && propertiesToErrorFor.containsKey(name)) {
                    compiler.report(JSError.make(
                        t.getSourceName(), child, propertiesToErrorFor.get(name),
                        Warnings.INVALIDATION, name, type.toString(), n.toString()));
                }
            }
        }
    }
}",3,0
31,Closure_118,"private void handleObjectLit(NodeTraversal t, Node n) {
      for (Node child = n.getFirstChild();
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child,
                                   processProperty(t, prop, type, null))) {
          // TODO(user): It doesn't look like the user can do much in this
          // case right now.
          if (propertiesToErrorFor.containsKey(name)) {
            compiler.report(JSError.make(
                t.getSourceName(), child, propertiesToErrorFor.get(name),
                Warnings.INVALIDATION, name,
                (type == null ? ""null"" : type.toString()), n.toString(), """"));
          }
        }
      }
    }","private void handleObjectLit(NodeTraversal t, Node n) {
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        // Ensure we are dealing with strings only to avoid mix with numbers
        if (!child.isString()) {
            continue;
        }
        
        String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);

        // Handle case where type could be null
        if (type == null) {
            // If type is null, we don't proceed with scheduling or processing
            compiler.report(JSError.make(t.getSourceName(), child, Warnings.INVALID_ARGUMENT, name, ""null"", n.toString()));
            continue;
        }

        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) {
            // If scheduling failed, report an error
            if (propertiesToErrorFor.containsKey(name)) {
                compiler.report(JSError.make(
                    t.getSourceName(), child, propertiesToErrorFor.get(name),
                    Warnings.INVALIDATION, name, type.toString(), n.toString(), """"));
            }
        }
    }
}",4,0
32,Closure_119,"public void collect(JSModule module, Scope scope, Node n) {
      Node parent = n.getParent();

      String name;
      boolean isSet = false;
      Name.Type type = Name.Type.OTHER;
      boolean isPropAssign = false;

      switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
          // This may be a key in an object literal declaration.
          name = null;
          if (parent != null && parent.isObjectLit()) {
            name = getNameForObjLitKey(n);
          }
          if (name == null) {
            return;
          }
          isSet = true;
          switch (n.getType()) {
            case Token.STRING_KEY:
              type = getValueType(n.getFirstChild());
              break;
            case Token.GETTER_DEF:
              type = Name.Type.GET;
              break;
            case Token.SETTER_DEF:
              type = Name.Type.SET;
              break;
            default:
              throw new IllegalStateException(""unexpected:"" + n);
          }
          break;
        case Token.NAME:
          // This may be a variable get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.VAR:
                isSet = true;
                Node rvalue = n.getFirstChild();
                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                break;
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                }
                break;
              case Token.GETPROP:
                return;
              case Token.FUNCTION:
                Node gramps = parent.getParent();
                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                  return;
                }
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
                type = Name.Type.OTHER;
                break;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getString();
          break;
        case Token.GETPROP:
          // This may be a namespaced name get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                  isPropAssign = true;
                }
                break;
              case Token.INC:
              case Token.DEC:
                isSet = true;
                type = Name.Type.OTHER;
                break;
              case Token.GETPROP:
                return;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getQualifiedName();
          if (name == null) {
            return;
          }
          break;
        default:
          return;
      }

      // We are only interested in global names.
      if (!isGlobalNameReference(name, scope)) {
        return;
      }

      if (isSet) {
        if (isGlobalScope(scope)) {
          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
          handleSetFromLocal(module, scope, n, parent, name);
        }
      } else {
        handleGet(module, scope, n, parent, name);
      }
    }","public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();

    if (parent == null) {
        return;
    }

    String name;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;

    switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            name = null;
            if (parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
            }
            if (name == null) {
                return;
            }
            isSet = true;
            switch (n.getType()) {
                case Token.STRING_KEY:
                    type = getValueType(n.getFirstChild());
                    break;
                case Token.GETTER_DEF:
                    type = Name.Type.GET;
                    break;
                case Token.SETTER_DEF:
                    type = Name.Type.SET;
                    break;
                default:
                    throw new IllegalStateException(""unexpected:"" + n);
            }
            break;
        case Token.NAME:
            switch (parent.getType()) {
                case Token.VAR:
                    isSet = true;
                    Node rvalue = n.getFirstChild();
                    type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                    break;
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                    }
                    break;
                case Token.GETPROP:
                    return;
                case Token.FUNCTION:
                    Node gramps = parent.getParent();
                    if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                        return;
                    }
                    isSet = true;
                    type = Name.Type.FUNCTION;
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getString();
            break;
        case Token.GETPROP:
            switch (parent.getType()) {
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                        isPropAssign = true;
                    }
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                case Token.GETPROP:
                    return;
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;
        default:
            return;
    }

    // Ensure name is a global name reference before processing further
    if (!isGlobalNameReference(name, scope)) {
        return;
    }

    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}",0,0
32,Closure_119,"public void collect(JSModule module, Scope scope, Node n) {
      Node parent = n.getParent();

      String name;
      boolean isSet = false;
      Name.Type type = Name.Type.OTHER;
      boolean isPropAssign = false;

      switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
          // This may be a key in an object literal declaration.
          name = null;
          if (parent != null && parent.isObjectLit()) {
            name = getNameForObjLitKey(n);
          }
          if (name == null) {
            return;
          }
          isSet = true;
          switch (n.getType()) {
            case Token.STRING_KEY:
              type = getValueType(n.getFirstChild());
              break;
            case Token.GETTER_DEF:
              type = Name.Type.GET;
              break;
            case Token.SETTER_DEF:
              type = Name.Type.SET;
              break;
            default:
              throw new IllegalStateException(""unexpected:"" + n);
          }
          break;
        case Token.NAME:
          // This may be a variable get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.VAR:
                isSet = true;
                Node rvalue = n.getFirstChild();
                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                break;
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                }
                break;
              case Token.GETPROP:
                return;
              case Token.FUNCTION:
                Node gramps = parent.getParent();
                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                  return;
                }
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
                type = Name.Type.OTHER;
                break;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getString();
          break;
        case Token.GETPROP:
          // This may be a namespaced name get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                  isPropAssign = true;
                }
                break;
              case Token.INC:
              case Token.DEC:
                isSet = true;
                type = Name.Type.OTHER;
                break;
              case Token.GETPROP:
                return;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getQualifiedName();
          if (name == null) {
            return;
          }
          break;
        default:
          return;
      }

      // We are only interested in global names.
      if (!isGlobalNameReference(name, scope)) {
        return;
      }

      if (isSet) {
        if (isGlobalScope(scope)) {
          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
          handleSetFromLocal(module, scope, n, parent, name);
        }
      } else {
        handleGet(module, scope, n, parent, name);
      }
    }","public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();
    
    if (parent == null) {
        return;
    }

    String name = null;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;

    switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            if (parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
                if (name != null) {
                    isSet = true;
                    switch (n.getType()) {
                        case Token.STRING_KEY:
                            type = getValueType(n.getFirstChild());
                            break;
                        case Token.GETTER_DEF:
                            type = Name.Type.GET;
                            break;
                        case Token.SETTER_DEF:
                            type = Name.Type.SET;
                            break;
                    }
                }
            }
            break;
        case Token.NAME:
            switch (parent.getType()) {
                case Token.VAR:
                    isSet = true;
                    Node rvalue = n.getFirstChild();
                    type = (rvalue != null) ? getValueType(rvalue) : Name.Type.OTHER;
                    break;
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                    }
                    break;
                case Token.GETPROP:
                    return;
                case Token.FUNCTION:
                    Node gramps = parent.getParent();
                    if (gramps != null && !NodeUtil.isFunctionExpression(parent)) {
                        isSet = true;
                        type = Name.Type.FUNCTION;
                    }
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getString();
            break;
        case Token.GETPROP:
            switch (parent.getType()) {
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                        isPropAssign = true;
                    }
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;
        default:
            return;
    }

    if (!isGlobalNameReference(name, scope)) {
        return;
    }

    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}",1,0
32,Closure_119,"public void collect(JSModule module, Scope scope, Node n) {
      Node parent = n.getParent();

      String name;
      boolean isSet = false;
      Name.Type type = Name.Type.OTHER;
      boolean isPropAssign = false;

      switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
          // This may be a key in an object literal declaration.
          name = null;
          if (parent != null && parent.isObjectLit()) {
            name = getNameForObjLitKey(n);
          }
          if (name == null) {
            return;
          }
          isSet = true;
          switch (n.getType()) {
            case Token.STRING_KEY:
              type = getValueType(n.getFirstChild());
              break;
            case Token.GETTER_DEF:
              type = Name.Type.GET;
              break;
            case Token.SETTER_DEF:
              type = Name.Type.SET;
              break;
            default:
              throw new IllegalStateException(""unexpected:"" + n);
          }
          break;
        case Token.NAME:
          // This may be a variable get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.VAR:
                isSet = true;
                Node rvalue = n.getFirstChild();
                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                break;
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                }
                break;
              case Token.GETPROP:
                return;
              case Token.FUNCTION:
                Node gramps = parent.getParent();
                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                  return;
                }
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
                type = Name.Type.OTHER;
                break;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getString();
          break;
        case Token.GETPROP:
          // This may be a namespaced name get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                  isPropAssign = true;
                }
                break;
              case Token.INC:
              case Token.DEC:
                isSet = true;
                type = Name.Type.OTHER;
                break;
              case Token.GETPROP:
                return;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getQualifiedName();
          if (name == null) {
            return;
          }
          break;
        default:
          return;
      }

      // We are only interested in global names.
      if (!isGlobalNameReference(name, scope)) {
        return;
      }

      if (isSet) {
        if (isGlobalScope(scope)) {
          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
          handleSetFromLocal(module, scope, n, parent, name);
        }
      } else {
        handleGet(module, scope, n, parent, name);
      }
    }","public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();
    if (parent == null) {
        return;
    }

    String name = null;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;

    switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            if (parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
                if (name == null) {
                    return;
                }
                isSet = true;
                switch (n.getType()) {
                    case Token.STRING_KEY:
                        type = getValueType(n.getFirstChild());
                        break;
                    case Token.GETTER_DEF:
                        type = Name.Type.GET;
                        break;
                    case Token.SETTER_DEF:
                        type = Name.Type.SET;
                        break;
                }
            }
            break;
        case Token.NAME:
            switch (parent.getType()) {
                case Token.VAR:
                    isSet = true;
                    Node rvalue = n.getFirstChild();
                    type = (rvalue != null) ? getValueType(rvalue) : Name.Type.OTHER;
                    break;
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                    }
                    break;
                case Token.GETPROP:
                case Token.CATCH:
                    name = n.getString();
                    if (name.equals(""e"")) {  // Handle special case for catch variable
                        return;
                    }
                    break;
                case Token.FUNCTION:
                    Node gramps = parent.getParent();
                    if (gramps != null && !NodeUtil.isFunctionExpression(parent)) {
                        isSet = true;
                        type = Name.Type.FUNCTION;
                    }
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getString();
            break;
        case Token.GETPROP:
            switch (parent.getType()) {
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                        isPropAssign = true;
                    }
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;
        default:
            return;
    }

    if (!isGlobalNameReference(name, scope)) {
        return;
    }

    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}",2,0
32,Closure_119,"public void collect(JSModule module, Scope scope, Node n) {
      Node parent = n.getParent();

      String name;
      boolean isSet = false;
      Name.Type type = Name.Type.OTHER;
      boolean isPropAssign = false;

      switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
          // This may be a key in an object literal declaration.
          name = null;
          if (parent != null && parent.isObjectLit()) {
            name = getNameForObjLitKey(n);
          }
          if (name == null) {
            return;
          }
          isSet = true;
          switch (n.getType()) {
            case Token.STRING_KEY:
              type = getValueType(n.getFirstChild());
              break;
            case Token.GETTER_DEF:
              type = Name.Type.GET;
              break;
            case Token.SETTER_DEF:
              type = Name.Type.SET;
              break;
            default:
              throw new IllegalStateException(""unexpected:"" + n);
          }
          break;
        case Token.NAME:
          // This may be a variable get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.VAR:
                isSet = true;
                Node rvalue = n.getFirstChild();
                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                break;
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                }
                break;
              case Token.GETPROP:
                return;
              case Token.FUNCTION:
                Node gramps = parent.getParent();
                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                  return;
                }
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
                type = Name.Type.OTHER;
                break;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getString();
          break;
        case Token.GETPROP:
          // This may be a namespaced name get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                  isPropAssign = true;
                }
                break;
              case Token.INC:
              case Token.DEC:
                isSet = true;
                type = Name.Type.OTHER;
                break;
              case Token.GETPROP:
                return;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getQualifiedName();
          if (name == null) {
            return;
          }
          break;
        default:
          return;
      }

      // We are only interested in global names.
      if (!isGlobalNameReference(name, scope)) {
        return;
      }

      if (isSet) {
        if (isGlobalScope(scope)) {
          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
          handleSetFromLocal(module, scope, n, parent, name);
        }
      } else {
        handleGet(module, scope, n, parent, name);
      }
    }","public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();
    if (parent == null) {
        return;
    }

    String name = null;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;

    switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            if (parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
                if (name == null) {
                    return;
                }
                isSet = true;
                switch (n.getType()) {
                    case Token.STRING_KEY:
                        type = getValueType(n.getFirstChild());
                        break;
                    case Token.GETTER_DEF:
                        type = Name.Type.GET;
                        break;
                    case Token.SETTER_DEF:
                        type = Name.Type.SET;
                        break;
                }
            }
            break;
        case Token.NAME:
            switch (parent.getType()) {
                case Token.VAR:
                    isSet = true;
                    Node rvalue = n.getFirstChild();
                    type = (rvalue != null) ? getValueType(rvalue) : Name.Type.OTHER;
                    break;
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                    }
                    break;
                case Token.GETPROP:
                    return;
                case Token.FUNCTION:
                    Node gramps = parent.getParent();
                    if (gramps != null && !NodeUtil.isFunctionExpression(parent)) {
                        isSet = true;
                        type = Name.Type.FUNCTION;
                    }
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                case Token.CATCH: // Handle catch variable edge case
                    name = n.getString();
                    if (""e"".equals(name)) {
                        return;
                    }
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getString();
            break;
        case Token.GETPROP:
            switch (parent.getType()) {
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                        isPropAssign = true;
                    }
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;
        default:
            return;
    }

    if (!isGlobalNameReference(name, scope)) {
        return;
    }

    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}",3,0
32,Closure_119,"public void collect(JSModule module, Scope scope, Node n) {
      Node parent = n.getParent();

      String name;
      boolean isSet = false;
      Name.Type type = Name.Type.OTHER;
      boolean isPropAssign = false;

      switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
          // This may be a key in an object literal declaration.
          name = null;
          if (parent != null && parent.isObjectLit()) {
            name = getNameForObjLitKey(n);
          }
          if (name == null) {
            return;
          }
          isSet = true;
          switch (n.getType()) {
            case Token.STRING_KEY:
              type = getValueType(n.getFirstChild());
              break;
            case Token.GETTER_DEF:
              type = Name.Type.GET;
              break;
            case Token.SETTER_DEF:
              type = Name.Type.SET;
              break;
            default:
              throw new IllegalStateException(""unexpected:"" + n);
          }
          break;
        case Token.NAME:
          // This may be a variable get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.VAR:
                isSet = true;
                Node rvalue = n.getFirstChild();
                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                break;
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                }
                break;
              case Token.GETPROP:
                return;
              case Token.FUNCTION:
                Node gramps = parent.getParent();
                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                  return;
                }
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
                type = Name.Type.OTHER;
                break;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getString();
          break;
        case Token.GETPROP:
          // This may be a namespaced name get or set.
          if (parent != null) {
            switch (parent.getType()) {
              case Token.ASSIGN:
                if (parent.getFirstChild() == n) {
                  isSet = true;
                  type = getValueType(n.getNext());
                  isPropAssign = true;
                }
                break;
              case Token.INC:
              case Token.DEC:
                isSet = true;
                type = Name.Type.OTHER;
                break;
              case Token.GETPROP:
                return;
              default:
                if (NodeUtil.isAssignmentOp(parent) &&
                    parent.getFirstChild() == n) {
                  isSet = true;
                  type = Name.Type.OTHER;
                }
            }
          }
          name = n.getQualifiedName();
          if (name == null) {
            return;
          }
          break;
        default:
          return;
      }

      // We are only interested in global names.
      if (!isGlobalNameReference(name, scope)) {
        return;
      }

      if (isSet) {
        if (isGlobalScope(scope)) {
          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
          handleSetFromLocal(module, scope, n, parent, name);
        }
      } else {
        handleGet(module, scope, n, parent, name);
      }
    }","public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();
    if (parent == null) {
        return;
    }

    String name = null;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;

    switch (n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            if (parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
                if (name == null) {
                    return;
                }
                isSet = true;
                switch (n.getType()) {
                    case Token.STRING_KEY:
                        type = getValueType(n.getFirstChild());
                        break;
                    case Token.GETTER_DEF:
                        type = Name.Type.GET;
                        break;
                    case Token.SETTER_DEF:
                        type = Name.Type.SET;
                        break;
                }
            }
            break;
        case Token.NAME:
            switch (parent.getType()) {
                case Token.VAR:
                    isSet = true;
                    Node rvalue = n.getFirstChild();
                    type = (rvalue != null) ? getValueType(rvalue) : Name.Type.OTHER;
                    break;
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                    }
                    break;
                case Token.GETPROP:
                    return;
                case Token.FUNCTION:
                    Node gramps = parent.getParent();
                    if (gramps != null && !NodeUtil.isFunctionExpression(parent)) {
                        isSet = true;
                        type = Name.Type.FUNCTION;
                    }
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                case Token.CATCH:
                    return; // Ignore catch block variables for global name processing
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getString();
            break;
        case Token.GETPROP:
            switch (parent.getType()) {
                case Token.ASSIGN:
                    if (parent.getFirstChild() == n) {
                        isSet = true;
                        type = getValueType(n.getNext());
                        isPropAssign = true;
                    }
                    break;
                case Token.INC:
                case Token.DEC:
                    isSet = true;
                    type = Name.Type.OTHER;
                    break;
                default:
                    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                        isSet = true;
                        type = Name.Type.OTHER;
                    }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;
        default:
            return;
    }

    if (!isGlobalNameReference(name, scope)) {
        return;
    }

    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}",4,0
33,Closure_12,"    public ReachingUses apply(List<ReachingUses> from) {
      ReachingUses result = new ReachingUses();
      for (ReachingUses uses : from) {
        result.mayUseMap.putAll(uses.mayUseMap);
      }
      return result;
    }
","public ReachingUses apply(List<ReachingUses> from) {
    ReachingUses result = new ReachingUses();
    for (ReachingUses uses : from) {
        if (uses != null && uses.mayUseMap != null) {
            result.mayUseMap.putAll(uses.mayUseMap);
        }
    }
    return result;
}",0,0
33,Closure_12,"    public ReachingUses apply(List<ReachingUses> from) {
      ReachingUses result = new ReachingUses();
      for (ReachingUses uses : from) {
        result.mayUseMap.putAll(uses.mayUseMap);
      }
      return result;
    }
","public ReachingUses apply(List<ReachingUses> from) {
    ReachingUses result = new ReachingUses();
    for (ReachingUses uses : from) {
        if (uses != null && uses.mayUseMap != null) {
            for (Map.Entry<String, Object> entry : uses.mayUseMap.entrySet()) {
                result.mayUseMap.putIfAbsent(entry.getKey(), entry.getValue());
            }
        }
    }
    return result;
}",1,0
33,Closure_12,"    public ReachingUses apply(List<ReachingUses> from) {
      ReachingUses result = new ReachingUses();
      for (ReachingUses uses : from) {
        result.mayUseMap.putAll(uses.mayUseMap);
      }
      return result;
    }
","public ReachingUses apply(List<ReachingUses> from) {
    ReachingUses result = new ReachingUses();
    for (ReachingUses uses : from) {
        if (uses != null && uses.mayUseMap != null) {
            for (Map.Entry<String, Object> entry : uses.mayUseMap.entrySet()) {
                result.mayUseMap.merge(entry.getKey(), entry.getValue(), (v1, v2) -> v2);
            }
        }
    }
    return result;
}",2,0
33,Closure_12,"    public ReachingUses apply(List<ReachingUses> from) {
      ReachingUses result = new ReachingUses();
      for (ReachingUses uses : from) {
        result.mayUseMap.putAll(uses.mayUseMap);
      }
      return result;
    }
","public ReachingUses apply(List<ReachingUses> from) {
    ReachingUses result = new ReachingUses();
    for (ReachingUses uses : from) {
        if (uses != null && uses.mayUseMap != null) {
            for (Map.Entry<String, Object> entry : uses.mayUseMap.entrySet()) {
                if (result.mayUseMap.containsKey(entry.getKey())) {
                    // Handle the conflict using a custom resolution strategy, e.g., merge the values
                    Object existingValue = result.mayUseMap.get(entry.getKey());
                    Object resolvedValue = resolveConflict(existingValue, entry.getValue());
                    result.mayUseMap.put(entry.getKey(), resolvedValue);
                } else {
                    result.mayUseMap.put(entry.getKey(), entry.getValue());
                }
            }
        }
    }
    return result;
}

private Object resolveConflict(Object existingValue, Object newValue) {
    // Custom logic to resolve conflicts between old and new values
    // For this example, we are assuming new value overrides old value
    return newValue;
}",3,0
33,Closure_12,"    public ReachingUses apply(List<ReachingUses> from) {
      ReachingUses result = new ReachingUses();
      for (ReachingUses uses : from) {
        result.mayUseMap.putAll(uses.mayUseMap);
      }
      return result;
    }
","public ReachingUses apply(List<ReachingUses> from) {
    ReachingUses result = new ReachingUses();
    for (ReachingUses uses : from) {
        if (uses != null && uses.mayUseMap != null) {
            uses.mayUseMap.forEach((key, value) -> {
                if (result.mayUseMap.containsKey(key)) {
                    result.mayUseMap.put(key, combineValues(result.mayUseMap.get(key), value));
                } else {
                    result.mayUseMap.put(key, value);
                }
            });
        }
    }
    return result;
}

private Object combineValues(Object oldValue, Object newValue) {
    // Logic to combine values, e.g., list aggregation or choosing the newer value
    return newValue; // For simplicity, override with the new value
}",4,0
34,Closure_120,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
      }

      // Make sure this assignment is not in a loop.
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
        }
      }

      return true;
    }","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }

    // Make sure this assignment is not in a loop.
    BasicBlock block = ref.getBasicBlock();
    while (block != null) {
        if (block.isFunction) {
            break;
        } else if (block.isLoop()) { // Fixed: Added parentheses to correctly call isLoop method
            return false;
        }
        block = block.getParent(); // Fixed: Properly update the block for the next iteration
    }

    return true;
}",0,0
34,Closure_120,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
      }

      // Make sure this assignment is not in a loop.
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
        }
      }

      return true;
    }","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }

    // Check if the assignment is in a loop or function block
    boolean inLoop = false;
    for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {
        if (block.isFunction) {
            break;
        }
        if (block.isLoop()) {
            inLoop = true;
        }
    }

    // Return false if in loop; otherwise true
    return !inLoop;
}",1,0
34,Closure_120,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
      }

      // Make sure this assignment is not in a loop.
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
        }
      }

      return true;
    }","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }

    // Check if the assignment is within a loop or function block using advanced logic
    BasicBlock block = ref.getBasicBlock();
    while (block != null) {
        if (block.isFunction) {
            return true; // Allow assignment if it is in a function block
        }
        if (block.isLoop()) {
            if (block.hasMultipleCalls(ref)) { // Ensure no redundant calls within the loop
                return false;
            }
        }
        block = block.getParent();
    }

    // Assume once if not found to be redundant in loop scope
    return true;
}",2,0
34,Closure_120,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
      }

      // Make sure this assignment is not in a loop.
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
        }
      }

      return true;
    }","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }

    // Ensure assignment is not within a loop by explicitly marking loops and functions
    BasicBlock block = ref.getBasicBlock();
    while (block != null) {
        if (block.isFunction) {
            return true; // If within a function block, assume assignment is valid
        }
        if (block.isLoop()) {
            return false; // If within a loop, assignment is invalid
        }
        block = block.getParent();
    }

    // If no loops or functions involved, assume it was a once-time assignment
    return true;
}",3,0
34,Closure_120,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
      }

      // Make sure this assignment is not in a loop.
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
        }
      }

      return true;
    }","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }

    // Ensure assignment is not within a loop or redundant by checking parent blocks carefully
    BasicBlock block = ref.getBasicBlock();
    while (block != null) {
        if (block.isFunction()) {
            return true; // Consider valid if within a function block
        } else if (block.isLoop() && block.referencesInside(ref)) {
            return false; // Invalid if loop contains references to the assignment
        }
        block = block.getParent();
    }

    // Assume valid if no disqualifying conditions are found
    return true;
}",4,0
35,Closure_121,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;

    if (refCount > 1 &&
        isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // Handle well-defined immutable variables
        Node value = (init != null) ? init.getAssignedValue() : NodeUtil.newUndefinedNode(declaration.getNode());
        if (value != null) {
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    } else if (refCount == firstRefAfterInit) {
        // Handle single usage with extra heuristics
        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        // Handle special case with only initialization reference
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            Node value = init.getAssignedValue();
            if (value != null) {
                inlineWellDefinedVariable(v, value, referenceInfo.references);
                staleVars.add(v);
            }
        }
    }

    // Handle alias inlining if applicable
    if (!maybeModifiedArguments &&
        !staleVars.contains(v) &&
        referenceInfo.isWellDefined() &&
        referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) &&
                    !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit = candidate.refInfo.getInitializingReference();
                    if (aliasInit != null) {
                        Node value = aliasInit.getAssignedValue();
                        if (value != null) {
                            inlineWellDefinedVariable(candidate.alias,
                                value,
                                candidate.refInfo.references);
                            staleVars.add(candidate.alias);
                        }
                    }
                }
            }
        }
    }
}",0,0
35,Closure_121,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
    // Adjust the logic for better handling of initialization and reference checks
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;

    if (refCount > 1 &&
        isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // Inline only if the variable is immutable and initialization is valid
        if (init == null || !isValidInitialization(init)) {
            return; // Skip invalid initialization cases
        }
        Node value = init.getAssignedValue();
        if (value != null) {
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    } else if (refCount == firstRefAfterInit) {
        // Handle single usage with stricter checks
        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference) &&
            isValidDeclaration(declaration) &&
            (init == null || isValidInitialization(init))) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        // Only inline if both declaration and initialization are valid
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            Node value = init.getAssignedValue();
            if (value != null) {
                inlineWellDefinedVariable(v, value, referenceInfo.references);
                staleVars.add(v);
            }
        }
    }

    // Alias inlining requires stricter criteria now, ensuring only one valid alias
    if (!maybeModifiedArguments &&
        !staleVars.contains(v) &&
        referenceInfo.isWellDefined() &&
        referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) &&
                    !isVarInlineForbidden(candidate.alias) &&
                    candidate.refInfo.isAssignedOnceInLifetime()) {
                    Reference aliasInit = candidate.refInfo.getInitializingReference();
                    if (aliasInit != null) {
                        Node value = aliasInit.getAssignedValue();
                        if (value != null) {
                            inlineWellDefinedVariable(candidate.alias,
                                value,
                                candidate.refInfo.references);
                            staleVars.add(candidate.alias);
                        }
                    }
                }
            }
        }
    }
}",1,0
35,Closure_121,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;

    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        Node value = (init != null) ? init.getAssignedValue() : NodeUtil.newUndefinedNode(declaration.getNode());
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == firstRefAfterInit) {
        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }

    if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit = candidate.refInfo.getInitializingReference();
                    if (aliasInit != null) {
                        Node value = aliasInit.getAssignedValue();
                        Preconditions.checkNotNull(value);
                        inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                        staleVars.add(candidate.alias);
                    }
                }
            }
        }
    }
}",2,0
35,Closure_121,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;

    if (refCount > 1 &&
        isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        Node value;
        if (init != null) {
            value = init.getAssignedValue();
        } else {
            Node srcLocation = declaration.getNode();
            value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == firstRefAfterInit) {
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)
            && !referenceInfo.references.contains(init)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) &&
            isValidInitialization(init) &&
            !referenceInfo.references.contains(init)) {
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }

    if (!maybeModifiedArguments &&
        !staleVars.contains(v) &&
        referenceInfo.isWellDefined() &&
        referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) &&
                    !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit;
                    aliasInit = candidate.refInfo.getInitializingReference();
                    if (aliasInit != null && !referenceInfo.references.contains(aliasInit)) {
                        Node value = aliasInit.getAssignedValue();
                        Preconditions.checkNotNull(value);
                        inlineWellDefinedVariable(candidate.alias,
                            value,
                            candidate.refInfo.references);
                        staleVars.add(candidate.alias);
                    }
                }
            }
        }
    }
}",3,0
35,Closure_121,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }","private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;

    if (refCount > 1 &&
        isImmutableAndWellDefinedVariable(v, referenceInfo) &&
        init != null) {
        // Ensure init is not null before processing immutable variables.
        Node value = init.getAssignedValue();
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == firstRefAfterInit) {
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init) && init != null) {
            // Add check to ensure init is not null.
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }

    if (!maybeModifiedArguments &&
        !staleVars.contains(v) &&
        referenceInfo.isWellDefined() &&
        referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) &&
                    !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit = candidate.refInfo.getInitializingReference();
                    if (aliasInit != null) {
                        Node value = aliasInit.getAssignedValue();
                        Preconditions.checkNotNull(value);
                        inlineWellDefinedVariable(candidate.alias,
                            value,
                            candidate.refInfo.references);
                        staleVars.add(candidate.alias);
                    }
                }
            }
        }
    }
}",4,0
36,Closure_122,"  private void handleBlockComment(Comment comment) {
    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
      errorReporter.warning(
          SUSPICIOUS_COMMENT_WARNING,
          sourceName,
          comment.getLineno(), """", 0);
    }
  }
","private void handleBlockComment(Comment comment) {
    String commentValue = comment.getValue();
    if (commentValue.contains(""/* @"") || commentValue.contains(""\n * @"")) {
        errorReporter.warning(
            SUSPICIOUS_COMMENT_WARNING,
            sourceName,
            comment.getLineno(), """", 0);
    }
}",0,0
36,Closure_122,"  private void handleBlockComment(Comment comment) {
    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
      errorReporter.warning(
          SUSPICIOUS_COMMENT_WARNING,
          sourceName,
          comment.getLineno(), """", 0);
    }
  }
","private void handleBlockComment(Comment comment) {
    String commentValue = comment.getValue();
    Pattern suspiciousPattern = Pattern.compile(""(?m)\\n \\* @|/\\* @"");
    Matcher matcher = suspiciousPattern.matcher(commentValue);
    if (matcher.find()) {
        errorReporter.warning(
            SUSPICIOUS_COMMENT_WARNING,
            sourceName,
            comment.getLineno(), """", 0);
    }
}",1,0
36,Closure_122,"  private void handleBlockComment(Comment comment) {
    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
      errorReporter.warning(
          SUSPICIOUS_COMMENT_WARNING,
          sourceName,
          comment.getLineno(), """", 0);
    }
  }
","private void handleBlockComment(Comment comment) {
    String commentValue = comment.getValue();
    if (commentValue.startsWith(""/* @"") || commentValue.contains(""\n * @"")) {
        errorReporter.warning(
            SUSPICIOUS_COMMENT_WARNING,
            sourceName,
            comment.getLineno(), """", 0);
    }
}",2,0
36,Closure_122,"  private void handleBlockComment(Comment comment) {
    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
      errorReporter.warning(
          SUSPICIOUS_COMMENT_WARNING,
          sourceName,
          comment.getLineno(), """", 0);
    }
  }
","private void handleBlockComment(Comment comment) {
    String commentValue = comment.getValue();
    if (commentValue.indexOf(""/* @"") >= 0 || commentValue.indexOf(""\n * @"") >= 0) {
        if (commentValue.substring(commentValue.indexOf(""/* @"")).contains(""@"")) {
            errorReporter.warning(
                SUSPICIOUS_COMMENT_WARNING,
                sourceName,
                comment.getLineno(), """", 0);
        }
    }
}",3,0
36,Closure_122,"  private void handleBlockComment(Comment comment) {
    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
      errorReporter.warning(
          SUSPICIOUS_COMMENT_WARNING,
          sourceName,
          comment.getLineno(), """", 0);
    }
  }
","private void handleBlockComment(Comment comment) {
    String commentValue = comment.getValue();
    int blockStart = commentValue.indexOf(""/* @"");
    int newLineStart = commentValue.indexOf(""\n * @"");

    if ((blockStart != -1 && commentValue.contains(""@"", blockStart + 3)) 
        || (newLineStart != -1 && commentValue.contains(""@"", newLineStart + 4))) {
        errorReporter.warning(
            SUSPICIOUS_COMMENT_WARNING,
            sourceName,
            comment.getLineno(), """", 0);
    }
}",4,0
37,Closure_123,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context,
            getContextForNoInOperator(context), 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // Unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top-level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3
            && TokenStream.isKeyword(last.getString())) {
          // Check for ECMASCRIPT3 keywords.
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(
            childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(
            childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString()
                && !(languageMode == LanguageMode.ECMASCRIPT3
                    && TokenStream.isKeyword(key))
                && TokenStream.isJSIdentifier(key)
                // do not encode literally any non-literal characters that
                // were Unicode escaped.
                && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(
            childCount == 2,
            ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
            opstr, childCount);
        int p = NodeUtil.precedence(type);

        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);

        // Ensure both children of binary operators are not null
        if (first != null && last != null) {
            if (last.getType() == type && NodeUtil.isAssociative(type)) {
                addExpr(first, p, context);
                cc.addOp(opstr, true);
                addExpr(last, p, rhsContext);
            } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
                // Assignments are the only right-associative binary operators
                addExpr(first, p, context);
                cc.addOp(opstr, true);
                addExpr(last, p, rhsContext);
            } else {
                unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
            }
            return;
        }
    }

    cc.startSourceMapping(n);

    switch (type) {
        case Token.TRY:
            Preconditions.checkState(first.getNext().isBlock() &&
                    !first.getNext().hasMoreThanOneChild());
            Preconditions.checkState(childCount >= 2 && childCount <= 3);

            add(""try"");
            add(first, Context.PRESERVE_BLOCK);

            // Second child contains the catch block, or nothing if there
            // isn't a catch block
            Node catchblock = first.getNext().getFirstChild();
            if (catchblock != null) {
                add(catchblock);
            }

            if (childCount == 3) {
                add(""finally"");
                add(last, Context.PRESERVE_BLOCK);
            }
            break;

        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;

        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);

            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;

        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;

        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;

        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;

        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;

        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;

        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;

        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context,
                getContextForNoInOperator(context), 0, 0);
            break;

        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;

        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            Preconditions.checkState(childCount == 1);
            cc.addOp(NodeUtil.opToStrNoFail(type), false);
            addExpr(first, NodeUtil.precedence(type), Context.OTHER);
            break;

        case Token.NEG:
            Preconditions.checkState(childCount == 1);

            if (n.getFirstChild().isNumber()) {
                cc.addNumber(-n.getFirstChild().getDouble());
            } else {
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
            }
            break;

        case Token.HOOK:
            Preconditions.checkState(childCount == 3);
            p = NodeUtil.precedence(type);
            rhsContext = Context.OTHER;
            addExpr(first, p + 1, context);
            cc.addOp(""?"", true);
            addExpr(first.getNext(), 1, rhsContext);
            cc.addOp("":"", true);
            addExpr(last, 1, rhsContext);
            break;

        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }

            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;

        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }

            add(""function"");
            add(first);

            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);

            if (funcNeedsParens) {
                add("")"");
            }
            break;

        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());

            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }

            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();

            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) &&
                NodeUtil.isLatin(name)) {
                add(name);
            } else {
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }

            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;

        case Token.SCRIPT:
        case Token.BLOCK:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            boolean preserveBlock = context == Context.PRESERVE_BLOCK;
            if (preserveBlock) {
                cc.beginBlock();
            }

            boolean preferLineBreaks =
                type == Token.SCRIPT ||
                (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
            for (Node c = first; c != null; c = c.getNext()) {
                add(c, Context.STATEMENT);

                if (c.isVar()) {
                    cc.endStatement();
                }

                if (c.isFunction()) {
                    cc.maybeLineBreak();
                }

                if (preferLineBreaks) {
                    cc.notePreferredLineBreak();
                }
            }
            if (preserveBlock) {
                cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
            }
            break;

        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;

        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;

        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;

        case Token.GETPROP:
            Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
            Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
            boolean needsParens = (first.isNumber());
            if (needsParens) {
                add(""("");
            }
            addExpr(first, NodeUtil.precedence(type), context);
            if (needsParens) {
                add("")"");
            }
            if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                add(""["");
                add(last);
                add(""]"");
            } else {
                add(""."");
                addIdentifier(last.getString());
            }
            break;

        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;

        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.INC:
        case Token.DEC:
            Preconditions.checkState(childCount == 1);
            String o = type == Token.INC ? ""++"" : ""--"";
            int postProp = n.getIntProp(Node.INCRDECR_PROP);
            if (postProp != 0) {
                addExpr(first, NodeUtil.precedence(type), context);
                cc.addOp(o, false);
            } else {
                cc.addOp(o, false);
                add(first);
            }
            break;

        case Token.CALL:
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;

        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }

            add(""if("");
            add(first);
            add("")"");

            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }

            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;

        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;

        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;

        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;

        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;

        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;

        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;

        case Token.NEW:
            add(""new "");
            precedence = NodeUtil.precedence(type);
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;

        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;

        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;

        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;

        case Token.OBJECTLIT:
            needsParens = (context == Context.START_OF_EXPR);
            if (needsParens) {
                add(""("");
            }
            add(""{"");
            for (Node c = first; c != null; c = c.getNext()) {
                if (c != first) {
                    cc.listSeparator();
                }

                if (c.isGetterDef() || c.isSetterDef()) {
                    add(c);
                } else {
                    Preconditions.checkState(c.isStringKey());
                    String key = c.getString();
                    if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key))
                        && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) {
                        add(key);
                    } else {
                        double d = getSimpleNumber(key);
                        if (!Double.isNaN(d)) {
                            cc.addNumber(d);
                        } else {
                            addExpr(c, 1, Context.OTHER);
                        }
                    }
                    add("":"");
                    addExpr(c.getFirstChild(), 1, Context.OTHER);
                }
            }
            add(""}"");
            if (needsParens) {
                add("")"");
            }
            break;

        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;

        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;

        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;

        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;

        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;

        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
}",0,0
37,Closure_123,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context,
            getContextForNoInOperator(context), 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // Unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top-level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3
            && TokenStream.isKeyword(last.getString())) {
          // Check for ECMASCRIPT3 keywords.
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(
            childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(
            childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString()
                && !(languageMode == LanguageMode.ECMASCRIPT3
                    && TokenStream.isKeyword(key))
                && TokenStream.isJSIdentifier(key)
                // do not encode literally any non-literal characters that
                // were Unicode escaped.
                && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && childCount == 2) {
        Preconditions.checkState(
            first != null && last != null,
            ""Bad binary operator \""%s\"": expected non-null children"",
            opstr);
        int p = NodeUtil.precedence(type);
        Context rhsContext = getContextForNoInOperator(context);

        if (NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }

    cc.startSourceMapping(n);

    switch (type) {
        case Token.TRY: {
            Preconditions.checkState(first.getNext().isBlock() &&
                    !first.getNext().hasMoreThanOneChild());
            Preconditions.checkState(childCount >= 2 && childCount <= 3);

            add(""try"");
            add(first, Context.PRESERVE_BLOCK);

            Node catchblock = first.getNext().getFirstChild();
            if (catchblock != null) {
                add(catchblock);
            }

            if (childCount == 3) {
                add(""finally"");
                add(last, Context.PRESERVE_BLOCK);
            }
            break;
        }

        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;

        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            cc.endStatement(true);
            break;

        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;

        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;

        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;

        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                addExpr(first, 0, getContextForNoInOperator(context));
            }
            break;

        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;

        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;

        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context,
                getContextForNoInOperator(context), 0, 0);
            break;

        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;

        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            Preconditions.checkState(childCount == 1);
            cc.addOp(NodeUtil.opToStrNoFail(type), false);
            addExpr(first, NodeUtil.precedence(type), Context.OTHER);
            break;

        case Token.HOOK: {
            Preconditions.checkState(childCount == 3);
            int p = NodeUtil.precedence(type);
            Context rhsContext = Context.OTHER;
            addExpr(first, p + 1, context);
            cc.addOp(""?"", true);
            addExpr(first.getNext(), 1, rhsContext);
            cc.addOp("":"", true);
            addExpr(last, 1, rhsContext);
            break;
        }

        case Token.REGEXP:
            Preconditions.checkState(first.isString() && last.isString(),
                ""Expected children to be strings"");
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;

        case Token.FUNCTION:
            Preconditions.checkState(n.getClass() == Node.class);
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }

            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);

            if (funcNeedsParens) {
                add("")"");
            }
            break;

        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());

            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }

            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();

            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) &&
                NodeUtil.isLatin(name)) {
                add(name);
            } else {
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }

            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;

        case Token.SCRIPT:
        case Token.BLOCK:
            Preconditions.checkState(n.getClass() == Node.class);
            boolean preserveBlock = context == Context.PRESERVE_BLOCK;
            if (preserveBlock) {
                cc.beginBlock();
            }

            boolean preferLineBreaks = type == Token.SCRIPT ||
                (type == Token.BLOCK && !preserveBlock &&
                n.getParent() != null && n.getParent().isScript());
            for (Node c = first; c != null; c = c.getNext()) {
                add(c, Context.STATEMENT);
                if (c.isVar()) {
                    cc.endStatement();
                }
                if (c.isFunction()) {
                    cc.maybeLineBreak();
                }
                if (preferLineBreaks) {
                    cc.notePreferredLineBreak();
                }
            }
            if (preserveBlock) {
                cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
            }
            break;

        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;

        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;

        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;

        case Token.GETPROP:
            Preconditions.checkState(childCount == 2,
                ""Bad GETPROP: expected 2 children, but got %s"", childCount);
            Preconditions.checkState(last.isString(),
                ""Bad GETPROP: RHS should be STRING"");
            boolean needsParens = (first.isNumber());
            if (needsParens) {
                add(""("");
            }
            addExpr(first, NodeUtil.precedence(type), context);
            if (needsParens) {
                add("")"");
            }
            if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                add(""["");
                add(last);
                add(""]"");
            } else {
                add(""."");
                addIdentifier(last.getString());
            }
            break;

        case Token.GETELEM:
            Preconditions.checkState(childCount == 2,
                ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;

        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.INC:
        case Token.DEC:
            Preconditions.checkState(childCount == 1);
            String o = type == Token.INC ? ""++"" : ""--"";
            int postProp = n.getIntProp(Node.INCRDECR_PROP);
            if (postProp != 0) {
                addExpr(first, NodeUtil.precedence(type), context);
                cc.addOp(o, false);
            } else {
                cc.addOp(o, false);
                add(first);
            }
            break;

        case Token.CALL:
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;

        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }

            add(""if("");
            add(first);
            add("")"");

            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }

            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;

        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;

        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;

        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;

        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;

        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                Precondition.checkArgument(first.isLabelName(), ""Unexpected token type. Should be LABEL_NAME."");
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;

        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                Precondition.checkArgument(first.isLabelName(), ""Unexpected token type. Should be LABEL_NAME."");
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;

        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;

        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;

        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;

        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;

        case Token.OBJECTLIT:
            boolean needsParens = context == Context.START_OF_EXPR;
            if (needsParens) {
                add(""("");
            }
            add(""{"");
            for (Node c = first; c != null; c = c.getNext()) {
                if (c != first) {
                    cc.listSeparator();
                }

                if (c.isGetterDef() || c.isSetterDef()) {
                    add(c);
                } else {
                    Preconditions.checkState(c.isStringKey());
                    String key = c.getString();
                    if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) {
                        add(key);
                    } else {
                        double d = getSimpleNumber(key);
                        if (!Double.isNaN(d)) {
                            cc.addNumber(d);
                        } else {
                            addExpr(c, 1, Context.OTHER);
                        }
                    }
                    add("":"");
                    addExpr(c.getFirstChild(), 1, Context.OTHER);
                }
            }
            add(""}"");
            if (needsParens) {
                add("")"");
            }
            break;

        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;

        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;

        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;

        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            Preconditions.checkState(first.isLabelName(), ""Unexpected token type. Should be LABEL_NAME."");
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;

        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;

        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
}",1,0
37,Closure_123,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context,
            getContextForNoInOperator(context), 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // Unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top-level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3
            && TokenStream.isKeyword(last.getString())) {
          // Check for ECMASCRIPT3 keywords.
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(
            childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(
            childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString()
                && !(languageMode == LanguageMode.ECMASCRIPT3
                    && TokenStream.isKeyword(key))
                && TokenStream.isJSIdentifier(key)
                // do not encode literally any non-literal characters that
                // were Unicode escaped.
                && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    if (opstr != null && childCount == 2) {
        Preconditions.checkState(first != null && last != null, ""Bad binary operator \""%s\"": expected non-null children"", opstr);
        int p = NodeUtil.precedence(type);
        Context rhsContext = getContextForNoInOperator(context);

        if (NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            addExpr(first, p, context);
            cc.addOp(opstr, false);
            addExpr(last, p, rhsContext);
        }
        return;
    }

    cc.startSourceMapping(n);

    switch (type) {
        case Token.TRY: {
            Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
            Preconditions.checkState(childCount >= 2 && childCount <= 3);

            add(""try"");
            add(first, Context.PRESERVE_BLOCK);

            Node catchblock = first.getNext().getFirstChild();
            if (catchblock != null) {
                add(catchblock);
            }

            if (childCount == 3) {
                add(""finally"");
                add(last, Context.PRESERVE_BLOCK);
            }
            break;
        }

        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;

        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            cc.endStatement(true);
            break;

        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            }
            cc.endStatement();
            break;

        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;

        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;

        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
            }
            break;

        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;

        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;

        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            addExpr(first, NodeUtil.precedence(Token.COMMA), context);
            cc.addOp("","", false);
            addExpr(last, NodeUtil.precedence(Token.COMMA), context);
            break;

        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;

        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS: {
            Preconditions.checkState(childCount == 1);
            cc.addOp(NodeUtil.opToStrNoFail(type), false);
            addExpr(first, NodeUtil.precedence(type), Context.OTHER);
            break;
        }

        case Token.NEG: {
            Preconditions.checkState(childCount == 1);
            if (n.getFirstChild().isNumber()) {
                cc.addNumber(-n.getFirstChild().getDouble());
            } else {
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
            }
            break;
        }

        case Token.HOOK: {
            Preconditions.checkState(childCount == 3);
            int p = NodeUtil.precedence(type);
            Context rhsContext = Context.OTHER;
            addExpr(first, p + 1, context);
            cc.addOp(""?"", true);
            addExpr(first.getNext(), 1, rhsContext);
            cc.addOp("":"", true);
            addExpr(last, 1, rhsContext);
            break;
        }

        case Token.REGEXP: {
            Preconditions.checkState(first.isString() && last.isString(), ""Expected children to be strings"");
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            add(regexp + last.getString());
            break;
        }

        case Token.FUNCTION: {
            Preconditions.checkState(n.getClass() == Node.class);
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }

            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);

            if (funcNeedsParens) {
                add("")"");
            }
            break;
        }

        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());

            if (type == Token.GETTER_DEF) {
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }

            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();

            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
                add(name);
            } else {
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }

            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;

        case Token.SCRIPT:
        case Token.BLOCK: {
            Preconditions.checkState(n.getClass() == Node.class);
            boolean preserveBlock = context == Context.PRESERVE_BLOCK;
            if (preserveBlock) {
                cc.beginBlock();
            }

            boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
            for (Node c = first; c != null; c = c.getNext()) {
                add(c, Context.STATEMENT);
                if (c.isVar()) {
                    cc.endStatement();
                }
                if (c.isFunction()) {
                    cc.maybeLineBreak();
                }
                if (preferLineBreaks) {
                    cc.notePreferredLineBreak();
                }
            }
            if (preserveBlock) {
                cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
            }
            break;
        }

        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;

        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;

        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;

        case Token.GETPROP: {
            Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
            Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
            boolean needsParens = (first.isNumber());
            if (needsParens) {
                add(""("");
            }
            addExpr(first, NodeUtil.precedence(type), context);
            if (needsParens) {
                add("")"");
            }
            if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                add(""["");
                add(last);
                add(""]"");
            } else {
                add(""."");
                addIdentifier(last.getString());
            }
            break;
        }

        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;

        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.INC:
        case Token.DEC: {
            Preconditions.checkState(childCount == 1);
            String o = type == Token.INC ? ""++"" : ""--"";
            int postProp = n.getIntProp(Node.INCRDECR_PROP);
            if (postProp != 0) {
                addExpr(first, NodeUtil.precedence(type), context);
                cc.addOp(o, false);
            } else {
                cc.addOp(o, false);
                add(first);
            }
            break;
        }

        case Token.CALL:
            if (!n.getBooleanProp(Node.FREE_CALL) || !NodeUtil.isGet(first)) {
                addExpr(first, NodeUtil.precedence(type), context);
            } else {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;

        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }

            add(""if("");
            add(first);
            add("")"");

            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
            }

            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;

        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;

        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;

        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;

        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;

        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                Preconditions.checkArgument(first.isLabelName(), ""Unexpected token type. Should be LABEL_NAME."");
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;

        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                Preconditions.checkArgument(first.isLabelName(), ""Unexpected token type. Should be LABEL_NAME."");
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;

        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;

        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;

        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;

        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;

        case Token.OBJECTLIT: {
            boolean needsParens = context == Context.START_OF_EXPR;
            if (needsParens) {
                add(""("");
            }
            add(""{"");
            for (Node c = first; c != null; c = c.getNext()) {
                if (c != first) {
                    cc.listSeparator();
                }

                if (c.isGetterDef() || c.isSetterDef()) {
                    add(c);
                } else {
                    Preconditions.checkState(c.isStringKey());
                    String key = c.getString();
                    if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) {
                        add(key);
                    } else {
                        double d = getSimpleNumber(key);
                        if (!Double.isNaN(d)) {
                            cc.addNumber(d);
                        } else {
                            addExpr(c, 1, Context.OTHER);
                        }
                    }
                    add("":"");
                    addExpr(c.getFirstChild(), 1, Context.OTHER);
                }
            }
            add(""}"");
            if (needsParens) {
                add("")"");
            }
            break;
        }

        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;

        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;

        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;

        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            Preconditions.checkArgument(first.isLabelName(), ""Unexpected token type. Should be LABEL_NAME."");
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;

        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;

        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
}",2,0
37,Closure_123,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context,
            getContextForNoInOperator(context), 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // Unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top-level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3
            && TokenStream.isKeyword(last.getString())) {
          // Check for ECMASCRIPT3 keywords.
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(
            childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(
            childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString()
                && !(languageMode == LanguageMode.ECMASCRIPT3
                    && TokenStream.isKeyword(key))
                && TokenStream.isJSIdentifier(key)
                // do not encode literally any non-literal characters that
                // were Unicode escaped.
                && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);

        // For right-hand-side of operations, use default context
        Context rhsContext = Context.OTHER;

        // Handle associativity
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }

    cc.startSourceMapping(n);

    switch (type) {
        case Token.TRY: {
            Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
            Preconditions.checkState(childCount >= 2 && childCount <= 3);

            add(""try"");
            add(first, Context.PRESERVE_BLOCK);

            Node catchblock = first.getNext().getFirstChild();
            if (catchblock != null) {
                add(catchblock);
            }

            if (childCount == 3) {
                add(""finally"");
                add(last, Context.PRESERVE_BLOCK);
            }
            break;
        }

        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;

        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);

            cc.endStatement(true);
            break;

        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            }
            cc.endStatement();
            break;

        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;

        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;

        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;

        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;

        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;

        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            addExpr(first, NodeUtil.precedence(Token.COMMA), context);
            cc.addOp("","", true);
            addExpr(last, NodeUtil.precedence(Token.COMMA), rhsContext);
            break;

        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;

        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            Preconditions.checkState(childCount == 1);
            cc.addOp(NodeUtil.opToStrNoFail(type), false);
            addExpr(first, NodeUtil.precedence(type), Context.OTHER);
            break;

        case Token.NEG:
            Preconditions.checkState(childCount == 1);
            if (n.getFirstChild().isNumber()) {
                cc.addNumber(-n.getFirstChild().getDouble());
            } else {
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
            }
            break;

        case Token.HOOK:
            Preconditions.checkState(childCount == 3);
            int p = NodeUtil.precedence(type);
            addExpr(first, p + 1, context);
            cc.addOp(""?"", true);
            addExpr(first.getNext(), 1, rhsContext);
            cc.addOp("":"", true);
            addExpr(last, 1, rhsContext);
            break;

        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }

            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            add(regexp + last.getString());
            break;

        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }

            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);

            if (funcNeedsParens) {
                add("")"");
            }
            break;

        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());

            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }

            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();

            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
                add(name);
            } else {
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }

            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;

        case Token.SCRIPT:
        case Token.BLOCK:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            boolean preserveBlock = context == Context.PRESERVE_BLOCK;
            if (preserveBlock) {
                cc.beginBlock();
            }

            boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
            for (Node c = first; c != null; c = c.getNext()) {
                add(c, Context.STATEMENT);
                if (c.isVar()) {
                    cc.endStatement();
                }
                if (c.isFunction()) {
                    cc.maybeLineBreak();
                }
                if (preferLineBreaks) {
                    cc.notePreferredLineBreak();
                }
            }
            if (preserveBlock) {
                cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
            }
            break;

        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;

        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;

        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;

        case Token.GETPROP:
            Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
            Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
            boolean needsParens = (first.isNumber());
            if (needsParens) {
                add(""("");
            }
            addExpr(first, NodeUtil.precedence(type), context);
            if (needsParens) {
                add("")"");
            }
            if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                add(""["");
                add(last);
                add(""]"");
            } else {
                add(""."");
                addIdentifier(last.getString());
            }
            break;

        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;

        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;

        case Token.INC:
        case Token.DEC:
            Preconditions.checkState(childCount == 1);
            String o = type == Token.INC ? ""++"" : ""--"";
            int postProp = n.getIntProp(Node.INCRDECR_PROP);
            if (postProp != 0) {
                addExpr(first, NodeUtil.precedence(type), context);
                cc.addOp(o, false);
            } else {
                cc.addOp(o, false);
                add(first);
            }
            break;

        case Token.CALL:
            if (!n.getBooleanProp(Node.FREE_CALL) || !NodeUtil.isGet(first)) {
                addExpr(first, NodeUtil.precedence(type), context);
            } else {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;

        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }

            add(""if("");
            add(first);
            add("")"");

            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
            }

            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;

        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;

        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;

        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;

        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;

        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;

        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;

        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;

        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;

        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;

        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;

        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;

        case Token.OBJECTLIT:
            boolean needsParens = (context == Context.START_OF_EXPR);
            if (needsParens) {
                add(""("");
            }
            add(""{"");
            for (Node c = first; c != null; c = c.getNext()) {
                if (c != first) {
                    cc.listSeparator();
                }

                if (c.isGetterDef() || c.isSetterDef()) {
                    add(c);
                } else {
                    Preconditions.checkState(c.isStringKey());
                    String key = c.getString();
                    if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) {
                        add(key);
                    } else {
                        double d = getSimpleNumber(key);
                        if (!Double.isNaN(d)) {
                            cc.addNumber(d);
                        } else {
                            addExpr(c, 1, Context.OTHER);
                        }
                    }
                    add("":"");
                    addExpr(c.getFirstChild(), 1, Context.OTHER);
                }
            }
            add(""}"");
            if (needsParens) {
                add("")"");
            }
            break;

        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;

        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;

        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;

        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;

        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;

        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
}",3,0
37,Closure_123,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context,
            getContextForNoInOperator(context), 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // Unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top-level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3
            && TokenStream.isKeyword(last.getString())) {
          // Check for ECMASCRIPT3 keywords.
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(
            childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(
            childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString()
                && !(languageMode == LanguageMode.ECMASCRIPT3
                    && TokenStream.isKeyword(key))
                && TokenStream.isJSIdentifier(key)
                // do not encode literally any non-literal characters that
                // were Unicode escaped.
                && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }","void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = context == Context.IN_FOR_INIT_CLAUSE ? context : Context.OTHER;

      // Handle associativity.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          addExpr(first, 0, Context.OTHER);
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context, Context.OTHER, 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

      case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() || !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);
        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());

        if (type == Token.GETTER_DEF) {
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
          add(name);
        } else {
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(last, Context.OTHER, false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(last, Context.OTHER, false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(last, Context.OTHER, false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(last, Context.OTHER, false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        if (!n.getBooleanProp(Node.FREE_CALL) || !NodeUtil.isGet(first)) {
          addExpr(first, NodeUtil.precedence(type), context);
        } else {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(last, Context.OTHER, false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          Preconditions.checkState(first.isLabelName());
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          Preconditions.checkState(first.isLabelName());
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        Preconditions.checkState(first.isLabelName());
        add(first);
        add("":"");
        addNonEmptyStatement(last, Context.OTHER, true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }",4,0
38,Closure_124,"private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
      return true;
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
    }

    return true;
  }","private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
        return true;
    }
    Preconditions.checkArgument(node.isGetProp());

    Node firstChild = node.getFirstChild();
    if (firstChild.isName()
        && isNameAssignedTo(firstChild.getString(), replacement)) {
        return false;
    }

    return true;
}",0,0
38,Closure_124,"private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
      return true;
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
    }

    return true;
  }","private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
        return true;
    }

    Preconditions.checkArgument(node.isGetProp());

    Node firstChild = node.getFirstChild();
    if (firstChild.isName()
        && isNameAssignedTo(firstChild.getString(), replacement)
        && !firstChild.isEquivalentTo(replacement.getFirstChild())) {
        return false;
    }

    return true;
}",1,0
38,Closure_124,"private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
      return true;
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
    }

    return true;
  }","private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
        return true;
    }
    Preconditions.checkArgument(node.isGetProp());

    Node firstChild = node.getFirstChild();
    if (firstChild.isName() && isNameAssignedTo(firstChild.getString(), replacement)) {
        // Check if replacement is a property access (e.g., GETPROP) or assignment
        if (replacement.isGetProp() || replacement.isAssign()) {
            return false;
        }
    }

    return true;
}",2,0
38,Closure_124,"private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
      return true;
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
    }

    return true;
  }","private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
        return true;
    }
    Preconditions.checkArgument(node.isGetProp());

    Node firstChild = node.getFirstChild();
    if (firstChild.isName()) {
        // Instead of just checking assignment, let's verify if replacement is structurally safe
        if (firstChild.getString().equals(replacement.getQualifiedName())) {
            return false;
        }
    }
    
    return true;
}",3,0
38,Closure_124,"private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
      return true;
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
    }

    return true;
  }","private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
        return true;
    }
    Preconditions.checkArgument(node.isGetProp());

    Node firstChild = node.getFirstChild();
    if (firstChild != null && firstChild.isName()) {
        // Ensure that the replacement is not a direct assignment to the same name
        return !replacement.isAssign() || !firstChild.getString().equals(replacement.getFirstChild().getString());
    }

    return true;
}",4,0
39,Closure_125,"private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
       if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
        ensureTyped(t, n);
      }
    } else {
      report(t, n, NOT_A_CONSTRUCTOR);
      ensureTyped(t, n);
    }
  }","private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    FunctionType fnType = type.toMaybeFunctionType();
    if (fnType != null && (type.isConstructor() || type.isEmptyType() || type.isUnknownType())) {
        visitParameterList(t, n, fnType);
        ensureTyped(t, n, fnType.getInstanceType());
    } else {
        report(t, n, NOT_A_CONSTRUCTOR);
        ensureTyped(t, n);
    }
}",0,0
39,Closure_125,"private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
       if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
        ensureTyped(t, n);
      }
    } else {
      report(t, n, NOT_A_CONSTRUCTOR);
      ensureTyped(t, n);
    }
  }","private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    FunctionType fnType = type.toMaybeFunctionType();
    if (fnType != null) {
        if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
            visitParameterList(t, n, fnType);
            ensureTyped(t, n, fnType.getInstanceType());
        } else {
            report(t, n, NOT_A_CONSTRUCTOR);
            ensureTyped(t, n);
        }
    } else {
        report(t, n, NOT_A_FUNCTION);
        ensureTyped(t, n);
    }
}",1,0
39,Closure_125,"private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
       if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
        ensureTyped(t, n);
      }
    } else {
      report(t, n, NOT_A_CONSTRUCTOR);
      ensureTyped(t, n);
    }
  }","private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    if (type.isConstructor()) {
        FunctionType fnType = type.toMaybeFunctionType();
        if (fnType != null) {
            visitParameterList(t, n, fnType);
            ensureTyped(t, n, fnType.getInstanceType());
        } else {
            report(t, n, NOT_A_FUNCTION);
            ensureTyped(t, n);
        }
    } else if (type.isEmptyType() || type.isUnknownType()) {
        report(t, n, EMPTY_OR_UNKNOWN_TYPE);
        ensureTyped(t, n);
    } else {
        report(t, n, NOT_A_CONSTRUCTOR);
        ensureTyped(t, n);
    }
}",2,0
39,Closure_125,"private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
       if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
        ensureTyped(t, n);
      }
    } else {
      report(t, n, NOT_A_CONSTRUCTOR);
      ensureTyped(t, n);
    }
  }","private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    FunctionType fnType = type.toMaybeFunctionType();

    if (fnType != null && type.isConstructor()) {
        visitParameterList(t, n, fnType);
        ensureTyped(t, n, fnType.getInstanceType());
    } else {
        // Adjust logic to cover unsupported cases and prevent illegal state
        if (type.isEmptyType() || type.isUnknownType()) {
            report(t, n, EMPTY_OR_UNKNOWN_TYPE);
        }
        ensureTyped(t, n);
    }
}",3,0
39,Closure_125,"private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
       if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
        ensureTyped(t, n);
      }
    } else {
      report(t, n, NOT_A_CONSTRUCTOR);
      ensureTyped(t, n);
    }
  }","private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    FunctionType fnType = type.toMaybeFunctionType();

    if (fnType != null && fnType.isConstructor()) {
        visitParameterList(t, n, fnType);
        ensureTyped(t, n, fnType.getInstanceType());
    } else {
        if (type.isEmptyType() || type.isUnknownType() || fnType == null) {
            report(t, n, NOT_A_CONSTRUCTOR);
        }
        ensureTyped(t, n);
    }
}",4,0
40,Closure_126,"void tryMinimizeExits(Node n, int exitType, String labelName) {

    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
      NodeUtil.removeChild(n.getParent(), n);
      compiler.reportCodeChange();
      return;
    }

    // Just an 'if'.
    if (n.isIf()) {
      Node ifBlock = n.getFirstChild().getNext();
      tryMinimizeExits(ifBlock, exitType, labelName);
      Node elseBlock = ifBlock.getNext();
      if (elseBlock != null) {
        tryMinimizeExits(elseBlock, exitType, labelName);
      }
      return;
    }

    // Just a 'try/catch/finally'.
    if (n.isTry()) {
      Node tryBlock = n.getFirstChild();
      tryMinimizeExits(tryBlock, exitType, labelName);
      Node allCatchNodes = NodeUtil.getCatchBlock(n);
      if (NodeUtil.hasCatchHandler(allCatchNodes)) {
        Preconditions.checkState(allCatchNodes.hasOneChild());
        Node catchNode = allCatchNodes.getFirstChild();
        Node catchCodeBlock = catchNode.getLastChild();
        tryMinimizeExits(catchCodeBlock, exitType, labelName);
      }
      /* Don't try to minimize the exits of finally blocks, as this
        * can cause problems if it changes the completion type of the finally
        * block. See ECMA 262 Sections 8.9 & 12.14
        */
       if (NodeUtil.hasFinally(n)) {
         Node finallyBlock = n.getLastChild();
         tryMinimizeExits(finallyBlock, exitType, labelName);
       }
     }
 
     // Just a 'label'.
    if (n.isLabel()) {
      Node labelBlock = n.getLastChild();
      tryMinimizeExits(labelBlock, exitType, labelName);
    }

    // TODO(johnlenz): The last case of SWITCH statement?

    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
      return;
    }

    // Multiple if-exits can be converted in a single pass.
    // Convert ""if (blah) break;  if (blah2) break; other_stmt;"" to
    // become ""if (blah); else { if (blah2); else { other_stmt; } }""
    // which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
    for (Node c : n.children()) {

      // An 'if' block to process below.
      if (c.isIf()) {
        Node ifTree = c;
        Node trueBlock, falseBlock;

        // First, the true condition block.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        tryMinimizeIfBlockExits(trueBlock, falseBlock,
            ifTree, exitType, labelName);

        // Now the else block.
        // The if blocks may have changed, get them again.
        trueBlock = ifTree.getFirstChild().getNext();
        falseBlock = trueBlock.getNext();
        if (falseBlock != null) {
          tryMinimizeIfBlockExits(falseBlock, trueBlock,
              ifTree, exitType, labelName);
        }
      }

      if (c == n.getLastChild()) {
        break;
      }
    }

    // Now try to minimize the exits of the last child, if it is removed
    // look at what has become the last child.
    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
      tryMinimizeExits(c, exitType, labelName);
      // If the node is still the last child, we are done.
      if (c == n.getLastChild()) {
        break;
      }
    }
  }","void tryMinimizeExits(Node n, int exitType, String labelName) {

    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
        NodeUtil.removeChild(n.getParent(), n);
        compiler.reportCodeChange();
        return;
    }

    // Just an 'if'.
    if (n.isIf()) {
        Node ifBlock = n.getFirstChild().getNext();
        tryMinimizeExits(ifBlock, exitType, labelName);
        Node elseBlock = ifBlock.getNext();
        if (elseBlock != null) {
            tryMinimizeExits(elseBlock, exitType, labelName);
        }
        return;
    }

    // Just a 'try/catch/finally'.
    if (n.isTry()) {
        Node tryBlock = n.getFirstChild();
        tryMinimizeExits(tryBlock, exitType, labelName);
        Node allCatchNodes = NodeUtil.getCatchBlock(n);
        if (NodeUtil.hasCatchHandler(allCatchNodes)) {
            Preconditions.checkState(allCatchNodes.hasOneChild());
            Node catchNode = allCatchNodes.getFirstChild();
            Node catchCodeBlock = catchNode.getLastChild();
            tryMinimizeExits(catchCodeBlock, exitType, labelName);
        }
        // Don't try to minimize the exits of finally blocks
        // as this can cause problems if it changes the completion type
        // See ECMA 262 Sections 8.9 & 12.14
    }

    // Just a 'label'.
    if (n.isLabel()) {
        Node labelBlock = n.getLastChild();
        tryMinimizeExits(labelBlock, exitType, labelName);
        return;
    }

    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
        return;
    }

    // Multiple if-exits can be converted in a single pass.
    // Convert ""if (blah) break;  if (blah2) break; other_stmt;"" to
    // become ""if (blah); else { if (blah2); else { other_stmt; } }""
    // which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
    for (Node c : n.children()) {
        if (c.isIf()) {
            Node ifTree = c;
            Node trueBlock = ifTree.getFirstChild().getNext();
            Node falseBlock = trueBlock.getNext();
            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);
            
            falseBlock = trueBlock.getNext();
            if (falseBlock != null) {
                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);
            }
        }

        if (c == n.getLastChild()) {
            break;
        }
    }

    // Now try to minimize the exits of the last child, if it is removed
    // look at what has become the last child.
    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
        tryMinimizeExits(c, exitType, labelName);
        // If the node is still the last child, we are done.
        if (c == n.getLastChild()) {
            break;
        }
    }
}",0,0
41,Closure_128,"static boolean isSimpleNumber(String s) {
     int len = s.length();
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
       if (c < '0' || c > '9') {
         return false;
       }
     }
     return len > 0 && s.charAt(0) != '0';
   }","static boolean isSimpleNumber(String s) {
    int len = s.length();
    if (len == 0 || (s.charAt(0) == '0' && len > 1)) {
        return false;
    }
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return true;
}",0,0
42,Closure_129,"private void annotateCalls(Node n) {
      Preconditions.checkState(n.isCall());

      // Keep track of of the ""this"" context of a call.  A call without an
      // explicit ""this"" is a free call.
       Node first = n.getFirstChild();
 
       // ignore cast nodes.
 
       if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
      }

      // Keep track of the context in which eval is called. It is important
      // to distinguish between ""(0, eval)()"" and ""eval()"".
      if (first.isName() &&
          ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
      }
    }","private void annotateCalls(Node n) {
    Preconditions.checkState(n.isCall());

    // Keep track of of the ""this"" context of a call.  A call without an
    // explicit ""this"" is a free call.
    Node first = n.getFirstChild();
 
    // ignore cast nodes.
    while (first != null && first.isCast()) {
        first = first.getNext();
    }
 
    if (first != null && !NodeUtil.isGet(first)) {
        n.putBooleanProp(Node.FREE_CALL, true);
    }

    // Keep track of the context in which eval is called. It is important
    // to distinguish between ""(0, eval)()"" and ""eval()"".
    if (first != null && first.isName() &&
        ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
    }
}",0,0
43,Closure_13,"private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
      return;
    }

    int visits = 0;
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
      visit(node);
      visits++;

      Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));

    exitNode(node);
  }","private void traverse(Node node) {

    // The goal here is to avoid retraversing the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed, and revisit immediately.
    if (!shouldVisit(node)) {
        return;
    }

    int visits = 0;
    do {
        Node c = node.getFirstChild();
        while (c != null) {
            traverse(c);
            c = c.getNext();
        }

        visit(node);
        visits++;

        Preconditions.checkState(visits < 10000, ""too many iterations"");
    } while (shouldRetraverse(node) && visits < 10000);

    exitNode(node);
}",0,0
43,Closure_13,"private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
      return;
    }

    int visits = 0;
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
      visit(node);
      visits++;

      Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));

    exitNode(node);
  }","private void traverse(Node node) {
    // The goal here is to avoid retraversing the entire AST to catch newly created opportunities.
    // Track whether a ""unit of code"" has changed, revisit if necessary, and ensure no infinite loop.
    if (!shouldVisit(node)) {
        return;
    }

    int visits = 0;
    Node currentNode = node;  // Keep track of the current node being traversed
    do {
        Node c = currentNode.getFirstChild();
        while (c != null) {
            traverse(c); 
            c = c.getNext();
        }

        // Visit the node after processing its children
        visit(currentNode);

        // If retraversal is required, ensure the specific node's state has changed meaningfully
        if (shouldRetraverse(currentNode) && visits < 10000) {
            currentNode = node;  // Force retraverse from the original node
            visits++;
        } else {
            break;
        }
    } while (true);  // Break explicitly on non-retraversing criteria

    exitNode(currentNode);
}",1,0
43,Closure_13,"private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
      return;
    }

    int visits = 0;
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
      visit(node);
      visits++;

      Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));

    exitNode(node);
  }","private void traverse(Node node) {
    if (!shouldVisit(node)) {
        return;
    }

    int visits = 0;

    while (true) {
        Node c = node.getFirstChild();
        while (c != null) {
            traverse(c);
            c = c.getNext();
        }

        visit(node);
        visits++;

        if (!shouldRetraverse(node) || visits >= 10000) {
            break;
        }

        // Reset the node traversal state as a fresh start to avoid repeated side-effects
        resetTraversalState(node);
    }

    exitNode(node);
}

private void resetTraversalState(Node node) {
    // Reset specific state that might affect retraversal logic.
    // For example, resetting flags or cached information in traversalState.
    ScopeState state = traversalState.peek();
    if (state != null) {
        state.changed = false;
        state.traverseChildScopes = false;
    }
}",2,0
43,Closure_13,"private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
      return;
    }

    int visits = 0;
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
      visit(node);
      visits++;

      Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));

    exitNode(node);
  }","private void traverse(Node node) {
        if (!shouldVisit(node)) {
            return;
        }

        int visits = 0;
        Node originalNode = node;  // Keep track of the original node
        boolean needsRetraverse;
        
        do {
            Node c = node.getFirstChild();
            while (c != null) {
                traverse(c);
                c = c.getNext();
            }

            visit(node);
            visits++;

            Preconditions.checkState(visits < 10000, ""too many iterations"");

            // Check if the node or its parent node needs retraversal
            needsRetraverse = shouldRetraverse(node) || ((node.getParent() != null) && shouldRetraverse(node.getParent()));
            node = originalNode;  // Reset to the original node for potential retraversal
            
        } while (needsRetraverse);

        exitNode(originalNode);
    }",3,0
43,Closure_13,"private void traverse(Node node) {
    // The goal here is to avoid retraversing
    // the entire AST to catch newly created opportunities.
    // So we track whether a ""unit of code"" has changed,
    // and revisit immediately.
    if (!shouldVisit(node)) {
      return;
    }

    int visits = 0;
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
      visit(node);
      visits++;

      Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));

    exitNode(node);
  }","private void traverse(Node node) {
    if (!shouldVisit(node)) {
        return;
    }

    int visits = 0;
    do {
        Node c = node.getFirstChild();
        while (c != null) {
            traverse(c);
            Node next = c.getNext();
            c = next;
        }

        visit(node);
        visits++;

        Preconditions.checkState(visits < 10000, ""too many iterations"");
        
        // Modify the retraversal logic to check and reset only if the node's state has changed meaningfully.
        if (shouldRetraverse(node) && nodeHasChanges(node)) {
            resetNodeState(node);
        } else {
            break;
        }
    } while (true);

    exitNode(node);
}

private boolean nodeHasChanges(Node node) {
    // Check meaningful changes in node; possibly compare state properties.
    ScopeState state = traversalState.peek();
    return state != null && state.changed;
}

private void resetNodeState(Node node) {
    // Reset the traversal state or any node-specific flags to ensure accurate retraversal
    ScopeState state = traversalState.peek();
    if (state != null) {
        state.changed = false;
        state.traverseChildScopes = false;
    }
}",4,0
44,Closure_130,"private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
      Name name = workList.pop();

      // Don't attempt to inline a getter or setter property as a variable.
      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
         continue;
       }
 
       if (name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
        List<Ref> refs = Lists.newArrayList(name.getRefs());
        for (Ref ref : refs) {
          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
            // {@code name} meets condition (c). Try to inline it.
            if (inlineAliasIfPossible(ref, namespace)) {
              name.removeRef(ref);
            }
          }
        }
      }

      // Check if {@code name} has any aliases left after the
      // local-alias-inlining above.
      if ((name.type == Name.Type.OBJECTLIT ||
           name.type == Name.Type.FUNCTION) &&
          name.aliasingGets == 0 && name.props != null) {
        // All of {@code name}'s children meet condition (a), so they can be
        // added to the worklist.
        workList.addAll(name.props);
      }
    }
  }","private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();

        // Skip processing for getter or setter properties.
        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }

        if (name.globalSets == 1 && name.localSets == 0 &&
            name.aliasingGets > 0) {
            // {@code name} meets condition (b). Find all of its local aliases
            // and try to inline them.
            List<Ref> refs = Lists.newArrayList(name.getRefs());
            for (Ref ref : refs) {
                if (ref.type == Ref.Type.ALIASING_GET && ref.scope.isLocal()) {
                    // {@code name} meets condition (c). Try to inline it.
                    if (inlineAliasIfPossible(ref, namespace)) {
                        name.removeRef(ref);
                        name.decrementAliasingGets(); // Update aliasingGets after removal.
                    }
                }
            }
        }

        // Check if {@code name} has any aliases left after the
        // local-alias-inlining above.
        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) &&
            name.aliasingGets == 0 && name.props != null) {
            // All of {@code name}'s children meet condition (a), so they can be
            // added to the worklist.
            workList.addAll(name.props);
        }
    }
}",0,0
44,Closure_130,"private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
      Name name = workList.pop();

      // Don't attempt to inline a getter or setter property as a variable.
      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
         continue;
       }
 
       if (name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
        List<Ref> refs = Lists.newArrayList(name.getRefs());
        for (Ref ref : refs) {
          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
            // {@code name} meets condition (c). Try to inline it.
            if (inlineAliasIfPossible(ref, namespace)) {
              name.removeRef(ref);
            }
          }
        }
      }

      // Check if {@code name} has any aliases left after the
      // local-alias-inlining above.
      if ((name.type == Name.Type.OBJECTLIT ||
           name.type == Name.Type.FUNCTION) &&
          name.aliasingGets == 0 && name.props != null) {
        // All of {@code name}'s children meet condition (a), so they can be
        // added to the worklist.
        workList.addAll(name.props);
      }
    }
  }","private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();

        // Skip processing for getter or setter properties.
        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }

        // Modify logic to check aliasingGets after trying to inline aliases
        boolean hasAliasingGets = name.aliasingGets > 0;
        if (name.globalSets == 1 && name.localSets == 0 && hasAliasingGets) {
            // {@code name} meets condition (b). Find all of its local aliases
            // and try to inline them.
            List<Ref> refs = Lists.newArrayList(name.getRefs());
            for (Ref ref : refs) {
                if (ref.type == Ref.Type.ALIASING_GET && ref.scope.isLocal()) {
                    // {@code name} meets condition (c). Try to inline it.
                    if (inlineAliasIfPossible(ref, namespace)) {
                        name.removeRef(ref);
                        hasAliasingGets = name.aliasingGets > 0; // Update flag after removal.
                    }
                }
            }
        }

        // Check if {@code name} has any aliases left after the
        // local-alias-inlining above.
        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && !hasAliasingGets && name.props != null) {
            // All of {@code name}'s children meet condition (a), so they can be
            // added to the worklist.
            workList.addAll(name.props);
        }
    }
}",1,0
44,Closure_130,"private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
      Name name = workList.pop();

      // Don't attempt to inline a getter or setter property as a variable.
      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
         continue;
       }
 
       if (name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
        List<Ref> refs = Lists.newArrayList(name.getRefs());
        for (Ref ref : refs) {
          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
            // {@code name} meets condition (c). Try to inline it.
            if (inlineAliasIfPossible(ref, namespace)) {
              name.removeRef(ref);
            }
          }
        }
      }

      // Check if {@code name} has any aliases left after the
      // local-alias-inlining above.
      if ((name.type == Name.Type.OBJECTLIT ||
           name.type == Name.Type.FUNCTION) &&
          name.aliasingGets == 0 && name.props != null) {
        // All of {@code name}'s children meet condition (a), so they can be
        // added to the worklist.
        workList.addAll(name.props);
      }
    }
  }",Match failed,2,0
44,Closure_130,"private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
      Name name = workList.pop();

      // Don't attempt to inline a getter or setter property as a variable.
      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
         continue;
       }
 
       if (name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
        List<Ref> refs = Lists.newArrayList(name.getRefs());
        for (Ref ref : refs) {
          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
            // {@code name} meets condition (c). Try to inline it.
            if (inlineAliasIfPossible(ref, namespace)) {
              name.removeRef(ref);
            }
          }
        }
      }

      // Check if {@code name} has any aliases left after the
      // local-alias-inlining above.
      if ((name.type == Name.Type.OBJECTLIT ||
           name.type == Name.Type.FUNCTION) &&
          name.aliasingGets == 0 && name.props != null) {
        // All of {@code name}'s children meet condition (a), so they can be
        // added to the worklist.
        workList.addAll(name.props);
      }
    }
  }","private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();

        // Skip processing for getter or setter properties.
        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }

        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
            // Refactor the aliasing check to validate removal independently:
            List<Ref> refs = Lists.newArrayList(name.getRefs());
            int aliasCountBefore = name.aliasingGets;
            for (Ref ref : refs) {
                if (ref.type == Ref.Type.ALIASING_GET && ref.scope.isLocal()) {
                    // Try to inline only valid aliases and verify impact on counts.
                    boolean inlined = inlineAliasIfPossible(ref, namespace);
                    if (inlined) {
                        name.removeRef(ref);
                    }
                }
            }
            int aliasCountAfter = name.aliasingGets; // Reevaluate alias count.
            if (aliasCountAfter == aliasCountBefore) { // Check for inlining effectiveness.
                continue;
            }
        }

        // Check if name props are eligible for further worklist iteration.
        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) 
                && name.aliasingGets == 0 && name.props != null) {
            workList.addAll(name.props);
        }
    }
}",3,0
44,Closure_130,"private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
      Name name = workList.pop();

      // Don't attempt to inline a getter or setter property as a variable.
      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
         continue;
       }
 
       if (name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
        List<Ref> refs = Lists.newArrayList(name.getRefs());
        for (Ref ref : refs) {
          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
            // {@code name} meets condition (c). Try to inline it.
            if (inlineAliasIfPossible(ref, namespace)) {
              name.removeRef(ref);
            }
          }
        }
      }

      // Check if {@code name} has any aliases left after the
      // local-alias-inlining above.
      if ((name.type == Name.Type.OBJECTLIT ||
           name.type == Name.Type.FUNCTION) &&
          name.aliasingGets == 0 && name.props != null) {
        // All of {@code name}'s children meet condition (a), so they can be
        // added to the worklist.
        workList.addAll(name.props);
      }
    }
  }","private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();

        // Skip processing for getter or setter properties.
        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }

        // Modify logic to only inline if globalSets are exclusively from aliasingGets
        boolean canInline = name.globalSets == name.aliasingGets;
        if (name.localSets == 0 && canInline) {
            // {@code name} meets condition (b). Find all of its local aliases and try to inline them.
            List<Ref> refs = Lists.newArrayList(name.getRefs());
            for (Ref ref : refs) {
                if (ref.type == Ref.Type.ALIASING_GET && ref.scope.isLocal()) {
                    // {@code name} meets condition (c). Try to inline it.
                    if (inlineAliasIfPossible(ref, namespace)) {
                        name.removeRef(ref);
                    }
                }
            }
        }

        // Check if {@code name} has any aliases left after the local-alias-inlining above.
        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) &&
            name.aliasingGets == 0 && name.props != null) {
            // All of {@code name}'s children meet condition (a), so they can be added to the worklist.
            workList.addAll(name.props);
        }
    }
}",4,0
45,Closure_131,"public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
         if (
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
      }

      return true;
    }","public static boolean isJSIdentifier(String s) {
    int length = s.length();

    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
        return false;
    }

    for (int i = 1; i < length; i++) {
        if (!Character.isJavaIdentifierPart(s.charAt(i))) {
            return false;
        }
    }

    // Ensure none of the characters are the null character
    for (int i = 0; i < length; i++) {
        if (s.charAt(i) == '\0') {
            return false;
        }
    }

    return true;
}",0,0
45,Closure_131,"public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
         if (
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
      }

      return true;
    }","public static boolean isJSIdentifier(String s) {
    int length = s.length();
    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
        return false;
    }
    boolean valid = true;
    for (int i = 1; i < length; i++) {
        char c = s.charAt(i);
        if (!Character.isJavaIdentifierPart(c)) {
            valid = false;
        }
    }
    return !s.contains(""\0"") && valid;
}",1,0
45,Closure_131,"public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
         if (
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
      }

      return true;
    }","public static boolean isJSIdentifier(String s) {
    int length = s.length();

    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
        return false;
    }

    for (int i = 1; i < length; i++) {
        char c = s.charAt(i);
        if (!Character.isJavaIdentifierPart(c)) {
            return false;
        }
        // Ensure character is not the null character
        if (c == '\0') {
            return false;
        }
    }

    return true;
}",2,0
45,Closure_131,"public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
         if (
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
      }

      return true;
    }","public static boolean isJSIdentifier(String s) {
    int length = s.length();
 
    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
        return false;
    }
    
    boolean nullCharacterFound = false;
    for (int i = 1; i < length; i++) {
        char c = s.charAt(i);
        if (!Character.isJavaIdentifierPart(c)) {
            return false;
        }
        if (c == '\0') {
            nullCharacterFound = true;
        }
    }
    
    return !nullCharacterFound && length > 0;
}",3,0
45,Closure_131,"public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
         if (
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
      }

      return true;
    }","public static boolean isJSIdentifier(String s) {
    int length = s.length();
    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
        return false;
    }

    for (int i = 1; i < length; i++) {
        char c = s.charAt(i);
        if (!Character.isJavaIdentifierPart(c) || c == '\0') {
            return false;
        }
    }

    return true;
}",4,0
46,Closure_132,"private Node tryMinimizeIf(Node n) {

    Node parent = n.getParent();

    Node cond = n.getFirstChild();

    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
      return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
      if (isFoldableExpressBlock(thenBranch)) {
        Node expr = getBlockExpression(thenBranch);
        if (!late && isPropertyAssignmentInExpression(expr)) {
          // Keep opportunities for CollapseProperties such as
          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
          // until CollapseProperties has been run.
          return n;
        }

        if (cond.isNot()) {
          // if(!x)bar(); -> x||bar();
          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
              isLowerPrecedenceInExpression(expr.getFirstChild(),
                  OR_PRECEDENCE)) {
            // It's not okay to add two sets of parentheses.
            return n;
          }

          Node or = IR.or(
              cond.removeFirstChild(),
              expr.removeFirstChild()).srcref(n);
          Node newExpr = NodeUtil.newExpr(or);
          parent.replaceChild(n, newExpr);
          reportCodeChange();

          return newExpr;
        }

        // if(x)foo(); -> x&&foo();
        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
            isLowerPrecedenceInExpression(expr.getFirstChild(),
                AND_PRECEDENCE)) {
          // One additional set of parentheses is worth the change even if
          // there is no immediate code size win. However, two extra pair of
          // {}, we would have to think twice. (unless we know for sure the
          // we can further optimize its parent.
          return n;
        }

        n.removeChild(cond);
        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
        Node newExpr = NodeUtil.newExpr(and);
        parent.replaceChild(n, newExpr);
        reportCodeChange();

        return newExpr;
      } else {

        // Try to combine two IF-ELSE
        if (NodeUtil.isStatementBlock(thenBranch) &&
            thenBranch.hasOneChild()) {
          Node innerIf = thenBranch.getFirstChild();

          if (innerIf.isIf()) {
            Node innerCond = innerIf.getFirstChild();
            Node innerThenBranch = innerCond.getNext();
            Node innerElseBranch = innerThenBranch.getNext();

            if (innerElseBranch == null &&
                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
              n.detachChildren();
              n.addChildToBack(
                  IR.and(
                      cond,
                      innerCond.detachFromParent())
                      .srcref(cond));
              n.addChildrenToBack(innerThenBranch.detachFromParent());
              reportCodeChange();
              // Not worth trying to fold the current IF-ELSE into && because
              // the inner IF-ELSE wasn't able to be folded into && anyways.
              return n;
            }
          }
        }
      }

      return n;
    }

    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);

    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
      n.replaceChild(cond, cond.removeFirstChild());
      n.removeChild(thenBranch);
      n.addChildToBack(thenBranch);
      reportCodeChange();
      return n;
    }

    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
      Node thenExpr = getBlockReturnExpression(thenBranch);
      Node elseExpr = getBlockReturnExpression(elseBranch);
      n.removeChild(cond);
      thenExpr.detachFromParent();
      elseExpr.detachFromParent();

      // note - we ignore any cases with ""return;"", technically this
      // can be converted to ""return undefined;"" or some variant, but
      // that does not help code size.
      Node returnNode = IR.returnNode(
                            IR.hook(cond, thenExpr, elseExpr)
                                .srcref(n));
      parent.replaceChild(n, returnNode);
      reportCodeChange();
      return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
      Node thenOp = getBlockExpression(thenBranch).getFirstChild();
      Node elseOp = getBlockExpression(elseBranch).getFirstChild();
      if (thenOp.getType() == elseOp.getType()) {
        // if(x)a=1;else a=2; -> a=x?1:2;
        if (NodeUtil.isAssignmentOp(thenOp)) {
          Node lhs = thenOp.getFirstChild();
          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
              // if LHS has side effects, don't proceed [since the optimization
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
               !mayEffectMutableState(lhs)) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
            Node thenExpr = thenOp.removeFirstChild();
            Node elseExpr = elseOp.getLastChild();
            elseOp.removeChild(elseExpr);

            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            Node assign = new Node(thenOp.getType(), assignName, hookNode)
                              .srcref(thenOp);
            Node expr = NodeUtil.newExpr(assign);
            parent.replaceChild(n, expr);
            reportCodeChange();

            return expr;
          }
        }
      }
      // if(x)foo();else bar(); -> x?foo():bar()
      n.removeChild(cond);
      thenOp.detachFromParent();
      elseOp.detachFromParent();
      Node expr = IR.exprResult(
          IR.hook(cond, thenOp, elseOp).srcref(n));
      parent.replaceChild(n, expr);
      reportCodeChange();
      return expr;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(thenBranch);
      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

      Node name1 = var.getFirstChild();
      Node maybeName2 = elseAssign.getFirstChild();

      if (name1.hasChildren()
          && maybeName2.isName()
          && name1.getString().equals(maybeName2.getString())) {
        Node thenExpr = name1.removeChildren();
        Node elseExpr = elseAssign.getLastChild().detachFromParent();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name1.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();
        return var;
      }

    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
        getBlockExpression(thenBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(elseBranch);
      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

      Node maybeName1 = thenAssign.getFirstChild();
      Node name2 = var.getFirstChild();

      if (name2.hasChildren()
          && maybeName1.isName()
          && maybeName1.getString().equals(name2.getString())) {
        Node thenExpr = thenAssign.getLastChild().detachFromParent();
        Node elseExpr = name2.removeChildren();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name2.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();

        return var;
      }
    }

    return n;
  }","private Node tryMinimizeIf(Node n) {

    Node parent = n.getParent();

    Node cond = n.getFirstChild();

    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                return n;
            }

            if (cond.isNot()) {
                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
                        isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {
                    return n;
                }

                Node or = IR.or(
                        cond.removeFirstChild(),
                        expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();

                return newExpr;
            }

            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                    isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {
                return n;
            }

            n.removeChild(cond);
            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();

            return newExpr;
        } else if (NodeUtil.isStatementBlock(thenBranch) &&
                   thenBranch.hasOneChild()) {
            Node innerIf = thenBranch.getFirstChild();

            if (innerIf.isIf()) {
                Node innerCond = innerIf.getFirstChild();
                Node innerThenBranch = innerCond.getNext();
                Node innerElseBranch = innerThenBranch.getNext();

                if (innerElseBranch == null &&
                     !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                       isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
                    n.detachChildren();
                    n.addChildToBack(
                        IR.and(
                            cond,
                            innerCond.detachFromParent())
                            .srcref(cond));
                    n.addChildrenToBack(innerThenBranch.detachFromParent());
                    reportCodeChange();
                    return n;
                }
            }
        }

        return n;
    }

    tryRemoveRepeatedStatements(n);

    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }

    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();

        Node returnNode = IR.returnNode(
            IR.hook(cond, thenExpr, elseExpr).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType() && NodeUtil.isAssignmentOp(thenOp)) {
            Node lhs = thenOp.getFirstChild();
            if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
                !mayEffectMutableState(lhs)) {

                n.removeChild(cond);
                Node assignName = thenOp.removeFirstChild();
                Node thenExpr = thenOp.removeFirstChild();
                Node elseExpr = elseOp.getLastChild();
                elseOp.removeChild(elseExpr);

                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                Node assign = new Node(thenOp.getType(), assignName, hookNode)
                              .srcref(thenOp);
                Node expr = NodeUtil.newExpr(assign);
                parent.replaceChild(n, expr);
                reportCodeChange();

                return expr;
            }
        }
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node expr = IR.exprResult(
            IR.hook(cond, thenOp, elseOp).srcref(n));
        parent.replaceChild(n, expr);
        reportCodeChange();
        return expr;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {

        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();

        if (name1.hasChildren()
            && maybeName2.isName()
            && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }

    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
               getBlockExpression(thenBranch).getFirstChild().isAssign()) {

        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();

        if (name2.hasChildren()
            && maybeName1.isName()
            && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();

            return var;
        }
    }

    return n;
}",0,0
46,Closure_132,"private Node tryMinimizeIf(Node n) {

    Node parent = n.getParent();

    Node cond = n.getFirstChild();

    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
      return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
      if (isFoldableExpressBlock(thenBranch)) {
        Node expr = getBlockExpression(thenBranch);
        if (!late && isPropertyAssignmentInExpression(expr)) {
          // Keep opportunities for CollapseProperties such as
          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
          // until CollapseProperties has been run.
          return n;
        }

        if (cond.isNot()) {
          // if(!x)bar(); -> x||bar();
          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
              isLowerPrecedenceInExpression(expr.getFirstChild(),
                  OR_PRECEDENCE)) {
            // It's not okay to add two sets of parentheses.
            return n;
          }

          Node or = IR.or(
              cond.removeFirstChild(),
              expr.removeFirstChild()).srcref(n);
          Node newExpr = NodeUtil.newExpr(or);
          parent.replaceChild(n, newExpr);
          reportCodeChange();

          return newExpr;
        }

        // if(x)foo(); -> x&&foo();
        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
            isLowerPrecedenceInExpression(expr.getFirstChild(),
                AND_PRECEDENCE)) {
          // One additional set of parentheses is worth the change even if
          // there is no immediate code size win. However, two extra pair of
          // {}, we would have to think twice. (unless we know for sure the
          // we can further optimize its parent.
          return n;
        }

        n.removeChild(cond);
        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
        Node newExpr = NodeUtil.newExpr(and);
        parent.replaceChild(n, newExpr);
        reportCodeChange();

        return newExpr;
      } else {

        // Try to combine two IF-ELSE
        if (NodeUtil.isStatementBlock(thenBranch) &&
            thenBranch.hasOneChild()) {
          Node innerIf = thenBranch.getFirstChild();

          if (innerIf.isIf()) {
            Node innerCond = innerIf.getFirstChild();
            Node innerThenBranch = innerCond.getNext();
            Node innerElseBranch = innerThenBranch.getNext();

            if (innerElseBranch == null &&
                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
              n.detachChildren();
              n.addChildToBack(
                  IR.and(
                      cond,
                      innerCond.detachFromParent())
                      .srcref(cond));
              n.addChildrenToBack(innerThenBranch.detachFromParent());
              reportCodeChange();
              // Not worth trying to fold the current IF-ELSE into && because
              // the inner IF-ELSE wasn't able to be folded into && anyways.
              return n;
            }
          }
        }
      }

      return n;
    }

    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);

    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
      n.replaceChild(cond, cond.removeFirstChild());
      n.removeChild(thenBranch);
      n.addChildToBack(thenBranch);
      reportCodeChange();
      return n;
    }

    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
      Node thenExpr = getBlockReturnExpression(thenBranch);
      Node elseExpr = getBlockReturnExpression(elseBranch);
      n.removeChild(cond);
      thenExpr.detachFromParent();
      elseExpr.detachFromParent();

      // note - we ignore any cases with ""return;"", technically this
      // can be converted to ""return undefined;"" or some variant, but
      // that does not help code size.
      Node returnNode = IR.returnNode(
                            IR.hook(cond, thenExpr, elseExpr)
                                .srcref(n));
      parent.replaceChild(n, returnNode);
      reportCodeChange();
      return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
      Node thenOp = getBlockExpression(thenBranch).getFirstChild();
      Node elseOp = getBlockExpression(elseBranch).getFirstChild();
      if (thenOp.getType() == elseOp.getType()) {
        // if(x)a=1;else a=2; -> a=x?1:2;
        if (NodeUtil.isAssignmentOp(thenOp)) {
          Node lhs = thenOp.getFirstChild();
          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
              // if LHS has side effects, don't proceed [since the optimization
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
               !mayEffectMutableState(lhs)) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
            Node thenExpr = thenOp.removeFirstChild();
            Node elseExpr = elseOp.getLastChild();
            elseOp.removeChild(elseExpr);

            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            Node assign = new Node(thenOp.getType(), assignName, hookNode)
                              .srcref(thenOp);
            Node expr = NodeUtil.newExpr(assign);
            parent.replaceChild(n, expr);
            reportCodeChange();

            return expr;
          }
        }
      }
      // if(x)foo();else bar(); -> x?foo():bar()
      n.removeChild(cond);
      thenOp.detachFromParent();
      elseOp.detachFromParent();
      Node expr = IR.exprResult(
          IR.hook(cond, thenOp, elseOp).srcref(n));
      parent.replaceChild(n, expr);
      reportCodeChange();
      return expr;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(thenBranch);
      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

      Node name1 = var.getFirstChild();
      Node maybeName2 = elseAssign.getFirstChild();

      if (name1.hasChildren()
          && maybeName2.isName()
          && name1.getString().equals(maybeName2.getString())) {
        Node thenExpr = name1.removeChildren();
        Node elseExpr = elseAssign.getLastChild().detachFromParent();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name1.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();
        return var;
      }

    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
        getBlockExpression(thenBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(elseBranch);
      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

      Node maybeName1 = thenAssign.getFirstChild();
      Node name2 = var.getFirstChild();

      if (name2.hasChildren()
          && maybeName1.isName()
          && maybeName1.getString().equals(name2.getString())) {
        Node thenExpr = thenAssign.getLastChild().detachFromParent();
        Node elseExpr = name2.removeChildren();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name2.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();

        return var;
      }
    }

    return n;
  }","private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();

    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch) && !late && !isPropertyAssignmentInExpression(getBlockExpression(thenBranch))) {
            Node expr = getBlockExpression(thenBranch);
            n.removeChild(cond);

            if (cond.isNot()) {
                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }

            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        }

        if (isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
            Node innerIf = thenBranch.getFirstChild();
            if (innerIf.isIf() && innerIf.getChildCount() == 2) {
                Node innerCond = innerIf.getFirstChild();
                Node innerThenBranch = innerIf.getSecondChild();

                n.detachChildren();
                n.addChildToBack(IR.and(cond, innerCond).srcref(cond));
                n.addChildrenToBack(innerThenBranch.detachFromParent());
                reportCodeChange();
                return n;
            }
        }

        return n;
    }

    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }

    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);

        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();

        if (thenOp.getType() == elseOp.getType() && NodeUtil.isAssignmentOp(thenOp)) {
            Node lhs = thenOp.getFirstChild();
            if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {
                n.removeChild(cond);
                Node hookNode = IR.hook(cond, thenOp.removeSecondChild(), elseOp.removeLastChild()).srcref(n);
                Node assign = new Node(thenOp.getType(), thenOp.removeFirstChild(), hookNode).srcref(thenOp);
                parent.replaceChild(n, NodeUtil.newExpr(assign));
                reportCodeChange();
                return n;
            }
        }

        n.removeChild(cond);
        parent.replaceChild(n, IR.exprResult(IR.hook(cond, thenOp, elseOp)).srcref(n));
        reportCodeChange();
        return n;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        if (var.getFirstChild().getString().equals(elseAssign.getFirstChild().getString())) {
            Node hookNode = IR.hook(cond, var.getFirstChild().removeChildren(), elseAssign.getLastChild()).srcref(n);
            var.getFirstChild().addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        if (var.getFirstChild().getString().equals(thenAssign.getFirstChild().getString())) {
            Node hookNode = IR.hook(cond, thenAssign.getLastChild(), var.getFirstChild().removeChildren()).srcref(n);
            var.getFirstChild().addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }

    return n;
}",1,0
46,Closure_132,"private Node tryMinimizeIf(Node n) {

    Node parent = n.getParent();

    Node cond = n.getFirstChild();

    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
      return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
      if (isFoldableExpressBlock(thenBranch)) {
        Node expr = getBlockExpression(thenBranch);
        if (!late && isPropertyAssignmentInExpression(expr)) {
          // Keep opportunities for CollapseProperties such as
          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
          // until CollapseProperties has been run.
          return n;
        }

        if (cond.isNot()) {
          // if(!x)bar(); -> x||bar();
          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
              isLowerPrecedenceInExpression(expr.getFirstChild(),
                  OR_PRECEDENCE)) {
            // It's not okay to add two sets of parentheses.
            return n;
          }

          Node or = IR.or(
              cond.removeFirstChild(),
              expr.removeFirstChild()).srcref(n);
          Node newExpr = NodeUtil.newExpr(or);
          parent.replaceChild(n, newExpr);
          reportCodeChange();

          return newExpr;
        }

        // if(x)foo(); -> x&&foo();
        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
            isLowerPrecedenceInExpression(expr.getFirstChild(),
                AND_PRECEDENCE)) {
          // One additional set of parentheses is worth the change even if
          // there is no immediate code size win. However, two extra pair of
          // {}, we would have to think twice. (unless we know for sure the
          // we can further optimize its parent.
          return n;
        }

        n.removeChild(cond);
        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
        Node newExpr = NodeUtil.newExpr(and);
        parent.replaceChild(n, newExpr);
        reportCodeChange();

        return newExpr;
      } else {

        // Try to combine two IF-ELSE
        if (NodeUtil.isStatementBlock(thenBranch) &&
            thenBranch.hasOneChild()) {
          Node innerIf = thenBranch.getFirstChild();

          if (innerIf.isIf()) {
            Node innerCond = innerIf.getFirstChild();
            Node innerThenBranch = innerCond.getNext();
            Node innerElseBranch = innerThenBranch.getNext();

            if (innerElseBranch == null &&
                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
              n.detachChildren();
              n.addChildToBack(
                  IR.and(
                      cond,
                      innerCond.detachFromParent())
                      .srcref(cond));
              n.addChildrenToBack(innerThenBranch.detachFromParent());
              reportCodeChange();
              // Not worth trying to fold the current IF-ELSE into && because
              // the inner IF-ELSE wasn't able to be folded into && anyways.
              return n;
            }
          }
        }
      }

      return n;
    }

    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);

    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
      n.replaceChild(cond, cond.removeFirstChild());
      n.removeChild(thenBranch);
      n.addChildToBack(thenBranch);
      reportCodeChange();
      return n;
    }

    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
      Node thenExpr = getBlockReturnExpression(thenBranch);
      Node elseExpr = getBlockReturnExpression(elseBranch);
      n.removeChild(cond);
      thenExpr.detachFromParent();
      elseExpr.detachFromParent();

      // note - we ignore any cases with ""return;"", technically this
      // can be converted to ""return undefined;"" or some variant, but
      // that does not help code size.
      Node returnNode = IR.returnNode(
                            IR.hook(cond, thenExpr, elseExpr)
                                .srcref(n));
      parent.replaceChild(n, returnNode);
      reportCodeChange();
      return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
      Node thenOp = getBlockExpression(thenBranch).getFirstChild();
      Node elseOp = getBlockExpression(elseBranch).getFirstChild();
      if (thenOp.getType() == elseOp.getType()) {
        // if(x)a=1;else a=2; -> a=x?1:2;
        if (NodeUtil.isAssignmentOp(thenOp)) {
          Node lhs = thenOp.getFirstChild();
          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
              // if LHS has side effects, don't proceed [since the optimization
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
               !mayEffectMutableState(lhs)) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
            Node thenExpr = thenOp.removeFirstChild();
            Node elseExpr = elseOp.getLastChild();
            elseOp.removeChild(elseExpr);

            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            Node assign = new Node(thenOp.getType(), assignName, hookNode)
                              .srcref(thenOp);
            Node expr = NodeUtil.newExpr(assign);
            parent.replaceChild(n, expr);
            reportCodeChange();

            return expr;
          }
        }
      }
      // if(x)foo();else bar(); -> x?foo():bar()
      n.removeChild(cond);
      thenOp.detachFromParent();
      elseOp.detachFromParent();
      Node expr = IR.exprResult(
          IR.hook(cond, thenOp, elseOp).srcref(n));
      parent.replaceChild(n, expr);
      reportCodeChange();
      return expr;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(thenBranch);
      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

      Node name1 = var.getFirstChild();
      Node maybeName2 = elseAssign.getFirstChild();

      if (name1.hasChildren()
          && maybeName2.isName()
          && name1.getString().equals(maybeName2.getString())) {
        Node thenExpr = name1.removeChildren();
        Node elseExpr = elseAssign.getLastChild().detachFromParent();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name1.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();
        return var;
      }

    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
        getBlockExpression(thenBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(elseBranch);
      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

      Node maybeName1 = thenAssign.getFirstChild();
      Node name2 = var.getFirstChild();

      if (name2.hasChildren()
          && maybeName1.isName()
          && maybeName1.getString().equals(name2.getString())) {
        Node thenExpr = thenAssign.getLastChild().detachFromParent();
        Node elseExpr = name2.removeChildren();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name2.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();

        return var;
      }
    }

    return n;
  }","private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();

    // Return early if the condition is literal.
    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
        // Handle foldable single branch
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                return n;
            }

            if (cond.isNot()) {
                Node or = IR.or(
                    cond.removeFirstChild(),
                    expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            } else {
                Node and = IR.and(
                    cond.removeFirstChild(),
                    expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(and);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }
        } else if (NodeUtil.isStatementBlock(thenBranch) &&
                   thenBranch.hasOneChild() &&
                   thenBranch.getFirstChild().isIf()) {
            Node innerIf = thenBranch.getFirstChild();
            Node innerCond = innerIf.getFirstChild();
            Node innerThenBranch = innerCond.getNext();

            n.detachChildren();
            n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));
            n.addChildrenToBack(innerThenBranch.detachFromParent());
            reportCodeChange();
            return n;
        }

        return n;
    }

    // Simplify conditional inversion for two branches
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }

    // Convert conditional return statements
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        Node returnNode = IR.returnNode(
            IR.hook(cond, thenExpr.detachFromParent(), elseExpr.detachFromParent()).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }

    // Merge identical assignments in both branches
    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType() && NodeUtil.isAssignmentOp(thenOp)) {
            Node lhs = thenOp.getFirstChild();
            if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {
                Node assign = new Node(thenOp.getType(), lhs.detachFromParent(),
                    IR.hook(cond, thenOp.getLastChild().detachFromParent(), elseOp.getLastChild().detachFromParent())
                        .srcref(n));
                Node expr = NodeUtil.newExpr(assign);
                parent.replaceChild(n, expr);
                reportCodeChange();
                return expr;
            }
        }

        Node hookNode = IR.hook(
            cond.detachFromParent(),
            thenOp.detachFromParent(),
            elseOp.detachFromParent()).srcref(n);
        Node expr = IR.exprResult(hookNode).srcref(n);
        parent.replaceChild(n, expr);
        reportCodeChange();
        return expr;
    }

    // Combine var assignments on both branches
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        if (areNodesEqualForInlining(var.getFirstChild(), elseAssign.getFirstChild())) {
            Node hookNode = IR.hook(cond, var.getFirstChild().removeChildren(),
                elseAssign.getLastChild().detachFromParent()).srcref(n);
            var.getFirstChild().addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
               getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        if (areNodesEqualForInlining(var.getFirstChild(), thenAssign.getFirstChild())) {
            Node hookNode = IR.hook(cond, thenAssign.getLastChild().detachFromParent(),
                var.getFirstChild().removeChildren()).srcref(n);
            var.getFirstChild().addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }

    return n;
}",2,0
46,Closure_132,"private Node tryMinimizeIf(Node n) {

    Node parent = n.getParent();

    Node cond = n.getFirstChild();

    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
      return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
      if (isFoldableExpressBlock(thenBranch)) {
        Node expr = getBlockExpression(thenBranch);
        if (!late && isPropertyAssignmentInExpression(expr)) {
          // Keep opportunities for CollapseProperties such as
          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
          // until CollapseProperties has been run.
          return n;
        }

        if (cond.isNot()) {
          // if(!x)bar(); -> x||bar();
          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
              isLowerPrecedenceInExpression(expr.getFirstChild(),
                  OR_PRECEDENCE)) {
            // It's not okay to add two sets of parentheses.
            return n;
          }

          Node or = IR.or(
              cond.removeFirstChild(),
              expr.removeFirstChild()).srcref(n);
          Node newExpr = NodeUtil.newExpr(or);
          parent.replaceChild(n, newExpr);
          reportCodeChange();

          return newExpr;
        }

        // if(x)foo(); -> x&&foo();
        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
            isLowerPrecedenceInExpression(expr.getFirstChild(),
                AND_PRECEDENCE)) {
          // One additional set of parentheses is worth the change even if
          // there is no immediate code size win. However, two extra pair of
          // {}, we would have to think twice. (unless we know for sure the
          // we can further optimize its parent.
          return n;
        }

        n.removeChild(cond);
        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
        Node newExpr = NodeUtil.newExpr(and);
        parent.replaceChild(n, newExpr);
        reportCodeChange();

        return newExpr;
      } else {

        // Try to combine two IF-ELSE
        if (NodeUtil.isStatementBlock(thenBranch) &&
            thenBranch.hasOneChild()) {
          Node innerIf = thenBranch.getFirstChild();

          if (innerIf.isIf()) {
            Node innerCond = innerIf.getFirstChild();
            Node innerThenBranch = innerCond.getNext();
            Node innerElseBranch = innerThenBranch.getNext();

            if (innerElseBranch == null &&
                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
              n.detachChildren();
              n.addChildToBack(
                  IR.and(
                      cond,
                      innerCond.detachFromParent())
                      .srcref(cond));
              n.addChildrenToBack(innerThenBranch.detachFromParent());
              reportCodeChange();
              // Not worth trying to fold the current IF-ELSE into && because
              // the inner IF-ELSE wasn't able to be folded into && anyways.
              return n;
            }
          }
        }
      }

      return n;
    }

    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);

    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
      n.replaceChild(cond, cond.removeFirstChild());
      n.removeChild(thenBranch);
      n.addChildToBack(thenBranch);
      reportCodeChange();
      return n;
    }

    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
      Node thenExpr = getBlockReturnExpression(thenBranch);
      Node elseExpr = getBlockReturnExpression(elseBranch);
      n.removeChild(cond);
      thenExpr.detachFromParent();
      elseExpr.detachFromParent();

      // note - we ignore any cases with ""return;"", technically this
      // can be converted to ""return undefined;"" or some variant, but
      // that does not help code size.
      Node returnNode = IR.returnNode(
                            IR.hook(cond, thenExpr, elseExpr)
                                .srcref(n));
      parent.replaceChild(n, returnNode);
      reportCodeChange();
      return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
      Node thenOp = getBlockExpression(thenBranch).getFirstChild();
      Node elseOp = getBlockExpression(elseBranch).getFirstChild();
      if (thenOp.getType() == elseOp.getType()) {
        // if(x)a=1;else a=2; -> a=x?1:2;
        if (NodeUtil.isAssignmentOp(thenOp)) {
          Node lhs = thenOp.getFirstChild();
          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
              // if LHS has side effects, don't proceed [since the optimization
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
               !mayEffectMutableState(lhs)) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
            Node thenExpr = thenOp.removeFirstChild();
            Node elseExpr = elseOp.getLastChild();
            elseOp.removeChild(elseExpr);

            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            Node assign = new Node(thenOp.getType(), assignName, hookNode)
                              .srcref(thenOp);
            Node expr = NodeUtil.newExpr(assign);
            parent.replaceChild(n, expr);
            reportCodeChange();

            return expr;
          }
        }
      }
      // if(x)foo();else bar(); -> x?foo():bar()
      n.removeChild(cond);
      thenOp.detachFromParent();
      elseOp.detachFromParent();
      Node expr = IR.exprResult(
          IR.hook(cond, thenOp, elseOp).srcref(n));
      parent.replaceChild(n, expr);
      reportCodeChange();
      return expr;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(thenBranch);
      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

      Node name1 = var.getFirstChild();
      Node maybeName2 = elseAssign.getFirstChild();

      if (name1.hasChildren()
          && maybeName2.isName()
          && name1.getString().equals(maybeName2.getString())) {
        Node thenExpr = name1.removeChildren();
        Node elseExpr = elseAssign.getLastChild().detachFromParent();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name1.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();
        return var;
      }

    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
        getBlockExpression(thenBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(elseBranch);
      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

      Node maybeName1 = thenAssign.getFirstChild();
      Node name2 = var.getFirstChild();

      if (name2.hasChildren()
          && maybeName1.isName()
          && maybeName1.getString().equals(name2.getString())) {
        Node thenExpr = thenAssign.getLastChild().detachFromParent();
        Node elseExpr = name2.removeChildren();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name2.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();

        return var;
      }
    }

    return n;
  }","private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();

    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                return n;
            }

            if (NodeUtil.isLiteralValue(cond.getFirstChild(), true)) {
                Node newExpr = NodeUtil.newExpr(cond.removeFirstChild());
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }

            n.removeChild(cond);
            Node foldedNode = cond.isNot()
                ? IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n)
                : IR.and(cond, expr.removeFirstChild()).srcref(n);

            Node newExpr = NodeUtil.newExpr(foldedNode);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        } else if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
            Node innerIf = thenBranch.getFirstChild();
            if (innerIf.isIf()) {
                Node innerCond = innerIf.getFirstChild();
                Node innerThenBranch = innerIf.getSecondChild();

                n.replaceChild(cond, IR.and(cond, innerCond.detachFromParent()).srcref(cond));
                cond.addChildrenToBack(innerThenBranch.detachFromParent());
                reportCodeChange();
                return cond;
            }
        }

        return n;
    }

    tryRemoveRepeatedStatements(n);

    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        Node swappedBranch = thenBranch.detachFromParent();
        n.removeChild(elseBranch);
        Node newCond = cond.removeFirstChild();
        n.replaceChild(cond, newCond);
        n.addChildToBack(swappedBranch);
        reportCodeChange();
        return n;
    }

    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);

        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr.detachFromParent(), elseExpr.detachFromParent()).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();

        if (thenOp.getType() == elseOp.getType() && NodeUtil.isAssignmentOp(thenOp) &&
            areNodesEqualForInlining(thenOp.getFirstChild(), elseOp.getFirstChild())) {
            Node lhs = thenOp.removeFirstChild();
            Node hookNode = IR.hook(cond, thenOp.removeFirstChild(), elseOp.removeFirstChild()).srcref(n);
            Node assignNode = new Node(Token.ASSIGN, lhs, hookNode).srcref(thenOp);
            parent.replaceChild(n, NodeUtil.newExpr(assignNode));
            reportCodeChange();
            return n;
        }

        Node hookNode = IR.hook(cond.detachFromParent(), thenOp.detachFromParent(), elseOp.detachFromParent()).srcref(n);
        parent.replaceChild(n, IR.exprResult(hookNode).srcref(n));
        reportCodeChange();
        return n;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

        if (areNodesEqualForInlining(var.getFirstChild(), elseAssign.getFirstChild())) {
            Node hookNode = IR.hook(cond, var.getFirstChild().removeChildren(),
                elseAssign.getLastChild().detachFromParent()).srcref(n);
            var.getFirstChild().addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
               getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

        if (areNodesEqualForInlining(var.getFirstChild(), thenAssign.getFirstChild())) {
            Node hookNode = IR.hook(cond, thenAssign.getLastChild().detachFromParent(),
                var.getFirstChild().removeChildren()).srcref(n);
            var.getFirstChild().addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }

    return n;
}",3,0
46,Closure_132,"private Node tryMinimizeIf(Node n) {

    Node parent = n.getParent();

    Node cond = n.getFirstChild();

    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
      return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
      if (isFoldableExpressBlock(thenBranch)) {
        Node expr = getBlockExpression(thenBranch);
        if (!late && isPropertyAssignmentInExpression(expr)) {
          // Keep opportunities for CollapseProperties such as
          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
          // until CollapseProperties has been run.
          return n;
        }

        if (cond.isNot()) {
          // if(!x)bar(); -> x||bar();
          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
              isLowerPrecedenceInExpression(expr.getFirstChild(),
                  OR_PRECEDENCE)) {
            // It's not okay to add two sets of parentheses.
            return n;
          }

          Node or = IR.or(
              cond.removeFirstChild(),
              expr.removeFirstChild()).srcref(n);
          Node newExpr = NodeUtil.newExpr(or);
          parent.replaceChild(n, newExpr);
          reportCodeChange();

          return newExpr;
        }

        // if(x)foo(); -> x&&foo();
        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
            isLowerPrecedenceInExpression(expr.getFirstChild(),
                AND_PRECEDENCE)) {
          // One additional set of parentheses is worth the change even if
          // there is no immediate code size win. However, two extra pair of
          // {}, we would have to think twice. (unless we know for sure the
          // we can further optimize its parent.
          return n;
        }

        n.removeChild(cond);
        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
        Node newExpr = NodeUtil.newExpr(and);
        parent.replaceChild(n, newExpr);
        reportCodeChange();

        return newExpr;
      } else {

        // Try to combine two IF-ELSE
        if (NodeUtil.isStatementBlock(thenBranch) &&
            thenBranch.hasOneChild()) {
          Node innerIf = thenBranch.getFirstChild();

          if (innerIf.isIf()) {
            Node innerCond = innerIf.getFirstChild();
            Node innerThenBranch = innerCond.getNext();
            Node innerElseBranch = innerThenBranch.getNext();

            if (innerElseBranch == null &&
                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
              n.detachChildren();
              n.addChildToBack(
                  IR.and(
                      cond,
                      innerCond.detachFromParent())
                      .srcref(cond));
              n.addChildrenToBack(innerThenBranch.detachFromParent());
              reportCodeChange();
              // Not worth trying to fold the current IF-ELSE into && because
              // the inner IF-ELSE wasn't able to be folded into && anyways.
              return n;
            }
          }
        }
      }

      return n;
    }

    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);

    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
      n.replaceChild(cond, cond.removeFirstChild());
      n.removeChild(thenBranch);
      n.addChildToBack(thenBranch);
      reportCodeChange();
      return n;
    }

    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
      Node thenExpr = getBlockReturnExpression(thenBranch);
      Node elseExpr = getBlockReturnExpression(elseBranch);
      n.removeChild(cond);
      thenExpr.detachFromParent();
      elseExpr.detachFromParent();

      // note - we ignore any cases with ""return;"", technically this
      // can be converted to ""return undefined;"" or some variant, but
      // that does not help code size.
      Node returnNode = IR.returnNode(
                            IR.hook(cond, thenExpr, elseExpr)
                                .srcref(n));
      parent.replaceChild(n, returnNode);
      reportCodeChange();
      return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
      Node thenOp = getBlockExpression(thenBranch).getFirstChild();
      Node elseOp = getBlockExpression(elseBranch).getFirstChild();
      if (thenOp.getType() == elseOp.getType()) {
        // if(x)a=1;else a=2; -> a=x?1:2;
        if (NodeUtil.isAssignmentOp(thenOp)) {
          Node lhs = thenOp.getFirstChild();
          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
              // if LHS has side effects, don't proceed [since the optimization
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
               !mayEffectMutableState(lhs)) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
            Node thenExpr = thenOp.removeFirstChild();
            Node elseExpr = elseOp.getLastChild();
            elseOp.removeChild(elseExpr);

            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            Node assign = new Node(thenOp.getType(), assignName, hookNode)
                              .srcref(thenOp);
            Node expr = NodeUtil.newExpr(assign);
            parent.replaceChild(n, expr);
            reportCodeChange();

            return expr;
          }
        }
      }
      // if(x)foo();else bar(); -> x?foo():bar()
      n.removeChild(cond);
      thenOp.detachFromParent();
      elseOp.detachFromParent();
      Node expr = IR.exprResult(
          IR.hook(cond, thenOp, elseOp).srcref(n));
      parent.replaceChild(n, expr);
      reportCodeChange();
      return expr;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(thenBranch);
      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

      Node name1 = var.getFirstChild();
      Node maybeName2 = elseAssign.getFirstChild();

      if (name1.hasChildren()
          && maybeName2.isName()
          && name1.getString().equals(maybeName2.getString())) {
        Node thenExpr = name1.removeChildren();
        Node elseExpr = elseAssign.getLastChild().detachFromParent();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name1.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();
        return var;
      }

    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
        getBlockExpression(thenBranch).getFirstChild().isAssign()) {

      Node var = getBlockVar(elseBranch);
      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

      Node maybeName1 = thenAssign.getFirstChild();
      Node name2 = var.getFirstChild();

      if (name2.hasChildren()
          && maybeName1.isName()
          && maybeName1.getString().equals(name2.getString())) {
        Node thenExpr = thenAssign.getLastChild().detachFromParent();
        Node elseExpr = name2.removeChildren();
        cond.detachFromParent();
        Node hookNode = IR.hook(cond, thenExpr, elseExpr)
                            .srcref(n);
        var.detachFromParent();
        name2.addChildrenToBack(hookNode);
        parent.replaceChild(n, var);
        reportCodeChange();

        return var;
      }
    }

    return n;
  }","private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();

    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }

    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();

    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                return n;
            }

            if (cond.isNot()) {
                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            } else {
                Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(and);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }
        } else if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild() &&
                   thenBranch.getFirstChild().isIf()) {
            Node innerIf = thenBranch.getFirstChild();
            Node innerCond = innerIf.getFirstChild();
            Node innerThenBranch = innerCond.getNext();

            n.detachChildren();
            n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));
            n.addChildrenToBack(innerThenBranch.detachFromParent());
            reportCodeChange();
            return n;
        }
        return n;
    }

    tryRemoveRepeatedStatements(n);

    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        Node thenBranchCopy = thenBranch.detachFromParent();
        n.removeChild(elseBranch);
        Node newCond = cond.removeFirstChild();
        n.replaceChild(cond, newCond);
        n.addChildToBack(thenBranchCopy);
        reportCodeChange();
        return n;
    }

    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        Node returnNode = IR.returnNode(
            IR.hook(cond, thenExpr.detachFromParent(), elseExpr.detachFromParent()).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }

    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();

        if (thenOp.getType() == elseOp.getType() && NodeUtil.isAssignmentOp(thenOp)) {
            Node lhs = thenOp.removeFirstChild();
            Node hookNode = IR.hook(cond, thenOp.removeFirstChild(), elseOp.removeLastChild()).srcref(n);
            Node assignNode = new Node(thenOp.getType(), lhs, hookNode).srcref(thenOp);
            parent.replaceChild(n, NodeUtil.newExpr(assignNode));
            reportCodeChange();
            return n;
        }

        Node hookNode = IR.hook(cond.detachFromParent(), thenOp.detachFromParent(), elseOp.detachFromParent()).srcref(n);
        parent.replaceChild(n, IR.exprResult(hookNode).srcref(n));
        reportCodeChange();
        return n;
    }

    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);

    if (thenBranchIsVar && elseBranchIsExpressionBlock &&
        getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

        if (areNodesEqualForInlining(var.getFirstChild(), elseAssign.getFirstChild())) {
            Node hookNode = IR.hook(cond, var.getFirstChild().removeChildren(),
                elseAssign.getLastChild().detachFromParent()).srcref(n);
            var.getFirstChild().addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
               getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

        if (areNodesEqualForInlining(var.getFirstChild(), thenAssign.getFirstChild())) {
            Node hookNode = IR.hook(cond, thenAssign.getLastChild().detachFromParent(),
                var.getFirstChild().removeChildren()).srcref(n);
            var.getFirstChild().addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }

    return n;
}",4,0
47,Closure_133,"private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }","private String getRemainingJSDocLine() {
    try {
        String result = stream.getRemainingJSDocLine();
        if (result == null || result.isEmpty()) {
            throw new IllegalStateException(""Recorded bad position information"");
        }
        return result;
    } catch (Exception e) {
        throw new IllegalStateException(""Error processing JSDoc line"", e);
    }
}",0,0
47,Closure_133,"private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }","private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();
    if (result == null) {
        return """"; // Return an empty string for null case
    }
    result = result.trim(); // Trim whitespace before proceeding
    if (result.isEmpty() || result.contains(""Recorded bad position information"")) {
        throw new IllegalStateException(""Position information contains errors: "" + result);
    }
    return result;
}",1,0
47,Closure_133,"private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }","private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();
    if (result != null && result.contains(""Recorded bad position information"")) {
        throw new IllegalStateException(""Recorded bad position information"");
    }
    return result != null ? result : """";
}",2,0
47,Closure_133,"private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }","private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();
    if (result == null || result.contains(""Recorded bad position information"")) {
        throw new IllegalStateException(""Recorded bad position information"");
    }
    return result;
}",3,0
47,Closure_133,"private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }","private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();
    if (result != null && result.matches("".*\\}\\s*"")) {
        throw new IllegalStateException(""Detected bad position information at the end of the line: "" + result);
    }
    return result != null ? result : """";
}",4,0
48,Closure_14,"private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
      return null;
    }

    // If we are just before a IF/WHILE/DO/FOR:
    switch (parent.getType()) {
      // The follow() of any of the path from IF would be what follows IF.
      case Token.IF:
        return computeFollowNode(fromNode, parent, cfa);
      case Token.CASE:
      case Token.DEFAULT_CASE:
        // After the body of a CASE, the control goes to the body of the next
        // case, without having to go to the case condition.
        if (parent.getNext() != null) {
          if (parent.getNext().isCase()) {
            return parent.getNext().getFirstChild().getNext();
          } else if (parent.getNext().isDefaultCase()) {
            return parent.getNext().getFirstChild();
          } else {
            Preconditions.checkState(false, ""Not reachable"");
          }
        } else {
          return computeFollowNode(fromNode, parent, cfa);
        }
        break;
      case Token.FOR:
        if (NodeUtil.isForIn(parent)) {
          return parent;
        } else {
          return parent.getFirstChild().getNext().getNext();
        }
      case Token.WHILE:
      case Token.DO:
        return parent;
      case Token.TRY:
        // If we are coming out of the TRY block...
        if (parent.getFirstChild() == node) {
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(parent.getLastChild());
          } else { // and have no FINALLY.
            return computeFollowNode(fromNode, parent, cfa);
          }
        // CATCH block.
        } else if (NodeUtil.getCatchBlock(parent) == node){
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(node.getNext());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        // If we are coming out of the FINALLY block...
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
        }
    }

    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();

    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
      nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
      return computeFallThrough(nextSibling);
    } else {
      // If there are no more siblings, control is transferred up the AST.
      return computeFollowNode(fromNode, parent, cfa);
    }
  }","private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
   
     Node parent = node.getParent();
     if (parent == null || parent.isFunction() ||
         (cfa != null && node == cfa.root)) {
       return null;
     }

     Node nextSibling = node.getNext();
     while (nextSibling != null && nextSibling.isFunction()) {
       nextSibling = nextSibling.getNext();
     }

     if (nextSibling != null) {
       return computeFallThrough(nextSibling);
     }

     switch (parent.getType()) {
       case Token.IF:
         return computeFollowNode(fromNode, parent, cfa);
       case Token.CASE:
       case Token.DEFAULT_CASE:
         if (parent.getNext() != null) {
           if (parent.getNext().isCase()) {
             return parent.getNext().getFirstChild().getNext();
           } else if (parent.getNext().isDefaultCase()) {
             return parent.getNext().getFirstChild();
           } else {
             Preconditions.checkState(false, ""Not reachable"");
           }
         } else {
           return computeFollowNode(fromNode, parent, cfa);
         }
         break;
       case Token.FOR:
         if (NodeUtil.isForIn(parent)) {
           return parent;
         } else {
           return parent.getFirstChild().getNext().getNext();
         }
       case Token.WHILE:
       case Token.DO:
         return parent;
       case Token.TRY:
         if (parent.getFirstChild() == node) {
           if (NodeUtil.hasFinally(parent)) {
             return computeFallThrough(parent.getLastChild());
           } else {
             return computeFollowNode(fromNode, parent, cfa);
           }
         } else if (NodeUtil.getCatchBlock(parent) == node) {
           if (NodeUtil.hasFinally(parent)) {
             return computeFallThrough(node.getNext());
           } else {
             return computeFollowNode(fromNode, parent, cfa);
           }
         } else if (parent.getLastChild() == node) {
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
        }
     }

     return computeFollowNode(fromNode, parent, cfa);
   }",0,0
48,Closure_14,"private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
      return null;
    }

    // If we are just before a IF/WHILE/DO/FOR:
    switch (parent.getType()) {
      // The follow() of any of the path from IF would be what follows IF.
      case Token.IF:
        return computeFollowNode(fromNode, parent, cfa);
      case Token.CASE:
      case Token.DEFAULT_CASE:
        // After the body of a CASE, the control goes to the body of the next
        // case, without having to go to the case condition.
        if (parent.getNext() != null) {
          if (parent.getNext().isCase()) {
            return parent.getNext().getFirstChild().getNext();
          } else if (parent.getNext().isDefaultCase()) {
            return parent.getNext().getFirstChild();
          } else {
            Preconditions.checkState(false, ""Not reachable"");
          }
        } else {
          return computeFollowNode(fromNode, parent, cfa);
        }
        break;
      case Token.FOR:
        if (NodeUtil.isForIn(parent)) {
          return parent;
        } else {
          return parent.getFirstChild().getNext().getNext();
        }
      case Token.WHILE:
      case Token.DO:
        return parent;
      case Token.TRY:
        // If we are coming out of the TRY block...
        if (parent.getFirstChild() == node) {
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(parent.getLastChild());
          } else { // and have no FINALLY.
            return computeFollowNode(fromNode, parent, cfa);
          }
        // CATCH block.
        } else if (NodeUtil.getCatchBlock(parent) == node){
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(node.getNext());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        // If we are coming out of the FINALLY block...
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
        }
    }

    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();

    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
      nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
      return computeFallThrough(nextSibling);
    } else {
      // If there are no more siblings, control is transferred up the AST.
      return computeFollowNode(fromNode, parent, cfa);
    }
  }","private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {
        return null;
    }

    Node nextSibling = node.getNext();
    if (nextSibling != null && !nextSibling.isFunction()) {
        return computeFallThrough(nextSibling);
    }

    switch (parent.getType()) {
        case Token.IF:
        case Token.CASE:
        case Token.DEFAULT_CASE:
            if (parent.getNext() != null) {
                return parent.getNext().getFirstChild();
            } else {
                return computeFollowNode(fromNode, parent, cfa);
            }
        case Token.FOR:
            if (NodeUtil.isForIn(parent)) {
                return parent;
            } else {
                return parent.getFirstChild().getNext().getNext();
            }
        case Token.WHILE:
        case Token.DO:
            return parent;
        case Token.TRY:
            if (node == NodeUtil.getCatchBlock(parent) && NodeUtil.hasFinally(parent)) {
                return computeFallThrough(parent.getLastChild());
            } else {
                return computeFollowNode(fromNode, parent, cfa);
            }
    }
    return computeFollowNode(fromNode, parent, cfa);
}",1,0
48,Closure_14,"private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
      return null;
    }

    // If we are just before a IF/WHILE/DO/FOR:
    switch (parent.getType()) {
      // The follow() of any of the path from IF would be what follows IF.
      case Token.IF:
        return computeFollowNode(fromNode, parent, cfa);
      case Token.CASE:
      case Token.DEFAULT_CASE:
        // After the body of a CASE, the control goes to the body of the next
        // case, without having to go to the case condition.
        if (parent.getNext() != null) {
          if (parent.getNext().isCase()) {
            return parent.getNext().getFirstChild().getNext();
          } else if (parent.getNext().isDefaultCase()) {
            return parent.getNext().getFirstChild();
          } else {
            Preconditions.checkState(false, ""Not reachable"");
          }
        } else {
          return computeFollowNode(fromNode, parent, cfa);
        }
        break;
      case Token.FOR:
        if (NodeUtil.isForIn(parent)) {
          return parent;
        } else {
          return parent.getFirstChild().getNext().getNext();
        }
      case Token.WHILE:
      case Token.DO:
        return parent;
      case Token.TRY:
        // If we are coming out of the TRY block...
        if (parent.getFirstChild() == node) {
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(parent.getLastChild());
          } else { // and have no FINALLY.
            return computeFollowNode(fromNode, parent, cfa);
          }
        // CATCH block.
        } else if (NodeUtil.getCatchBlock(parent) == node){
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(node.getNext());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        // If we are coming out of the FINALLY block...
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
        }
    }

    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();

    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
      nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
      return computeFallThrough(nextSibling);
    } else {
      // If there are no more siblings, control is transferred up the AST.
      return computeFollowNode(fromNode, parent, cfa);
    }
  }","private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {
        return null;
    }

    switch (parent.getType()) {
        case Token.IF:
            return parent.getNext() != null ? parent.getNext().getFirstChild() : computeFollowNode(fromNode, parent, cfa);
        case Token.CASE:
        case Token.DEFAULT_CASE:
            if (parent.getNext() != null) {
                Node nextCase = parent.getNext();
                if (nextCase.isCase() || nextCase.isDefaultCase()) {
                    return nextCase.getFirstChild();
                }
            }
            return computeFollowNode(fromNode, parent, cfa);
        case Token.FOR:
            return NodeUtil.isForIn(parent) ? parent.getFirstChild() : parent.getFirstChild().getNext().getNext();
        case Token.WHILE:
        case Token.DO:
            return parent;
        case Token.TRY:
            if (node == parent.getFirstChild() && NodeUtil.hasFinally(parent)) {
                return computeFallThrough(parent.getLastChild());
            } else if (node == NodeUtil.getCatchBlock(parent)) {
                return NodeUtil.hasFinally(parent) ? computeFallThrough(parent.getLastChild()) : computeFollowNode(fromNode, parent, cfa);
            } else if (node == parent.getLastChild() && cfa != null) {
                for (Node finallyNode : cfa.finallyMap.get(parent)) {
                    cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
                }
                return computeFollowNode(fromNode, parent, cfa);
            }
    }

    Node nextSibling = node.getNext();
    if (nextSibling != null && !nextSibling.isFunction()) {
        return computeFallThrough(nextSibling);
    }

    return computeFollowNode(fromNode, parent, cfa);
}",2,0
48,Closure_14,"private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
      return null;
    }

    // If we are just before a IF/WHILE/DO/FOR:
    switch (parent.getType()) {
      // The follow() of any of the path from IF would be what follows IF.
      case Token.IF:
        return computeFollowNode(fromNode, parent, cfa);
      case Token.CASE:
      case Token.DEFAULT_CASE:
        // After the body of a CASE, the control goes to the body of the next
        // case, without having to go to the case condition.
        if (parent.getNext() != null) {
          if (parent.getNext().isCase()) {
            return parent.getNext().getFirstChild().getNext();
          } else if (parent.getNext().isDefaultCase()) {
            return parent.getNext().getFirstChild();
          } else {
            Preconditions.checkState(false, ""Not reachable"");
          }
        } else {
          return computeFollowNode(fromNode, parent, cfa);
        }
        break;
      case Token.FOR:
        if (NodeUtil.isForIn(parent)) {
          return parent;
        } else {
          return parent.getFirstChild().getNext().getNext();
        }
      case Token.WHILE:
      case Token.DO:
        return parent;
      case Token.TRY:
        // If we are coming out of the TRY block...
        if (parent.getFirstChild() == node) {
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(parent.getLastChild());
          } else { // and have no FINALLY.
            return computeFollowNode(fromNode, parent, cfa);
          }
        // CATCH block.
        } else if (NodeUtil.getCatchBlock(parent) == node){
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(node.getNext());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        // If we are coming out of the FINALLY block...
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
        }
    }

    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();

    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
      nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
      return computeFallThrough(nextSibling);
    } else {
      // If there are no more siblings, control is transferred up the AST.
      return computeFollowNode(fromNode, parent, cfa);
    }
  }","private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {
        return null;
    }

    // Check the node type and handle accordingly
    switch (node.getType()) {
        case Token.BREAK:
        case Token.CONTINUE:
            return NodeUtil.getLoopFromLabel(node);
    }

    Node nextSibling = node.getNext();
    if (nextSibling != null && !nextSibling.isFunction()) {
        return computeFallThrough(nextSibling);
    }

    switch (parent.getType()) {
        case Token.IF:
        case Token.CASE:
        case Token.DEFAULT_CASE:
            if (parent.getNext() != null) {
                return parent.getNext().getFirstChild();
            } else {
                return computeFollowNode(fromNode, parent, cfa);
            }
        case Token.FOR:
            if (NodeUtil.isForIn(parent)) {
                return parent;
            } else {
                return parent.getFirstChild().getNext().getNext();
            }
        case Token.WHILE:
        case Token.DO:
            return parent;
        case Token.TRY:
            if (node == NodeUtil.getCatchBlock(parent) && NodeUtil.hasFinally(parent)) {
                return computeFallThrough(parent.getLastChild());
            } else {
                return computeFollowNode(fromNode, parent, cfa);
            }
    }

    return computeFollowNode(fromNode, parent, cfa);
}",3,0
48,Closure_14,"private static Node computeFollowNode(
      Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() ||
        (cfa != null && node == cfa.root)) {
      return null;
    }

    // If we are just before a IF/WHILE/DO/FOR:
    switch (parent.getType()) {
      // The follow() of any of the path from IF would be what follows IF.
      case Token.IF:
        return computeFollowNode(fromNode, parent, cfa);
      case Token.CASE:
      case Token.DEFAULT_CASE:
        // After the body of a CASE, the control goes to the body of the next
        // case, without having to go to the case condition.
        if (parent.getNext() != null) {
          if (parent.getNext().isCase()) {
            return parent.getNext().getFirstChild().getNext();
          } else if (parent.getNext().isDefaultCase()) {
            return parent.getNext().getFirstChild();
          } else {
            Preconditions.checkState(false, ""Not reachable"");
          }
        } else {
          return computeFollowNode(fromNode, parent, cfa);
        }
        break;
      case Token.FOR:
        if (NodeUtil.isForIn(parent)) {
          return parent;
        } else {
          return parent.getFirstChild().getNext().getNext();
        }
      case Token.WHILE:
      case Token.DO:
        return parent;
      case Token.TRY:
        // If we are coming out of the TRY block...
        if (parent.getFirstChild() == node) {
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(parent.getLastChild());
          } else { // and have no FINALLY.
            return computeFollowNode(fromNode, parent, cfa);
          }
        // CATCH block.
        } else if (NodeUtil.getCatchBlock(parent) == node){
          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
            return computeFallThrough(node.getNext());
          } else {
            return computeFollowNode(fromNode, parent, cfa);
          }
        // If we are coming out of the FINALLY block...
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
        }
    }

    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();

    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
      nextSibling = nextSibling.getNext();
    }

    if (nextSibling != null) {
      return computeFallThrough(nextSibling);
    } else {
      // If there are no more siblings, control is transferred up the AST.
      return computeFollowNode(fromNode, parent, cfa);
    }
  }","private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {
        return null;
    }

    if (node.isReturn()) {
        return null; // Return statements transfer control to the caller
    }

    Node nextSibling = node.getNext();
    if (nextSibling != null) {
        while (nextSibling != null && nextSibling.isFunction()) {
            nextSibling = nextSibling.getNext();
        }
        if (nextSibling != null) {
            return computeFallThrough(nextSibling); // Follow the next sibling
        }
    }

    switch (parent.getType()) {
        case Token.IF:
            Node thenBlock = parent.getFirstChild();
            Node elseBlock = thenBlock.getNext();
            if (node == thenBlock && elseBlock != null) {
                return computeFallThrough(elseBlock); // Use else block if exists
            }
            break;

        case Token.CASE:
        case Token.DEFAULT_CASE:
            Node nextCase = parent.getNext();
            if (nextCase != null) {
                if (nextCase.isCase() || nextCase.isDefaultCase()) {
                    return nextCase.getFirstChild();
                }
            }
            break;

        case Token.FOR:
            return parent.getLastChild(); // Return the update expression

        case Token.WHILE:
        case Token.DO:
            return parent.getFirstChild();

        case Token.TRY:
            Node catchBlock = NodeUtil.getCatchBlock(parent);
            Node finallyBlock = parent.getLastChild();
            if (node == parent.getFirstChild() && NodeUtil.hasFinally(parent)) {
                return computeFallThrough(finallyBlock); // Handle FINALLY after TRY
            } else if (node == catchBlock && NodeUtil.hasFinally(parent)) {
                return computeFallThrough(finallyBlock); // Handle FINALLY after CATCH
            }
            break;
    }

    // Backtrack up the AST
    return computeFollowNode(fromNode, parent, cfa);
}",4,0
49,Closure_15,"@Override
      public boolean apply(Node n) {
        // When the node is null it means, we reached the implicit return
        // where the function returns (possibly without an return statement)
        if (n == null) {
          return false;
        }

        // TODO(user): We only care about calls to functions that
        // passes one of the dependent variable to a non-side-effect free
        // function.
        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
          return true;
        }

        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
           return true;
         }
 
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
          }
        }
        return false;
      }","@Override
public boolean apply(Node n) {
    // When the node is null it means, we reached the implicit return
    // where the function returns (possibly without a return statement)
    if (n == null) {
        return false;
    }

    // We only care about calls to functions that pass one of the dependent 
    // variables to a non-side-effect free function.
    if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
        return true;
    }

    if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
        return true;
    }

    // Traverse the children of the current node, ensuring we skip unnecessary CFG nodes
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {
            // Apply recursively to child nodes
            if (apply(c)) {
                return true;
            }
        }
    }

    return false;
}",0,0
49,Closure_15,"@Override
      public boolean apply(Node n) {
        // When the node is null it means, we reached the implicit return
        // where the function returns (possibly without an return statement)
        if (n == null) {
          return false;
        }

        // TODO(user): We only care about calls to functions that
        // passes one of the dependent variable to a non-side-effect free
        // function.
        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
          return true;
        }

        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
           return true;
         }
 
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
          }
        }
        return false;
      }","@Override
public boolean apply(Node n) {
    // Return false for null nodes (end of traversal)
    if (n == null) {
        return false;
    }

    // Check for function calls with side effects
    if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
        return true;
    }

    // Check for constructor calls with side effects
    if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
        return true;
    }

    // Skip nodes that are entering new CFG nodes and traverse all children
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {
            // Introduce a stricter condition for child node traversal
            if (c.isExpression() || c.isReturn()) {
                if (apply(c)) {
                    return true;
                }
            }
        }
    }

    return false;
}",1,0
49,Closure_15,"@Override
      public boolean apply(Node n) {
        // When the node is null it means, we reached the implicit return
        // where the function returns (possibly without an return statement)
        if (n == null) {
          return false;
        }

        // TODO(user): We only care about calls to functions that
        // passes one of the dependent variable to a non-side-effect free
        // function.
        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
          return true;
        }

        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
           return true;
         }
 
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
          }
        }
        return false;
      }","@Override
public boolean apply(Node n) {
    // Return false for null nodes
    if (n == null) {
        return false;
    }

    // Check for function calls with side effects
    if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
        return true;
    }

    // Check for constructor calls with side effects
    if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
        return true;
    }

    // Traverse children, applying stricter conditions
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {
            if (c.isFunction() || c.isBlock()) { // Enhanced condition for relevant nodes
                if (apply(c)) {
                    return true;
                }
            }
        }
    }

    return false;
}",2,0
49,Closure_15,"@Override
      public boolean apply(Node n) {
        // When the node is null it means, we reached the implicit return
        // where the function returns (possibly without an return statement)
        if (n == null) {
          return false;
        }

        // TODO(user): We only care about calls to functions that
        // passes one of the dependent variable to a non-side-effect free
        // function.
        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
          return true;
        }

        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
           return true;
         }
 
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
          }
        }
        return false;
      }","@Override
public boolean apply(Node n) {
    // Return false for null nodes
    if (n == null) {
        return false;
    }

    // Check for function calls with side effects
    if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
        return true;
    }

    // Check for constructor calls with side effects
    if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
        return true;
    }

    // Traverse children, adding explicit node type checks and early exit
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {
            // Limit recursive calls to specific node types to avoid infinite loops
            if (c.isExpression() || c.isFunction() || c.isAssign()) {
                if (apply(c)) {
                    return true;
                }
            }
        }
    }

    return false;
}",3,0
49,Closure_15,"@Override
      public boolean apply(Node n) {
        // When the node is null it means, we reached the implicit return
        // where the function returns (possibly without an return statement)
        if (n == null) {
          return false;
        }

        // TODO(user): We only care about calls to functions that
        // passes one of the dependent variable to a non-side-effect free
        // function.
        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
          return true;
        }

        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
           return true;
         }
 
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
          }
        }
        return false;
      }","@Override
public boolean apply(Node n) {
    // Return false if the node is null
    if (n == null) {
        return false;
    }

    // Check for function calls with side effects on dependent variables
    if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
        return true;
    }

    // Check for constructor calls with side effects
    if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
        return true;
    }

    // Traverse child nodes, limiting recursion to avoid unnecessary checks
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {
            // Apply stricter checks on child nodes before invoking recursively
            if (c.isCall() || c.isNew() || (c.isAssign() && NodeUtil.assignHasSideEffects(c))) {
                if (apply(c)) {
                    return true;
                }
            }
        }
    }

    return false;
}",4,0
50,Closure_17,"private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else {
          // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
              } else if (rValue.isOr()) {
                // Check for a very specific JS idiom:
                // var x = x || TYPE;
                // This is used by Closure's base namespace for esoteric
                // reasons.
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName()
                    && lValue.isName()
                    && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null
                    && !secondClause.getJSType().isUnknownType()) {
                  return secondClause.getJSType();
                }
              }
            }
          }
        }
      }

      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }","private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else if (info.isConstant()) {
          if (rValue != null) {
            if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
              // If rValue has a type-cast, we use the type in the type-cast.
              // If rValue's type was already computed during scope creation,
              // then we can safely use that.
              return rValue.getJSType();
            } else if (rValue.isOr()) {
              // Check for a very specific JS idiom:
              // var x = x || TYPE;
              // This is used by Closure's base namespace for esoteric
              // reasons.
              Node firstClause = rValue.getFirstChild();
              Node secondClause = firstClause.getNext();
              boolean namesMatch = firstClause.isName()
                  && lValue.isName()
                  && firstClause.getString().equals(lValue.getString());
              if (namesMatch && secondClause.getJSType() != null
                  && !secondClause.getJSType().isUnknownType()) {
                return secondClause.getJSType();
              }
            }
          }
        }
      }

      // Fix: Ensure consistency in the return type by adding a final fallback
      return null;
    }",0,0
50,Closure_17,"private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else {
          // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
              } else if (rValue.isOr()) {
                // Check for a very specific JS idiom:
                // var x = x || TYPE;
                // This is used by Closure's base namespace for esoteric
                // reasons.
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName()
                    && lValue.isName()
                    && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null
                    && !secondClause.getJSType().isUnknownType()) {
                  return secondClause.getJSType();
                }
              }
            }
          }
        }
      }

      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }","private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
    if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }

    if (rValue != null && rValue.isFunction() &&
            shouldUseFunctionLiteralType(
                    JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    }

    if (info != null) {
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            }
            return createEnumTypeFromNodes(
                    rValue, lValue.getQualifiedName(), info, lValue);
        }

        if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(
                    rValue, lValue.getQualifiedName(), info, lValue);
        }

        if (info.isConstant()) {
            if (rValue != null) {
                // Fix: Handle unknown types explicitly to ensure accurate determination.
                if (rValue.getJSType() != null) {
                    if (!rValue.getJSType().isUnknownType()) {
                        return rValue.getJSType();
                    }
                } else if (rValue.isOr()) {
                    Node firstClause = rValue.getFirstChild();
                    Node secondClause = firstClause.getNext();
                    boolean namesMatch = firstClause.isName()
                            && lValue.isName()
                            && firstClause.getString().equals(lValue.getString());
                    if (namesMatch && secondClause.getJSType() != null) {
                        if (!secondClause.getJSType().isUnknownType()) {
                            return secondClause.getJSType();
                        }
                    }
                }
            }
        }

        // Fix: Ensure a fallback mechanism is in place to handle constant declarations lacking a clear type.
        return createDefaultTypeForConstant(lValue, info);
    }

    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}",1,0
50,Closure_17,"private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else {
          // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
              } else if (rValue.isOr()) {
                // Check for a very specific JS idiom:
                // var x = x || TYPE;
                // This is used by Closure's base namespace for esoteric
                // reasons.
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName()
                    && lValue.isName()
                    && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null
                    && !secondClause.getJSType().isUnknownType()) {
                  return secondClause.getJSType();
                }
              }
            }
          }
        }
      }

      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }","private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {
    JSType declaredType = null;

    if (info != null) {
        if (info.hasType()) {
            declaredType = getDeclaredTypeInAnnotation(sourceName, lValue, info);
        } else if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                declaredType = rValue.getJSType();
            } else {
                declaredType = createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            declaredType = createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        } 
    }

    if (declaredType == null && rValue != null && rValue.isFunction() &&
        shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        declaredType = rValue.getJSType();
    }

    if (declaredType == null && info != null && info.isConstant()) {
        if (rValue != null) {
            if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                declaredType = rValue.getJSType();
            } else if (rValue.isOr()) {
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {
                    declaredType = secondClause.getJSType();
                }
            }
        }
    }

    // Use a default type if no specific type information is provided
    if (declaredType == null) {
        declaredType = createDefaultType(lValue, info);
    }

    return declaredType;
}",2,0
50,Closure_17,"private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else {
          // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
              } else if (rValue.isOr()) {
                // Check for a very specific JS idiom:
                // var x = x || TYPE;
                // This is used by Closure's base namespace for esoteric
                // reasons.
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName()
                    && lValue.isName()
                    && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null
                    && !secondClause.getJSType().isUnknownType()) {
                  return secondClause.getJSType();
                }
              }
            }
          }
        }
      }

      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }","private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {
    JSType declaredType = null;

    if (info != null) {
        if (info.hasType()) {
            declaredType = getDeclaredTypeInAnnotation(sourceName, lValue, info);
        } else if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                declaredType = rValue.getJSType();
            } else {
                declaredType = createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            declaredType = createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        }
    }

    if (declaredType == null && rValue != null && rValue.isFunction() &&
        shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        declaredType = rValue.getJSType();
    }

    if (declaredType == null && info != null && info.isConstant()) {
        if (rValue != null) {
            if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                declaredType = rValue.getJSType();
            } else if (rValue.isOr()) {
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {
                    declaredType = secondClause.getJSType();
                }
            }
        }
    }

    // Fix: Make sure to return the type determined from lValue if everything else fails, avoiding null return.
    if (declaredType == null) {
        declaredType = lValue.getJSType();
        if (declaredType == null) {
            // Provide a safe fallback by determining the type through a default creation mechanism
            declaredType = createDefaultType(lValue, info);
        }
    }
    
    return declaredType;
}",3,0
50,Closure_17,"private JSType getDeclaredType(String sourceName, JSDocInfo info,
        Node lValue, @Nullable Node rValue) {
      if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
      } else if (rValue != null && rValue.isFunction() &&
          shouldUseFunctionLiteralType(
              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
      } else if (info != null) {
        if (info.hasEnumParameterType()) {
          if (rValue != null && rValue.isObjectLit()) {
            return rValue.getJSType();
          } else {
            return createEnumTypeFromNodes(
                rValue, lValue.getQualifiedName(), info, lValue);
          }
        } else if (info.isConstructor() || info.isInterface()) {
          return createFunctionTypeFromNodes(
              rValue, lValue.getQualifiedName(), info, lValue);
        } else {
          // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
              } else if (rValue.isOr()) {
                // Check for a very specific JS idiom:
                // var x = x || TYPE;
                // This is used by Closure's base namespace for esoteric
                // reasons.
                Node firstClause = rValue.getFirstChild();
                Node secondClause = firstClause.getNext();
                boolean namesMatch = firstClause.isName()
                    && lValue.isName()
                    && firstClause.getString().equals(lValue.getString());
                if (namesMatch && secondClause.getJSType() != null
                    && !secondClause.getJSType().isUnknownType()) {
                  return secondClause.getJSType();
                }
              }
            }
          }
        }
      }

      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    }","private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {
    JSType declaredType = null;

    if (info != null) {
        if (info.hasType()) {
            declaredType = getDeclaredTypeInAnnotation(sourceName, lValue, info);
        } else if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                declaredType = rValue.getJSType();
            } else {
                declaredType = createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            declaredType = createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        } else if (info.isConstant()) {
            if (rValue != null) {
                if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                    declaredType = rValue.getJSType();
                } else if (rValue.isOr()) {
                    Node firstClause = rValue.getFirstChild();
                    Node secondClause = firstClause.getNext();
                    boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());
                    if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {
                        declaredType = secondClause.getJSType();
                    }
                }
            }
        }
    }

    if (declaredType == null && rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        declaredType = rValue.getJSType();
    }

    // Fix: Providing a fallback by creating a default type consistent with context to avoid inconsistent return type.
    if (declaredType == null) {
        declaredType = createDefaultType(lValue, info);
    }

    return declaredType;
}",4,0
51,Closure_18,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      hoistExterns(externsRoot);
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
       if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      hoistNoCompileFiles();

      if (staleInputs) {
        repartitionInputs();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        hoistExterns(externsRoot);

        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs =
                    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                        .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(
                    JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(
                    MISSING_ENTRY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }

        hoistNoCompileFiles();

        if (staleInputs) {
            repartitionInputs();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null ||
                options.nameReferenceReportPath != null) {

                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia =
                    new SourceInformationAnnotator(
                        input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",0,0
51,Closure_18,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      hoistExterns(externsRoot);
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
       if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      hoistNoCompileFiles();

      if (staleInputs) {
        repartitionInputs();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        hoistExterns(externsRoot);

        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                        .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException | MissingProvideException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                if (hasErrors()) {
                    return null;
                }
            }
        }

        hoistNoCompileFiles();

        if (staleInputs) {
            repartitionInputs();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",1,0
51,Closure_18,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      hoistExterns(externsRoot);
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
       if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      hoistNoCompileFiles();

      if (staleInputs) {
        repartitionInputs();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        hoistExterns(externsRoot);

        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement()) {
            staleInputs = options.closurePass && manageDependencies();
        }

        hoistNoCompileFiles();

        if (staleInputs) {
            repartitionInputs();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}

// Helper method added within Method 1
private boolean manageDependencies() {
    for (CompilerInput input : inputs) {
        for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
        }
    }
    try {
        inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                .manageDependencies(options.dependencyOptions, inputs);
        return true;
    } catch (CircularDependencyException | MissingProvideException e) {
        report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
        return hasErrors();
    }
}",2,0
51,Closure_18,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      hoistExterns(externsRoot);
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
       if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      hoistNoCompileFiles();

      if (staleInputs) {
        repartitionInputs();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                report(JSError.make(MISSING_ENTRY_ERROR, input.getName()));
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        hoistExterns(externsRoot);

        // Check if the sources need to be re-ordered.
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs =
                    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                        .manageDependencies(options.dependencyOptions, inputs);
            } catch (Exception e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                if (hasErrors() || !(e instanceof CircularDependencyException)) {
                    return null;
                }
            }
        }

        hoistNoCompileFiles();

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                report(JSError.make(MISSING_ENTRY_ERROR, input.getName()));
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), devMode);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",3,0
51,Closure_18,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      hoistExterns(externsRoot);
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
       if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      hoistNoCompileFiles();

      if (staleInputs) {
        repartitionInputs();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) {
                report(JSError.make(MISSING_ENTRY_ERROR, input.getName()));
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        hoistExterns(externsRoot);

        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            try {
                inputs = manageAndSortDependencies(inputs);
                staleInputs = true;
            } catch (DependencyManagementException e) {
                report(JSError.make(DEPENDENCY_ERROR, e.getMessage()));
                if (hasErrors()) {
                    return null;
                }
            }
        }

        hoistNoCompileFiles();

        if (staleInputs) {
            repartitionInputs();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                report(JSError.make(MISSING_ENTRY_ERROR, input.getName()));
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), devMode);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}

// Helper Method for Fixed Method 1
private List<CompilerInput> manageAndSortDependencies(List<CompilerInput> inputs) throws DependencyManagementException {
    for (CompilerInput input : inputs) {
        for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
        }
    }
    try {
        return (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
            .manageDependencies(options.dependencyOptions, inputs);
    } catch (CircularDependencyException | MissingProvideException e) {
        throw new DependencyManagementException(e.getMessage());
    }
}

// Exception Class for Dependency Management
private static class DependencyManagementException extends Exception {
    public DependencyManagementException(String message) {
        super(message);
    }
}",4,0
52,Closure_19,"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch (node.getType()) {
      case Token.NAME:
        scope.inferSlotType(node.getString(), type);
        break;

      case Token.GETPROP:
        String qualifiedName = node.getQualifiedName();
        Preconditions.checkNotNull(qualifiedName);

        JSType origType = node.getJSType();
        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
         scope.inferQualifiedSlot(node, qualifiedName, origType, type);
         break;
 
         // ""this"" references aren't currently modeled in the CFG.
 
       default:
         throw new IllegalArgumentException(""Node cannot be refined. \n"" +
            node.toStringTree());
    }
  }","protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch (node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;

        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);

            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;

        // Handle ""this"" explicitly to avoid exceptions
        case Token.THIS:
            // No inference is performed for ""this"" references as per the model.
            break;

        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" +
                node.toStringTree());
    }
}",0,0
53,Closure_2,"private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
      String functionName, HashMap<String, ObjectType> properties,
      HashMap<String, ObjectType> currentProperties,
       ObjectType interfaceType) {
     ObjectType implicitProto = interfaceType.getImplicitPrototype();
     Set<String> currentPropertyNames;
       // This can be the case if interfaceType is proxy to a non-existent
       // object (which is a bad type annotation, but shouldn't crash).
       currentPropertyNames = implicitProto.getOwnPropertyNames();
     for (String name : currentPropertyNames) {
       ObjectType oType = properties.get(name);
       if (oType != null) {
        if (!interfaceType.getPropertyType(name).isEquivalentTo(
            oType.getPropertyType(name))) {
          compiler.report(
              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
                  functionName, name, oType.toString(),
                  interfaceType.toString()));
        }
      }
      currentProperties.put(name, interfaceType);
    }
    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
      checkInterfaceConflictProperties(t, n, functionName, properties,
          currentProperties, iType);
    }
  }","private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
    String functionName, HashMap<String, ObjectType> properties,
    HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {
    ObjectType implicitProto = interfaceType.getImplicitPrototype();
    if (implicitProto == null) {
        // Handle the case where interfaceType is proxy to a non-existent object
        return;
    }
    Set<String> currentPropertyNames = implicitProto.getOwnPropertyNames();
    for (String name : currentPropertyNames) {
        ObjectType oType = properties.get(name);
        if (oType != null) {
            if (!interfaceType.getPropertyType(name).isEquivalentTo(
                oType.getPropertyType(name))) {
                compiler.report(
                    t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
                        functionName, name, oType.toString(),
                        interfaceType.toString()));
            }
        }
        currentProperties.put(name, interfaceType);
    }
    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
        checkInterfaceConflictProperties(t, n, functionName, properties,
            currentProperties, iType);
    }
}",0,0
54,Closure_20,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
       if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
      }
    }
    return n;
  }","private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(""String"")) {
        // Fold String(a) to '' + (a) on immutable literals,
        // which allows further optimizations
        //
        // We can't do this in the general case, because String(a) has
        // slightly different semantics than '' + (a). See
        // http://code.google.com/p/closure-compiler/issues/detail?id=759

        Node value = callTarget.getNext();
        if (value != null && value.isImmutable()) { // Added check for immutable nodes
            Node addition = IR.add(
                IR.string("""").srcref(callTarget),
                value.detachFromParent());
            n.getParent().replaceChild(n, addition);
            reportCodeChange();
            return addition;
        }
    }
    return n;
}",0,0
54,Closure_20,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
       if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
      }
    }
    return n;
  }","private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(""String"")) {
        Node value = callTarget.getNext();
        if (value != null && value.isString()) { // Check specifically for string type nodes
            Node addition = IR.add(
                IR.string("""").srcref(callTarget),
                value.detachFromParent());
            n.getParent().replaceChild(n, addition);
            reportCodeChange();
            return addition;
        }
    }
    return n;
}",1,0
54,Closure_20,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
       if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
      }
    }
    return n;
  }","private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(""String"")) {
        Node value = callTarget.getNext();
        if (value != null && !value.isObjectLit()) { // Exclude if the call is on an object literal
            Node addition = IR.add(
                IR.string("""").srcref(callTarget),
                value.detachFromParent());
            n.getParent().replaceChild(n, addition);
            reportCodeChange();
            return addition;
        }
    }
    return n;
}",2,0
54,Closure_20,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
       if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
      }
    }
    return n;
  }","private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
        callTarget.getString().equals(""String"")) {
        Node value = callTarget.getNext();
        if (value != null && value.hasChildren()) { // Ensure value has no children
            Node addition = IR.add(
                IR.string("""").srcref(callTarget),
                value.detachFromParent());
            n.getParent().replaceChild(n, addition);
            reportCodeChange();
            return addition;
        }
    }
    return n;
}",3,0
54,Closure_20,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
      // Fold String(a) to '' + (a) on immutable literals,
      // which allows further optimizations
      //
      // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
       if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
        n.getParent().replaceChild(n, addition);
        reportCodeChange();
        return addition;
      }
    }
    return n;
  }","private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() &&
          callTarget.getString().equals(""String"")) {
        Node value = callTarget.getNext();
        if (value != null && value.isLiteral()) { // Check if the value is a literal type
            Node addition = IR.add(
                IR.string("""").srcref(callTarget),
                value.detachFromParent());
            n.getParent().replaceChild(n, addition);
            reportCodeChange();
            return addition;
        }
    }
    return n;
}",4,0
55,Closure_21,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
      return;
    }

    // This no-op statement was there so that JSDoc information could
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
         return;
       }
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA) continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
           else break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
         return;
       }
     }
     if (
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
        msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // Allow these semicolons as they are stylistic choices.
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    // Do not try to remove a block or an expression result.
    // These cases are handled elsewhere.
    if (n.isExprResult()) {
        return;
    }

    // Ignore JSDoc-attached no-op statements.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    if (parent.getType() == Token.COMMA) {
        if (isResultUsed) {
            return;
        }
        if (n == parent.getLastChild()) {
            Node ancestor = parent.getParent();
            while (ancestor != null) {
                int ancestorType = ancestor.getType();
                if (ancestorType == Token.COMMA) {
                    ancestor = ancestor.getParent();
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                }
                break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        // Special case for ""FOR"" loops with specific children count and types
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4
                && (n == parent.getFirstChild()
                || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    // Check for side-effects and report accordingly
    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase()
                    + ""' operator is not being used."";
        }

        t.getCompiler().report(
                t.makeError(n, CheckLevel.WARNING, USELESS_CODE_ERROR, msg));
        // If necessary, add problematic nodes
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",0,0
55,Closure_21,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
      return;
    }

    // This no-op statement was there so that JSDoc information could
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
         return;
       }
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA) continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
           else break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
         return;
       }
     }
     if (
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
        msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    if (n.isEmpty() || n.isComma() || parent == null || n.isExprResult() || (n.isQualifiedName() && n.getJSDocInfo() != null)) {
        return;
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    if (parent.getType() == Token.COMMA) {
        if (isResultUsed) {
            return;
        }
        if (n == parent.getLastChild()) {
            Node ancestor = parent.getParent();
            while (ancestor != null) {
                int ancestorType = ancestor.getType();
                if (ancestorType == Token.COMMA) {
                    ancestor = ancestor.getParent();
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                }
                break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK
               && !(parent.getType() == Token.FOR && parent.getChildCount() == 4
               && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
        return;
    }

    if ((isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, CheckLevel.WARNING, USELESS_CODE_ERROR, msg));

        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",1,0
55,Closure_21,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
      return;
    }

    // This no-op statement was there so that JSDoc information could
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
         return;
       }
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA) continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
           else break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
         return;
       }
     }
     if (
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
        msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isEmpty() || n.isComma() || parent == null || n.isExprResult() || (n.isQualifiedName() && n.getJSDocInfo() != null)) {
        return;
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    if (parent.getType() == Token.COMMA) {
        if (isResultUsed) {
            return;
        }
        boolean validAncestor = false;
        for (Node ancestor : parent.getAncestors()) {
            int ancestorType = ancestor.getType();
            if (ancestorType == Token.COMMA) {
                continue;
            }
            if (ancestorType == Token.EXPR_RESULT || ancestorType == Token.BLOCK) {
                validAncestor = true;
                break;
            } else {
                return;
            }
        }
        if (!validAncestor) {
            return;
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, CheckLevel.WARNING, USELESS_CODE_ERROR, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",2,0
55,Closure_21,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
      return;
    }

    // This no-op statement was there so that JSDoc information could
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
         return;
       }
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA) continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
           else break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
         return;
       }
     }
     if (
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
        msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isEmpty() || n.isComma() || parent == null || n.isExprResult() || (n.isQualifiedName() && n.getJSDocInfo() != null)) {
        return;
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    if (parent.getType() == Token.COMMA) {
        if (isResultUsed) {
            return;
        }
        if (n == parent.getLastChild()) {
            Node ancestor = parent.getParent();
            while (ancestor != null) {
                int ancestorType = ancestor.getType();
                if (ancestorType == Token.COMMA) {
                    ancestor = ancestor.getParent();
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                }
                break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4
                && (n == parent.getFirstChild()
                || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, CheckLevel.WARNING, USELESS_CODE_ERROR, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",3,0
55,Closure_21,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

    // Do not try to remove a block or an expr result. We already handle
    // these cases when we visit the child, and the peephole passes will
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
      return;
    }

    // This no-op statement was there so that JSDoc information could
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
         return;
       }
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA) continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
           else break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
         return;
       }
     }
     if (
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
        msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    if (n.isExprResult()) {
        return;
    }

    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    // Adjust the logic to handle cases when parent is a COMMA node
    if (parent.getType() == Token.COMMA) {
        if (!isResultUsed && n == parent.getLastChild()) {
            Node ancestor = parent.getParent();
            while (ancestor != null) {
                int ancestorType = ancestor.getType();
                if (ancestorType == Token.COMMA) {
                    ancestor = ancestor.getParent();
                    continue;
                }
                if (ancestorType == Token.EXPR_RESULT || ancestorType == Token.BLOCK) {
                    break;
                } else {
                    return;
                }
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        // Include logic to specifically handle FOR loops with unexpected node structures
        if (!(parent.getType() == Token.FOR && parent.getChildCount() >= 4 &&
              (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    // Simplify side-effects check and reporting
    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n))) {
        String msg = ""Detected potential issue with unused code."";
        if (n.isString()) {
            msg = ""Possible missing concatenation operator ('+') in string."";
        } else if (isSimpleOp) {
            msg = ""Unused operator result detected: "" + Token.name(n.getType()).toLowerCase();
        }

        t.getCompiler().report(t.makeError(n, CheckLevel.WARNING, USELESS_CODE_ERROR, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",4,0
56,Closure_22,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
     if (parent.getType() == Token.COMMA) {
       Node gramps = parent.getParent();
       if (gramps.isCall() && parent == gramps.getFirstChild()) {
         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
         }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA)
             continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
             return;
           else
             break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
            n == parent.getFirstChild().getNext().getNext())) {
       } else {
       return;
       }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       if (n.isQualifiedName() && n.getJSDocInfo() != null) {
         return;
       } else if (n.isExprResult()) {
         return;
       }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // Allow them to pass as they are not harmful.
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    // Do not try to remove a block or an expression result.
    // These are handled elsewhere more appropriately.
    if (parent.getType() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps != null && gramps.isCall() && parent == gramps.getFirstChild()) {
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext() != null &&
                n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }

        // Skip no-op statements used for retaining JSDoc.
        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType == Token.COMMA) {
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                } else {
                    break;
                }
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 &&
            (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {
            // Allow the condition and update expressions of a FOR loop.
        } else {
            return;
        }
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        // Skip checking qualified names with associated JSDoc or expression results.
        if (n.isQualifiedName() && n.getJSDocInfo() != null) {
            return;
        } else if (n.getParent() != null && n.getParent().isExprResult()) {
            return;
        }

        // Craft a warning message based on node type.
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
                ""' operator is not being used."";
        }

        // Report the issue to the compiler and record the node if it's not a statement.
        t.getCompiler().report(t.makeError(n, CheckLevel.WARNING, DiagnosticGroups.USELESS_CODE, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",0,0
56,Closure_22,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
     if (parent.getType() == Token.COMMA) {
       Node gramps = parent.getParent();
       if (gramps.isCall() && parent == gramps.getFirstChild()) {
         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
         }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA)
             continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
             return;
           else
             break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
            n == parent.getFirstChild().getNext().getNext())) {
       } else {
       return;
       }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       if (n.isQualifiedName() && n.getJSDocInfo() != null) {
         return;
       } else if (n.isExprResult()) {
         return;
       }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    if (parent.getType() == Token.COMMA) {
        Node grandparent = parent.getParent();
        if (grandparent != null && grandparent.isCall() && parent == grandparent.getFirstChild()) {
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }

        if (n == parent.getLastChild()) {
            for (Node ancestor : parent.getAncestors()) {
                int ancestorType = ancestor.getType();
                if (ancestorType == Token.COMMA) {
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                } else {
                    break;
                }
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());

    if (!isResultUsed && !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",1,0
56,Closure_22,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
     if (parent.getType() == Token.COMMA) {
       Node gramps = parent.getParent();
       if (gramps.isCall() && parent == gramps.getFirstChild()) {
         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
         }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA)
             continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
             return;
           else
             break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
            n == parent.getFirstChild().getNext().getNext())) {
       } else {
       return;
       }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       if (n.isQualifiedName() && n.getJSDocInfo() != null) {
         return;
       } else if (n.isExprResult()) {
         return;
       }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    if (parent.getType() == Token.COMMA) {
        Node grandParent = parent.getParent();
        if (grandParent != null && grandParent.isCall() && parent == grandParent.getFirstChild()) {
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }

        if (n == parent.getLastChild()) {
            for (Node ancestor : parent.getAncestors()) {
                int ancestorType = ancestor.getType();
                if (ancestorType == Token.COMMA) {
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                } else {
                    break;
                }
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    boolean mayHaveSideEffects = NodeUtil.mayHaveSideEffects(n, t.getCompiler());

    if (!mayHaveSideEffects) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",2,0
56,Closure_22,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
     if (parent.getType() == Token.COMMA) {
       Node gramps = parent.getParent();
       if (gramps.isCall() && parent == gramps.getFirstChild()) {
         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
         }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA)
             continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
             return;
           else
             break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
            n == parent.getFirstChild().getNext().getNext())) {
       } else {
       return;
       }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       if (n.isQualifiedName() && n.getJSDocInfo() != null) {
         return;
       } else if (n.isExprResult()) {
         return;
       }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    if (parent.getType() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps != null && gramps.isCall() && parent == gramps.getFirstChild()) {
            // Adjusting condition to check if the node has a certain property
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext() != null &&
                n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }

        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType == Token.COMMA) {
                    continue;
                }
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                } else {
                    break;
                }
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 &&
              (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    boolean mayHaveSideEffects = NodeUtil.mayHaveSideEffects(n, t.getCompiler());

    if (!isResultUsed && !mayHaveSideEffects && isSimpleOp) {
        String msg = ""This code lacks side-effects and the result of the '"" + Token.name(n.getType()).toLowerCase() +
                     ""' operator is not being used."";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",3,0
56,Closure_22,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    // I've been unable to think of any cases where this indicates a bug,
    // and apparently some people like keeping these semicolons around,
    // so we'll allow it.
    if (n.isEmpty() ||
        n.isComma()) {
      return;
    }

    if (parent == null) {
      return;
    }

     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
     if (parent.getType() == Token.COMMA) {
       Node gramps = parent.getParent();
       if (gramps.isCall() && parent == gramps.getFirstChild()) {
         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
         }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
       if (n == parent.getLastChild()) {
         for (Node an : parent.getAncestors()) {
           int ancestorType = an.getType();
           if (ancestorType == Token.COMMA)
             continue;
           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
             return;
           else
             break;
         }
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
            n == parent.getFirstChild().getNext().getNext())) {
       } else {
       return;
       }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       if (n.isQualifiedName() && n.getJSDocInfo() != null) {
         return;
       } else if (n.isExprResult()) {
         return;
       }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
      } else if (isSimpleOp) {
        msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
            ""' operator is not being used."";
      }

      t.getCompiler().report(
          t.makeError(n, level, USELESS_CODE_ERROR, msg));
      // TODO(johnlenz): determine if it is necessary to
      // try to protect side-effect free statements as well.
      if (!NodeUtil.isStatement(n)) {
        problemNodes.add(n);
      }
    }
  }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // VOID nodes appear when there are extra semicolons at the BLOCK level.
    if (n.isEmpty() || n.isComma()) {
        return;
    }

    if (parent == null) {
        return;
    }

    if (parent.getType() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps.isCall() && parent == gramps.getFirstChild()) {
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }
        
        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {
                    return;
                }
                break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }

    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    
    if (!isResultUsed && (!isSimpleOp && NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        if (n.isQualifiedName() && n.getJSDocInfo() != null) {
            return;
        } else if (n.isExprResult()) {
            return;
        }
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }

        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));

        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",4,0
57,Closure_23,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }
 
     Node current = left.getFirstChild();
     Node elem = null;
     for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
  }","private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    // ""[][0] += 1""
    if (isAssignmentTarget(n)) {
        return n;
    }

    if (!right.isNumber()) {
        // Sometimes people like to use complex expressions to index into
        // arrays, or strings to index into array methods.
        return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index || intIndex < 0) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }

    Node current = left.getFirstChild();
    Node elem = null;
    for (int i = 0; current != null; current = current.getNext(), i++) {
        if (i == intIndex) {
            elem = current;
            break;
        }
    }

    if (elem == null) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }

    if (elem.isEmpty()) {
        elem = NodeUtil.newUndefinedNode(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
}",0,0
57,Closure_23,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }
 
     Node current = left.getFirstChild();
     Node elem = null;
     for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
  }","private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    if (isAssignmentTarget(n)) {
        return n;
    }

    if (!right.isNumber()) {
        return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index || intIndex < 0) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }

    Node current = left.getFirstChild();
    Node elem = current;
    
    for (int i = 0; current != null && i <= intIndex; current = current.getNext(), i++) {
        elem = current;
    }

    if (elem == null || elem.isEmpty()) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }

    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
}",1,0
57,Closure_23,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }
 
     Node current = left.getFirstChild();
     Node elem = null;
     for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
  }","private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    if (isAssignmentTarget(n)) {
        return n;
    }

    if (!right.isNumber()) {
        return n;
    }
    
    double index = right.getDouble();
    int intIndex = (int) index;
    
    if (intIndex != index || intIndex < 0) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }
    
    Node current = left.getFirstChild();
    for (int i = 0; current != null && i < intIndex; current = current.getNext(), i++) {
        // Continue until the correct index or end of list
    }
    
    if (current == null || current.isEmpty()) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }
    
    Node elem = NodeUtil.newUndefinedNode(current.isEmpty() ? current : current);
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
}",2,0
57,Closure_23,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }
 
     Node current = left.getFirstChild();
     Node elem = null;
     for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
  }","private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    if (isAssignmentTarget(n)) {
        return n;
    }

    if (!right.isNumber()) {
        return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;

    // Adjust index comparison to ensure precision and validity
    if (intIndex != index || intIndex < 0) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }

    Node current = left.getFirstChild();
    Node elem = null;

    // Prepare to iterate correctly through child nodes
    for (int i = 0; current != null && i <= intIndex; current = current.getNext(), i++) {
        if (i == intIndex) {
            elem = current;
        }
    }

    if (elem == null || elem.isEmpty()) {
        elem = NodeUtil.newUndefinedNode(elem);
    }

    // Replace entire GETELEM node with found or undefined node
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
}",3,0
57,Closure_23,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    //    ""[][0] += 1""
    if (isAssignmentTarget(n)) {
      return n;
    }

    if (!right.isNumber()) {
      // Sometimes people like to use complex expressions to index into
      // arrays, or strings to index into array methods.
      return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
      error(INVALID_GETELEM_INDEX_ERROR, right);
      return n;
    }

    if (intIndex < 0) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }
 
     Node current = left.getFirstChild();
     Node elem = null;
     for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }

    if (elem == null) {
      error(INDEX_OUT_OF_BOUNDS_ERROR, right);
      return n;
    }

    if (elem.isEmpty()) {
      elem = NodeUtil.newUndefinedNode(elem);
    } else {
      left.removeChild(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
  }","private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // If GETPROP/GETELEM is used as assignment target the array literal is
    // acting as a temporary we can't fold it here:
    // ""[][0] += 1""
    if (isAssignmentTarget(n)) {
        return n;
    }

    if (!right.isNumber()) {
        // Sometimes people like to use complex expressions to index into
        // arrays, or strings to index into array methods.
        return n;
    }

    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
        error(INVALID_GETELEM_INDEX_ERROR, right);
        return n;
    }

    if (intIndex < 0) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }
 
    Node current = left.getFirstChild();
    Node elem = current;
    for (int i = 0; current != null; current = current.getNext(), i++) {
        if (i == intIndex) {
            elem = current;
            break;
        }
    }

    if (elem == null || elem.isEmpty()) {
        elem = NodeUtil.newUndefinedNode(elem);
    }

    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
}",4,0
58,Closure_24,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
         if (parent.isVar()) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);

          String qualifiedName =
              aliasVar.getInitialValue().getQualifiedName();
          transformation.addAlias(name, qualifiedName);
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else {
          // TODO(robbyw): Support using locals for private variables.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
        }
      }
    }","private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.isVar()) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);
                if (aliasVar != null && aliasVar.getInitialValue() != null) {
                    String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                    if (qualifiedName != null) {
                        aliases.put(name, aliasVar);
                        transformation.addAlias(name, qualifiedName);
                    }
                }
            } else {
                // TODO: Support using locals for private variables.
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",0,0
58,Closure_24,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
         if (parent.isVar()) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);

          String qualifiedName =
              aliasVar.getInitialValue().getQualifiedName();
          transformation.addAlias(name, qualifiedName);
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else {
          // TODO(robbyw): Support using locals for private variables.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
        }
      }
    }","private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.isVar() && n.hasChildren()) {
            if (n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);
                
                // Ensure aliasVar is not null before adding to aliases
                if (aliasVar != null && aliasVar.getInitialValue() != null) {
                    aliases.put(name, aliasVar);
                    
                    String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                    if (qualifiedName != null) {
                        transformation.addAlias(name, qualifiedName);
                    }
                }
            } else {
                // TODO: Support using locals for private variables.
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",1,0
58,Closure_24,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
         if (parent.isVar()) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);

          String qualifiedName =
              aliasVar.getInitialValue().getQualifiedName();
          transformation.addAlias(name, qualifiedName);
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else {
          // TODO(robbyw): Support using locals for private variables.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
        }
      }
    }","private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.isVar() && n.hasChildren()) {
            if (n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);
                
                // Check if aliasVar and its initial value are not null
                if (aliasVar != null && aliasVar.getInitialValue() != null) {
                    aliases.put(name, aliasVar);
                    String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                    if (qualifiedName != null) {
                        transformation.addAlias(name, qualifiedName);
                    }
                }
            } else {
                // Report non-alias local error
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",2,0
58,Closure_24,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
         if (parent.isVar()) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);

          String qualifiedName =
              aliasVar.getInitialValue().getQualifiedName();
          transformation.addAlias(name, qualifiedName);
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else {
          // TODO(robbyw): Support using locals for private variables.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
        }
      }
    }","private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.isVar() && n.hasChildren() 
                && n.getFirstChild().isQualifiedName()) {
            String name = n.getString();
            Var aliasVar = scope.getVar(name);
            if (aliasVar != null && aliasVar.getInitialValue() != null) {
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                if (qualifiedName != null) {
                    aliases.put(name, aliasVar);
                    transformation.addAlias(name, qualifiedName);
                }
            }
        } else {
            // Report non-alias local error outside of the if-block
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}",3,0
58,Closure_24,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
         if (parent.isVar()) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);

          String qualifiedName =
              aliasVar.getInitialValue().getQualifiedName();
          transformation.addAlias(name, qualifiedName);
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else {
          // TODO(robbyw): Support using locals for private variables.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
        }
      }
    }","private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        if (parent.isVar()) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);

                // Ensure aliasVar and its initial value are not null before operating on them
                if (aliasVar != null && aliasVar.getInitialValue() != null && aliasVar.getInitialValue().getQualifiedName() != null) {
                    aliases.put(name, aliasVar);

                    String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                    transformation.addAlias(name, qualifiedName);
                }
            } else {
                // Report non-alias local error
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",4,0
59,Closure_25,"private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
      constructorType = constructorType.restrictByNotNullOrUndefined();
      if (constructorType.isUnknownType()) {
        type = getNativeType(UNKNOWN_TYPE);
      } else {
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct == null && constructorType instanceof FunctionType) {
          // If constructorType is a NoObjectType, then toMaybeFunctionType will
          // return null. But NoObjectType implements the FunctionType
          // interface, precisely because it can validly construct objects.
          ct = (FunctionType) constructorType;
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
       scope = traverse(arg, scope);
     }
     return scope;
   }","private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
        constructorType = constructorType.restrictByNotNullOrUndefined();
        if (constructorType.isUnknownType()) {
            type = getNativeType(UNKNOWN_TYPE);
        } else {
            FunctionType ct = constructorType.toMaybeFunctionType();
            if (ct == null && constructorType instanceof FunctionType) {
                ct = (FunctionType) constructorType;
            }
            if (ct != null && ct.isConstructor()) {
                type = ct.getInstanceType();
            } else {
                type = getNativeType(UNKNOWN_TYPE);
            }
        }
    }
    n.setJSType(type);
    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
        scope = traverse(arg, scope);
    }
    return scope;
}",0,0
59,Closure_25,"private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
      constructorType = constructorType.restrictByNotNullOrUndefined();
      if (constructorType.isUnknownType()) {
        type = getNativeType(UNKNOWN_TYPE);
      } else {
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct == null && constructorType instanceof FunctionType) {
          // If constructorType is a NoObjectType, then toMaybeFunctionType will
          // return null. But NoObjectType implements the FunctionType
          // interface, precisely because it can validly construct objects.
          ct = (FunctionType) constructorType;
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
       scope = traverse(arg, scope);
     }
     return scope;
   }","private FlowScope traverseNew(Node n, FlowScope scope) {
    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
        constructorType = constructorType.restrictByNotNullOrUndefined();
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct != null && ct.isConstructor()) {
            type = ct.getInstanceType();
        } else {
            if (constructorType.isConstructor()) {
                type = constructorType.getInstanceType();
            } else {
                type = getNativeType(UNKNOWN_TYPE);
            }
        }
    }
    n.setJSType(type);
    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
        scope = traverse(arg, scope);
    }
    return scope;
}",1,0
59,Closure_25,"private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
      constructorType = constructorType.restrictByNotNullOrUndefined();
      if (constructorType.isUnknownType()) {
        type = getNativeType(UNKNOWN_TYPE);
      } else {
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct == null && constructorType instanceof FunctionType) {
          // If constructorType is a NoObjectType, then toMaybeFunctionType will
          // return null. But NoObjectType implements the FunctionType
          // interface, precisely because it can validly construct objects.
          ct = (FunctionType) constructorType;
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
       scope = traverse(arg, scope);
     }
     return scope;
   }","private FlowScope traverseNew(Node n, FlowScope scope) {
    Node constructor = n.getFirstChild();
    if (constructor != null) {
        scope = traverse(constructor, scope);
        JSType constructorType = constructor.getJSType();
        JSType type = null;
        
        if (constructorType != null) {
            constructorType = constructorType.restrictByNotNullOrUndefined();
            
            FunctionType ct = constructorType.toMaybeFunctionType();
            if (ct == null && constructorType instanceof FunctionType) {
                ct = (FunctionType) constructorType;
            }
            
            if (ct != null) {
                type = ct.isConstructor() ? ct.getInstanceType() : getNativeType(UNKNOWN_TYPE);
            } else {
                type = getNativeType(UNKNOWN_TYPE);
            }
        }
        
        n.setJSType(type);
    }
    
    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
        scope = traverse(arg, scope);
    }
    
    return scope;
}",2,0
59,Closure_25,"private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
      constructorType = constructorType.restrictByNotNullOrUndefined();
      if (constructorType.isUnknownType()) {
        type = getNativeType(UNKNOWN_TYPE);
      } else {
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct == null && constructorType instanceof FunctionType) {
          // If constructorType is a NoObjectType, then toMaybeFunctionType will
          // return null. But NoObjectType implements the FunctionType
          // interface, precisely because it can validly construct objects.
          ct = (FunctionType) constructorType;
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
       scope = traverse(arg, scope);
     }
     return scope;
   }","private FlowScope traverseNew(Node n, FlowScope scope) {
    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;

    if (constructorType != null) {
        constructorType = constructorType.restrictByNotNullOrUndefined();
        if (constructorType.isUnknownType()) {
            type = getNativeType(UNKNOWN_TYPE);
        } else {
            FunctionType ct = constructorType.toMaybeFunctionType();
            if (ct == null && constructorType instanceof FunctionType) {
                ct = (FunctionType) constructorType;
            }
            if (ct != null && ct.isConstructor()) {
                type = ct.getInstanceType();
            } else {
                type = getNativeType(UNKNOWN_TYPE);
            }
        }
    }
    n.setJSType(type);

    Node arg = constructor.getNext();
    while (arg != null) {
        scope = traverse(arg, scope);
        arg = arg.getNext();
    }
    return scope;
}",3,0
59,Closure_25,"private FlowScope traverseNew(Node n, FlowScope scope) {

    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
      constructorType = constructorType.restrictByNotNullOrUndefined();
      if (constructorType.isUnknownType()) {
        type = getNativeType(UNKNOWN_TYPE);
      } else {
        FunctionType ct = constructorType.toMaybeFunctionType();
        if (ct == null && constructorType instanceof FunctionType) {
          // If constructorType is a NoObjectType, then toMaybeFunctionType will
          // return null. But NoObjectType implements the FunctionType
          // interface, precisely because it can validly construct objects.
          ct = (FunctionType) constructorType;
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
       scope = traverse(arg, scope);
     }
     return scope;
   }","private FlowScope traverseNew(Node n, FlowScope scope) {
    Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
    JSType constructorType = constructor.getJSType();
    JSType type = null;

    // New logic: ensure non-null constructorType and check for constructor explicitly
    if (constructorType != null) {
        constructorType = constructorType.restrictByNotNullOrUndefined();
        FunctionType ct = constructorType.toMaybeFunctionType();

        // Force casting only if the type is NoObjectType
        if (ct == null && constructorType instanceof FunctionType && constructorType.isNoObjectType()) {
            ct = (FunctionType) constructorType;
        }

        // Prioritize constructor check before assigning instance type
        if (ct != null && ct.isConstructor()) {
            type = ct.getInstanceType();
        } else {
            type = getNativeType(UNKNOWN_TYPE);
        }
    }

    n.setJSType(type);
    
    // Traverse argument nodes if they exist
    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
        scope = traverse(arg, scope);
    }

    return scope;
}",4,0
60,Closure_28,"/*
 * Copyright 2008 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      add(ESTIMATED_IDENTIFIER);
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}
","package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      append(ESTIMATED_IDENTIFIER);  // Fix: use append instead of add to update cost correctly
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}",0,0
60,Closure_28,"/*
 * Copyright 2008 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      add(ESTIMATED_IDENTIFIER);
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}
","package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str) {
      last = str.charAt(str.length() - 1);
      cost += str.trim().length();  // Fix: Consider trimmed length to avoid counting extra whitespace
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      append(ESTIMATED_IDENTIFIER);  // Fix: Use append to ensure trimmed identifier is accounted correctly
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}",1,0
60,Closure_28,"/*
 * Copyright 2008 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      add(ESTIMATED_IDENTIFIER);
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}
","package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  private static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshold) {
      this.maxCost = costThreshold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      // Ensure to bound the cost to maxCost if exceeded.
      return Math.min(cost, maxCost);
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str) {
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      cost += ESTIMATED_IDENTIFIER_COST;  // Update cost directly for an identifier
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}",2,0
60,Closure_28,"/*
 * Copyright 2008 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      add(ESTIMATED_IDENTIFIER);
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}
","package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      // Consider each node individually, avoiding deep recursive calls.
      for (Node current = root; current != null; current = current.getNext()) {
        CodeGenerator cg = new CodeGenerator(this);
        cg.add(current);
        if (!continueProcessing) {
          break;
        }
      }
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      cost += ESTIMATED_IDENTIFIER_COST;  // Directly add estimated identifier cost
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}",3,0
60,Closure_28,"/*
 * Copyright 2008 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      add(ESTIMATED_IDENTIFIER);
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}
","package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      cost += ESTIMATED_IDENTIFIER_COST; // Directly increment cost by estimated identifier amount
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }
  }
}",4,0
61,Closure_29,"private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target maybe using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-refential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }


          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target maybe using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            // NOTE(nicksantos): This pass's object-splitting algorithm has
            // a blind spot. It assumes that if a property isn't defined on an
            // object, then the value is undefined. This is not true, because
            // Object.prototype can have arbitrary properties on it.
            // We short-circuit this problem by bailing out if we see a reference
            // to a property that isn't defined on the object literal. This
            // isn't a perfect algorithm, but it should catch most cases.
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null || !val.isObjectLit()) {
            // A var with no assignment or not an object literal assignment
            continue;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        // TODO: Only exclude unorderable self-referential assignments. i.e.
        // x = {a: x.b, b: x.a} is not orderable, but x = {a: 1, b: x.a} is.
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }

            Node childVal = child.getFirstChild();
            // Check if childVal is the parent of any of the passed-in references,
            // as that is how self-referential assignments will happen.
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
    }

    // We have found an acceptable object literal assignment. As long
    // as there are no other assignments that mess things up, we can inline.
    return true;
}",0,0
61,Closure_29,"private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target maybe using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-refential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }


          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);

            // A call target may be using the object as 'this'. If so, exclude.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null || !val.isObjectLit()) {
            // A var with no assignment or not an object literal assignment
            return false;
        }

        // Make sure the object literal does not have a self-referential assignment
        Set<Node> objectChildrenSet = new HashSet<>();
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }
            Node childVal = child.getFirstChild();
            objectChildrenSet.add(childVal);
        }

        for (Reference t : refs) {
            Node refNode = t.getParent();
            while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                if (objectChildrenSet.contains(refNode)) {
                    // There's a self-referential assignment
                    return false;
                }
                refNode = refNode.getParent();
            }
        }
    }
    // We have found an acceptable object literal assignment. As long
    // as there are no other assignments that mess things up, we can inline.
    return true;
}",1,0
61,Closure_29,"private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target maybe using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-refential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }


          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target maybe using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null || !val.isObjectLit()) {
            // A var with no assignment or not an object literal assignment
            continue;
        }

        // Additional check for references in parent chain to avoid self-referential assignments
        Set<Node> pathToCurrent = new HashSet<>();
        for (Node current = parent; current != null; current = current.getParent()) {
            pathToCurrent.add(current);
        }

        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }

            Node childVal = child.getFirstChild();
            // Ensure childVal does not create self-referential assignment
            if (pathToCurrent.contains(childVal)) {
                return false;
            }
        }

        // We have found an acceptable object literal assignment.
        ret = true;
    }
    return ret;
}",2,0
61,Closure_29,"private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target maybe using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-refential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }


          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target maybe using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null || !val.isObjectLit()) {
            return false; // A var with no assignment or not an object literal assignment
        }

        // Check for self-referential assignments directly within the object literal
        Set<Node> childValues = new HashSet<>();
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                return false; // ES5 get/set not supported
            }
            childValues.add(child.getFirstChild());
        }

        for (Node childVal : childValues) {
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        return false; // There's a self-referential assignment
                    }
                    refNode = refNode.getParent();
                }
            }
        }
    }

    // We have found an acceptable object literal assignment. As long as there are no other assignments that mess things up, we can inline.
    return true;
}",3,0
61,Closure_29,"private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target maybe using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-refential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }


          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean isInlinable = true;
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore indirect references, like x.y (except x.y(), since
        // the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target maybe using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null || !val.isObjectLit()) {
            // A var with no assignment or not an object literal assignment
            return false;
        }

        // Ensure that there are no self-referential assignments within the object literal
        Set<String> propertyNames = new HashSet<>();
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }
            propertyNames.add(child.getString());
        }

        for (Reference otherRef : refs) {
            Node otherName = otherRef.getNode();
            if (propertyNames.contains(otherName.getString())) {
                // There's a self-referential assignment if the object literal references itself
                return false;
            }
        }
    }

    // We have found an acceptable object literal assignment. As long
    // as there are no other assignments that mess things up, we can inline.
    return isInlinable;
}",4,0
62,Closure_31,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
           !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        // Check if inputs need to be rebuilt from modules.
        boolean staleInputs = false;

        // Check if the sources need to be re-ordered.
        if (options.dependencyOptions.needsManagement() &&
            !options.skipAllPasses &&
            options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs =
                    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                    .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(
                    JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(
                    MISSING_ENTRY_ERROR, e.getMessage()));

                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }

        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);

            // Inputs can have a null AST during initial parse.
            if (n == null) {
                continue;
            }

            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    // If the input file is explicitly marked as an externs file, then
                    // assume the programmer made a mistake and throw it into
                    // the externs pile anyways.
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);

                    input.getModule().remove(input);

                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }

        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null ||
                options.nameReferenceReportPath != null) {

                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia =
                    new SourceInformationAnnotator(
                        input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",0,0
62,Closure_31,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
           !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Create new synthetic blocks for js and externs.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) {  // Ensure node is valid and check for errors.
                continue;
            }
            externsRoot.addChildToBack(n);
        }

        // Process modules: AMD/CJS
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        // Dependency management.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() &&
            !options.skipAllPasses &&
            options.closurePass) {
            for (CompilerInput input : inputs) {
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                        .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException | MissingProvideException e) {
                report(JSError.make(
                    JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                if (hasErrors()) {
                    continue;  // Instead of returning, continue to process remaining inputs.
                }
            }
        }

        // Handle inputs and AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);
                    input.getModule().remove(input);
                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }

        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }

        // Final AST construction.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    continue;
                }
            }

            if (options.sourceMapOutputPath != null ||
                options.nameReferenceReportPath != null) {
                SourceInformationAnnotator sia =
                    new SourceInformationAnnotator(
                        input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",1,0
62,Closure_31,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
           !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (hasErrors()) {  // Ensure node is valid and check for errors.
                return null;
            }
            externsRoot.addChildToBack(n);
        }

        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }

        // Check if inputs need to be rebuilt from modules.
        boolean staleInputs = false;

        // Check if the sources need to be re-ordered.
        if (options.dependencyOptions.needsManagement() &&
            !options.skipAllPasses &&
            options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }

            try {
                inputs =
                    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                    .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(
                    JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
            } catch (MissingProvideException e) {
                report(JSError.make(
                    MISSING_ENTRY_ERROR, e.getMessage()));
            }
        }

        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);

            // Inputs can have a null AST during initial parse.
            if (n == null) {
                continue;
            }

            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);

                    input.getModule().remove(input);

                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }

        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }

        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null ||
                options.nameReferenceReportPath != null) {
                SourceInformationAnnotator sia =
                    new SourceInformationAnnotator(
                        input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }

            jsRoot.addChildToBack(n);
        }

        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",2,0
62,Closure_31,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
           !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
   
    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
   
    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
   
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
   
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
   
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
   
    Tracer tracer = newTracer(""parseInputs"");

    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (n == null || hasErrors()) {  // Ensure node is valid and check for errors.
                return null;
            }
            externsRoot.addChildToBack(n);
        }
       
        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
       
        // Check if inputs need to be rebuilt from modules.
        boolean staleInputs = false;

        // Check if the sources need to be re-ordered.
        if (options.dependencyOptions.needsManagement() &&
            !options.skipAllPasses &&
            options.closurePass) {
            for (CompilerInput input : inputs) {
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
           
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
                        .manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(
                        JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                return null;  // Immediately return in case of errors rather than continuing.
            } catch (MissingProvideException e) {
                report(JSError.make(
                        MISSING_ENTRY_ERROR, e.getMessage()));
                return null;  // Immediately return in case of errors rather than continuing.
            }
        }
       
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
           
            // Inputs can have a null AST during initial parse.
            if (n == null) {
                continue;
            }
           
            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    // If the input file is explicitly marked as an externs file, then
                    // assume the programmer made a mistake and throw it into
                    // the externs pile anyways.
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);
                   
                    input.getModule().remove(input);
                   
                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }
       
        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }
       
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }

            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }

            if (options.sourceMapOutputPath != null ||
                    options.nameReferenceReportPath != null) {
               
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia =
                        new SourceInformationAnnotator(
                                input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
           
            jsRoot.addChildToBack(n);
        }
       
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",3,0
62,Closure_31,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
           !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources only if inputs are not stale.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (n == null || hasErrors()) {  // Skip if AST root is null or errors exist
          continue;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;

      // Check if the sources need to be re-ordered.
      if (options.dependencyOptions.needsManagement() &&
          !options.skipAllPasses &&
          options.closurePass) {
        for (CompilerInput input : inputs) {
          // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // In case of errors, mark inputs as stale and stop processing further
          staleInputs = true;
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));
          
          // In case of errors, mark inputs as stale and stop processing further
          staleInputs = true;
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null || hasErrors()) {  // Skip if AST root is null or errors exist
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            continue;  // Instead of returning, continue to process remaining inputs
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }",4,0
63,Closure_32,"@SuppressWarnings(""fallthrough"")
  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                      WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
      return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
      line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.

    do {
      switch (token) {
        case STAR:
          if (ignoreStar) {
            // Mark the position after the star as the new start of the line.
          } else {
            // The star is part of the comment.
            if (builder.length() > 0) {
              builder.append(' ');
            }

            builder.append('*');
          }

          token = next();
          continue;

        case EOL:
          if (option != WhitespaceOption.SINGLE_LINE) {
            builder.append(""\n"");
           }
 
           ignoreStar = true;
           token = next();
           continue;
 
        default:
          ignoreStar = false;
          state = State.SEARCHING_ANNOTATION;

              // All tokens must be separated by a space.

          if (token == JsDocToken.EOC ||
              token == JsDocToken.EOF ||
              // When we're capturing a license block, annotations
              // in the block are ok.
              (token == JsDocToken.ANNOTATION &&
               option != WhitespaceOption.PRESERVE)) {
            String multilineText = builder.toString();

            if (option != WhitespaceOption.PRESERVE) {
              multilineText = multilineText.trim();
            }

            int endLineno = stream.getLineno();
            int endCharno = stream.getCharno();

            if (multilineText.length() > 0) {
              jsdocBuilder.markText(multilineText, startLineno, startCharno,
                  endLineno, endCharno);
            }

            return new ExtractionInfo(multilineText, token);
          }

          if (builder.length() > 0) {
            builder.append(' ');
          }
          builder.append(toString(token));

          line = stream.getRemainingJSDocLine();

          if (option != WhitespaceOption.PRESERVE) {
            line = trimEnd(line);
          }

          builder.append(line);
          token = next();
      }
    } while (true);
  }","@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                    WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    do {
        switch (token) {
            case STAR:
                if (ignoreStar) {
                    // Mark the position after the star as the new start of the line.
                } else {
                    // The star is part of the comment.
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;

            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                continue;

            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;

                // All tokens must be separated by a space.
                if (token == JsDocToken.EOC ||
                    token == JsDocToken.EOF ||
                    (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {

                    String multilineText = builder.toString();
                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }

                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();

                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno,
                                endLineno, endCharno);
                    }

                    return new ExtractionInfo(multilineText, token);
                }

                if (builder.length() > 0) {
                    builder.append(' ');
                }

                builder.append(toString(token));

                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }

                builder.append(line);
                token = next();
                break; // Added break to ensure loop control
        }
    } while (true);
}",0,0
63,Closure_32,"@SuppressWarnings(""fallthrough"")
  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                      WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
      return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
      line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.

    do {
      switch (token) {
        case STAR:
          if (ignoreStar) {
            // Mark the position after the star as the new start of the line.
          } else {
            // The star is part of the comment.
            if (builder.length() > 0) {
              builder.append(' ');
            }

            builder.append('*');
          }

          token = next();
          continue;

        case EOL:
          if (option != WhitespaceOption.SINGLE_LINE) {
            builder.append(""\n"");
           }
 
           ignoreStar = true;
           token = next();
           continue;
 
        default:
          ignoreStar = false;
          state = State.SEARCHING_ANNOTATION;

              // All tokens must be separated by a space.

          if (token == JsDocToken.EOC ||
              token == JsDocToken.EOF ||
              // When we're capturing a license block, annotations
              // in the block are ok.
              (token == JsDocToken.ANNOTATION &&
               option != WhitespaceOption.PRESERVE)) {
            String multilineText = builder.toString();

            if (option != WhitespaceOption.PRESERVE) {
              multilineText = multilineText.trim();
            }

            int endLineno = stream.getLineno();
            int endCharno = stream.getCharno();

            if (multilineText.length() > 0) {
              jsdocBuilder.markText(multilineText, startLineno, startCharno,
                  endLineno, endCharno);
            }

            return new ExtractionInfo(multilineText, token);
          }

          if (builder.length() > 0) {
            builder.append(' ');
          }
          builder.append(toString(token));

          line = stream.getRemainingJSDocLine();

          if (option != WhitespaceOption.PRESERVE) {
            line = trimEnd(line);
          }

          builder.append(line);
          token = next();
      }
    } while (true);
  }","@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = trimEnd(line.trim());
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;
    boolean firstLine = true;

    do {
        switch (token) {
            case STAR: {
                if (!firstLine && builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append('*');
                ignoreStar = false;
                break;
            }
            case EOL: {
                if (option != WhitespaceOption.SINGLE_LINE && !firstLine) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                firstLine = false;
                break;
            }
            default: {
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString().trim();

                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();

                    if (!multilineText.isEmpty()) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }

                    return new ExtractionInfo(multilineText, token);
                }

                if (builder.length() > 0 && !firstLine) {
                    builder.append(' ');
                }

                builder.append(toString(token));

                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line).trim();
                }

                builder.append(line);
                break;
            }
        }
        token = next();
    } while (true);
}",1,0
63,Closure_32,"@SuppressWarnings(""fallthrough"")
  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                      WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
      return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
      line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.

    do {
      switch (token) {
        case STAR:
          if (ignoreStar) {
            // Mark the position after the star as the new start of the line.
          } else {
            // The star is part of the comment.
            if (builder.length() > 0) {
              builder.append(' ');
            }

            builder.append('*');
          }

          token = next();
          continue;

        case EOL:
          if (option != WhitespaceOption.SINGLE_LINE) {
            builder.append(""\n"");
           }
 
           ignoreStar = true;
           token = next();
           continue;
 
        default:
          ignoreStar = false;
          state = State.SEARCHING_ANNOTATION;

              // All tokens must be separated by a space.

          if (token == JsDocToken.EOC ||
              token == JsDocToken.EOF ||
              // When we're capturing a license block, annotations
              // in the block are ok.
              (token == JsDocToken.ANNOTATION &&
               option != WhitespaceOption.PRESERVE)) {
            String multilineText = builder.toString();

            if (option != WhitespaceOption.PRESERVE) {
              multilineText = multilineText.trim();
            }

            int endLineno = stream.getLineno();
            int endCharno = stream.getCharno();

            if (multilineText.length() > 0) {
              jsdocBuilder.markText(multilineText, startLineno, startCharno,
                  endLineno, endCharno);
            }

            return new ExtractionInfo(multilineText, token);
          }

          if (builder.length() > 0) {
            builder.append(' ');
          }
          builder.append(toString(token));

          line = stream.getRemainingJSDocLine();

          if (option != WhitespaceOption.PRESERVE) {
            line = trimEnd(line);
          }

          builder.append(line);
          token = next();
      }
    } while (true);
  }","@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;
    boolean newLineStarted = true;  // New logic added to handle star at the beginning of lines

    do {
        switch (token) {
            case STAR:
                if (!ignoreStar || newLineStarted) {
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                newLineStarted = false;
                token = next();
                continue;

            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                newLineStarted = true;  // New logic added to set flag
                token = next();
                continue;

            default:
                ignoreStar = false;
                newLineStarted = false;  // Reset flag as it's not a new line start
                state = State.SEARCHING_ANNOTATION;

                if (token == JsDocToken.EOC || token == JsDocToken.EOF ||
                        (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString();

                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }

                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();

                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }

                    return new ExtractionInfo(multilineText, token);
                }

                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));

                line = stream.getRemainingJSDocLine();

                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }

                builder.append(line);
                token = next();
        }
    } while (true);
}",2,0
63,Closure_32,"@SuppressWarnings(""fallthrough"")
  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                      WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
      return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
      line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.

    do {
      switch (token) {
        case STAR:
          if (ignoreStar) {
            // Mark the position after the star as the new start of the line.
          } else {
            // The star is part of the comment.
            if (builder.length() > 0) {
              builder.append(' ');
            }

            builder.append('*');
          }

          token = next();
          continue;

        case EOL:
          if (option != WhitespaceOption.SINGLE_LINE) {
            builder.append(""\n"");
           }
 
           ignoreStar = true;
           token = next();
           continue;
 
        default:
          ignoreStar = false;
          state = State.SEARCHING_ANNOTATION;

              // All tokens must be separated by a space.

          if (token == JsDocToken.EOC ||
              token == JsDocToken.EOF ||
              // When we're capturing a license block, annotations
              // in the block are ok.
              (token == JsDocToken.ANNOTATION &&
               option != WhitespaceOption.PRESERVE)) {
            String multilineText = builder.toString();

            if (option != WhitespaceOption.PRESERVE) {
              multilineText = multilineText.trim();
            }

            int endLineno = stream.getLineno();
            int endCharno = stream.getCharno();

            if (multilineText.length() > 0) {
              jsdocBuilder.markText(multilineText, startLineno, startCharno,
                  endLineno, endCharno);
            }

            return new ExtractionInfo(multilineText, token);
          }

          if (builder.length() > 0) {
            builder.append(' ');
          }
          builder.append(toString(token));

          line = stream.getRemainingJSDocLine();

          if (option != WhitespaceOption.PRESERVE) {
            line = trimEnd(line);
          }

          builder.append(line);
          token = next();
      }
    } while (true);
  }","@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;
    boolean firstLine = true;

    do {
        switch (token) {
            case STAR:
                if (!ignoreStar || firstLine) {
                    if (!firstLine && builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                firstLine = false;
                break;
            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                firstLine = true;
                break;
            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                if (token == JsDocToken.EOC || token == JsDocToken.EOF ||
                        (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString().trim();

                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();

                    if (!multilineText.isEmpty()) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }

                    return new ExtractionInfo(multilineText, token);
                }

                if (builder.length() > 0 && !firstLine) {
                    builder.append(' ');
                }
                builder.append(toString(token));

                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = line.trim();
                }

                builder.append(line);
                firstLine = false;
        }
        token = next();
    } while (true);
}",3,0
63,Closure_32,"@SuppressWarnings(""fallthrough"")
  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                      WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
      return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
      line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.

    do {
      switch (token) {
        case STAR:
          if (ignoreStar) {
            // Mark the position after the star as the new start of the line.
          } else {
            // The star is part of the comment.
            if (builder.length() > 0) {
              builder.append(' ');
            }

            builder.append('*');
          }

          token = next();
          continue;

        case EOL:
          if (option != WhitespaceOption.SINGLE_LINE) {
            builder.append(""\n"");
           }
 
           ignoreStar = true;
           token = next();
           continue;
 
        default:
          ignoreStar = false;
          state = State.SEARCHING_ANNOTATION;

              // All tokens must be separated by a space.

          if (token == JsDocToken.EOC ||
              token == JsDocToken.EOF ||
              // When we're capturing a license block, annotations
              // in the block are ok.
              (token == JsDocToken.ANNOTATION &&
               option != WhitespaceOption.PRESERVE)) {
            String multilineText = builder.toString();

            if (option != WhitespaceOption.PRESERVE) {
              multilineText = multilineText.trim();
            }

            int endLineno = stream.getLineno();
            int endCharno = stream.getCharno();

            if (multilineText.length() > 0) {
              jsdocBuilder.markText(multilineText, startLineno, startCharno,
                  endLineno, endCharno);
            }

            return new ExtractionInfo(multilineText, token);
          }

          if (builder.length() > 0) {
            builder.append(' ');
          }
          builder.append(toString(token));

          line = stream.getRemainingJSDocLine();

          if (option != WhitespaceOption.PRESERVE) {
            line = trimEnd(line);
          }

          builder.append(line);
          token = next();
      }
    } while (true);
  }","@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;
    boolean newLineStarted = true;

    do {
        switch (token) {
            case STAR:
                if (!ignoreStar) {
                    builder.append('*');
                }
                token = next();
                continue;

            case EOL:
                builder.append(""\n"");
                ignoreStar = true;
                newLineStarted = true;
                token = next();
                continue;

            default:
                ignoreStar = false;
                newLineStarted = false;
                state = State.SEARCHING_ANNOTATION;

                if (token == JsDocToken.EOC || token == JsDocToken.EOF || 
                    (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString().trim();
                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();

                    if (!multilineText.isEmpty()) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }

                    return new ExtractionInfo(multilineText, token);
                }

                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));

                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = line.trim();
                }

                builder.append(line);
                token = next();
        }
    } while (true);
}",4,0
64,Closure_33,"@Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj.isRecordType()) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!hasProperty(prop)) {
            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                .getLeastSupertype(propType);
          }
          defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
  }","@Override
public void matchConstraint(ObjectType constraintObj) {
    // We only want to match constraints on anonymous types.

    // Handle the case where the constraint object is a record type.
    //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj != null && constraintObj.isRecordType()) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
            JSType propType = constraintObj.getPropertyType(prop);
            if (propType != null && !isPropertyTypeDeclared(prop)) {
                JSType typeToInfer = propType;
                if (!hasProperty(prop)) {
                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                        .getLeastSupertype(propType);
                }
                defineInferredProperty(prop, typeToInfer, null);
            }
        }
    }
}",0,0
64,Closure_33,"@Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj.isRecordType()) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!hasProperty(prop)) {
            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                .getLeastSupertype(propType);
          }
          defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
  }","@Override
public void matchConstraint(ObjectType constraintObj) {
    // We only want to match constraints on anonymous types.

    // Ensure the constraint object is not null and is a record type
    if (constraintObj != null && constraintObj.isRecordType()) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
            JSType propType = constraintObj.getPropertyType(prop);
            if (!isPropertyTypeDeclared(prop)) {
                JSType typeToInfer = propType;
                
                // Include additional logic to handle generic types separately
                if (typeToInfer instanceof UnionType) {
                    UnionType unionType = (UnionType) typeToInfer;
                    if (!hasProperty(prop)) {
                        for (JSType alternativeType : unionType.getAlternatives()) {
                            defineInferredProperty(prop, alternativeType, null);
                        }
                    }
                } else {
                    if (!hasProperty(prop)) {
                        typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                            .getLeastSupertype(propType);
                    }
                    defineInferredProperty(prop, typeToInfer, null);
                }
            }
        }
    }
}",1,0
64,Closure_33,"@Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj.isRecordType()) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!hasProperty(prop)) {
            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                .getLeastSupertype(propType);
          }
          defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
  }","@Override
public void matchConstraint(ObjectType constraintObj) {
    // We only want to match constraints on anonymous types.

    // Handle the case where the constraint object is a record type.
    if (constraintObj != null && constraintObj.isRecordType()) {
        // Create a map to store inferred property types and override exists properties
        Map<String, JSType> inferredProperties = new HashMap<>();

        for (String prop : constraintObj.getOwnPropertyNames()) {
            JSType propType = constraintObj.getPropertyType(prop);
            if (!isPropertyTypeDeclared(prop) || inferredProperties.containsKey(prop)) {
                JSType typeToInfer = propType;
                if (!hasProperty(prop)) {
                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                        .getLeastSupertype(propType);
                }
                inferredProperties.put(prop, typeToInfer);
                defineInferredProperty(prop, typeToInfer, null);
            }
        }

        // Apply logic to handle cases where inference led to overridden properties
        for (Map.Entry<String, JSType> entry : inferredProperties.entrySet()) {
            JSType currentType = entry.getValue();
            if (currentType != constraintObj.getPropertyType(entry.getKey())) {
                defineInferredProperty(entry.getKey(), currentType, null);
            }
        }
    }
}",2,0
64,Closure_33,"@Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj.isRecordType()) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!hasProperty(prop)) {
            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                .getLeastSupertype(propType);
          }
          defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
  }","@Override
public void matchConstraint(ObjectType constraintObj) {
    // We only want to match constraints on anonymous types.
    if (constraintObj != null && constraintObj.isRecordType()) {
        Map<String, JSType> overriddenPropertiesMap = new HashMap<>();
        for (String prop : constraintObj.getOwnPropertyNames()) {
            JSType propType = constraintObj.getPropertyType(prop);
            JSType inferredType = null;
            
            if (!isPropertyTypeDeclared(prop)) {
                if (!hasProperty(prop)) {
                    inferredType = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);
                }
                // record inferred properties
                overriddenPropertiesMap.put(prop, inferredType == null ? propType : inferredType);
            }
        }
        
        // apply inferred properties
        for (Map.Entry<String, JSType> entry : overriddenPropertiesMap.entrySet()) {
            defineInferredProperty(entry.getKey(), entry.getValue(), null);
        }
    }
}",3,0
64,Closure_33,"@Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
    // param constraintObj {{prop: (number|undefined)}}
    // function f(constraintObj) {}
    // f({});
    //
    // We want to modify the object literal to match the constraint, by
    // taking any each property on the record and trying to match
    // properties on this object.
    if (constraintObj.isRecordType()) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!hasProperty(prop)) {
            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
                .getLeastSupertype(propType);
          }
          defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
  }","@Override
public void matchConstraint(ObjectType constraintObj) {
    // Ensure the constraint object is not null and is a record type
    if (constraintObj != null && constraintObj.isRecordType()) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
            JSType propType = constraintObj.getPropertyType(prop);
            
            // Modify logic to check both declaration and inferred types
            if (!isPropertyTypeDeclared(prop)) {
                JSType inferredType = propType;
                
                // Explicitly handle void type inference separately
                if (propType instanceof VoidType) {
                    inferredType = getNativeType(JSTypeNative.VOID_TYPE);
                } else if (!hasProperty(prop)) {
                    inferredType = propType.getLeastSupertype(getNativeType(JSTypeNative.VOID_TYPE));
                }
                
                defineInferredProperty(prop, inferredType, null);
            }
        }
    }
}",4,0
65,Closure_35,"private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     if (constraintObj != null && constraintObj.isRecordType()) {
       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
       if (objType != null) {
         for (String prop : constraintObj.getOwnPropertyNames()) {
           JSType propType = constraintObj.getPropertyType(prop);
           if (!objType.isPropertyTypeDeclared(prop)) {
             JSType typeToInfer = propType;
             if (!objType.hasProperty(prop)) {
               typeToInfer =
                   getNativeType(VOID_TYPE).getLeastSupertype(propType);
             }
             objType.defineInferredProperty(prop, typeToInfer, null);
           }
         }
       }
     }
   }","private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }

    ObjectType constraintObj =
        ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null && constraintObj.isRecordType()) {
      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
      if (objType != null) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
          if (constraintObj.hasProperty(prop)) {
            JSType propType = constraintObj.getPropertyType(prop);
            if (!objType.isPropertyTypeDeclared(prop)) {
              JSType typeToInfer = propType;
              if (!objType.hasProperty(prop)) {
                typeToInfer =
                    getNativeType(VOID_TYPE).getLeastSupertype(propType);
              }
              objType.defineInferredProperty(prop, typeToInfer, null);
            }
          }
        }
      }
    }
  }",0,0
65,Closure_35,"private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     if (constraintObj != null && constraintObj.isRecordType()) {
       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
       if (objType != null) {
         for (String prop : constraintObj.getOwnPropertyNames()) {
           JSType propType = constraintObj.getPropertyType(prop);
           if (!objType.isPropertyTypeDeclared(prop)) {
             JSType typeToInfer = propType;
             if (!objType.hasProperty(prop)) {
               typeToInfer =
                   getNativeType(VOID_TYPE).getLeastSupertype(propType);
             }
             objType.defineInferredProperty(prop, typeToInfer, null);
           }
         }
       }
     }
   }","private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
        return;
    }

    ObjectType constraintObj =
        ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null && constraintObj.isRecordType()) {
        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
        if (objType != null) {
            for (String prop : constraintObj.getOwnPropertyNames()) {
                JSType propType = constraintObj.getPropertyType(prop);
                if (!objType.isPropertyTypeDeclared(prop)) {
                    // Adjust the inference based on both properties being undefined or optional
                    if (!objType.hasProperty(prop) || constraintObj.getPropertyType(prop).isOptionalArgType()) {
                        JSType inferredType = getNativeType(VOID_TYPE).getLeastSupertype(propType);
                        objType.defineInferredProperty(prop, inferredType, null);
                    } else {
                        objType.defineInferredProperty(prop, propType, null);
                    }
                }
            }
        }
    }
}",1,0
65,Closure_35,"private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     if (constraintObj != null && constraintObj.isRecordType()) {
       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
       if (objType != null) {
         for (String prop : constraintObj.getOwnPropertyNames()) {
           JSType propType = constraintObj.getPropertyType(prop);
           if (!objType.isPropertyTypeDeclared(prop)) {
             JSType typeToInfer = propType;
             if (!objType.hasProperty(prop)) {
               typeToInfer =
                   getNativeType(VOID_TYPE).getLeastSupertype(propType);
             }
             objType.defineInferredProperty(prop, typeToInfer, null);
           }
         }
       }
     }
   }","private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
        return;
    }

    ObjectType constraintObj =
        ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null && constraintObj.isRecordType()) {
        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
        if (objType != null) {
            for (String prop : constraintObj.getOwnPropertyNames()) {
                JSType propType = constraintObj.getPropertyType(prop);
                if (!objType.isPropertyTypeDeclared(prop)) {
                    JSType typeToInfer = propType;
                    // Define the property with VOID_TYPE only if the property is known to be absent elsewhere
                    if (!objType.hasProperty(prop) && !constraintObj.hasProperty(prop)) {
                        typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);
                    }
                    objType.defineInferredProperty(prop, typeToInfer, null);
                }
            }
        }
    }
}",2,0
65,Closure_35,"private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     if (constraintObj != null && constraintObj.isRecordType()) {
       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
       if (objType != null) {
         for (String prop : constraintObj.getOwnPropertyNames()) {
           JSType propType = constraintObj.getPropertyType(prop);
           if (!objType.isPropertyTypeDeclared(prop)) {
             JSType typeToInfer = propType;
             if (!objType.hasProperty(prop)) {
               typeToInfer =
                   getNativeType(VOID_TYPE).getLeastSupertype(propType);
             }
             objType.defineInferredProperty(prop, typeToInfer, null);
           }
         }
       }
     }
   }","private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }

    ObjectType constraintObj =
        ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null && constraintObj.isRecordType()) {
      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
      if (objType != null) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
          JSType propType = constraintObj.getPropertyType(prop);

          // Check if the property exists in objType or if it is defined in constraintObj
          boolean objHasProperty = objType.hasProperty(prop);
          boolean constraintHasProperty = constraintObj.hasProperty(prop);

          if (!objType.isPropertyTypeDeclared(prop)) {
            JSType typeToInfer = propType;
            
            // Infer type based on property presence and VOID_TYPE if explicitly missing in objType
            if (!objHasProperty && constraintHasProperty) {
              typeToInfer = propType;
            } else if (!objHasProperty) {
              typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);
            }
            
            objType.defineInferredProperty(prop, typeToInfer, null);
          }
        }
      }
    }
  }",3,0
65,Closure_35,"private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
      return;
    }
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     if (constraintObj != null && constraintObj.isRecordType()) {
       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
       if (objType != null) {
         for (String prop : constraintObj.getOwnPropertyNames()) {
           JSType propType = constraintObj.getPropertyType(prop);
           if (!objType.isPropertyTypeDeclared(prop)) {
             JSType typeToInfer = propType;
             if (!objType.hasProperty(prop)) {
               typeToInfer =
                   getNativeType(VOID_TYPE).getLeastSupertype(propType);
             }
             objType.defineInferredProperty(prop, typeToInfer, null);
           }
         }
       }
     }
   }","private void inferPropertyTypesToMatchConstraint(
      JSType type, JSType constraint) {
    if (type == null || constraint == null) {
        return;
    }

    ObjectType constraintObj =
        ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null && constraintObj.isRecordType()) {
        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
        if (objType != null) {
            for (String prop : constraintObj.getOwnPropertyNames()) {
                JSType propType = constraintObj.getPropertyType(prop);

                // Ensure only non-void types are considered for inference
                if (!objType.isPropertyTypeDeclared(prop) && !getNativeType(VOID_TYPE).isSubtype(propType)) {
                    JSType typeToInfer = propType;
                    if (!objType.hasProperty(prop)) {
                        typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);
                    }
                    objType.defineInferredProperty(prop, typeToInfer, null);
                }
            }
        }
    }
}",4,0
66,Closure_36,"private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Be very conservative and do no cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is ok.
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confused class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }","private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the declaration is not equal to initialization and the grandparent
      // of initialization is not an expression result, cannot inline.
      if (!initialization.getGrandparent().isExprResult() &&
          declaration != initialization) {
        return false;
      }

      // Ensure all references are within the same basic block
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node to prevent changing the context
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      // Prevent inlining function values where certain coding conventions are not met
      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (callNode.isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
          // Avoid inlining singleton getter methods to maintain class structure
        }
      }

      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }",0,0
66,Closure_36,"private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Be very conservative and do no cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is ok.
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confused class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }","private boolean canInline(
    Reference declaration,
    Reference initialization,
    Reference reference) {
  if (!isValidDeclaration(declaration)
      || !isValidInitialization(initialization)
      || !isValidReference(reference)) {
    return false;
  }

  // Ensure the references are within the same basic block
  if (!areReferencesInSameBlock(declaration, initialization, reference)) {
      return false;
  }

  // Do not inline if the value is read more than once
  if (!isSingleRead(declaration, initialization)) {
      return false;
  }

  // Validate inlining context for getProp values
  Node value = initialization.getAssignedValue();
  Preconditions.checkState(value != null);
  if (shouldPreventInliningIntoCallNode(value, reference)) {
      return false;
  }

  // Skip inlining logic for specific function patterns or coding conventions
  if (shouldPreventInliningFunction(value, reference)) {
      return false;
  }

  return canMoveAggressively(value) || canMoveModerately(initialization, reference);
}

// Helper methods
private boolean areReferencesInSameBlock(Reference decl, Reference init, Reference ref) {
  return decl.getBasicBlock() == init.getBasicBlock() && decl.getBasicBlock() == ref.getBasicBlock();
}

private boolean isSingleRead(Reference decl, Reference init) {
  return decl == init || init.getGrandparent().isExprResult();
}

private boolean shouldPreventInliningIntoCallNode(Node value, Reference ref) {
  return value.isGetProp() && ref.getParent().isCall() 
         && ref.getParent().getFirstChild() == ref.getNode();
}

private boolean shouldPreventInliningFunction(Node value, Reference ref) {
  if (value.isFunction()) {
    Node callNode = ref.getParent();
    if (callNode.isCall()) {
      CodingConvention convention = compiler.getCodingConvention();
      SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode);
      if (relationship != null || isSingletonMethod(callNode)) {
        return true;
      }
    }
  }
  return false;
}

private boolean isSingletonMethod(Node callNode) {
  // Logic to identify singleton getter method calls can be placed here
  return false; // Assumes this is determined based on additional context
}",1,0
66,Closure_36,"private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Be very conservative and do no cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is ok.
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confused class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }","private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // Ensure the references are within the same basic block
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline if the value is read more than once or the parent is not an expression result.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Prevent inlining into a call node if it changes the context in which it is called
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      // Prevent inlining function values where certain coding conventions are not met
      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (callNode.isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
        }

        // Prevent inlining singleton getter methods to maintain class structure
        if (isSingletonGetterMethod(value)) {
          return false;
        }
      }

      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }

// Method to check if it's a singleton getter method
private boolean isSingletonGetterMethod(Node value) {
    // Logic to identify singleton getter method calls
    // Example: Assume method isSingletonGetter is implemented elsewhere to check this condition
    return compiler.getCodingConvention().isSingletonGetter(value);
}",2,0
66,Closure_36,"private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Be very conservative and do no cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is ok.
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confused class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }","private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }
      
      // Check if references cross control structures or scope boundaries
      if (crossesControlStructure(declaration, initialization, reference)) {
        return false;
      }

      // Do not inline into a call node that may affect the call context
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp() && affectsCallContext(reference)) {
        return false;
      }

      // Prevent inlining for specific coding conventions or singleton methods
      if (preventsInliningDueToConventions(value, reference)) {
        return false;
      }

      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }

private boolean crossesControlStructure(Reference decl, Reference init, Reference ref) {
  // Logic to determine crossing control structures or scope boundaries
  return decl.getBasicBlock() != init.getBasicBlock() ||
         decl.getBasicBlock() != ref.getBasicBlock();
}

private boolean affectsCallContext(Reference ref) {
  return ref.getParent().isCall() && ref.getParent().getFirstChild() == ref.getNode();
}

private boolean preventsInliningDueToConventions(Node value, Reference ref) {
  if (value.isFunction()) {
    Node callNode = ref.getParent();
    if (callNode.isCall()) {
      CodingConvention convention = compiler.getCodingConvention();
      // Check relationships based on coding conventions
      SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode);
      if (relationship != null || isSingletonMethod(value)) {
        return true;
      }
    }
  }
  return false;
}

private boolean isSingletonMethod(Node value) {
  // Logic for identifying singleton getter methods
  return compiler.getCodingConvention().isSingletonGetter(value);
}",3,0
66,Closure_36,"private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Be very conservative and do no cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is ok.
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confused class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }","private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
    if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
    }

    // Ensure that all references are in the same scope
    if (!areReferencesInSameScope(declaration, initialization, reference)) {
        return false;
    }

    // Restrict inlining for specific value types, such as function or property getter
    Node value = initialization.getAssignedValue();
    Preconditions.checkState(value != null);
    if (shouldPreventInliningForValueType(value, reference)) {
        return false;
    }

    return canMoveAggressively(value) || canMoveModerately(initialization, reference);
}

// Helper methods
private boolean areReferencesInSameScope(Reference decl, Reference init, Reference ref) {
    return decl.getBasicBlock().getScopeDepth() == init.getBasicBlock().getScopeDepth() &&
           decl.getBasicBlock().getScopeDepth() == ref.getBasicBlock().getScopeDepth();
}

private boolean shouldPreventInliningForValueType(Node value, Reference ref) {
    if (value.isGetProp()) {
        return ref.getParent().isCall() && ref.getParent().getFirstChild() == ref.getNode();
    }
    if (value.isFunction()) {
        Node callNode = ref.getParent();
        if (callNode.isCall()) {
            CodingConvention convention = compiler.getCodingConvention();
            SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode);
            if (relationship != null || convention.isSingletonGetter(value)) {
                return true;
            }
        }
    }
    return false;
}",4,0
67,Closure_38,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
     if (x < 0 && prev == '-') {
       add("" "");
     }
 
    if ((long) x == x && !negativeZero) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }
  }","void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);
    if (x < 0 && prev == '-') {
        add("" "");
    }

    if ((long) x == x && !negativeZero) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(x) >= 100) {
            while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        String str = String.valueOf(x);
        if (negativeZero) {
            str = ""-0.0"";
        }
        add(str);
    }
}",0,0
67,Closure_38,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
     if (x < 0 && prev == '-') {
       add("" "");
     }
 
    if ((long) x == x && !negativeZero) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }
  }","void addNumber(double x) {
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);

    if (negativeZero && prev == '-') {
        add("" "");
    }

    if ((long) x == x && !negativeZero) {
        long value = (long) x;
        add(Long.toString(value));
    } else {
        String str = String.valueOf(x);
        add(str);
    }
}",1,0
67,Closure_38,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
     if (x < 0 && prev == '-') {
       add("" "");
     }
 
    if ((long) x == x && !negativeZero) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }
  }","void addNumber(double x) {
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);

    if (negativeZero && prev == '-') {
        add("" "");
    }

    if ((long) x == x && !negativeZero) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(x) >= 100) {
            while (mantissa >= 10 && mantissa / 10 * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        if (negativeZero) {
            add(""-0.0"");
        } else {
            add(String.valueOf(x));
        }
    }
}",2,0
67,Closure_38,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
     if (x < 0 && prev == '-') {
       add("" "");
     }
 
    if ((long) x == x && !negativeZero) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }
  }","void addNumber(double x) {
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);
    
    if ((negativeZero || x < 0) && prev == '-') {
        add("" "");
    }
    
    if ((long) x == x && !negativeZero) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(x) >= 100) {
            while (mantissa >= 10 && mantissa / 10 * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        if (negativeZero) {
            add(""-0.0"");
        } else {
            add(String.valueOf(x));
        }
    }
}",3,0
67,Closure_38,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
     if (x < 0 && prev == '-') {
       add("" "");
     }
 
    if ((long) x == x && !negativeZero) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }
  }","void addNumber(double x) {
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);

    // Ensure spacing before negative zero output
    if ((negativeZero || (x < 0 && !negativeZero)) && prev == '-') {
        add("" "");
    }

    if ((long) x == x && !negativeZero) {
        long value = (long) x;
        add(Long.toString(value));
    } else {
        if (negativeZero) {
            add(""-0.0"");
        } else {
            add(String.valueOf(x));
        }
    }
}",4,0
68,Closure_39,"@Override
  String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
      return getReferenceName();
    } else if (prettyPrint) {
      // Don't pretty print recursively.
      prettyPrint = false;

      // Use a tree set so that the properties are sorted.
      Set<String> propertyNames = Sets.newTreeSet();
      for (ObjectType current = this;
           current != null && !current.isNativeObjectType() &&
               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
           current = current.getImplicitPrototype()) {
        propertyNames.addAll(current.getOwnPropertyNames());
      }

      StringBuilder sb = new StringBuilder();
      sb.append(""{"");

      int i = 0;
      for (String property : propertyNames) {
        if (i > 0) {
          sb.append("", "");
        }

        sb.append(property);
        sb.append("": "");
        sb.append(getPropertyType(property).toString());

        ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
          sb.append("", ..."");
          break;
        }
      }

      sb.append(""}"");

       prettyPrint = true;
       return sb.toString();
     } else {
       return ""{...}"";
     }
   }","@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;

        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this;
             current != null && !current.isNativeObjectType() &&
             propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
             current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }

        StringBuilder sb = new StringBuilder();
        sb.append(""{"");

        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }

            sb.append(property);
            sb.append("": "");
            JSType propertyType = getPropertyType(property);
            // Avoid infinite recursion for cyclic references.
            sb.append(propertyType == this ? ""{...}"" : propertyType.toString());

            ++i;
            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }

        sb.append(""}"");

        prettyPrint = true;
        return sb.toString();
    } else {
        return ""{...}"";
    }
}",0,0
68,Closure_39,"@Override
  String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
      return getReferenceName();
    } else if (prettyPrint) {
      // Don't pretty print recursively.
      prettyPrint = false;

      // Use a tree set so that the properties are sorted.
      Set<String> propertyNames = Sets.newTreeSet();
      for (ObjectType current = this;
           current != null && !current.isNativeObjectType() &&
               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
           current = current.getImplicitPrototype()) {
        propertyNames.addAll(current.getOwnPropertyNames());
      }

      StringBuilder sb = new StringBuilder();
      sb.append(""{"");

      int i = 0;
      for (String property : propertyNames) {
        if (i > 0) {
          sb.append("", "");
        }

        sb.append(property);
        sb.append("": "");
        sb.append(getPropertyType(property).toString());

        ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
          sb.append("", ..."");
          break;
        }
      }

      sb.append(""}"");

       prettyPrint = true;
       return sb.toString();
     } else {
       return ""{...}"";
     }
   }",Match failed,1,0
68,Closure_39,"@Override
  String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
      return getReferenceName();
    } else if (prettyPrint) {
      // Don't pretty print recursively.
      prettyPrint = false;

      // Use a tree set so that the properties are sorted.
      Set<String> propertyNames = Sets.newTreeSet();
      for (ObjectType current = this;
           current != null && !current.isNativeObjectType() &&
               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
           current = current.getImplicitPrototype()) {
        propertyNames.addAll(current.getOwnPropertyNames());
      }

      StringBuilder sb = new StringBuilder();
      sb.append(""{"");

      int i = 0;
      for (String property : propertyNames) {
        if (i > 0) {
          sb.append("", "");
        }

        sb.append(property);
        sb.append("": "");
        sb.append(getPropertyType(property).toString());

        ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
          sb.append("", ..."");
          break;
        }
      }

      sb.append(""}"");

       prettyPrint = true;
       return sb.toString();
     } else {
       return ""{...}"";
     }
   }",Match failed,2,0
68,Closure_39,"@Override
  String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
      return getReferenceName();
    } else if (prettyPrint) {
      // Don't pretty print recursively.
      prettyPrint = false;

      // Use a tree set so that the properties are sorted.
      Set<String> propertyNames = Sets.newTreeSet();
      for (ObjectType current = this;
           current != null && !current.isNativeObjectType() &&
               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
           current = current.getImplicitPrototype()) {
        propertyNames.addAll(current.getOwnPropertyNames());
      }

      StringBuilder sb = new StringBuilder();
      sb.append(""{"");

      int i = 0;
      for (String property : propertyNames) {
        if (i > 0) {
          sb.append("", "");
        }

        sb.append(property);
        sb.append("": "");
        sb.append(getPropertyType(property).toString());

        ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
          sb.append("", ..."");
          break;
        }
      }

      sb.append(""}"");

       prettyPrint = true;
       return sb.toString();
     } else {
       return ""{...}"";
     }
   }",Match failed,3,0
68,Closure_39,"@Override
  String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
      return getReferenceName();
    } else if (prettyPrint) {
      // Don't pretty print recursively.
      prettyPrint = false;

      // Use a tree set so that the properties are sorted.
      Set<String> propertyNames = Sets.newTreeSet();
      for (ObjectType current = this;
           current != null && !current.isNativeObjectType() &&
               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
           current = current.getImplicitPrototype()) {
        propertyNames.addAll(current.getOwnPropertyNames());
      }

      StringBuilder sb = new StringBuilder();
      sb.append(""{"");

      int i = 0;
      for (String property : propertyNames) {
        if (i > 0) {
          sb.append("", "");
        }

        sb.append(property);
        sb.append("": "");
        sb.append(getPropertyType(property).toString());

        ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
          sb.append("", ..."");
          break;
        }
      }

      sb.append(""}"");

       prettyPrint = true;
       return sb.toString();
     } else {
       return ""{...}"";
     }
   }",Match failed,4,0
69,Closure_4,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
      handleTypeCycle(t);
    }

    if (resolved) {
      super.resolveInternal(t, enclosing);
      finishPropertyContinuations();
      return registry.isLastGeneration() ?
          getReferencedType() : this;
     }
 
     resolveViaProperties(t, enclosing);
     if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
      finishPropertyContinuations();
    }
    return registry.isLastGeneration() ?
        getReferencedType() : this;
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // Check if the type is resolved via the registry, avoiding cycles.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (resolved) {
        if (detectImplicitPrototypeCycle()) {
            handleTypeCycle(t);
            return this; // Early return to avoid further resolution attempts in case of cycle
        }
        super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ? getReferencedType() : this;
    }
    
    resolveViaProperties(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
        return this; // Early return to avoid further resolution attempts in case of cycle
    }
    
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
        finishPropertyContinuations();
    }
    return registry.isLastGeneration() ? getReferencedType() : this;
}",0,0
69,Closure_4,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
      handleTypeCycle(t);
    }

    if (resolved) {
      super.resolveInternal(t, enclosing);
      finishPropertyContinuations();
      return registry.isLastGeneration() ?
          getReferencedType() : this;
     }
 
     resolveViaProperties(t, enclosing);
     if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
      finishPropertyContinuations();
    }
    return registry.isLastGeneration() ?
        getReferencedType() : this;
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // Resolve via registry first
    boolean resolved = resolveViaRegistry(t, enclosing);

    // Detect cycles early to avoid unnecessary resolution attempts
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
        return this; // Return early in case of cycle to prevent further errors
    }

    if (resolved) {
        super.resolveInternal(t, enclosing);
        if (!isResolved()) {
            finishPropertyContinuations();
        }
        return registry.isLastGeneration() ? getReferencedType() : this;   
    }

    // Attempt resolution via properties only if not resolved via registry
    resolveViaProperties(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
        return this;
    }
    
    super.resolveInternal(t, enclosing);
    if (!isResolved()) {
        finishPropertyContinuations();
    }
    return registry.isLastGeneration() ? getReferencedType() : this;
}",1,0
69,Closure_4,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
      handleTypeCycle(t);
    }

    if (resolved) {
      super.resolveInternal(t, enclosing);
      finishPropertyContinuations();
      return registry.isLastGeneration() ?
          getReferencedType() : this;
     }
 
     resolveViaProperties(t, enclosing);
     if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
      finishPropertyContinuations();
    }
    return registry.isLastGeneration() ?
        getReferencedType() : this;
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // Attempt resolution via properties first to catch more specific cycles early
    resolveViaProperties(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
        return this; // Early return to prevent further errors
    }

    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
        return this; // Early return in case of cycle
    }
    
    if (resolved) {
        super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ? getReferencedType() : this;
    }
    
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
        finishPropertyContinuations();
    }
    return registry.isLastGeneration() ? getReferencedType() : this;
}",2,0
69,Closure_4,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
      handleTypeCycle(t);
    }

    if (resolved) {
      super.resolveInternal(t, enclosing);
      finishPropertyContinuations();
      return registry.isLastGeneration() ?
          getReferencedType() : this;
     }
 
     resolveViaProperties(t, enclosing);
     if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
      finishPropertyContinuations();
    }
    return registry.isLastGeneration() ?
        getReferencedType() : this;
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    boolean resolvedViaRegistry = resolveViaRegistry(t, enclosing);
    boolean resolvedViaProperties = false; // track resolution via properties

    if (!resolvedViaRegistry) {
        resolvedViaProperties = resolveViaProperties(t, enclosing);
        if (detectImplicitPrototypeCycle()) {
            handleTypeCycle(t);
            return this; // abort early if a cycle is detected
        }
    }

    if (resolvedViaRegistry || resolvedViaProperties) {
        super.resolveInternal(t, enclosing);
        if (!resolvedViaRegistry) {
            finishPropertyContinuations(); // only finish continuations if not resolved via registry
        }
        return registry.isLastGeneration() ? getReferencedType() : this;
    }

    super.resolveInternal(t, enclosing);
    if (isResolved()) {
        finishPropertyContinuations();
    }
    return registry.isLastGeneration() ? getReferencedType() : this;
}",3,0
69,Closure_4,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
      handleTypeCycle(t);
    }

    if (resolved) {
      super.resolveInternal(t, enclosing);
      finishPropertyContinuations();
      return registry.isLastGeneration() ?
          getReferencedType() : this;
     }
 
     resolveViaProperties(t, enclosing);
     if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
      finishPropertyContinuations();
    }
    return registry.isLastGeneration() ?
        getReferencedType() : this;
  }","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    boolean resolvedViaRegistry = resolveViaRegistry(t, enclosing);
    
    if (resolvedViaRegistry) {
        if (detectImplicitPrototypeCycle()) {
            handleTypeCycle(t);
            return this; // cycle detected, return immediately
        }
        super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ? getReferencedType() : this;
    }

    boolean resolvedViaProperties = resolveViaProperties(t, enclosing);

    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
        return this; // cycle detected, return immediately
    }

    if (resolvedViaProperties) {
        super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ? getReferencedType() : this;
    }

    super.resolveInternal(t, enclosing);
    finishPropertyContinuations();
    return registry.isLastGeneration() ? getReferencedType() : this;
}",4,0
70,Closure_40,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          Preconditions.checkNotNull(ns);
          recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            recordSet(nameInfo.name, nameNode);
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
           }
         }
       }
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {

  try {
    // Record global variable and function declarations
    if (t.inGlobalScope()) {
      if (NodeUtil.isVarDeclaration(n)) {
        NameInformation ns = createNameInformation(t, n, parent);
        Preconditions.checkNotNull(ns);
        recordSet(ns.name, n);
      } else if (NodeUtil.isFunctionDeclaration(n)) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          JsName nameInfo = getName(nameNode.getString(), true);
          recordSet(nameInfo.name, nameNode);
        }
      } else if (NodeUtil.isObjectLitKey(n, parent)) {
        NameInformation ns = createNameInformation(t, n, parent);
        if (ns != null) {
          recordSet(ns.name, n);
        }
      }
    }

    // Record assignments and call sites
    if (n.isAssign()) {
      Node nameNode = n.getFirstChild();

      NameInformation ns = createNameInformation(t, nameNode, n);
      if (ns != null) {
        if (ns.isPrototype) {
          recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
        } else {
          recordSet(ns.name, nameNode);
        }
      }
    } else if (n.isCall()) {
      Node nameNode = n.getFirstChild();
      NameInformation ns = createNameInformation(t, nameNode, n);
      if (ns != null && ns.onlyAffectsClassDef) {
        JsName name = getName(ns.name, false);
        if (name != null) {
          refNodes.add(new ClassDefiningFunctionNode(
              name, n, parent, parent.getParent()));
        }
      }
    }
  } catch (RuntimeException e) {
    // Log the error or handle it appropriately
    throw new RuntimeException(""INTERNAL COMPILER ERROR."", e);
  }
}",0,0
70,Closure_40,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          Preconditions.checkNotNull(ns);
          recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            recordSet(nameInfo.name, nameNode);
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
           }
         }
       }
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {

    // Record global variable and function declarations
    if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
            NameInformation ns = createNameInformation(t, n, parent);
            if (ns != null) {
                recordSet(ns.name, n);
            }
        } else if (NodeUtil.isFunctionDeclaration(n)) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null) {
                JsName nameInfo = getName(nameNode.getString(), true);
                if (nameInfo != null) {
                    recordSet(nameInfo.name, nameNode);
                }
            }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
            NameInformation ns = createNameInformation(t, n, parent);
            if (ns != null) {
                recordSet(ns.name, n);
            }
        }
    }

    // Record assignments and call sites
    if (n.isAssign()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
            if (ns.isPrototype) {
                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
            } else {
                recordSet(ns.name, nameNode);
            }
        }
    } else if (n.isCall()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null && ns.onlyAffectsClassDef) {
            JsName name = getName(ns.name, false);
            if (name != null) {
                refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));
            }
        }
    }
}",1,0
70,Closure_40,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          Preconditions.checkNotNull(ns);
          recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            recordSet(nameInfo.name, nameNode);
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
           }
         }
       }
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {

    try {
        // Record global variable and function declarations
        if (t.inGlobalScope()) {
            if (NodeUtil.isVarDeclaration(n)) {
                NameInformation ns = createNameInformation(t, n, parent);
                if (ns != null) {
                    recordSet(ns.name, n);
                }
            } else if (NodeUtil.isFunctionDeclaration(n)) {
                Node nameNode = n.getFirstChild();
                NameInformation ns = createNameInformation(t, nameNode, n);
                if (ns != null) {
                    JsName nameInfo = getName(nameNode.getString(), true);
                    if (nameInfo != null) {
                        recordSet(nameInfo.name, nameNode);
                    }
                }
            } else if (NodeUtil.isObjectLitKey(n, parent)) {
                NameInformation ns = createNameInformation(t, n, parent);
                if (ns != null) {
                    recordSet(ns.name, n);
                }
            }
        }

        // Record assignments and call sites
        if (n.isAssign()) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null) {
                if (ns.isPrototype) {
                    recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
                } else {
                    recordSet(ns.name, nameNode);
                }
            }
        } else if (n.isCall()) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null && ns.onlyAffectsClassDef) {
                JsName name = getName(ns.name, false);
                if (name != null) {
                    refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));
                }
            }
        }
    } catch (RuntimeException e) {
        System.err.println(""Recording error: "" + e.getMessage());
        throw e;
    }
}",2,0
70,Closure_40,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          Preconditions.checkNotNull(ns);
          recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            recordSet(nameInfo.name, nameNode);
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
           }
         }
       }
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // Record global variable and function declarations
    if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
            NameInformation ns = createNameInformation(t, n, parent);
            if (ns != null && ns.isValid()) {
                recordSet(ns.name, n);
            }
        } else if (NodeUtil.isFunctionDeclaration(n)) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null && ns.isValid()) {
                JsName nameInfo = getName(nameNode.getString(), true);
                if (nameInfo != null) {
                    recordSet(nameInfo.name, nameNode);
                }
            }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
            NameInformation ns = createNameInformation(t, n, parent);
            if (ns != null && ns.isValid()) {
                recordSet(ns.name, n);
            }
        }
    }

    // Record assignments and call sites
    if (n.isAssign()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
            if (ns.isPrototype) {
                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
            } else if (ns.isValid()) {
                recordSet(ns.name, nameNode);
            }
        }
    } else if (n.isCall()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null && ns.isValid() && ns.onlyAffectsClassDef) {
            JsName name = getName(ns.name, false);
            if (name != null) {
                refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));
            }
        }
    }
}",3,0
70,Closure_40,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      // Record global variable and function declarations
      if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
          NameInformation ns = createNameInformation(t, n, parent);
          Preconditions.checkNotNull(ns);
          recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
          Node nameNode = n.getFirstChild();
          NameInformation ns = createNameInformation(t, nameNode, n);
          if (ns != null) {
            JsName nameInfo = getName(nameNode.getString(), true);
            recordSet(nameInfo.name, nameNode);
          }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
          NameInformation ns = createNameInformation(t, n, parent);
          if (ns != null) {
            recordSet(ns.name, n);
          }
        }
      }

      // Record assignments and call sites
      if (n.isAssign()) {
        Node nameNode = n.getFirstChild();

        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
          if (ns.isPrototype) {
            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
          } else {
            recordSet(ns.name, nameNode);
          }
        }
      } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, false);
           if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
           }
         }
       }
     }","@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    try {
        // Record global variable and function declarations
        if (t.inGlobalScope()) {
            if (NodeUtil.isVarDeclaration(n)) {
                NameInformation ns = createNameInformation(t, n, parent);
                if (ns == null) {
                    throw new RuntimeException(""NameInformation creation failed for variable declaration"");
                }
                recordSet(ns.name, n);
            } else if (NodeUtil.isFunctionDeclaration(n)) {
                Node nameNode = n.getFirstChild();
                NameInformation ns = createNameInformation(t, nameNode, n);
                if (ns == null) {
                    throw new RuntimeException(""NameInformation creation failed for function declaration"");
                }
                JsName nameInfo = getName(nameNode.getString(), true);
                if (nameInfo != null) {
                    recordSet(nameInfo.name, nameNode);
                }
            } else if (NodeUtil.isObjectLitKey(n, parent)) {
                NameInformation ns = createNameInformation(t, n, parent);
                if (ns == null) {
                    throw new RuntimeException(""NameInformation creation failed for object literal key"");
                }
                recordSet(ns.name, n);
            }
        }

        // Record assignments and call sites
        if (n.isAssign()) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns == null) {
                throw new RuntimeException(""NameInformation creation failed for assignment"");
            }
            if (ns.isPrototype) {
                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
            } else {
                recordSet(ns.name, nameNode);
            }
        } else if (n.isCall()) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null && ns.onlyAffectsClassDef) {
                JsName name = getName(ns.name, false);
                if (name != null) {
                    refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));
                }
            }
        }
    } catch (RuntimeException e) {
        System.err.println(""Error during visiting nodes: "" + e.getMessage());
        throw new RuntimeException(""INTERNAL COMPILER ERROR."", e);
    }
}",4,0
71,Closure_42,"@Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
          transform(loopNode.getIteratedObject()),
          transformBlock(loopNode.getBody()));
    }","@Override
Node processForInLoop(ForInLoop loopNode) {

    // Ensure 'loopNode' is fully initialized before processing.
    if (loopNode == null || loopNode.getIterator() == null || loopNode.getIteratedObject() == null || loopNode.getBody() == null) {
        throw new IllegalArgumentException(""Invalid ForInLoop node."");
    }

    // Return the bare minimum to put the AST in a valid state.
    return newNode(
        Token.FOR,
        transform(loopNode.getIterator()),
        transform(loopNode.getIteratedObject()),
        transformBlock(loopNode.getBody()));
}",0,0
71,Closure_42,"@Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
          transform(loopNode.getIteratedObject()),
          transformBlock(loopNode.getBody()));
    }","@Override
Node processForInLoop(ForInLoop loopNode) {

    // Introduce logic to handle possible null nodes during AST transformation.
    Node iteratorNode = (loopNode.getIterator() != null) ? transform(loopNode.getIterator()) : null;
    Node iteratedObjectNode = (loopNode.getIteratedObject() != null) ? transform(loopNode.getIteratedObject()) : null;
    Node bodyNode = (loopNode.getBody() != null) ? transformBlock(loopNode.getBody()) : null;

    // Return a new node with safeguarded iteration variables.
    if (iteratorNode != null && iteratedObjectNode != null && bodyNode != null) {
        return newNode(Token.FOR, iteratorNode, iteratedObjectNode, bodyNode);
    } else {
        return null; // If any of the components are null, we cannot form a valid ForInLoop node.
    }
}",1,0
71,Closure_42,"@Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
          transform(loopNode.getIteratedObject()),
          transformBlock(loopNode.getBody()));
    }","@Override
Node processForInLoop(ForInLoop loopNode) {
    // Introduce logic to ensure loop nodes are valid and handle them if not.
    if (loopNode.getIterator() == null) {
        // Create a default iterator if absent.
        loopNode.setIterator(new DefaultIteratorNode());
    }
    if (loopNode.getIteratedObject() == null) {
        // Create a default object to iterate over if absent.
        loopNode.setIteratedObject(new DefaultIteratedObjectNode());
    }
    if (loopNode.getBody() == null) {
        // Create a default empty body if absent.
        loopNode.setBody(new DefaultBodyNode());
    }

    // Transform and return the AST node.
    return newNode(
        Token.FOR,
        transform(loopNode.getIterator()),
        transform(loopNode.getIteratedObject()),
        transformBlock(loopNode.getBody()));
}",2,0
71,Closure_42,"@Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
          transform(loopNode.getIteratedObject()),
          transformBlock(loopNode.getBody()));
    }","@Override
Node processForInLoop(ForInLoop loopNode) {

    // Preserve existing components and add conditional logic for missing nodes.
    Node iteratorNode = transform(loopNode.getIterator());
    Node iteratedObjectNode = transform(loopNode.getIteratedObject());
    Node bodyNode = transformBlock(loopNode.getBody());

    // Check if the nodes were transformed correctly.
    if (iteratorNode == null || iteratedObjectNode == null || bodyNode == null) {
        throw new IllegalStateException(""Transformation resulted in null node."");
    }

    // Create and return a valid AST FOR node.
    return newNode(Token.FOR, iteratorNode, iteratedObjectNode, bodyNode);
}",3,0
71,Closure_42,"@Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
          transform(loopNode.getIteratedObject()),
          transformBlock(loopNode.getBody()));
    }","@Override
Node processForInLoop(ForInLoop loopNode) {
    // Implement logic to handle empty nodes and create defaults if necessary
    Node iteratorNode = (loopNode.getIterator() != null) ? transform(loopNode.getIterator()) : new EmptyNode();
    Node iteratedObjectNode = (loopNode.getIteratedObject() != null) ? transform(loopNode.getIteratedObject()) : new EmptyNode();
    Node bodyNode = (loopNode.getBody() != null) ? transformBlock(loopNode.getBody()) : new EmptyNode();

    // Implementing custom logic to ensure fallback must form valid loop node
    Node processedNode = processLoopLogic(iteratorNode, iteratedObjectNode, bodyNode);

    return newNode(Token.FOR, processedNode);
}

// Implement logic specific to processing loop components
Node processLoopLogic(Node iteratorNode, Node iteratedObjectNode, Node bodyNode) {
    if (iteratorNode == null || iteratedObjectNode == null || bodyNode == null) {
        throw new InvalidNodeException(""Loop components resulted in invalid node."");
    }
    // Add additional handling or customization of nodes here if needed 
    return combineNodes(iteratorNode, iteratedObjectNode, bodyNode);
}

// Dummy EmptyNode class
class EmptyNode extends Node {
    public EmptyNode() {
        super(Token.EMPTY);
    }
}",4,0
72,Closure_44,"void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
      return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar())) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
  }","void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
      return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar())) {
       // need space to separate. This is not pretty printing.
       append("" "");
       // Allow forward slash to appear after a non-word character.
       // If the last character is a closing character like ')', don't add space.
    } else if (c == '/' && !isWordChar(getLastChar())) {
       // Allowing forward slash without space for regex patterns.
    }
 
     append(newcode);
  }",0,0
72,Closure_44,"void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
      return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar())) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
  }","void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
        return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar()) &&
        !(c == '/' && getLastChar() == '/')) {
        // Only insert a space if current character and last character are word characters
        // or backslash, and not when a forward slash appears after another forward slash.
        append("" "");
    }

    append(newcode);
}",1,0
72,Closure_44,"void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
      return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar())) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
  }","void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
        return;
    }

    char c = newcode.charAt(0);
    char lastChar = getLastChar();
    if ((isWordChar(c) || c == '\\') && isWordChar(lastChar)) {
        // need space to separate words and special backslash,
        append("" "");
    } else if (c == '/' && lastChar == '/') {
        // do not insert space between consecutive forward slashes
    } else if (c == '/' && isWordChar(lastChar)) {
        // check and avoid adding space after division operator followed by regex slashes
        if (!(lastChar == '/') || !(c == '/')) {
            append("" "");
        }
    }

    append(newcode);
}",2,0
72,Closure_44,"void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
      return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar())) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
  }","void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
        return;
    }

    char c = newcode.charAt(0);
    boolean isCurrentCharWordOrBackslash = isWordChar(c) || c == '\\';
    char lastChar = getLastChar();
    boolean isLastCharWordOrBackslash = isWordChar(lastChar) || lastChar == '\\';

    if (isCurrentCharWordOrBackslash && isLastCharWordOrBackslash) {
        append("" "");
    } else if (c == '/' && lastChar != '/') {
        append("" "");
    }

    append(newcode);
}",3,0
72,Closure_44,"void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
      return;
    }

    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') &&
        isWordChar(getLastChar())) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
  }","void add(String newcode) {
    maybeEndStatement();

    if (newcode.length() == 0) {
        return;
    }

    char c = newcode.charAt(0);
    char lastChar = getLastChar();

    if ((isWordChar(c) || c == '\\' || Character.isWhitespace(c)) && 
        (isWordChar(lastChar) || lastChar == '\\')) {
        append("" "");
    } else if (Character.isWhitespace(c) && lastChar != '/') {
        append("" "");
    }

    append(newcode);
}",4,0
73,Closure_46,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
","public ObjectType getImplicitPrototype() {
    // Assuming registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) can return null,
    // add a check to handle the null case.
    ObjectType prototype = registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    return prototype != null ? prototype : registry.createAnonymousObjectType();
}",0,0
73,Closure_46,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
","public ObjectType getImplicitPrototype() {
    ObjectType prototype = registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    if (prototype == null) {
        throw new IllegalStateException(""Expected native object type, but found null."");
    }
    return prototype;
}",1,0
73,Closure_46,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
","public ObjectType getImplicitPrototype() {
    // Attempting to address the issue by checking the type availability first.
    if (registry.isNativeObjectTypeAvailable(JSTypeNative.OBJECT_TYPE)) {
        return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    }
    return registry.createAnonymousObjectType();
}",2,0
73,Closure_46,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
","public ObjectType getImplicitPrototype() {
    // Instead of returning the native object type directly, we will use a fallback strategy.
    // Checking if the registry can provide a valid object type. If not, use the default object type.
    ObjectType prototype = registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    if (prototype == null || !prototype.isNativeObjectType()) {
        return registry.getNativeObjectType(JSTypeNative.DEFAULT_OBJECT_TYPE);
    }
    return prototype;
}",3,0
73,Closure_46,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
","public ObjectType getImplicitPrototype() {
    FunctionType constructor = registry.getNativeFunctionType(JSTypeNative.OBJECT_TYPE);
    if (constructor != null) {
        return constructor.getPrototype();
    } else {
        return registry.createAnonymousObjectType();
    }
}",4,0
74,Closure_48,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult() && t.getInput() != null) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }",0,0
74,Closure_48,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        valueType = rhsValue.getJSType();
      }
      
      // Avoid potential errors by ensuring variable type checks
      if (valueType == null) {
        if (parent.isExprResult() && t.getInput() != null) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput().isExtern(),
              ownerName));
        }
        return;
      }

      boolean inferred = true;
      if (info != null) {
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       ObjectType ownerType = getObjectSlot(ownerName);
       if (!inferred && ownerType != null) {
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        FunctionType ownerFuncionType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerFuncionType != null) {
          JSType ownerTypeOfThis = ownerFuncionType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
}",1,0
74,Closure_48,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);

    JSType valueType = null;
    // Adjust the logic to prioritize type setting based on certain flags
    if (info != null && (info.hasType() || info.hasEnumParameterType() ||
       (info.isConstant() && valueType != null && !valueType.isUnknownType()) ||
       FunctionTypeBuilder.isFunctionTypeDeclaration(info))) {
        valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    } else if (rhsValue != null && rhsValue.isFunction() &&
               (info != null || !scope.isDeclared(qName, false))) {
        valueType = rhsValue.getJSType();
    } else if (rhsValue != null) {
        valueType = rhsValue.getJSType();
    }

    if (valueType == null) {
        if (parent.isExprResult() && t.getInput() != null) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));
        }
        return;
    }

    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            ObjectType qVarType = ObjectType.cast(qVar.getType());
            if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {
                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype());
            } else if (!qVar.isTypeInferred()) {
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }

    ObjectType ownerType = getObjectSlot(ownerName);
    if (ownerType != null) {
        boolean isExtern = t.getInput() != null && t.getInput().isExtern();
        if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) &&
            ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
            ownerType.defineDeclaredProperty(propName, valueType, n);
        }
    }

    defineSlot(n, parent, valueType, false);
}",2,0
74,Closure_48,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);

    // Compute the declared type based on priority logic
    JSType valueType = null;
    if (info != null) {
        valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    }
    if (valueType == null && rhsValue != null) {
        valueType = rhsValue.getJSType();
    }

    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            ObjectType qVarType = ObjectType.cast(qVar.getType());
            if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {
                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype());
            } else if (!qVar.isTypeInferred() && rhsValue != null) {
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }

    if (valueType == null) {
        if (parent.isExprResult()) {
            stubDeclarations.add(new StubDeclaration(
                n, t.getInput() != null && t.getInput().isExtern(), ownerName));
        }
        return;
    }

    boolean inferred = info == null || !(info.hasType() || info.hasEnumParameterType() ||
                (info.isConstant() && valueType != null && !valueType.isUnknownType()) ||
                FunctionTypeBuilder.isFunctionTypeDeclaration(info) ||
                (rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false))));

    ObjectType ownerType = getObjectSlot(ownerName);
    if (!inferred && ownerType != null) {
        boolean isExtern = t.getInput() != null && t.getInput().isExtern();
        if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) &&
            ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
            ownerType.defineDeclaredProperty(propName, valueType, n);
        }

        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.isTrue()) {
        FunctionType ownerFunctionType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerFunctionType != null) {
            JSType ownerTypeOfThis = ownerFunctionType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}",3,0
74,Closure_48,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
          // then they are responsible for making sure that the object literal's
          // implicit prototype is set up appropriately. We just obey
          // the @extends tag.
          ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.isObjectLit()) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to some arbitrary expression,
            // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.isExprResult()) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      // NOTE(nicksantos): Determining whether a property is declared or not
      // is really really obnoxious.
      //
      // The problem is that there are two (equally valid) coding styles:
      //
      // (function() {
      //   /* The authoritative definition of goog.bar. */
      //   goog.bar = function() {};
      // })();
      //
      // function f() {
      //   goog.bar();
      //   /* Reset goog.bar to a no-op. */
      //   goog.bar = function() {};
      // }
      //
      // In a dynamic language with first-class functions, it's very difficult
      // to know which one the user intended without looking at lots of
      // contextual information (the second example demonstrates a small case
      // of this, but there are some really pathological cases as well).
      //
      // The current algorithm checks if either the declaration has
      // jsdoc type information, or @const with a known type,
      // or a function literal with a name we haven't seen before.
      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
             rhsValue.isFunction() &&
             (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);

    // Determine the type based on provided information
    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
        valueType = rhsValue.getJSType();
    }

    // Check if the property is prototype
    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            ObjectType qVarType = ObjectType.cast(qVar.getType());
            if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {
                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype());
            } else if (!qVar.isTypeInferred()) {
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }

    if (valueType == null) {
        if (parent.isExprResult() && t.getInput() != null) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));
        }
        return;
    }

    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType() || info.hasEnumParameterType() ||
                     (info.isConstant() && valueType != null && !valueType.isUnknownType()) ||
                     FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred) {
        inferred = !(rhsValue != null && rhsValue.isFunction() &&
                     (info != null || !scope.isDeclared(qName, false)));
    }

    ObjectType ownerType = getObjectSlot(ownerName);
    if (!inferred && ownerType != null) {
        boolean isExtern = t.getInput() != null && t.getInput().isExtern();
        if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) &&
            ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
            ownerType.defineDeclaredProperty(propName, valueType, n);
        }
        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.isTrue()) {
        FunctionType ownerFunctionType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerFunctionType != null) {
            JSType ownerTypeOfThis = ownerFunctionType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}",4,0
75,Closure_5,"private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target may be using the object as a 'this' value.
            if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            // Deleting a property has different semantics from deleting
            // a variable, so deleted properties should not be inlined.

            // NOTE(nicksantos): This pass's object-splitting algorithm has
            // a blind spot. It assumes that if a property isn't defined on an
            // object, then the value is undefined. This is not true, because
            // Object.prototype can have arbitrary properties on it.
            //
            // We short-circuit this problem by bailing out if we see a reference
            // to a property that isn't defined on the object literal. This
            // isn't a perfect algorithm, but it should catch most cases.
            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }

            validProperties.add(child.getString());

            Node childVal = child.getFirstChild();
            if (childVal != null) {
                // Check if childVal is the parent of any of the passed in
                // references, as that is how self-referential assignments
                // will happen.
                for (Reference t : refs) {
                    Node refNode = t.getParent();
                    while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                        if (refNode == childVal) {
                            // There's a self-referential assignment
                            return false;
                        }
                        refNode = refNode.getParent();
                    }
                }
            }
        }

        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}",0,0
75,Closure_5,"private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    Set<String> referencedProperties = Sets.newHashSet();
    
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        if (parent.isGetProp()) {
            String propName = parent.getLastChild().getString();
            referencedProperties.add(propName);
            Preconditions.checkState(parent.getFirstChild() == name);

            if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            // Check deletion semantics
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }

        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
            continue;
        }

        if (!val.isObjectLit()) {
            return false;
        }

        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                return false;
            }

            String childPropertyName = child.getString();
            validProperties.add(childPropertyName);

            Node childVal = child.getFirstChild();
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }

        ret = true;
    }
    
    // Ensure there are no referenced properties outside of valid ones
    for (String referencedProperty : referencedProperties) {
        if (!validProperties.contains(referencedProperty)) {
            return false;
        }
    }
    
    return ret;
}",1,0
75,Closure_5,"private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }

        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
            continue;
        }

        if (!val.isObjectLit()) {
            return false;
        }

        Set<String> tempValidProperties = new HashSet<>();
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                return false;
            }

            tempValidProperties.add(child.getString());

            Node childVal = child.getFirstChild();
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }

        if (!validProperties.containsAll(tempValidProperties)) {
            return false;
        }

        validProperties.addAll(tempValidProperties);
        ret = true;
    }
    return ret;
}",2,0
75,Closure_5,"private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    Set<String> validProperties = Sets.newHashSet();
    Set<Node> seenNodes = new HashSet<>();

    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }

        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null || !val.isObjectLit()) {
            return false;
        }

        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                return false;
            }

            validProperties.add(child.getString());
            Node childVal = child.getFirstChild();
            
            if (childVal != null && seenNodes.contains(childVal)) {
                return false;
            }
            seenNodes.add(childVal);
        }
    }
    return true;
}",3,0
75,Closure_5,"private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }","private boolean isInlinableObject(List<Reference> refs) {
    Set<String> validProperties = Sets.newHashSet();
    Map<Node, String> selfReferentialCheck = new HashMap<>();

    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }

            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }

        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null || !val.isObjectLit()) {
            return false;
        }

        Set<String> objectProperties = new HashSet<>();
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                return false;
            }
            objectProperties.add(child.getString());

            Node childVal = child.getFirstChild();
            if (selfReferentialCheck.containsKey(childVal)) {
                if (!selfReferentialCheck.get(childVal).equals(child.getString())) {
                    return false;
                }
            } else {
                selfReferentialCheck.put(childVal, child.getString());
            }
        }

        validProperties.addAll(objectProperties);
    }
    return true;
}",4,0
76,Closure_50,"private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
      return n;
    }
 
     Node right = callTarget.getNext();
     if (right != null) {
       if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return n;
    }

      // "","" is the default, it doesn't need to be explicit

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getArrayElementStringValue(elem));
      } else {
        if (sb != null) {
          Preconditions.checkNotNull(prev);
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(
              Node.newString(sb.toString()).copyInformationFrom(prev));
          sb = null;
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem);
      }
      prev = elem;
      elem = elem.getNext();
    }

    if (sb != null) {
      Preconditions.checkNotNull(prev);
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(
          Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        n.getParent().replaceChild(n, emptyStringNode);
        reportCodeChange();
        return emptyStringNode;
      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString("""").copyInformationFrom(n),
              foldedStringNode);
          foldedStringNode = replacement;
        }
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return n;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        reportCodeChange();
        break;
    }

    return n;
  }","private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();
    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }

    Node right = callTarget.getNext();
    if (right != null && !NodeUtil.isImmutableValue(right)) {
        return n;
    }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();
    if (arrayNode == null || functionName == null || 
        arrayNode.getType() != Token.ARRAYLIT || 
        !functionName.getString().equals(""join"")) {
        return n;
    }

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();

    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            if (sb == null) {
                sb = new StringBuilder();
            } else {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        } else {
            if (sb != null) {
                Preconditions.checkNotNull(prev);
                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
                sb = null;
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        prev = elem;
        elem = elem.getNext();
    }

    if (sb != null) {
        Preconditions.checkNotNull(prev);
        foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
    }

    foldedSize += arrayFoldedChildren.size() - 1;
    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            n.getParent().replaceChild(n, emptyStringNode);
            reportCodeChange();
            return emptyStringNode;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return n;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                Node replacement = new Node(Token.ADD, 
                    Node.newString("""").copyInformationFrom(n), 
                    foldedStringNode);
                foldedStringNode = replacement;
            }
            n.getParent().replaceChild(n, foldedStringNode);
            reportCodeChange();
            return foldedStringNode;
        default:
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return n;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
            if (foldedSize > originalSize) {
                return n;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            reportCodeChange();
            break;
    }
    return n;
}",0,0
76,Closure_50,"private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
      return n;
    }
 
     Node right = callTarget.getNext();
     if (right != null) {
       if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return n;
    }

      // "","" is the default, it doesn't need to be explicit

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getArrayElementStringValue(elem));
      } else {
        if (sb != null) {
          Preconditions.checkNotNull(prev);
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(
              Node.newString(sb.toString()).copyInformationFrom(prev));
          sb = null;
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem);
      }
      prev = elem;
      elem = elem.getNext();
    }

    if (sb != null) {
      Preconditions.checkNotNull(prev);
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(
          Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        n.getParent().replaceChild(n, emptyStringNode);
        reportCodeChange();
        return emptyStringNode;
      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString("""").copyInformationFrom(n),
              foldedStringNode);
          foldedStringNode = replacement;
        }
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return n;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        reportCodeChange();
        break;
    }

    return n;
  }","private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();
    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }

    Node right = callTarget.getNext();
    if (right != null && !NodeUtil.isImmutableValue(right)) {
        return n;
    }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();
    if (arrayNode == null || functionName == null || 
        arrayNode.getType() != Token.ARRAYLIT || 
        !functionName.getString().equals(""join"")) {
        return n;
    }

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    boolean hasNonImmutableElements = false;

    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            if (sb.length() != 0) {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        } else {
            hasNonImmutableElements = true;
            sb.append(joinString);
            sb.append(""-"");
        }
        foldedSize += sb.length() + 2; // Adjust folded size
        elem = elem.getNext();
    }

    foldedSize += sb.length(); // Include sb length in folded size

    if (!hasNonImmutableElements) {
        Node foldedStringNode = Node.newString(sb.toString());
        foldedSize = sb.length();
        arrayNode.detachChildren();
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
    }

    return n; // Return original node if no folding performed
}",1,0
76,Closure_50,"private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
      return n;
    }
 
     Node right = callTarget.getNext();
     if (right != null) {
       if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return n;
    }

      // "","" is the default, it doesn't need to be explicit

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getArrayElementStringValue(elem));
      } else {
        if (sb != null) {
          Preconditions.checkNotNull(prev);
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(
              Node.newString(sb.toString()).copyInformationFrom(prev));
          sb = null;
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem);
      }
      prev = elem;
      elem = elem.getNext();
    }

    if (sb != null) {
      Preconditions.checkNotNull(prev);
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(
          Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        n.getParent().replaceChild(n, emptyStringNode);
        reportCodeChange();
        return emptyStringNode;
      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString("""").copyInformationFrom(n),
              foldedStringNode);
          foldedStringNode = replacement;
        }
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return n;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        reportCodeChange();
        break;
    }

    return n;
  }","private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();
    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }

    Node right = callTarget.getNext();
    if (right != null && !NodeUtil.isImmutableValue(right)) {
        return n;
    }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();
    if (arrayNode == null || functionName == null || 
        arrayNode.getType() != Token.ARRAYLIT || 
        !functionName.getString().equals(""join"")) {
        return n;
    }

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    Node elem = arrayNode.getFirstChild();
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        } else if (sb.length() > 0) {
            arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
            sb.setLength(0);  // Clear the StringBuilder
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }
    
    if (sb.length() > 0) {
        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
    }

    if (arrayFoldedChildren.size() < arrayNode.getChildCount()) {
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
            arrayNode.addChildToBack(node);
        }
        reportCodeChange();
    }
    return n;
}",2,0
76,Closure_50,"private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
      return n;
    }
 
     Node right = callTarget.getNext();
     if (right != null) {
       if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return n;
    }

      // "","" is the default, it doesn't need to be explicit

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getArrayElementStringValue(elem));
      } else {
        if (sb != null) {
          Preconditions.checkNotNull(prev);
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(
              Node.newString(sb.toString()).copyInformationFrom(prev));
          sb = null;
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem);
      }
      prev = elem;
      elem = elem.getNext();
    }

    if (sb != null) {
      Preconditions.checkNotNull(prev);
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(
          Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        n.getParent().replaceChild(n, emptyStringNode);
        reportCodeChange();
        return emptyStringNode;
      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString("""").copyInformationFrom(n),
              foldedStringNode);
          foldedStringNode = replacement;
        }
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return n;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        reportCodeChange();
        break;
    }

    return n;
  }","private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();
    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }

    Node right = callTarget.getNext();
    if (right != null && !NodeUtil.isImmutableValue(right)) {
        return n;
    }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();
    if (arrayNode == null || functionName == null || 
        arrayNode.getType() != Token.ARRAYLIT || 
        !functionName.getString().equals(""join"")) {
        return n;
    }

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    Node prev = null;
    boolean performFold = false;
    Node elem = arrayNode.getFirstChild();

    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            performFold = true;
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        } else {
            if (sb.length() > 0) {
                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
                sb.setLength(0);
            }
            arrayFoldedChildren.add(elem);
        }
        prev = elem;
        elem = elem.getNext();
    }
    
    if (sb.length() > 0) {
        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
    }

    if (performFold && arrayFoldedChildren.size() < arrayNode.getChildCount()) {
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
            arrayNode.addChildToBack(node);
        }
        reportCodeChange();
    } else if (sb.length() > 0) {
        Node foldedStringNode = Node.newString(sb.toString()).copyInformationFrom(prev);
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
    }
    return n;
}",3,0
76,Closure_50,"private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();

    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
      return n;
    }
 
     Node right = callTarget.getNext();
     if (right != null) {
       if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();

    if ((arrayNode.getType() != Token.ARRAYLIT) ||
        !functionName.getString().equals(""join"")) {
      return n;
    }

      // "","" is the default, it doesn't need to be explicit

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
          sb.append(joinString);
        }
        sb.append(NodeUtil.getArrayElementStringValue(elem));
      } else {
        if (sb != null) {
          Preconditions.checkNotNull(prev);
          // + 2 for the quotes.
          foldedSize += sb.length() + 2;
          arrayFoldedChildren.add(
              Node.newString(sb.toString()).copyInformationFrom(prev));
          sb = null;
        }
        foldedSize += InlineCostEstimator.getCost(elem);
        arrayFoldedChildren.add(elem);
      }
      prev = elem;
      elem = elem.getNext();
    }

    if (sb != null) {
      Preconditions.checkNotNull(prev);
      // + 2 for the quotes.
      foldedSize += sb.length() + 2;
      arrayFoldedChildren.add(
          Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;

    int originalSize = InlineCostEstimator.getCost(n);
    switch (arrayFoldedChildren.size()) {
      case 0:
        Node emptyStringNode = Node.newString("""");
        n.getParent().replaceChild(n, emptyStringNode);
        reportCodeChange();
        return emptyStringNode;
      case 1:
        Node foldedStringNode = arrayFoldedChildren.remove(0);
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        if (foldedStringNode.getType() != Token.STRING) {
          // If the Node is not a string literal, ensure that
          // it is coerced to a string.
          Node replacement = new Node(Token.ADD,
              Node.newString("""").copyInformationFrom(n),
              foldedStringNode);
          foldedStringNode = replacement;
        }
        n.getParent().replaceChild(n, foldedStringNode);
        reportCodeChange();
        return foldedStringNode;
      default:
        // No folding could actually be performed.
        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
          return n;
        }
        int kJoinOverhead = ""[].join()"".length();
        foldedSize += kJoinOverhead;
        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
        if (foldedSize > originalSize) {
          return n;
        }
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
          arrayNode.addChildToBack(node);
        }
        reportCodeChange();
        break;
    }

    return n;
  }","private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();
    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }

    Node right = callTarget.getNext();
    if (right != null && !NodeUtil.isImmutableValue(right)) {
        return n;
    }

    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();
    if (arrayNode == null || functionName == null || 
        arrayNode.getType() != Token.ARRAYLIT || 
        !functionName.getString().equals(""join"")) {
        return n;
    }

    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    Node elem = arrayNode.getFirstChild();
    while (elem != null) {
        if (NodeUtil.isObjectValueElement(elem)) {
            return n;
        }
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            if (sb == null) {
                sb = new StringBuilder();
            } else {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        } else {
            if (sb != null) {
                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
                sb = null;
            }
            arrayFoldedChildren.add(elem);
        }
        prev = elem;
        elem = elem.getNext();
    }
    
    if (sb != null) {
        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
    }

    int foldedSize = arrayFoldedChildren.size() - 1;
    int originalSize = InlineCostEstimator.getCost(n);
    if (foldedSize <= originalSize) {
        arrayNode.detachChildren();
        for (Node node : arrayFoldedChildren) {
            arrayNode.addChildToBack(node);
        }
        reportCodeChange();
    }
    return n;
}",4,0
77,Closure_51,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
      add("" "");
    }

    if ((long) x == x) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }

  }","void addNumber(double x) {
    
        char prev = getLastChar();
    
        // Handle special case for -0.0
        if (Double.doubleToRawLongBits(x) == Double.doubleToRawLongBits(-0.0)) {
            x = 0.0; // Convert -0.0 to 0.0 for printing purposes
        }
    
        if (x == 0.0) {
            add(""0"");
            return;
        }
    
        if (x < 0 && prev == '-') {
            add("" "");
        }
    
        if ((long) x == x) {
            long value = (long) x;
            long mantissa = value;
            int exp = 0;
            if (Math.abs(value) >= 100) {
                while (mantissa % 10 == 0 && mantissa / 10 * Math.pow(10, exp + 1) == value) {
                    mantissa /= 10;
                    exp++;
                }
            }
            if (exp > 2) {
                add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
            } else {
                add(Long.toString(value));
            }
        } else {
            add(String.valueOf(x));
        }
    }",0,0
77,Closure_51,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
      add("" "");
    }

    if ((long) x == x) {
      long value = (long) x;
      long mantissa = value;
      int exp = 0;
      if (Math.abs(x) >= 100) {
        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
          mantissa /= 10;
          exp++;
        }
      }
      if (exp > 2) {
        add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
      } else {
        add(Long.toString(value));
      }
    } else {
      add(String.valueOf(x));
    }

  }","void addNumber(double x) {
    char prev = getLastChar();
    if (Double.doubleToRawLongBits(x) == Double.doubleToRawLongBits(-0.0)) {
        add(""-0.0"");
        return;
    }

    // Handle cases where x is a negative and prev is '-'
    if (x < 0 && prev == '-') {
        add("" "");
    }

    if ((long) x == x) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(value) >= 100) {
            while (mantissa % 10 == 0 && mantissa / 10 * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        add(String.valueOf(x));
    }
}",1,0
78,Closure_52,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
      char c = s.charAt(index);
      if (c < '0' || c > '9') {
         return false;
       }
     }
     return len > 0;
   }",Match failed,0,0
78,Closure_52,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
      char c = s.charAt(index);
      if (c < '0' || c > '9') {
         return false;
       }
     }
     return len > 0;
   }","static boolean isSimpleNumber(String s) {
    // Adjust logic to ensure no leading zeros in non-zero value numbers
    if (s.length() == 0 || (s.length() > 1 && s.charAt(0) == '0')) {
        return false;
    }
    for (int index = 0; index < s.length(); index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return true;
}",1,0
79,Closure_53,"private void replaceAssignmentExpression(Var v, Reference ref,
                                             Map<String, String> varmap) {
      // Compute all of the assignments necessary
      List<Node> nodes = Lists.newArrayList();
      Node val = ref.getAssignedValue();
      blacklistVarReferencesInTree(val, v.scope);
      Preconditions.checkState(val.getType() == Token.OBJECTLIT);
      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
      for (Node key = val.getFirstChild(); key != null;
           key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
      }

      // TODO(user): Better source information.
      for (String var : all) {
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)),
                   NodeUtil.newUndefinedNode(null)));
       }
 
       Node replacement;
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));

        // Join these using COMMA.  A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
          cur.addChildToFront(nodes.get(i));
          Node t = new Node(Token.COMMA);
          cur.addChildToFront(t);
          cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));

      Node replace = ref.getParent();
      replacement.copyInformationFromForTree(replace);

      if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(
            replace, NodeUtil.newExpr(replacement));
      } else {
        replace.getParent().replaceChild(replace, replacement);
      }
    }","private void replaceAssignmentExpression(Var v, Reference ref,
                                         Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(new Node(Token.ASSIGN,
                           Node.newString(Token.NAME, varmap.getOrDefault(var, var)), value));
        all.remove(var);
    }

    // TODO(user): Better source information.
    for (String var : all) {
        nodes.add(new Node(Token.ASSIGN,
                           Node.newString(Token.NAME, varmap.get(var)),
                           NodeUtil.newUndefinedNode(null)));
    }

    Node replacement;
    // All assignments evaluate to true, so we ensure that the 
    // expression statement evaluates to true in case it matters.
    nodes.add(new Node(Token.TRUE));

    // Join these using COMMA. A COMMA node must have 2 children, so we
    // create a tree. In the tree, the first child must be the COMMA to match
    // the parser, otherwise tree equality tests fail.
    nodes = Lists.reverse(nodes);
    replacement = nodes.get(0); 
    for (int i = 1; i < nodes.size(); i++) {
        Node t = new Node(Token.COMMA, replacement, nodes.get(i));
        replacement = t;
    }

    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);

    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}",0,0
79,Closure_53,"private void replaceAssignmentExpression(Var v, Reference ref,
                                             Map<String, String> varmap) {
      // Compute all of the assignments necessary
      List<Node> nodes = Lists.newArrayList();
      Node val = ref.getAssignedValue();
      blacklistVarReferencesInTree(val, v.scope);
      Preconditions.checkState(val.getType() == Token.OBJECTLIT);
      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
      for (Node key = val.getFirstChild(); key != null;
           key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
      }

      // TODO(user): Better source information.
      for (String var : all) {
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)),
                   NodeUtil.newUndefinedNode(null)));
       }
 
       Node replacement;
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));

        // Join these using COMMA.  A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
          cur.addChildToFront(nodes.get(i));
          Node t = new Node(Token.COMMA);
          cur.addChildToFront(t);
          cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));

      Node replace = ref.getParent();
      replacement.copyInformationFromForTree(replace);

      if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(
            replace, NodeUtil.newExpr(replacement));
      } else {
        replace.getParent().replaceChild(replace, replacement);
      }
    }","private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();

    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());

    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // Ensure key value is mapped correctly, else ignore
        if (varmap.containsKey(var)) {
            nodes.add(
                new Node(Token.ASSIGN,
                         Node.newString(Token.NAME, varmap.get(var)), value));
            all.remove(var);
        }
    }

    // Handle remaining variables that may not be accounted for
    for (String var : all) {
        nodes.add(
            new Node(Token.ASSIGN,
                Node.newString(Token.NAME, varmap.get(var)),
                NodeUtil.newUndefinedNode(null)));
    }

    Node replacement = new Node(Token.COMMA);
    Node cur = replacement;
    boolean firstNodeAdded = false;

    for (Node node : nodes) {
        if (!firstNodeAdded) {
            cur.addChildToFront(node);
            firstNodeAdded = true;
        } else {
            Node t = new Node(Token.COMMA, node, cur);
            cur = t;
        }
    }

    // Handle case where Node list is empty
    if (!firstNodeAdded) {
        cur.addChildToFront(new Node(Token.TRUE));
    }

    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);

    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}",1,0
79,Closure_53,"private void replaceAssignmentExpression(Var v, Reference ref,
                                             Map<String, String> varmap) {
      // Compute all of the assignments necessary
      List<Node> nodes = Lists.newArrayList();
      Node val = ref.getAssignedValue();
      blacklistVarReferencesInTree(val, v.scope);
      Preconditions.checkState(val.getType() == Token.OBJECTLIT);
      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
      for (Node key = val.getFirstChild(); key != null;
           key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
      }

      // TODO(user): Better source information.
      for (String var : all) {
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)),
                   NodeUtil.newUndefinedNode(null)));
       }
 
       Node replacement;
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));

        // Join these using COMMA.  A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
          cur.addChildToFront(nodes.get(i));
          Node t = new Node(Token.COMMA);
          cur.addChildToFront(t);
          cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));

      Node replace = ref.getParent();
      replacement.copyInformationFromForTree(replace);

      if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(
            replace, NodeUtil.newExpr(replacement));
      } else {
        replace.getParent().replaceChild(replace, replacement);
      }
    }","private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());

    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        if (varmap.containsKey(var)) {
            nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));
            all.remove(var);
        }
    }

    // Handle remaining variables that may not be accounted for
    for (String var : all) {
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));
    }

    nodes.add(new Node(Token.TRUE)); // Ensure expression evaluates to true

    // Join these using COMMA. Create a single COMMA node with all assignments as children.
    Node replacement = new Node(Token.COMMA);
    for (Node node : nodes) {
        replacement.addChildToBack(node);
    }

    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);

    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}",2,0
79,Closure_53,"private void replaceAssignmentExpression(Var v, Reference ref,
                                             Map<String, String> varmap) {
      // Compute all of the assignments necessary
      List<Node> nodes = Lists.newArrayList();
      Node val = ref.getAssignedValue();
      blacklistVarReferencesInTree(val, v.scope);
      Preconditions.checkState(val.getType() == Token.OBJECTLIT);
      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
      for (Node key = val.getFirstChild(); key != null;
           key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
      }

      // TODO(user): Better source information.
      for (String var : all) {
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)),
                   NodeUtil.newUndefinedNode(null)));
       }
 
       Node replacement;
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));

        // Join these using COMMA.  A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
          cur.addChildToFront(nodes.get(i));
          Node t = new Node(Token.COMMA);
          cur.addChildToFront(t);
          cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));

      Node replace = ref.getParent();
      replacement.copyInformationFromForTree(replace);

      if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(
            replace, NodeUtil.newExpr(replacement));
      } else {
        replace.getParent().replaceChild(replace, replacement);
      }
    }","private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());

    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // Ensure key value is mapped correctly, else ignore
        if (varmap.containsKey(var)) {
            nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));
            all.remove(var);
        }
    }

    // Handle remaining variables that may not be accounted for
    for (String var : all) {
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));
    }

    // Construct replacement tree using a flat COMMA structure
    Node replacement = null;
    if (!nodes.isEmpty()) {
        replacement = nodes.get(0);
        for (int i = 1; i < nodes.size(); i++) {
            replacement = new Node(Token.COMMA, replacement, nodes.get(i));
        }
    } else {
        replacement = new Node(Token.TRUE); // No nodes to process, return TRUE node
    }

    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);

    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}",3,0
79,Closure_53,"private void replaceAssignmentExpression(Var v, Reference ref,
                                             Map<String, String> varmap) {
      // Compute all of the assignments necessary
      List<Node> nodes = Lists.newArrayList();
      Node val = ref.getAssignedValue();
      blacklistVarReferencesInTree(val, v.scope);
      Preconditions.checkState(val.getType() == Token.OBJECTLIT);
      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
      for (Node key = val.getFirstChild(); key != null;
           key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
      }

      // TODO(user): Better source information.
      for (String var : all) {
        nodes.add(
          new Node(Token.ASSIGN,
                   Node.newString(Token.NAME, varmap.get(var)),
                   NodeUtil.newUndefinedNode(null)));
       }
 
       Node replacement;
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));

        // Join these using COMMA.  A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
          cur.addChildToFront(nodes.get(i));
          Node t = new Node(Token.COMMA);
          cur.addChildToFront(t);
          cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));

      Node replace = ref.getParent();
      replacement.copyInformationFromForTree(replace);

      if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(
            replace, NodeUtil.newExpr(replacement));
      } else {
        replace.getParent().replaceChild(replace, replacement);
      }
    }","private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    if (val != null && val.getType() == Token.OBJECTLIT) {
        blacklistVarReferencesInTree(val, v.scope);
        Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
        
        for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
            String var = key.getString();
            Node value = key.removeFirstChild();
            
            if (value != null && varmap.containsKey(var)) {
                nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));
                all.remove(var);
            }
        }
        
        for (String var : all) {
            nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));
        }
        
        nodes.add(new Node(Token.TRUE)); // Ensure expression evaluates to true
    } 

    // Generate replacement
    Node replacement;
    if (nodes.isEmpty()) {
        replacement = new Node(Token.TRUE); // No valid assignments, return TRUE node
    } else {
        replacement = nodes.get(0);
        for (int i = 1; i < nodes.size(); i++) {
            replacement = new Node(Token.COMMA, replacement, nodes.get(i));
        }
    }

    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);

    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}",4,0
80,Closure_55,"  public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }
","public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    if (root == null || !NodeUtil.isFunctionExpression(root.getFirstChild())) {
        throw new IllegalStateException(""Expected function but was: "" + root);
    }
    return root.removeFirstChild();
}",0,0
80,Closure_55,"  public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }
","public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    if (root != null && NodeUtil.isFunctionExpression(root.getFirstChild())) {
        return root.removeFirstChild();
    } else {
        return null;
    }
}",1,0
80,Closure_55,"  public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }
","public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    if (root == null) {
        return null;
    }
    Node firstChild = root.getFirstChild();
    if (NodeUtil.isFunctionExpression(firstChild)) {
        return firstChild;
    }
    root.addChildToFront(new Node(Token.FUNCTION));
    return root.getFirstChild();
}",2,0
80,Closure_55,"  public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }
","public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());

    Node firstChild = (root != null) ? root.getFirstChild() : null;

    if (firstChild != null) {
        if (NodeUtil.isFunctionExpression(firstChild)) {
            return firstChild;
        } else {
            throw new IllegalStateException(""Expected function but was: "" + firstChild);
        }
    }
    return null;
}",3,0
80,Closure_55,"  public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    return (root != null) ? root.removeFirstChild() : null;
  }
","public Node parseHelperCode(Reducer reducer) {
    Node root = compiler.parseSyntheticCode(
        reducer.getClass().toString() + "":helper"", reducer.getHelperSource());
    
    if (root == null) {
        return null;
    }

    Node firstChild = root.getFirstChild();
    root.detachChildren(); // Prevent alteration of the root node
    
    if (firstChild != null && NodeUtil.isFunctionExpression(firstChild)) {
        return firstChild;
    } else {
        return new Node(Token.FUNCTION); // Return default function if expected function missing
    }
}",4,0
81,Closure_56,"public String getLine(int lineNumber) {
    String js = """";
    try {
      // NOTE(nicksantos): Right now, this is optimized for few warnings.
      // This is probably the right trade-off, but will be slow if there
      // are lots of warnings in one file.
      js = getCode();
    } catch (IOException e) {
      return null;
    }

    int pos = 0;
    int startLine = 1;

    // If we've saved a previous offset and it's for a line less than the
    // one we're searching for, then start at that point.
    if (lineNumber >= lastLine) {
      pos = lastOffset;
      startLine = lastLine;
    }

    for (int n = startLine; n < lineNumber; n++) {
      int nextpos = js.indexOf('\n', pos);
      if (nextpos == -1) {
        return null;
      }
      pos = nextpos + 1;
    }

    // Remember this offset for the next search we do.
    lastOffset = pos;
    lastLine = lineNumber;

    if (js.indexOf('\n', pos) == -1) {
       // If next new line cannot be found, there are two cases
       // 1. pos already reaches the end of file, then null should be returned
       // 2. otherwise, return the contents between pos and the end of file.
         return null;
     } else {
       return js.substring(pos, js.indexOf('\n', pos));
     }
  }","public String getLine(int lineNumber) {
    String js = """";
    try {
        // NOTE(nicksantos): Right now, this is optimized for few warnings.
        // This is probably the right trade-off, but will be slow if there
        // are lots of warnings in one file.
        js = getCode();
    } catch (IOException e) {
        return null;
    }

    int pos = 0;
    int startLine = 1;

    // If we've saved a previous offset and it's for a line less than the
    // one we're searching for, then start at that point.
    if (lineNumber >= lastLine) {
        pos = lastOffset;
        startLine = lastLine;
    }

    for (int n = startLine; n < lineNumber; n++) {
        int nextpos = js.indexOf('\n', pos);
        if (nextpos == -1) {
            return null;
        }
        pos = nextpos + 1;
    }

    // Remember this offset for the next search we do.
    lastOffset = pos;
    lastLine = lineNumber;

    int endPos = js.indexOf('\n', pos);
    if (endPos == -1) {
        // Return the contents from pos to the end of the file.
        return pos < js.length() ? js.substring(pos) : null;
    } else {
        return js.substring(pos, endPos);
    }
}",0,0
82,Closure_57,"private static String extractClassNameIfGoog(Node node, Node parent,
      String functionName){
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
      Node callee = node.getFirstChild();
      if (callee != null && callee.getType() == Token.GETPROP) {
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
           if (target != null) {
             className = target.getString();
           }
         }
      }
    }
    return className;
  }","private static String extractClassNameIfGoog(Node node, Node parent,
    String functionName){
  String className = null;
  if (NodeUtil.isExprCall(parent)) {
    Node callee = node.getFirstChild();
    if (callee != null && callee.getType() == Token.GETPROP) {
      String qualifiedName = callee.getQualifiedName();
      if (functionName.equals(qualifiedName)) {
        Node target = node.getNext(); // Fix: Change callee.getNext() to node.getNext()
        if (target != null && target.getType() == Token.STRING) { // Add check for STRING type
          className = target.getString();
        }
      }
    }
  }
  return className;
}",0,0
82,Closure_57,"private static String extractClassNameIfGoog(Node node, Node parent,
      String functionName){
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
      Node callee = node.getFirstChild();
      if (callee != null && callee.getType() == Token.GETPROP) {
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
           if (target != null) {
             className = target.getString();
           }
         }
      }
    }
    return className;
  }","private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
        Node callee = node.getFirstChild();
        if (callee != null && callee.getType() == Token.GETPROP) {
            String qualifiedName = callee.getQualifiedName();
            if (functionName.equals(qualifiedName)) {
                Node target = node.getNext();  // Retrieve target directly after the node
                if (target != null && target.getType() == Token.GETPROP) {  // Adjust check to consider structure of target
                    className = target.getFirstChild().getNext().getString();  // Access deeper property structure for class name
                }
            }
        }
    }
    return className;
}",1,0
82,Closure_57,"private static String extractClassNameIfGoog(Node node, Node parent,
      String functionName){
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
      Node callee = node.getFirstChild();
      if (callee != null && callee.getType() == Token.GETPROP) {
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
           if (target != null) {
             className = target.getString();
           }
         }
      }
    }
    return className;
  }","private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
        Node callNode = node.getFirstChild();
        if (callNode != null && callNode.getType() == Token.GETPROP) {
            String qualifiedName = callNode.getQualifiedName();
            if (functionName.equals(qualifiedName)) {
                Node target = callNode.getNext();
                if (target != null && target.getType() == Token.STRING) {
                    className = callNode.getLastChild().getString(); // Fix: Fetching class name directly from last child
                }
            }
        }
    }
    return className;
}",2,0
82,Closure_57,"private static String extractClassNameIfGoog(Node node, Node parent,
      String functionName){
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
      Node callee = node.getFirstChild();
      if (callee != null && callee.getType() == Token.GETPROP) {
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
           if (target != null) {
             className = target.getString();
           }
         }
      }
    }
    return className;
  }","private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
        Node callee = node.getFirstChild();
        if (callee != null && callee.getType() == Token.GETPROP) {
            String qualifiedName = callee.getQualifiedName();
            if (functionName.equals(qualifiedName)) {
                Node target = node.getNext();  // Change to node.getNext() to target the next node from parent
                if (target != null && target.getType() == Token.NAME) {  // Ensure target has type NAME for valid class name extraction
                    className = target.getString();  // Extract string from validated NAME type node
                }
            }
        }
    }
    return className;
}",3,0
82,Closure_57,"private static String extractClassNameIfGoog(Node node, Node parent,
      String functionName){
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
      Node callee = node.getFirstChild();
      if (callee != null && callee.getType() == Token.GETPROP) {
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
           if (target != null) {
             className = target.getString();
           }
         }
      }
    }
    return className;
  }","private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
        Node callee = node.getFirstChild();
        if (callee != null && callee.getType() == Token.GETPROP) {
            String qualifiedName = callee.getQualifiedName();
            if (functionName.equals(qualifiedName)) {
                Node target = node.getNext();
                if (target != null && target.getType() == Token.STRING) {
                    // Additional logic: Check if the target is actually a part of callee's chain earlier
                    Node checkNode = callee;
                    while (checkNode != null) {
                        if (checkNode == target) {
                            className = target.getString();
                            break;
                        }
                        checkNode = checkNode.getNext();
                    }
                }
            }
        }
    }
    return className;
}",4,0
83,Closure_58,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }","private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    if (n == null) return;
  
    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        Node conditionNode = NodeUtil.getConditionExpression(n);
        if (conditionNode != null) {
          computeGenKill(conditionNode, gen, kill, conditional);
        }
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          Node conditionNodeFor = NodeUtil.getConditionExpression(n);
          if (conditionNodeFor != null) {
            computeGenKill(conditionNodeFor, gen, kill, conditional);
          }
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (rhs != null) {
            if (NodeUtil.isVar(lhs)) {
              // for(var x in y) {...}
              lhs = lhs.getLastChild();
            }
            if (lhs != null) {
              addToSetIfLocal(lhs, kill);
              addToSetIfLocal(lhs, gen);
            }
            computeGenKill(rhs, gen, kill, conditional);
          }
        }
        return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }",0,0
83,Closure_58,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }","private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    if (n == null) return;

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        Node conditionNode = NodeUtil.getConditionExpression(n);
        if (conditionNode != null) {
          computeGenKill(conditionNode, gen, kill, conditional);
        }
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          Node conditionNodeFor = NodeUtil.getConditionExpression(n);
          if (conditionNodeFor != null) {
            computeGenKill(conditionNodeFor, gen, kill, conditional);
          }
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (rhs != null) {
            if (NodeUtil.isVar(lhs)) {
              // for(var x in y) {...}
              lhs = lhs.getLastChild();
            }
            if (lhs != null) {
              addToSetIfLocal(lhs, kill);
              computeGenKill(lhs, gen, kill, conditional); // Changed logic here
            }
            computeGenKill(rhs, gen, kill, conditional);
          }
        }
        return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
          } else { // Changed logic here
            addToSetIfLocal(c, gen);
          }
          if (!conditional) {
            addToSetIfLocal(c, kill);
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        computeGenKill(n.getLastChild(), gen, kill, conditional); // Fixed short circuit logic
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          addToSetIfLocal(lhs, gen); // Changed logic here for assignments
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }",1,0
83,Closure_58,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }","private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          Node lhs = NodeUtil.isVar(n.getFirstChild()) ? n.getFirstChild().getLastChild() : n.getFirstChild();
          Node rhs = lhs.getNext();
          computeGenKill(lhs, gen, kill, false); 
          addToSetIfLocal(lhs, kill);
          computeGenKill(rhs, gen, kill, conditional);
        }
        return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
          }
          if (!conditional) {
            addToSetIfLocal(c, kill);
          } else {
            addToSetIfLocal(c, gen);
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        computeGenKill(n.getLastChild(), gen, kill, conditional);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          computeGenKill(n.getLastChild(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }",2,0
83,Closure_58,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }","private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        Node conditionNode = NodeUtil.getConditionExpression(n);
        if (conditionNode != null) {
          computeGenKill(conditionNode, gen, kill, conditional);
        }
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          Node conditionNodeFor = NodeUtil.getConditionExpression(n);
          if (conditionNodeFor != null) {
            computeGenKill(conditionNodeFor, gen, kill, conditional);
          }
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (rhs != null) {
            if (NodeUtil.isVar(lhs)) {
              // for(var x in y) {...}
              lhs = lhs.getLastChild();
            }
            if (lhs != null) {
              addToSetIfLocal(lhs, kill);
              if (!conditional) {
                addToSetIfLocal(lhs, gen);
              }
            }
            computeGenKill(rhs, gen, kill, conditional);
          }
        }
        return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          } else {
            addToSetIfLocal(c, gen);
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Properly handle short-circuit logic for && and ||
        boolean isShortCircuit = (n.getType() == Token.AND || n.getType() == Token.OR);
        computeGenKill(n.getLastChild(), gen, kill, isShortCircuit && !conditional);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // Assignments such as a += 1 read a, adding to GEN set
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }",3,0
83,Closure_58,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
      boolean conditional) {

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
            conditional);
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
              conditional);
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          Node rhs = lhs.getNext();
          if (NodeUtil.isVar(lhs)) {
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // May short circuit.
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        // Assume both sides are conditional.
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (!NodeUtil.isAssign(n)) {
            // assignments such as a += 1 reads a.
            addToSetIfLocal(lhs, gen);
          }
          computeGenKill(lhs.getNext(), gen, kill, conditional);
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
  }","private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {

    if (n == null) return;

    switch (n.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.FUNCTION:
        return;

      case Token.WHILE:
      case Token.DO:
      case Token.IF:
        Node conditionNode = NodeUtil.getConditionExpression(n);
        if (conditionNode != null) {
          computeGenKill(conditionNode, gen, kill, conditional);
        }
        return;

      case Token.FOR:
        if (!NodeUtil.isForIn(n)) {
          Node conditionNodeFor = NodeUtil.getConditionExpression(n);
          if (conditionNodeFor != null) {
            computeGenKill(conditionNodeFor, gen, kill, conditional);
          }
        } else {
          // for(x in y) {...}
          Node lhs = n.getFirstChild();
          if (NodeUtil.isVar(lhs)) {
            lhs = lhs.getLastChild();
          }
          Node rhs = lhs.getNext();
          if (rhs != null) {
            computeGenKill(rhs, gen, kill, conditional);
          }
          if (!conditional && lhs != null) {
            addToSetIfLocal(lhs, kill);
          }
        }
        return;

      case Token.VAR:
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (c.hasChildren()) {
            computeGenKill(c.getFirstChild(), gen, kill, conditional);
            if (!conditional) {
              addToSetIfLocal(c, kill);
            }
          } else {
            addToSetIfLocal(c, gen);
          }
        }
        return;

      case Token.AND:
      case Token.OR:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        computeGenKill(n.getLastChild(), gen, kill, conditional);
        return;

      case Token.HOOK:
        computeGenKill(n.getFirstChild(), gen, kill, conditional);
        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
        computeGenKill(n.getLastChild(), gen, kill, true);
        return;

      case Token.NAME:
        if (isArgumentsName(n)) {
          markAllParametersEscaped();
        } else {
          addToSetIfLocal(n, gen);
        }
        return;

      default:
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
          Node lhs = n.getFirstChild();
          if (!conditional) {
            addToSetIfLocal(lhs, kill);
          }
          if (NodeUtil.isAssign(n)) {
            computeGenKill(lhs.getNext(), gen, kill, conditional);
          } else {
            addToSetIfLocal(lhs, gen);
          }
        } else {
          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            computeGenKill(c, gen, kill, conditional);
          }
        }
        return;
    }
}",4,0
84,Closure_59,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
           CheckLevel.OFF);
     }
 
     if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }","public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (!options.checkTypes) {
        // If DiagnosticGroups did not override the plain checkTypes
        // option, and checkTypes is enabled, then turn off the
        // parser type warnings.
        options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
    }

    // Check the level and warn only when specified
    if (options.checkGlobalThisLevel != CheckLevel.OFF) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, CheckLevel.OFF);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));
    WarningsGuard optionsGuard = options.getWarningsGuard();
    if (optionsGuard != null) {
        guards.add(optionsGuard);
    }

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
}",0,0
84,Closure_59,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
           CheckLevel.OFF);
     }
 
     if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }","public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(
                new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer =
                new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (!options.checkTypes) {
        options.setWarningLevel(
            DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));
    WarningsGuard optionsGuard = options.getWarningsGuard();
    if (optionsGuard != null) {
        guards.add(optionsGuard);
    }

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // Ensure checkSymbols logic is validated separately
    if (options.checkSymbols) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
            DiagnosticGroups.CHECK_VARIABLES, CheckLevel.WARNING)); // Changed to warning level
    } else if (!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
            DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
}",1,0
84,Closure_59,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
           CheckLevel.OFF);
     }
 
     if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }","public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (!options.checkTypes) {
        // If DiagnosticGroups did not override the plain checkTypes
        // option, and checkTypes is enabled, then turn off the
        // parser type warnings.
        options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));

    // Only add the options guard if it's not null
    WarningsGuard optionsGuard = options.getWarningsGuard();
    if (optionsGuard != null) {
        guards.add(optionsGuard);
    }

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // Update logic here to ensure guards respect options state
    if (!options.checkSymbols || !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
}",2,0
84,Closure_59,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
           CheckLevel.OFF);
     }
 
     if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }","public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }

    boolean checkTypesOriginal = options.checkTypes;

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    }

    // Restore original checkTypes if nothing overrode it
    if (checkTypesOriginal && options.checkTypes == false) {
        options.checkTypes = true;
    } else if (!options.checkTypes) {
        options.setWarningLevel(
            DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));
    
    WarningsGuard optionsGuard = options.getWarningsGuard();
    if (optionsGuard != null) {
        guards.add(optionsGuard);
    }

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
}",3,0
84,Closure_59,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
           CheckLevel.OFF);
     }
 
     if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }","public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (!options.checkTypes) {
        options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
    }

    if (options.checkGlobalThisLevel != CheckLevel.OFF) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, CheckLevel.OFF);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));

    WarningsGuard optionsGuard = options.getWarningsGuard();
    if (optionsGuard != null) {
        guards.add(optionsGuard);
    }

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // Ensure proper handling of checkSymbols and variable check
    if (!options.checkSymbols) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    } else if (!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.WARNING));
    }

    this.warningsGuard = composedGuards;
}",4,0
85,Closure_61,"static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }","static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
       if (nameNode.getFirstChild().getType() == Token.STRING
           && ""Math"".equals(nameNode.getFirstChild().getString())) {
         return true;
       }

       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
           return false;
         } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
           Node param = nameNode.getNext();
           if (param != null &&
               (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP)) {
             return false;
           }
         }
       }
    }

    return true;
  }",0,0
85,Closure_61,"static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }","static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
      }

      if (compiler != null) {
        if (!compiler.hasRegExpGlobalReferences() && nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING || param.getType() == Token.REGEXP)) {
            return false;
          }
        }
      }
    }

    return true;
  }",1,0
85,Closure_61,"static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }","static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
      }

      // Functions in certain namespaces have no side effects.
      if ((nameNode.getFirstChild().getType() == Token.NAME || nameNode.getFirstChild().getType() == Token.STRING)
          && NON_SIDEEFFECT_NAMESPACE.contains(nameNode.getFirstChild().getString())) {
        return false;
      }

      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
        if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING || param.getType() == Token.REGEXP))
            return false;
        }
      }
    }

    return true;
  }",2,0
85,Closure_61,"static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }","static boolean functionCallHasSideEffects(
    Node callNode, @Nullable AbstractCompiler compiler) {
  if (callNode.getType() != Token.CALL) {
    throw new IllegalStateException(""Expected CALL node, got "" + Token.name(callNode.getType()));
  }

  if (callNode.isNoSideEffectsCall()) {
    return false;
  }

  Node nameNode = callNode.getFirstChild();
  if (nameNode.getType() == Token.NAME) {
    String name = nameNode.getString();
    if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
      return false;
    }
  } else if (nameNode.getType() == Token.GETPROP) {
    Node objectNode = nameNode.getFirstChild();
    Node propertyNode = nameNode.getLastChild();
    
    if (compiler != null && compiler.hasRegExpGlobalReferences()) {
      // Additional check when compiler has RegExp global references
      return true;
    }

    if (OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(propertyNode.getString()) ||
        (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(objectNode))) {
      return false;
    }

    // Functions in certain namespaces have no side effects, additionally consider `Math`
    if (objectNode.getType() == Token.NAME && ""Math"".equals(objectNode.getString())) {
      return false;
    }

    if (objectNode.getType() == Token.REGEXP && REGEXP_METHODS.contains(propertyNode.getString())) {
      return false;
    } else if (objectNode.getType() == Token.STRING && STRING_REGEXP_METHODS.contains(propertyNode.getString())) {
      Node param = propertyNode.getNext();
      if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP)) {
        return false;
      }
    }
  }

  return true;
}",3,0
85,Closure_61,"static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }","static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          ""Expected CALL node, got "" + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      // Change: Adding additional checks for methods with side effects based on method signature
      Node objectNode = nameNode.getFirstChild();
      Node propertyNode = nameNode.getLastChild();

      if (OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(propertyNode.getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(objectNode)) {
        return false;
      }

      if (compiler != null) {
        // Consider side effects from potentially global objects
        if (compiler.hasRegExpGlobalReferences()) {
          return true;
        }
        
        if (objectNode.getType() == Token.REGEXP && REGEXP_METHODS.contains(propertyNode.getString())) {
          return false;
        } else if (objectNode.getType() == Token.STRING && STRING_REGEXP_METHODS.contains(propertyNode.getString())) {
          Node param = propertyNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING || param.getType() == Token.REGEXP)) {
            return false;
          }
        }
      }
    }

    return true;
  }",4,0
86,Closure_62,"private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null :
        excerpt.get(
            source, error.sourceName, error.lineNumber, excerptFormatter);

    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
      b.append(error.sourceName);
      if (error.lineNumber > 0) {
        b.append(':');
        b.append(error.lineNumber);
      }
      b.append("": "");
    }

    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");

    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
      b.append(sourceExcerpt);
      b.append('\n');
      int charno = error.getCharno();

      // padding equal to the excerpt and arrow at the end
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
           && 0 <= charno && charno < sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
            b.append(c);
          } else {
            b.append(' ');
          }
        }
        b.append(""^\n"");
      }
    }
    return b.toString();
  }","private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null :
        excerpt.get(
            source, error.sourceName, error.lineNumber, excerptFormatter);

    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
        b.append(error.sourceName);
        if (error.lineNumber > 0) {
            b.append(':');
            b.append(error.lineNumber);
        }
        b.append("": "");
    }

    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");
    b.append(error.description);
    b.append('\n');

    if (sourceExcerpt != null) {
        b.append(sourceExcerpt);
        b.append('\n');
        int charno = error.getCharno();

        // padding equal to the excerpt and arrow at the end
        // charno == sourceExcerpt.length() means something is missing
        // at the end of the line
        if (excerpt == LINE && 0 <= charno && charno <= sourceExcerpt.length()) {
            for (int i = 0; i < charno; i++) {
                char c = sourceExcerpt.charAt(i);
                if (Character.isWhitespace(c)) {
                    b.append(c);
                } else {
                    b.append(' ');
                }
            }
            b.append(""^\n"");
        }
    }
    
    return b.toString();
}",0,0
87,Closure_65,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c < 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0': sb.append(""\\0""); break;
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':  // Break --> into --\> or ]]> into ]]\>
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':  // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";

                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length()) ||
                    s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // Check if the character can be represented in the given character set
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // No charsetEncoder provided - pass straight latin characters through,
                    // and escape the rest. Doing the explicit character check is measurably
                    // faster than using the CharsetEncoder.
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,0
87,Closure_65,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c < 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0': sb.append(""\\00""); break;
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length()) ||
                    s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",1,0
87,Closure_65,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c < 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0': sb.append(""\\00""); break;
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length()) ||
                    s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",2,0
87,Closure_65,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c < 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0':
                // Use an alternative escape sequence \\u0000 for null character to prevent issues
                sb.append(""\\u0000"");
                break;
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length()) ||
                    s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",3,0
87,Closure_65,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c < 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\0': 
                // Properly escape null character using Unicode representation
                sb.append(""\\u0000""); 
                break;
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length()) ||
                    s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",4,0
88,Closure_66,"public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }","public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent != null && parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
        // Object literal keys are handled with OBJECTLIT
        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
          ensureTyped(t, n, STRING_TYPE);
          // Object literal keys are not typeable
        }
        break;

      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent != null && parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent != null && parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }",0,0
88,Closure_66,"public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }",Match failed,1,0
88,Closure_66,"public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }","public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    boolean typeable = true;

    switch (n.getType()) {
        case Token.STRING:
        // Add a special case to handle type as an object literal key
        if (!NodeUtil.isObjectLitKey(n, parent)) {
            ensureTyped(t, n, STRING_TYPE);
            typeable = false; // Mark as not typeable when handled as object literal key
        }
        break;

        case Token.GETPROP:
        // Modify method call when GETPROP is not assignment
        visitGetProp(t, n, parent);
        typeable = parent == null || parent.getType() != Token.ASSIGN || parent.getFirstChild() != n;
        break;

        case Token.SHEQ:
        case Token.SHNE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        // Add type checks for strict equality
        if (!leftType.canTestForShallowEqualityWith(rightType)) {
            report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());
            typeable = false; // Mark SHEQ/SHNE as not typeable if test result is deterministic no result
        }

        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

        case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        // Add additional expected type check for INSTANCEOF operation
        validator.expectActualObject(t, right, rightType, ""instanceof requires an object and not undefined"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

        // Add more handling if parent is expression node for CALL
        case Token.CALL:
        visitCall(t, n);
        typeable = parent != null && !NodeUtil.isExpressionNode(parent);
        break;

        // Handle VAR differently: merging evaluations of rvalue
        case Token.VAR:
        visitVar(t, n);
        ensureTyped(t, n, n.getFirstChild() != null ? n.getFirstChild().getJSType() : getNativeType(UNKNOWN_TYPE));
        typeable = false; // Mark VAR as not typeable after visit
        break;

        // Handle and ensure VOID type
        case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

        // Handling for block structures and typed expression directly
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT:
        typeable = false; // Handle as not typeable
        break;

        default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    typeable = typeable && !inExterns; // Ensure not in externs

    if (typeable) {
        doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false); // Check no type section
}",2,0
88,Closure_66,"public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }",Match failed,3,0
88,Closure_66,"public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;

    switch (n.getType()) {
      case Token.NAME:
        typeable = visitName(t, n, parent);
        break;

      case Token.LP:
        // If this is under a FUNCTION node, it is a parameter list and can be
        // ignored here.
        if (parent.getType() != Token.FUNCTION) {
          ensureTyped(t, n, getJSType(n.getFirstChild()));
        } else {
          typeable = false;
        }
        break;

      case Token.COMMA:
        ensureTyped(t, n, getJSType(n.getLastChild()));
        break;

      case Token.TRUE:
      case Token.FALSE:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.THIS:
        ensureTyped(t, n, t.getScope().getTypeOfThis());
        break;

      case Token.REF_SPECIAL:
        ensureTyped(t, n);
        break;

      case Token.GET_REF:
        ensureTyped(t, n, getJSType(n.getFirstChild()));
        break;

      case Token.NULL:
        ensureTyped(t, n, NULL_TYPE);
        break;

      case Token.NUMBER:
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.STRING:
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
      case Token.GET:
      case Token.SET:
        // Object literal keys are handled with OBJECTLIT
        break;

      case Token.ARRAYLIT:
        ensureTyped(t, n, ARRAY_TYPE);
        break;

      case Token.REGEXP:
        ensureTyped(t, n, REGEXP_TYPE);
        break;

      case Token.GETPROP:
        visitGetProp(t, n, parent);
        typeable = !(parent.getType() == Token.ASSIGN &&
                     parent.getFirstChild() == n);
        break;

      case Token.GETELEM:
        visitGetElem(t, n);
        // The type of GETELEM is always unknown, so no point counting that.
        // If that unknown leaks elsewhere (say by an assignment to another
        // variable), then it will be counted.
        typeable = false;
        break;

      case Token.VAR:
        visitVar(t, n);
        typeable = false;
        break;

      case Token.NEW:
        visitNew(t, n);
        typeable = true;
        break;

      case Token.CALL:
        visitCall(t, n);
        typeable = !NodeUtil.isExpressionNode(parent);
        break;

      case Token.RETURN:
        visitReturn(t, n);
        typeable = false;
        break;

      case Token.DEC:
      case Token.INC:
        left = n.getFirstChild();
        validator.expectNumber(
            t, left, getJSType(left), ""increment/decrement"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.NOT:
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.VOID:
        ensureTyped(t, n, VOID_TYPE);
        break;

      case Token.TYPEOF:
        ensureTyped(t, n, STRING_TYPE);
        break;

      case Token.BITNOT:
        childType = getJSType(n.getFirstChild());
        if (!childType.matchesInt32Context()) {
          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
              childType.toString());
        }
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.POS:
      case Token.NEG:
        left = n.getFirstChild();
        validator.expectNumber(t, left, getJSType(left), ""sign operator"");
        ensureTyped(t, n, NUMBER_TYPE);
        break;

      case Token.EQ:
      case Token.NE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        TernaryValue result =
            leftTypeRestricted.testForEquality(rightTypeRestricted);
        if (result != TernaryValue.UNKNOWN) {
          if (n.getType() == Token.NE) {
            result = result.not();
          }
          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
              rightType.toString(), result.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.SHEQ:
      case Token.SHNE: {
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());

        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
        if (!leftTypeRestricted.canTestForShallowEqualityWith(
                rightTypeRestricted)) {
          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
              rightType.toString());
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;
      }

      case Token.LT:
      case Token.LE:
      case Token.GT:
      case Token.GE:
        leftType = getJSType(n.getFirstChild());
        rightType = getJSType(n.getLastChild());
        if (rightType.isNumber()) {
          validator.expectNumber(
              t, n, leftType, ""left side of numeric comparison"");
        } else if (leftType.isNumber()) {
          validator.expectNumber(
              t, n, rightType, ""right side of numeric comparison"");
        } else if (leftType.matchesNumberContext() &&
                   rightType.matchesNumberContext()) {
          // OK.
        } else {
          // Whether the comparison is numeric will be determined at runtime
          // each time the expression is evaluated. Regardless, both operands
          // should match a string context.
          String message = ""left side of comparison"";
          validator.expectString(t, n, leftType, message);
          validator.expectNotNullOrUndefined(
              t, n, leftType, message, getNativeType(STRING_TYPE));
          message = ""right side of comparison"";
          validator.expectString(t, n, rightType, message);
          validator.expectNotNullOrUndefined(
              t, n, rightType, message, getNativeType(STRING_TYPE));
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.IN:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right);
        validator.expectObject(t, n, rightType, ""'in' requires an object"");
        validator.expectString(t, left, leftType, ""left side of 'in'"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.INSTANCEOF:
        left = n.getFirstChild();
        right = n.getLastChild();
        leftType = getJSType(left);
        rightType = getJSType(right).restrictByNotNullOrUndefined();

        validator.expectAnyObject(
            t, left, leftType, ""deterministic instanceof yields false"");
        validator.expectActualObject(
            t, right, rightType, ""instanceof requires an object"");
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.ASSIGN:
        visitAssign(t, n);
        typeable = false;
        break;

      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_MUL:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.DIV:
      case Token.MOD:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.SUB:
      case Token.ADD:
      case Token.MUL:
        visitBinaryOperator(n.getType(), t, n);
        break;

      case Token.DELPROP:
        if (!isReference(n.getFirstChild())) {
          report(t, n, BAD_DELETE);
        }
        ensureTyped(t, n, BOOLEAN_TYPE);
        break;

      case Token.CASE:
        JSType switchType = getJSType(parent.getFirstChild());
        JSType caseType = getJSType(n.getFirstChild());
        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
        typeable = false;
        break;

      case Token.WITH: {
        Node child = n.getFirstChild();
        childType = getJSType(child);
        validator.expectObject(
            t, child, childType, ""with requires an object"");
        typeable = false;
        break;
      }

      case Token.FUNCTION:
        visitFunction(t, n);
        break;

      // These nodes have no interesting type behavior.
      case Token.LABEL:
      case Token.LABEL_NAME:
      case Token.SWITCH:
      case Token.BREAK:
      case Token.CATCH:
      case Token.TRY:
      case Token.SCRIPT:
      case Token.EXPR_RESULT:
      case Token.BLOCK:
      case Token.EMPTY:
      case Token.DEFAULT:
      case Token.CONTINUE:
      case Token.DEBUGGER:
      case Token.THROW:
        typeable = false;
        break;

      // These nodes require data flow analysis.
      case Token.DO:
      case Token.FOR:
      case Token.IF:
      case Token.WHILE:
        typeable = false;
        break;

      // These nodes are typed during the type inference.
      case Token.AND:
      case Token.HOOK:
      case Token.OBJECTLIT:
      case Token.OR:
        if (n.getJSType() != null) { // If we didn't run type inference.
          ensureTyped(t, n);
        } else {
          // If this is an enum, then give that type to the objectlit as well.
          if ((n.getType() == Token.OBJECTLIT)
              && (parent.getJSType() instanceof EnumType)) {
            ensureTyped(t, n, parent.getJSType());
          } else {
            ensureTyped(t, n);
          }
        }
        if (n.getType() == Token.OBJECTLIT) {
          for (Node key : n.children()) {
            visitObjLitKey(t, key, n);
          }
        }
        break;

      default:
        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
        ensureTyped(t, n);
        break;
    }

    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;

    if (typeable) {
      doPercentTypedAccounting(t, n);
    }

    checkNoTypeCheckSection(n, false);
  }",Match failed,4,0
89,Closure_67,"private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
           ) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;

        if (isChainedProperty) {
          Node child = n.getFirstChild().getFirstChild().getNext();

          if (child.getType() == Token.STRING &&
              child.getString().equals(""prototype"")) {
            return true;
          }
        }
      }

      return false;
    }","private boolean isPrototypePropertyAssign(Node assign) {
    Node n = assign.getFirstChild();
    
    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) {
        Node obj = n.getFirstChild();
        
        if (obj != null && obj.getType() == Token.GETPROP) {
            Node prop = obj.getNext();
            
            if (prop != null && prop.getType() == Token.STRING && ""prototype"".equals(prop.getString())) {
                return true;
            }
        }
    }
    
    return false;
}",0,0
89,Closure_67,"private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
           ) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;

        if (isChainedProperty) {
          Node child = n.getFirstChild().getFirstChild().getNext();

          if (child.getType() == Token.STRING &&
              child.getString().equals(""prototype"")) {
            return true;
          }
        }
      }

      return false;
    }","private boolean isPrototypePropertyAssign(Node assign) {
    Node n = assign.getFirstChild();
    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) {
        Node obj = n.getFirstChild();
        
        while (obj != null && obj.getType() == Token.GETPROP) {
            Node prop = obj.getNext();
            if (prop != null && prop.getType() == Token.STRING && ""prototype"".equals(prop.getString())) {
                return true;
            }
            obj = obj.getFirstChild();
        }
    }
    
    return false;
}",1,0
89,Closure_67,"private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
           ) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;

        if (isChainedProperty) {
          Node child = n.getFirstChild().getFirstChild().getNext();

          if (child.getType() == Token.STRING &&
              child.getString().equals(""prototype"")) {
            return true;
          }
        }
      }

      return false;
    }","private boolean isPrototypePropertyAssign(Node assign) {
    Node n = assign.getFirstChild();
    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
        && n.getType() == Token.GETPROP) {
        
        // Traverse the property chain to look for ""prototype""
        Node current = n;
        while (current != null) {
            Node next = current.getNext();
            if (next != null && next.getType() == Token.STRING && ""prototype"".equals(next.getString())) {
                return true;
            }
            current = next;
        }
    }
    return false;
}",2,0
89,Closure_67,"private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
           ) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;

        if (isChainedProperty) {
          Node child = n.getFirstChild().getFirstChild().getNext();

          if (child.getType() == Token.STRING &&
              child.getString().equals(""prototype"")) {
            return true;
          }
        }
      }

      return false;
    }","private boolean isPrototypePropertyAssign(Node assign) {
    Node n = assign.getFirstChild();
    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) {
        // Instead of checking the second child, iterate over children to find ""prototype""
        Node current = n.getFirstChild();
        while (current != null) {
            if (current.getType() == Token.STRING && current.getString().equals(""prototype"")) {
                return true;
            }
            current = current.getNext(); // Traverse sibling nodes
        }
    }
    return false;
}",3,0
89,Closure_67,"private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
           ) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;

        if (isChainedProperty) {
          Node child = n.getFirstChild().getFirstChild().getNext();

          if (child.getType() == Token.STRING &&
              child.getString().equals(""prototype"")) {
            return true;
          }
        }
      }

      return false;
    }","private boolean isPrototypePropertyAssign(Node assign) {
    Node n = assign.getFirstChild();
    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) {
        Node obj = n.getFirstChild();
        // Check for chain of properties ""obj.method().prototype""
        if (obj != null && NodeUtil.isGetPropChain(obj)) {
            Node prototypeNode = obj.getNext();
            if (prototypeNode != null && prototypeNode.getType() == Token.STRING && ""prototype"".equals(prototypeNode.getString())) {
                return true;
            }
        }
    }
    return false;
}",4,0
90,Closure_69,"private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
      report(t, n, NOT_CALLABLE, childType.toString());
      ensureTyped(t, n);
      return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
      FunctionType functionType = (FunctionType) childType;

      boolean isExtern = false;
      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
      if(functionJSDocInfo != null) {
        String sourceName = functionJSDocInfo.getSourceName();
        CompilerInput functionSource = compiler.getInput(sourceName);
        isExtern = functionSource.isExtern();
      }

      // Non-native constructors should not be called directly
      // unless they specify a return type and are defined
      // in an extern.
      if (functionType.isConstructor() &&
          !functionType.isNativeObjectType() &&
          (functionType.getReturnType().isUnknownType() ||
           functionType.getReturnType().isVoidType() ||
           !isExtern)) {
        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
      }
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
    } else {
      ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
  }","private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;

        boolean isExtern = false;
        JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
        if (functionJSDocInfo != null) {
            String sourceName = functionJSDocInfo.getSourceName();
            CompilerInput functionSource = compiler.getInput(sourceName);
            isExtern = functionSource != null && functionSource.isExtern();
        }

        // Non-native constructors should not be called directly
        // unless they specify a return type and are defined
        // in an extern.
        if (functionType.isConstructor() &&
            !functionType.isNativeObjectType() &&
            (functionType.getReturnType().isUnknownType() ||
             functionType.getReturnType().isVoidType() ||
             !isExtern)) {
            report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
        }

        // Functions with explicit 'this' types must be called in a GETPROP
        // or GETELEM.

        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }
}",0,0
90,Closure_69,"private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
      report(t, n, NOT_CALLABLE, childType.toString());
      ensureTyped(t, n);
      return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
      FunctionType functionType = (FunctionType) childType;

      boolean isExtern = false;
      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
      if(functionJSDocInfo != null) {
        String sourceName = functionJSDocInfo.getSourceName();
        CompilerInput functionSource = compiler.getInput(sourceName);
        isExtern = functionSource.isExtern();
      }

      // Non-native constructors should not be called directly
      // unless they specify a return type and are defined
      // in an extern.
      if (functionType.isConstructor() &&
          !functionType.isNativeObjectType() &&
          (functionType.getReturnType().isUnknownType() ||
           functionType.getReturnType().isVoidType() ||
           !isExtern)) {
        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
      }
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
    } else {
      ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
  }","private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }

    if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;

        boolean isExtern = false;
        JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
        if (functionJSDocInfo != null) {
            String sourceName = functionJSDocInfo.getSourceName();
            CompilerInput functionSource = compiler.getInput(sourceName);
            if (functionSource != null) {
                isExtern = functionSource.isExtern();
            }
        }

        if (n.isPropertyAccess()) {
            ObjectType typeOfThis = functionType.getTypeOfThis();
            if (typeOfThis != null && !typeOfThis.isNativeObjectType()) {
                report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
            }
        }

        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
}",1,0
90,Closure_69,"private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
      report(t, n, NOT_CALLABLE, childType.toString());
      ensureTyped(t, n);
      return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
      FunctionType functionType = (FunctionType) childType;

      boolean isExtern = false;
      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
      if(functionJSDocInfo != null) {
        String sourceName = functionJSDocInfo.getSourceName();
        CompilerInput functionSource = compiler.getInput(sourceName);
        isExtern = functionSource.isExtern();
      }

      // Non-native constructors should not be called directly
      // unless they specify a return type and are defined
      // in an extern.
      if (functionType.isConstructor() &&
          !functionType.isNativeObjectType() &&
          (functionType.getReturnType().isUnknownType() ||
           functionType.getReturnType().isVoidType() ||
           !isExtern)) {
        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
      }
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
    } else {
      ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
  }","private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }

    if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;

        ObjectType typeOfThis = functionType.getTypeOfThis();
        if (typeOfThis != null && !(child.isGetProp() || child.isGetElem())) {
            report(t, n, NOT_CALLABLE, ""Function must be called in a property access or element access"");
            return;
        }

        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }
}",2,0
90,Closure_69,"private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
      report(t, n, NOT_CALLABLE, childType.toString());
      ensureTyped(t, n);
      return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
      FunctionType functionType = (FunctionType) childType;

      boolean isExtern = false;
      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
      if(functionJSDocInfo != null) {
        String sourceName = functionJSDocInfo.getSourceName();
        CompilerInput functionSource = compiler.getInput(sourceName);
        isExtern = functionSource.isExtern();
      }

      // Non-native constructors should not be called directly
      // unless they specify a return type and are defined
      // in an extern.
      if (functionType.isConstructor() &&
          !functionType.isNativeObjectType() &&
          (functionType.getReturnType().isUnknownType() ||
           functionType.getReturnType().isVoidType() ||
           !isExtern)) {
        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
      }
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
    } else {
      ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
  }","private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    boolean isRequireWarning = !childType.canBeCalled() || 
        (childType instanceof FunctionType &&
        !((FunctionType)childType).isNativeObjectType() &&
        ((FunctionType) childType).getTypeOfThis().isRecordType());

    if (isRequireWarning) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }

    if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;
        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }
}",3,0
90,Closure_69,"private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    if (!childType.canBeCalled()) {
      report(t, n, NOT_CALLABLE, childType.toString());
      ensureTyped(t, n);
      return;
    }

    // A couple of types can be called as if they were functions.
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
      FunctionType functionType = (FunctionType) childType;

      boolean isExtern = false;
      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
      if(functionJSDocInfo != null) {
        String sourceName = functionJSDocInfo.getSourceName();
        CompilerInput functionSource = compiler.getInput(sourceName);
        isExtern = functionSource.isExtern();
      }

      // Non-native constructors should not be called directly
      // unless they specify a return type and are defined
      // in an extern.
      if (functionType.isConstructor() &&
          !functionType.isNativeObjectType() &&
          (functionType.getReturnType().isUnknownType() ||
           functionType.getReturnType().isVoidType() ||
           !isExtern)) {
        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
      }
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
    } else {
      ensureTyped(t, n);
    }

    // TODO: Add something to check for calls of RegExp objects, which is not
    // supported by IE.  Either say something about the return type or warn
    // about the non-portability of the call or both.
  }","private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();

    // Report if type cannot be called
    if (!childType.canBeCalled()) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }

    if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;

        // Ensure the 'this' type is correct for non-native objects
        ObjectType typeOfThis = functionType.getTypeOfThis();
        if (typeOfThis != null && !typeOfThis.isNativeObjectType() && !(child.isGetProp() || child.isGetElem())) {
            report(t, n, CONSTRUCTOR_NOT_CALLABLE, ""Function must be accessed via a property or element access"");
        }

        // Validate parameters
        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }
}",4,0
91,Closure_7,"@Override
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }","@Override
public JSType caseObjectType(ObjectType type) {
    if (value.equals(""function"")) {
        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        return resultEqualsValue || type.isSubtype(ctorType) ? ctorType : null;
        // Filter result when expectation matches ""function"", allowing subtypes
    }
    return matchesExpectation(""object"") ? type : null;
}",0,0
91,Closure_7,"@Override
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }",Match failed,1,0
91,Closure_7,"@Override
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }","@Override
public JSType caseObjectType(ObjectType type) {
    if (value.equals(""function"")) {
        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        return (ctorType.isEquivalentTo(type) || ctorType.isSubtype(type)) ? ctorType : null;
        // Filter by equivalence or subtype instead of strict type match
    }
    return matchesExpectation(""object"") ? type : null;
}",2,0
91,Closure_7,"@Override
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }","@Override
public JSType caseObjectType(ObjectType type) {
    if (value.equals(""function"")) {
        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        // Check if the type is a subtype of ctorType and matches expectation
        return type.isSubtype(ctorType) && matchesExpectation(""function"") ? ctorType : null;
    }
    return matchesExpectation(""object"") ? type : null;
}",3,0
91,Closure_7,"@Override
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }","@Override
public JSType caseObjectType(ObjectType type) {
    if (value.equals(""function"")) {
        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        // Consider an intersection condition for filtering both subtype and equality with ctorType
        return (ctorType.isSubtype(type) || type.isSubtype(ctorType)) ? ctorType : null;
    }
    return matchesExpectation(""object"") ? type : null;
}",4,0
92,Closure_70,"private void declareArguments(Node functionNode) {
      Node astParameters = functionNode.getFirstChild().getNext();
      Node body = astParameters.getNext();
      FunctionType functionType = (FunctionType) functionNode.getJSType();
      if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
          Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                   jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
            }
          }
        }
      }
    } // end declareArguments","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
      Node jsDocParameters = functionType.getParametersNode();
      if (jsDocParameters != null) {
        Node jsDocParameter = jsDocParameters.getFirstChild();
        for (Node astParameter : astParameters.children()) {
          defineSlot(astParameter, functionNode,
              (jsDocParameter != null ? jsDocParameter.getJSType() : null), true);
          if (jsDocParameter != null) {
            jsDocParameter = jsDocParameter.getNext();
          }
        }
      }
    }
} // end declareArguments",0,0
92,Closure_70,"private void declareArguments(Node functionNode) {
      Node astParameters = functionNode.getFirstChild().getNext();
      Node body = astParameters.getNext();
      FunctionType functionType = (FunctionType) functionNode.getJSType();
      if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
          Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                   jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
            }
          }
        }
      }
    } // end declareArguments","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Node jsDocParameter = jsDocParameters.getFirstChild();
            for (Node astParameter : astParameters.children()) {
                try {
                    defineSlot(astParameter, functionNode,
                        (jsDocParameter != null ? jsDocParameter.getJSType() : null), true);
                    if (jsDocParameter != null) {
                        jsDocParameter = jsDocParameter.getNext();
                    }
                } catch (Exception e) {
                    defineSlot(astParameter, functionNode, null, true);
                }
            }
        } else {
            for (Node astParameter : astParameters.children()) {
                defineSlot(astParameter, functionNode, null, true);
            }
        }
    }
}",1,0
92,Closure_70,"private void declareArguments(Node functionNode) {
      Node astParameters = functionNode.getFirstChild().getNext();
      Node body = astParameters.getNext();
      FunctionType functionType = (FunctionType) functionNode.getJSType();
      if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
          Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                   jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
            }
          }
        }
      }
    } // end declareArguments","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Node jsDocParameter = jsDocParameters.getFirstChild();
            for (Node astParameter : astParameters.children()) {
                defineSlot(astParameter, functionNode,
                    (jsDocParameter != null && jsDocParameter.getJSType() != null) ? jsDocParameter.getJSType() : null, true);
                if (jsDocParameter != null) {
                    jsDocParameter = jsDocParameter.getNext();
                }
            }
        } else {
            for (Node astParameter : astParameters.children()) {
                defineSlot(astParameter, functionNode, null, true);
            }
        }
    } else {
        for (Node astParameter : astParameters.children()) {
            defineSlot(astParameter, functionNode, null, true);
        }
    }
}",2,0
92,Closure_70,"private void declareArguments(Node functionNode) {
      Node astParameters = functionNode.getFirstChild().getNext();
      Node body = astParameters.getNext();
      FunctionType functionType = (FunctionType) functionNode.getJSType();
      if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
          Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                   jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
            }
          }
        }
      }
    } // end declareArguments","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Node jsDocParameter = jsDocParameters.getFirstChild();
            Iterator<Node> astIterator = astParameters.children().iterator();
            while (astIterator.hasNext()) {
                Node astParameter = astIterator.next();
                if (jsDocParameter != null) {
                    defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);
                    jsDocParameter = jsDocParameter.getNext();
                } else {
                    defineSlot(astParameter, functionNode, null, true);
                }
            }
        } else {
            for (Node astParameter : astParameters.children()) {
                defineSlot(astParameter, functionNode, null, true);
            }
        }
    } else {
        for (Node astParameter : astParameters.children()) {
            defineSlot(astParameter, functionNode, null, true);
        }
    }
}",3,0
92,Closure_70,"private void declareArguments(Node functionNode) {
      Node astParameters = functionNode.getFirstChild().getNext();
      Node body = astParameters.getNext();
      FunctionType functionType = (FunctionType) functionNode.getJSType();
      if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
          Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                   jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
            }
          }
        }
      }
    } // end declareArguments","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Node jsDocParameter = jsDocParameters.getFirstChild();
            for (Node astParameter : astParameters.children()) {
                if (jsDocParameter != null && jsDocParameter.getJSType() != null) {
                    defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);
                    jsDocParameter = jsDocParameter.getNext();
                } else {
                    defineSlot(astParameter, functionNode, null, true);
                }
            }
        } else {
            for (Node astParameter : astParameters.children()) {
                defineSlot(astParameter, functionNode, null, true);
            }
        }
    } else {
        for (Node astParameter : astParameters.children()) {
            defineSlot(astParameter, functionNode, null, true);
        }
    }
}",4,0
93,Closure_71,"private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
       boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
      // Find the lowest property defined on a class with visibility
      // information.
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      for (; objectType != null;
           objectType = objectType.getImplicitPrototype()) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
      }

      if (objectType == null) {
        // We couldn't find a visibility modifier; assume it's public.
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);
      if (isOverride) {
        // Check an ASSIGN statement that's trying to override a property
        // on a superclass.
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check that (a) the property *can* be overridden, and
        // (b) that the visibility of the override is the same as the
        // visibility of the original property.
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          // private access is always allowed in the same file.
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          // private access is not allowed outside the file from a different
          // enclosing class.
          compiler.report(
              t.makeError(getprop,
                  BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          // There are 3 types of legal accesses of a protected property:
          // 1) Accesses in the same file
          // 2) Overriding the property in a subclass
          // 3) Accessing the property from inside a subclass
          // The first two have already been checked for.
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
  }","private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

    if (objectType != null) {
      // Determine if this is a normal property access or an attempt to override
      boolean isOverride = t.inGlobalScope() &&
          parent.getType() == Token.ASSIGN &&
          parent.getFirstChild() == getprop;

      // Get the lowest property defined on a class with visibility information
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      while (objectType != null) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
        objectType = objectType.getImplicitPrototype();
      }

      // If no visibility modifier is found, assume it's public
      if (docInfo == null) {
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);

      if (isOverride) {
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Verify visibility rules for overrides
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          compiler.report(
              t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
}",0,0
93,Closure_71,"private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
       boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
      // Find the lowest property defined on a class with visibility
      // information.
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      for (; objectType != null;
           objectType = objectType.getImplicitPrototype()) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
      }

      if (objectType == null) {
        // We couldn't find a visibility modifier; assume it's public.
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);
      if (isOverride) {
        // Check an ASSIGN statement that's trying to override a property
        // on a superclass.
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check that (a) the property *can* be overridden, and
        // (b) that the visibility of the override is the same as the
        // visibility of the original property.
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          // private access is always allowed in the same file.
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          // private access is not allowed outside the file from a different
          // enclosing class.
          compiler.report(
              t.makeError(getprop,
                  BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          // There are 3 types of legal accesses of a protected property:
          // 1) Accesses in the same file
          // 2) Overriding the property in a subclass
          // 3) Accessing the property from inside a subclass
          // The first two have already been checked for.
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
  }","private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

    if (objectType != null) {
        boolean isOverride = t.inGlobalScope() &&
            parent.getType() == Token.ASSIGN &&
            parent.getFirstChild() == getprop;

        if (isOverride) {
            objectType = objectType.getImplicitPrototype();
        }
        JSDocInfo docInfo = null;
        for (; objectType != null;
             objectType = objectType.getImplicitPrototype()) {
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null &&
                docInfo.getVisibility() != Visibility.INHERITED) {
                break;
            }
        } 

        if (docInfo == null || docInfo.getVisibility() == Visibility.PUBLIC) {
            return;
        }

        boolean sameInput =
            t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(objectType);
        if (isOverride) {
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ?
                Visibility.INHERITED : overridingInfo.getVisibility();

            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(
                    t.makeError(getprop, PRIVATE_OVERRIDE,
                        objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED &&
                overridingVisibility != visibility) {
                compiler.report(
                    t.makeError(getprop, VISIBILITY_MISMATCH,
                        visibility.name(), objectType.toString(),
                        overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                return;
            } else if (visibility == Visibility.PRIVATE &&
                (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() &&
                    isValidPrivateConstructorAccess(parent)) {
                    return;
                }

                compiler.report(
                    t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,
                        propertyName,
                        validator.getReadableJSTypeName(
                            getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED) {
                if (currentClass == null || !currentClass.isSubtype(ownerType)) {
                    compiler.report(
                        t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,
                            propertyName,
                            validator.getReadableJSTypeName(
                                getprop.getFirstChild(), true)));
                }
            }
        }
    }
}",1,0
93,Closure_71,"private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
       boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
      // Find the lowest property defined on a class with visibility
      // information.
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      for (; objectType != null;
           objectType = objectType.getImplicitPrototype()) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
      }

      if (objectType == null) {
        // We couldn't find a visibility modifier; assume it's public.
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);
      if (isOverride) {
        // Check an ASSIGN statement that's trying to override a property
        // on a superclass.
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check that (a) the property *can* be overridden, and
        // (b) that the visibility of the override is the same as the
        // visibility of the original property.
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          // private access is always allowed in the same file.
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          // private access is not allowed outside the file from a different
          // enclosing class.
          compiler.report(
              t.makeError(getprop,
                  BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          // There are 3 types of legal accesses of a protected property:
          // 1) Accesses in the same file
          // 2) Overriding the property in a subclass
          // 3) Accessing the property from inside a subclass
          // The first two have already been checked for.
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
  }","private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

    if (objectType != null) {
        boolean isOverride = t.inGlobalScope() &&
            parent.getType() == Token.ASSIGN &&
            parent.getFirstChild() == getprop;

        if (isOverride) {
            objectType = objectType.getImplicitPrototype();
        }
        
        JSDocInfo docInfo = null;
        for (; objectType != null;
             objectType = objectType.getImplicitPrototype()) {
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null &&
                docInfo.getVisibility() != Visibility.INHERITED) {
                break;
            }
        }

        if (docInfo == null) {
            return; // Assume public visibility if JSDocInfo is missing
        }

        boolean sameInput =
            t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(objectType);

        if (isOverride) {
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ?
                Visibility.INHERITED : overridingInfo.getVisibility();

            // Simplified validation logic for overrides
            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(
                    t.makeError(getprop, PRIVATE_OVERRIDE,
                        objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED &&
                       overridingVisibility != visibility) {
                compiler.report(
                    t.makeError(getprop, VISIBILITY_MISMATCH,
                        visibility.name(), objectType.toString(),
                        overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                return; // Always allow private access in the same input
            } else if (visibility == Visibility.PRIVATE &&
                       (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() &&
                    isValidPrivateConstructorAccess(parent)) {
                    return;
                }
                compiler.report(
                    t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,
                        propertyName,
                        validator.getReadableJSTypeName(
                            getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED) {
                if (currentClass == null || !currentClass.isSubtype(ownerType)) {
                    compiler.report(
                        t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,
                            propertyName,
                            validator.getReadableJSTypeName(
                                getprop.getFirstChild(), true)));
                }
            }
        }
    }
}",2,0
93,Closure_71,"private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
       boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
      // Find the lowest property defined on a class with visibility
      // information.
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      for (; objectType != null;
           objectType = objectType.getImplicitPrototype()) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
      }

      if (objectType == null) {
        // We couldn't find a visibility modifier; assume it's public.
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);
      if (isOverride) {
        // Check an ASSIGN statement that's trying to override a property
        // on a superclass.
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check that (a) the property *can* be overridden, and
        // (b) that the visibility of the override is the same as the
        // visibility of the original property.
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          // private access is always allowed in the same file.
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          // private access is not allowed outside the file from a different
          // enclosing class.
          compiler.report(
              t.makeError(getprop,
                  BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          // There are 3 types of legal accesses of a protected property:
          // 1) Accesses in the same file
          // 2) Overriding the property in a subclass
          // 3) Accessing the property from inside a subclass
          // The first two have already been checked for.
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
  }","private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

    if (objectType != null) {
      // Determine if this is a normal property access or an attempt to override
      boolean isOverride = t.inGlobalScope() &&
          parent.getType() == Token.ASSIGN &&
          parent.getFirstChild() == getprop;

      // Get the lowest property defined on a class with visibility information
      JSDocInfo docInfo = null;
      while (objectType != null) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        Visibility visibility = docInfo != null ? docInfo.getVisibility() : Visibility.PUBLIC;
        if (docInfo != null && visibility != Visibility.INHERITED) {
          break;
        }
        objectType = objectType.getImplicitPrototype();
      }

      if (docInfo == null) {
        // Assume public visibility if no JSDoc is found
        return;
      }

      boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);

      // If this is an override attempt
      if (isOverride) {
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check visibility rules for overrides
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));
        }
      } else {
        // Check non-override accesses
        if (sameInput) {
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (!docInfo.isConstructor() || !isValidPrivateConstructorAccess(parent)) {
            compiler.report(
                t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
          }
        } else if (visibility == Visibility.PROTECTED) {
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
          }
        }
      }
    }
}",3,0
93,Closure_71,"private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
       boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
      // Find the lowest property defined on a class with visibility
      // information.
      if (isOverride) {
        objectType = objectType.getImplicitPrototype();
      }
      JSDocInfo docInfo = null;
      for (; objectType != null;
           objectType = objectType.getImplicitPrototype()) {
        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        if (docInfo != null &&
            docInfo.getVisibility() != Visibility.INHERITED) {
          break;
        }
      }

      if (objectType == null) {
        // We couldn't find a visibility modifier; assume it's public.
        return;
      }

      boolean sameInput =
          t.getInput().getName().equals(docInfo.getSourceName());
      Visibility visibility = docInfo.getVisibility();
      JSType ownerType = normalizeClassType(objectType);
      if (isOverride) {
        // Check an ASSIGN statement that's trying to override a property
        // on a superclass.
        JSDocInfo overridingInfo = parent.getJSDocInfo();
        Visibility overridingVisibility = overridingInfo == null ?
            Visibility.INHERITED : overridingInfo.getVisibility();

        // Check that (a) the property *can* be overridden, and
        // (b) that the visibility of the override is the same as the
        // visibility of the original property.
        if (visibility == Visibility.PRIVATE && !sameInput) {
          compiler.report(
              t.makeError(getprop, PRIVATE_OVERRIDE,
                  objectType.toString()));
        } else if (overridingVisibility != Visibility.INHERITED &&
            overridingVisibility != visibility) {
          compiler.report(
              t.makeError(getprop, VISIBILITY_MISMATCH,
                  visibility.name(), objectType.toString(),
                  overridingVisibility.name()));
        }
      } else {
        if (sameInput) {
          // private access is always allowed in the same file.
          return;
        } else if (visibility == Visibility.PRIVATE &&
            (currentClass == null || ownerType.differsFrom(currentClass))) {
          if (docInfo.isConstructor() &&
              isValidPrivateConstructorAccess(parent)) {
            return;
          }

          // private access is not allowed outside the file from a different
          // enclosing class.
          compiler.report(
              t.makeError(getprop,
                  BAD_PRIVATE_PROPERTY_ACCESS,
                  propertyName,
                  validator.getReadableJSTypeName(
                      getprop.getFirstChild(), true)));
        } else if (visibility == Visibility.PROTECTED) {
          // There are 3 types of legal accesses of a protected property:
          // 1) Accesses in the same file
          // 2) Overriding the property in a subclass
          // 3) Accessing the property from inside a subclass
          // The first two have already been checked for.
          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
            compiler.report(
                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                    propertyName,
                    validator.getReadableJSTypeName(
                        getprop.getFirstChild(), true)));
          }
        }
      }
    }
  }","private void checkPropertyVisibility(NodeTraversal t,
      Node getprop, Node parent) {
    ObjectType objectType =
        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();

    if (objectType != null) {
        JSDocInfo docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);

        // If there's no visibility modifier, assume it's public.
        if (docInfo == null || docInfo.getVisibility() == Visibility.PUBLIC) {
            return;
        }

        boolean isOverride = t.inGlobalScope() &&
            parent.getType() == Token.ASSIGN &&
            parent.getFirstChild() == getprop;

        // Adjust objectType if overriding
        if (isOverride) {
            objectType = objectType.getImplicitPrototype();
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
        }

        boolean sameInput =
            t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(objectType);

        if (isOverride) {
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ?
                Visibility.INHERITED : overridingInfo.getVisibility();

            // Ensure override visibility rules are respected
            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(
                    t.makeError(getprop, PRIVATE_OVERRIDE,
                        objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED &&
                overridingVisibility != visibility) {
                compiler.report(
                    t.makeError(getprop, VISIBILITY_MISMATCH,
                        visibility.name(), objectType.toString(),
                        overridingVisibility.name()));
            }
        } else {
            if (!sameInput && visibility == Visibility.PRIVATE &&
                (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (!docInfo.isConstructor() || !isValidPrivateConstructorAccess(parent)){
                    compiler.report(
                        t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,
                            propertyName,
                            validator.getReadableJSTypeName(
                                getprop.getFirstChild(), true)));
                }
            } else if (visibility == Visibility.PROTECTED &&
                (currentClass == null || !currentClass.isSubtype(ownerType))) {
                compiler.report(
                    t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,
                        propertyName,
                        validator.getReadableJSTypeName(
                            getprop.getFirstChild(), true)));
            }
        }
    }
}",4,0
94,Closure_73,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      switch (c) {
        case '\0': sb.append(""\\0""); break;
        case '\n': sb.append(""\\n""); break;
        case '\r': sb.append(""\\r""); break;
        case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
             if (c > 0x1f && c <= 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      switch (c) {
        case '\0': sb.append(""\\0""); break;
        case '\n': sb.append(""\\n""); break;
        case '\r': sb.append(""\\r""); break;
        case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
             if (c > 0x1f && c < 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }",0,0
95,Closure_77,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c <= 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                // Break --> into --\> or ]]> into ]]\>
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                                    END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                           START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // If we're given an outputCharsetEncoder, then check if the
                // character can be represented in this character set.
                if (outputCharsetEncoder != null && outputCharsetEncoder.canEncode(c)) {
                    sb.append(c);
                } else if (c > 0x1f && c <= 0x7f) {
                    sb.append(c);
                } else {
                    // Other characters can be misinterpreted by some js parsers,
                    // or perhaps mangled by proxies along the way,
                    // so we play it safe and unicode escape them.
                    appendHexJavaScriptRepresentation(sb, c);
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",0,0
95,Closure_77,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c <= 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    boolean nonEmpty = s != null && !s.isEmpty();
    sb.append(quote);
    if (nonEmpty) {
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            switch (c) {
                case '\n': sb.append(""\\n""); break;
                case '\r': sb.append(""\\r""); break;
                case '\t': sb.append(""\\t""); break;
                case '\\': sb.append(backslashEscape); break;
                case '\""': sb.append(doublequoteEscape); break;
                case '\'': sb.append(singlequoteEscape); break;
                case '>':                       // Break --> into --\> or ]]> into ]]\>
                    if (i >= 2 &&
                            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                                    (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                        sb.append(""\\>"");
                    } else {
                        sb.append(c);
                    }
                    break;
                case '<':
                    // Break </script into <\/script
                    final String END_SCRIPT = ""/script"";

                    // Break <!-- into <\!--
                    final String START_COMMENT = ""!--"";

                    if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                            END_SCRIPT.length())) {
                        sb.append(""<\\"");
                    } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                            START_COMMENT.length())) {
                        sb.append(""<\\"");
                    } else {
                        sb.append(c);
                    }
                    break;
                default:
                    // Handle non-representable characters right away by default
                    if (c <= 0x1f || c > 0x7f) {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    } else {
                        sb.append(c);
                    }
            }
        }
    }
    sb.append(quote);
    return sb.toString();
}",1,0
95,Closure_77,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c <= 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                if (i >= 2 &&
                        ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                         (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length()) ||
                    s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (c < 0x20 || c > 0x7e) {
                    appendHexJavaScriptRepresentation(sb, c);
                } else if (outputCharsetEncoder != null && !outputCharsetEncoder.canEncode(c)) {
                    appendHexJavaScriptRepresentation(sb, c);
                } else {
                    sb.append(c);
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",2,0
95,Closure_77,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c <= 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch (c) {
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                final String END_SCRIPT = ""/script"";
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // Implement a logic that decides to escape characters based on specific conditions
                if (outputCharsetEncoder != null && !outputCharsetEncoder.canEncode(c)) {
                    appendHexJavaScriptRepresentation(sb, c);
                } else if ((c >= '<' && c <= '>') || c == '&') {
                    // Escaping special HTML/JavaScript sensitive chars in default case
                    appendHexJavaScriptRepresentation(sb, c);
                } else {
                    sb.append(c);
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",3,0
95,Closure_77,"static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
        case '\\': sb.append(backslashEscape); break;
        case '\""': sb.append(doublequoteEscape); break;
        case '\'': sb.append(singlequoteEscape); break;
        case '>':                       // Break --> into --\> or ]]> into ]]\>
          if (i >= 2 &&
              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
            sb.append(""\\>"");
          } else {
            sb.append(c);
          }
          break;
        case '<':
          // Break </script into <\/script
          final String END_SCRIPT = ""/script"";

          // Break <!-- into <\!--
          final String START_COMMENT = ""!--"";

          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                              END_SCRIPT.length())) {
            sb.append(""<\\"");
          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                     START_COMMENT.length())) {
            sb.append(""<\\"");
          } else {
            sb.append(c);
          }
          break;
        default:
          // If we're given an outputCharsetEncoder, then check if the
          //  character can be represented in this character set.
          if (outputCharsetEncoder != null) {
            if (outputCharsetEncoder.canEncode(c)) {
              sb.append(c);
            } else {
              // Unicode-escape the character.
              appendHexJavaScriptRepresentation(sb, c);
            }
          } else {
            // No charsetEncoder provided - pass straight latin characters
            // through, and escape the rest.  Doing the explicit character
            // check is measurably faster than using the CharsetEncoder.
            if (c > 0x1f && c <= 0x7f) {
              sb.append(c);
            } else {
              // Other characters can be misinterpreted by some js parsers,
              // or perhaps mangled by proxies along the way,
              // so we play it safe and unicode escape them.
              appendHexJavaScriptRepresentation(sb, c);
            }
          }
      }
    }
    sb.append(quote);
    return sb.toString();
  }","static String strEscape(String s, char quote,
                          String doublequoteEscape,
                          String singlequoteEscape,
                          String backslashEscape,
                          CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    boolean isScriptOrCommentEnd = false;
    String END_SCRIPT = ""/script"";
    String START_COMMENT = ""!--"";
    
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        
        switch (c) {
            case '\n': sb.append(""\\n""); break;
            case '\r': sb.append(""\\r""); break;
            case '\t': sb.append(""\\t""); break;
            case '\\': sb.append(backslashEscape); break;
            case '\""': sb.append(doublequoteEscape); break;
            case '\'': sb.append(singlequoteEscape); break;
            case '>':
                // Break --> into --\> or ]]> into ]]\\>
                if (i >= 2 &&
                    ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                     (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Escaping occurs at special script or comment beginning only
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                    isScriptOrCommentEnd = true;
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                    isScriptOrCommentEnd = true;
                } else {
                    sb.append(c);
                }
                break;
            default:
                if (outputCharsetEncoder != null && outputCharsetEncoder.canEncode(c)) {
                    sb.append(c);
                } else if (c > 0x1f && c <= 0x7f) {
                    sb.append(c);
                } else {
                    // Unicode-escape the character unless it's part of the recognized beginning patterns.
                    if (!isScriptOrCommentEnd) {
                        appendHexJavaScriptRepresentation(sb, c);
                    } else {
                        sb.append(c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",4,0
96,Closure_78,"private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
         break;
       case Token.MOD:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // TODO(johnlenz): consider removing the result length check.
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }","private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }

    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    // Avoiding operations where divisor is zero for MOD and DIV
    if ((opType == Token.MOD || opType == Token.DIV) && rval == 0) {
      error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
      return null;
    }

    double result;
    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
        break;
      case Token.MOD:
        result = lval % rval;
        break;
      case Token.DIV:
        result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // Further processing based on the result value.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
}",0,0
96,Closure_78,"private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
         break;
       case Token.MOD:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // TODO(johnlenz): consider removing the result length check.
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }","private Node performArithmeticOp(int opType, Node left, Node right) {
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    Double lValObj = NodeUtil.getNumberValue(left);
    Double rValObj = NodeUtil.getNumberValue(right);

    // Handling unknown values (NaN or other non-numeric)
    if (lValObj == null || rValObj == null) {
      return Node.newString(Token.NAME, ""NaN"");
    }

    double lval = lValObj;
    double rval = rValObj;

    double result;
    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
        break;
      case Token.MOD:
        if (rval == 0) {
          return Node.newString(Token.NAME, ""NaN"");
        }
        result = lval % rval;
        break;
      case Token.DIV:
        if (rval == 0) {
          return Node.newString(Token.NAME, ""Infinity"");
        }
        result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    } else if (Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    }

    return null;
}",1,0
96,Closure_78,"private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
         break;
       case Token.MOD:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // TODO(johnlenz): consider removing the result length check.
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }","private Node performArithmeticOp(int opType, Node left, Node right) {
    if (opType == Token.ADD 
        && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {
        return null;
    }

    Double lValObj = NodeUtil.getNumberValue(left);
    Double rValObj = NodeUtil.getNumberValue(right);

    if (lValObj == null || rValObj == null) {
        return null; // Skip processing if operands are non-numeric.
    }

    double lval = lValObj;
    double rval = rValObj;

    double result;
    switch (opType) {
        case Token.BITAND:
            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
            break;
        case Token.BITOR:
            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
            break;
        case Token.BITXOR:
            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
            break;
        case Token.ADD:
            result = lval + rval;
            break;
        case Token.SUB:
            result = lval - rval;
            break;
        case Token.MUL:
            result = lval * rval;
            break;
        case Token.MOD:
            result = rval != 0 ? lval % rval : Double.NaN;
            break;
        case Token.DIV:
            result = rval != 0 ? lval / rval : Double.NaN;
            break;
        default:
            throw new Error(""Unexpected arithmetic operator"");
    }

    if (Double.isNaN(result)) {
        return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
        return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
        return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    } else if (Math.abs(result) <= MAX_FOLD_NUMBER) {
        Node newNumber = Node.newNumber(result);
        return newNumber;
    }

    return null;
}",2,0
96,Closure_78,"private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
         break;
       case Token.MOD:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // TODO(johnlenz): consider removing the result length check.
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }","private Node performArithmeticOp(int opType, Node left, Node right) {
    if (opType == Token.ADD 
        && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {
        return null;
    }

    Double lValObj = NodeUtil.getNumberValue(left);
    Double rValObj = NodeUtil.getNumberValue(right);

    if (lValObj == null || rValObj == null) {
        return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    double result;
    switch (opType) {
        case Token.BITAND:
            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
            break;
        case Token.BITOR:
            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
            break;
        case Token.BITXOR:
            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
            break;
        case Token.ADD:
            result = lval + rval;
            break;
        case Token.SUB:
            result = lval - rval;
            break;
        case Token.MUL:
            result = lval * rval;
            break;
        case Token.MOD:
            result = rval != 0 ? lval % rval : 0;  // Treat divide by zero as zero
            break;
        case Token.DIV:
            result = rval != 0 ? lval / rval : Double.POSITIVE_INFINITY;  // Treat divide by zero as infinity
            break;
        default:
            throw new Error(""Unexpected arithmetic operator"");
    }

    if (Double.isNaN(result)) {
        return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
        return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
        return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    } else if (Math.abs(result) <= MAX_FOLD_NUMBER) {
        Node newNumber = Node.newNumber(result);
        return newNumber;
    }

    return null;
}",3,0
96,Closure_78,"private Node performArithmeticOp(int opType, Node left, Node right) {
    // Unlike other operations, ADD operands are not always converted
    // to Number.
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    double result;

    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.

    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
      return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
      return null;
    }

    double lval = lValObj;
    double rval = rValObj;

    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
         break;
       case Token.MOD:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    // TODO(johnlenz): consider removing the result length check.
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <=
        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

        // Do not try to fold arithmetic for numbers > 2^53. After that
        // point, fixed-point math starts to break down and become inaccurate.
        Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    } else if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }

    return null;
  }","private Node performArithmeticOp(int opType, Node left, Node right) {
    if (opType == Token.ADD
        && (NodeUtil.mayBeString(left, false)
            || NodeUtil.mayBeString(right, false))) {
      return null;
    }

    Double lValObj = NodeUtil.getNumberValue(left);
    Double rValObj = NodeUtil.getNumberValue(right);

    // Handling unknown values (NaN or other non-numeric)
    if (lValObj == null || rValObj == null) {
      return error(DiagnosticType.error(""JSC_INVALID_NUMBER_OPERAND"", ""Invalid number operand""), right);
    }

    double lval = lValObj;
    double rval = rValObj;

    double result;
    switch (opType) {
      case Token.BITAND:
        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
        break;
      case Token.BITOR:
        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
        break;
      case Token.BITXOR:
        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
        break;
      case Token.ADD:
        result = lval + rval;
        break;
      case Token.SUB:
        result = lval - rval;
        break;
      case Token.MUL:
        result = lval * rval;
        break;
      case Token.MOD:
        if (rval == 0) {
          return Node.newString(Token.NAME, ""NaN"");
        }
        result = lval % rval;
        break;
      case Token.DIV:
        if (rval == 0) {
          return error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
        }
        result = lval / rval;
        break;
      default:
        throw new Error(""Unexpected arithmetic operator"");
    }

    if (Double.isNaN(result)) {
      return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
      return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
      return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    } else if (Math.abs(result) <= MAX_FOLD_NUMBER) {
      Node newNumber = Node.newNumber(result);
      return newNumber;
    }

    return null;
}",4,0
97,Closure_81,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.LP);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
      node.addChildToBack(lp);

      Node bodyNode = transform(functionNode.getBody());
      parseDirectives(bodyNode);
      node.addChildToBack(bodyNode);
     return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    boolean isUnnamedFunction = (name == null || name.getIdentifier().isEmpty());
    
    if (isUnnamedFunction) {
        name = new Name();
        name.setIdentifier("""");
    }
    
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    
    if (isUnnamedFunction) {
        newName.setLineno(functionNode.getLineno());
        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
    }
    
    node.addChildToBack(newName);
    Node lp = newNode(Token.LP);
    
    // Setting line and character position for left paren
    lp.setLineno(isUnnamedFunction ? functionNode.getLineno() : name.getLineno());
    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));
    
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    
    node.addChildToBack(lp);
    Node bodyNode = transform(functionNode.getBody());
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);
    
    return node;
}",0,0
97,Closure_81,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.LP);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
      node.addChildToBack(lp);

      Node bodyNode = transform(functionNode.getBody());
      parseDirectives(bodyNode);
      node.addChildToBack(bodyNode);
     return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    boolean isUnnamedFunction = (name == null || name.getIdentifier().isEmpty());

    if (isUnnamedFunction) {
        name = new Name();
        name.setIdentifier("""");
        // Directly associating the position values with the unnamed function block
        name.setLineno(functionNode.getLineno());
        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        name.setCharno(position2charno(lpColumn));
    }

    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    node.addChildToBack(newName);

    Node lp = newNode(Token.LP);
    lp.setLineno(functionNode.getLineno());
    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));
    
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);

    Node bodyNode = transform(functionNode.getBody());
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);

    return node;
}",1,0
97,Closure_81,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.LP);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
      node.addChildToBack(lp);

      Node bodyNode = transform(functionNode.getBody());
      parseDirectives(bodyNode);
      node.addChildToBack(bodyNode);
     return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    boolean isUnnamedFunction = (name == null || name.getIdentifier().isEmpty());
    
    if (isUnnamedFunction) {
        name = new Name();
        name.setIdentifier("""");
    }
    
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    
    if (isUnnamedFunction) {
        newName.setLineno(functionNode.getLineno());
        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
    }
    
    node.addChildToBack(newName);

    int lparenLine = functionNode.getLineno();
    Node lp = newNode(Token.LP);
    lp.setLineno(lparenLine);
    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));

    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);

    Node bodyNode = transform(functionNode.getBody());
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);

    return node;
}",2,0
97,Closure_81,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.LP);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
      node.addChildToBack(lp);

      Node bodyNode = transform(functionNode.getBody());
      parseDirectives(bodyNode);
      node.addChildToBack(bodyNode);
     return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    boolean isUnnamedFunction = (name == null || name.getIdentifier().isEmpty());

    if (isUnnamedFunction) {
        name = new Name();
        name.setIdentifier("""");
    }

    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);

    newName.setLineno(functionNode.getLineno());
    int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
    newName.setCharno(position2charno(lpColumn));
    
    node.addChildToBack(newName);
    Node lp = newNode(Token.LP);

    lp.setLineno(functionNode.getLineno());
    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));
    
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);

    Node bodyNode = transform(functionNode.getBody());
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);

    return node;
}",3,0
97,Closure_81,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.LP);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
      node.addChildToBack(lp);

      Node bodyNode = transform(functionNode.getBody());
      parseDirectives(bodyNode);
      node.addChildToBack(bodyNode);
     return node;
    }","@Override
Node processFunctionNode(FunctionNode functionNode) {
   Name name = functionNode.getFunctionName();
   boolean isUnnamedFunction = (name == null || name.getIdentifier().isEmpty());
   if (isUnnamedFunction) {
     name = new Name();
     name.setIdentifier("""");
   }
   Node node = newNode(Token.FUNCTION);
   Node newName = transform(name);
   newName.setLineno(functionNode.getLineno());
   int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
   newName.setCharno(position2charno(lpColumn));
   
   node.addChildToBack(newName);
   Node lp = newNode(Token.LP);
   lp.setLineno(functionNode.getLineno());  // Assumes the line number for both cases
   int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
   lp.setCharno(position2charno(lparenCharno));

   for (AstNode param : functionNode.getParams()) {
     lp.addChildToBack(transform(param));
   }
   node.addChildToBack(lp);

   Node bodyNode = transform(functionNode.getBody());
   parseDirectives(bodyNode);
   node.addChildToBack(bodyNode);

   return node;
}",4,0
98,Closure_82,"  public boolean isNoObjectType() {
    return false;
  }
","public boolean isNoObjectType() {
    return true;
}",0,0
98,Closure_82,"  public boolean isNoObjectType() {
    return false;
  }
","public boolean isNoObjectType() {
    return isNoType() || isNoResolvedType();
}",1,0
98,Closure_82,"  public boolean isNoObjectType() {
    return false;
  }
","public boolean isNoObjectType() {
    return !isNullable();
}",2,0
98,Closure_82,"  public boolean isNoObjectType() {
    return false;
  }
","public boolean isNoObjectType() {
    return isNoType() || isNoResolvedType() || isEmptyType();
}

private boolean isEmptyType() {
    return isNoType() && !isAllType();
}

private boolean isAllType() {
    // Assume that this function defines what is considered 'all types'
    return false; // Placeholder logic, modify as per actual logic in context
}",3,0
98,Closure_82,"  public boolean isNoObjectType() {
    return false;
  }
","public boolean isNoObjectType() {
    return isNoType() && isNoResolvedType();
}",4,0
99,Closure_83,"      public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
      }
","public BooleanOptionHandler(
        CmdLineParser parser, OptionDef option,
        Setter<? super Boolean> setter) {
    super(parser, option, setter);
    if (setter == null) {
        throw new IllegalArgumentException(""Setter must not be null"");
    }
    // additional setup or checks could be added here if needed
}",0,0
99,Closure_83,"      public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
      }
","public BooleanOptionHandler(
        CmdLineParser parser, OptionDef option,
        Setter<? super Boolean> setter) {
    super(parser, option, setter);
    if (option == null) {
        throw new IllegalArgumentException(""OptionDef must not be null"");
    }
    if (parser == null) {
        throw new IllegalArgumentException(""CmdLineParser must not be null"");
    }
}",1,0
99,Closure_83,"      public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
      }
","public BooleanOptionHandler(
        CmdLineParser parser, OptionDef option,
        Setter<? super Boolean> setter) {
    super(parser, option, setter);

    if (!setter.getType().equals(Boolean.class)) {
        throw new IllegalArgumentException(""Setter type must be Boolean"");
    }

    if (option.requiresArgument()) {
        throw new IllegalArgumentException(""Option must not require an argument"");
    }
}",2,0
99,Closure_83,"      public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
      }
","public BooleanOptionHandler(
        CmdLineParser parser, OptionDef option,
        Setter<? super Boolean> setter) {
    super(parser, option, setter);
    if (!option.isOptionRequired()) {
        throw new IllegalStateException(""Options that require arguments are not supported"");
    }
    if (setter != null && !setter.isValid()) {
        throw new IllegalArgumentException(""Invalid setter configuration"");
    }
}",3,0
99,Closure_83,"      public BooleanOptionHandler(
          CmdLineParser parser, OptionDef option,
          Setter<? super Boolean> setter) {
        super(parser, option, setter);
      }
","public BooleanOptionHandler(
        CmdLineParser parser, OptionDef option,
        Setter<? super Boolean> setter) {
    super(parser, option, setter);
    if (option != null && setter != null) {
        boolean value = option.getDefaultValue();
        setter.addValue(value);
    } else {
        throw new IllegalArgumentException(""Option or Setter must not be null"");
    }
}",4,0
100,Closure_86,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        // Literals objects with non-literal children are allowed.
        return true;
      case Token.IN:
        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
        return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
        case Token.ASSIGN:
            return NodeUtil.isImmutableValue(value.getLastChild())
                || (locals.test(value.getFirstChild()) // Fixed: use test() instead of apply()
                    && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals)
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            if (value.getBooleanProp(Node.INCRDECR_PROP)) {
                return evaluatesToLocalValue(value.getFirstChild(), locals);
            } else {
                return true;
            }
        case Token.THIS:
            return locals.test(value); // Fixed: use test() instead of apply()
        case Token.NAME:
            return NodeUtil.isImmutableValue(value) || locals.test(value); // Fixed: use test() instead of apply()
        case Token.GETELEM:
        case Token.GETPROP:
            return false; // Fixed: Assume object properties are non-local for safety
        case Token.CALL:
            return NodeUtil.callHasLocalResult(value)
                || NodeUtil.isToStringMethodCall(value);
        case Token.NEW:
            return NodeUtil.callHasLocalResult(value); // Fixed: Ensure constructor checks for local results.
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return true;
        case Token.IN:
            return true;
        default:
            if (NodeUtil.isAssignmentOp(value)
                || NodeUtil.isSimpleOperator(value)
                || NodeUtil.isImmutableValue(value)) {
                return true;
            }
            throw new IllegalStateException(
                ""Unexpected expression node: "" + value +
                ""\n parent: "" + value.getParent());
    }
}",0,0
100,Closure_86,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        // Literals objects with non-literal children are allowed.
        return true;
      case Token.IN:
        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
        return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
        case Token.ASSIGN:
            // Only check the assignment's first child for locality if it's a NAME token
            return NodeUtil.isImmutableValue(value.getLastChild())
                || (value.getFirstChild().getType() == Token.NAME && locals.test(value.getFirstChild())
                && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals)
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
                && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            return value.getBooleanProp(Node.INCRDECR_PROP)
                && evaluatesToLocalValue(value.getFirstChild(), locals);
        case Token.THIS:
            return false; // 'this' typically represents the global object context
        case Token.NAME:
            return NodeUtil.isImmutableValue(value) || locals.test(value);
        case Token.GETELEM:
        case Token.GETPROP:
            // Object properties are usually not considered local without further context
            return false;
        case Token.CALL:
            return NodeUtil.callHasLocalResult(value)
                || NodeUtil.isToStringMethodCall(value);
        case Token.NEW:
            // Give a stricter criterion for ensuring objects from NEW are local
            return NodeUtil.callHasLocalResult(value)
                && !NodeUtil.hasSideEffects(value);
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return true;
        case Token.IN:
            return true;
        default:
            if (NodeUtil.isAssignmentOp(value) || NodeUtil.isSimpleOperator(value) || NodeUtil.isImmutableValue(value)) {
                return true;
            }
            throw new IllegalStateException(
                ""Unexpected expression node: "" + value +
                ""\n parent: "" + value.getParent());
    }
}",1,0
100,Closure_86,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        // Literals objects with non-literal children are allowed.
        return true;
      case Token.IN:
        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
        return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // Get the first child specifically for NAME or THIS type
        return NodeUtil.isImmutableValue(value.getLastChild())
            || ((value.getFirstChild().getType() == Token.NAME || value.getFirstChild().getType() == Token.THIS) 
                && locals.test(value.getFirstChild())
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        // Toggle based on increment property
        return value.getBooleanProp(Node.INCRDECR_PROP)
          && evaluatesToLocalValue(value.getFirstChild(), locals);
      case Token.THIS:
        return false; // Avoid considering 'this' as local
      case Token.NAME:
        return NodeUtil.isImmutableValue(value) || locals.test(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // Directly assume object properties as non-local safely
        return false;
      case Token.CALL:
        // Ensure use of method call locality logic
        return NodeUtil.callHasLocalResult(value) || NodeUtil.isToStringMethodCall(value);
      case Token.NEW:
        // Add side-effect check for construction locality
        return NodeUtil.callHasLocalResult(value) && !NodeUtil.hasSideEffects(value);
      case Token.FUNCTION:
      case Token.REGEXP:
      case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        return true;
      case Token.IN:
        return true;
      default:
        if (NodeUtil.isAssignmentOp(value) || NodeUtil.isSimpleOperator(value) || NodeUtil.isImmutableValue(value)) {
          return true;
        }
        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
}",2,0
100,Closure_86,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        // Literals objects with non-literal children are allowed.
        return true;
      case Token.IN:
        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
        return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
        case Token.ASSIGN:
            // Ensure locality checks based on specific token TYPE
            return NodeUtil.isImmutableValue(value.getLastChild()) ||
                   (value.getFirstChild().getType() == Token.NAME && locals.test(value.getFirstChild()) &&
                    evaluatesToLocalValue(value.getLastChild(), locals));

        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);

        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals) &&
                   evaluatesToLocalValue(value.getLastChild(), locals);

        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) &&
                   evaluatesToLocalValue(value.getLastChild(), locals);

        case Token.INC:
        case Token.DEC:
            // Assume changes are always non-local unless strictly increment based
            return value.getBooleanProp(Node.INCRDECR_PROP) &&
                   evaluatesToLocalValue(value.getFirstChild(), locals);

        case Token.THIS:
            // Consider 'this' never local unless proven otherwise
            return false;

        case Token.NAME:
            return NodeUtil.isImmutableValue(value) || locals.test(value);

        case Token.GETELEM:
        case Token.GETPROP:
            // Assume object properties and elements cannot be purely local
            return false;

        case Token.CALL:
            // Identity method calls based on local result flag
            return NodeUtil.callHasLocalResult(value) || NodeUtil.isToStringMethodCall(value);

        case Token.NEW:
            // Ensure strict checks when determining constructor locality
            return NodeUtil.callHasLocalResult(value);

        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return true;

        case Token.IN:
            return true;

        default:
            // Any unknown checks assume locality with simple operators until proven otherwise
            if (NodeUtil.isAssignmentOp(value) || NodeUtil.isSimpleOperator(value) ||
                NodeUtil.isImmutableValue(value)) {
                return true;
            }

            throw new IllegalStateException(
                ""Unexpected expression node: "" + value +
                ""\n parent: "" + value.getParent());
    }
}",3,0
100,Closure_86,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        // Literals objects with non-literal children are allowed.
        return true;
      case Token.IN:
        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
        return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
        case Token.ASSIGN:
            // Ensure that the locality of assignment is checked only for immutable values as locals.
            return NodeUtil.isImmutableValue(value.getLastChild()) ||
                   (NodeUtil.isImmutableValue(value.getFirstChild()) && locals.test(value.getFirstChild()));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals) &&
                   evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) &&
                   evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            // make non-locality assumption for increment/decrement operations.
            return locals.test(value.getFirstChild());
        case Token.THIS:
            // Explicitly do not consider 'this' as local.
            return false;
        case Token.NAME:
            return NodeUtil.isImmutableValue(value);
        case Token.GETELEM:
        case Token.GETPROP:
            // Assume properties cannot be local.
            return false;
        case Token.CALL:
            return NodeUtil.callHasLocalResult(value) || NodeUtil.isToStringMethodCall(value);
        case Token.NEW:
            // Enforce locality check by observing side effects along with result.
            return NodeUtil.callHasLocalResult(value) && !NodeUtil.hasSideEffects(value);
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            return true;
        case Token.IN:
            return true;
        default:
            if (NodeUtil.isAssignmentOp(value) || NodeUtil.isSimpleOperator(value) || NodeUtil.isImmutableValue(value)) {
                return true;
            }
            throw new IllegalStateException(
                ""Unexpected expression node: "" + value +
                ""\n parent: "" + value.getParent());
    }
}",4,0
101,Closure_87,"private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
 
           return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
    return false;
  }","private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK) {
        if (n.hasOneChild()) {
            Node maybeExpr = n.getFirstChild();
            // IE has a bug where event handlers behave differently when
            // their return value is used vs. when their return value is in
            // an EXPR_RESULT. It's pretty freaking weird. See:
            // http://code.google.com/p/closure-compiler/issues/detail?id=291
            // We try to detect this case, and not fold EXPR_RESULTs
            // into other expressions.

            // We only have to worry about methods with an implicit 'this'
            // param, or this doesn't happen.

            // Correct condition to check explicitly for EXPR_RESULT token type
            return maybeExpr.getType() == Token.EXPR_RESULT;
        }
    }
    return false;
}",0,0
101,Closure_87,"private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
 
           return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
    return false;
  }","private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK) {
        if (n.hasOneChild()) {
            Node maybeExpr = n.getFirstChild();
            // Instead of checking simply for EXPR_RESULT, we add an additional check to ensure
            // we're not folding methods with an implicit 'this' param, which could be problematic.
            if (NodeUtil.isExpressionNode(maybeExpr)) {
                // Here we ensure that maybeExpr does not correspond to special cases like event handlers
                return !(maybeExpr.hasSimilarNodeOfType(Token.FUNCTION) && maybeExpr.getParent().isScript());
            }
        }
    }
    return false;
}",1,0
101,Closure_87,"private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
 
           return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
    return false;
  }","private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK && n.hasOneChild()) {
        Node maybeExpr = n.getFirstChild();
        // Instead of returning based solely on isExpressionNode, include additional checks
        // for expression complexity and context sensitivity.
        if (maybeExpr.getType() == Token.EXPR_RESULT) {
            Node parent = maybeExpr.getParent();
            // Assume EXPR_RESULT within certain contexts cannot be folded, due to issues like implicit 'this'
            // param in certain environments. Check parent node type or context.
            return !(parent.getType() == Token.SCRIPT || 
                    (parent.getType() == Token.EXPR_RESULT && parent.hasOneChild()));
        }
    }
    return false;
}",2,0
101,Closure_87,"private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
 
           return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
    return false;
  }","private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK) {
        if (n.hasOneChild()) {
            Node maybeExpr = n.getFirstChild();
            // Perform additional validation to avoid folding EXPR_RESULT blocks incorrectly.
            if (maybeExpr.getType() == Token.EXPR_RESULT) {
                Node parent = maybeExpr.getParent();
                // Ensure the parent is not a problematic node type or context.
                return parent.getType() != Token.SCRIPT && !maybeExpr.isFunction();
            }
        }
    }
    return false;
}",3,0
101,Closure_87,"private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
 
           return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
    return false;
  }","private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK && n.hasOneChild()) {
        Node maybeExpr = n.getFirstChild();
        // Perform a stricter check to ensure EXPR_RESULT is foldable
        // Only allow folding if the block does not contain expressions
        // that are part of implicit 'this' operations or event handlers.
        return NodeUtil.isExpressionNode(maybeExpr) &&
               !maybeExpr.isEventHandler() &&
               !maybeExpr.isImplicitThisOperation();
    }
    return false;
}",4,0
102,Closure_88,"private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
      }
    }

    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild();
        child != null; child = child.getNext()) {
      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
        VariableLiveness state = isVariableReadBeforeKill(child, variable);
        if (state != VariableLiveness.MAYBE_LIVE) {
          return state;
        }
      }
    }
    return VariableLiveness.MAYBE_LIVE;
  }","private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {
    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        if (NodeUtil.isLhs(n, n.getParent())) {
            // The expression to which the assignment is made is evaluated before
            // the RHS is evaluated (normal left to right evaluation) but the KILL
            // occurs after the RHS is evaluated.
            return VariableLiveness.KILL;
        } else {
            return VariableLiveness.READ;
        }
    }

    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
            VariableLiveness state = isVariableReadBeforeKill(child, variable);
            if (state != VariableLiveness.MAYBE_LIVE) {
                return state;
            }
        }
    }

    // Return MAYBE_LIVE when no definite READ or KILL is found
    return VariableLiveness.MAYBE_LIVE;
}",0,0
102,Closure_88,"private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
      }
    }

    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild();
        child != null; child = child.getNext()) {
      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
        VariableLiveness state = isVariableReadBeforeKill(child, variable);
        if (state != VariableLiveness.MAYBE_LIVE) {
          return state;
        }
      }
    }
    return VariableLiveness.MAYBE_LIVE;
  }","private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {
    // Base case: If the node is a Name node and matches the variable name
    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        if (NodeUtil.isLhs(n, n.getParent())) {
            // If the variable is on the left-hand side of an assignment, it can be killed
            return VariableLiveness.KILL;
        } else {
            // Otherwise, if the variable is on the right-hand side, it is read
            return VariableLiveness.READ;
        }
    }

    // Initially assume the variable is not read yet
    VariableLiveness state = VariableLiveness.MAYBE_LIVE;

    // Traverse through child nodes. Expressions are evaluated left-right, depth first
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
            VariableLiveness childState = isVariableReadBeforeKill(child, variable);

            // If variable is definitely read or killed before any MAYBE_LIVE state, update the state
            if (childState == VariableLiveness.READ) {
                return VariableLiveness.READ;
            } else if (childState == VariableLiveness.KILL) {
                state = VariableLiveness.KILL;
            }
        }
    }

    // Return the determined state, can be MAYBE_LIVE if no definite READ or KILL is found
    return state;
}",1,0
103,Closure_91,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||

            // object literal keys
            pType == Token.STRING ||
            pType == Token.NUMBER)) {
        return false;
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this, @override, or @interface annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.isInterface() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
            return false;
        }

        // Don't traverse functions unless they are in valid contexts.
        int pType = parent != null ? parent.getType() : Token.EMPTY;
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.NAME ||
              pType == Token.ASSIGN ||

              // Object literal keys
              pType == Token.STRING ||
              pType == Token.NUMBER)) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            // Always traverse the left side of the assignment.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // Only traverse the right side if it's not an assignment to a prototype property/subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP &&
                    ""prototype"".equals(lhs.getLastChild().getString())) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP &&
                    ""prototype"".equals(llhs.getLastChild().getString())) {
                    return false;
                }
            }
        }
    }

    return true;
}",0,0
103,Closure_91,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||

            // object literal keys
            pType == Token.STRING ||
            pType == Token.NUMBER)) {
        return false;
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && 
            (jsDoc.isConstructor() || 
             jsDoc.isInterface() || 
             jsDoc.hasThisType() || 
             jsDoc.isOverride())) {
            return false;
        }

        int pType = parent != null ? parent.getType() : Token.EMPTY;
        if (!(pType == Token.BLOCK || 
              pType == Token.SCRIPT || 
              pType == Token.NAME || 
              pType == Token.ASSIGN || 
              pType == Token.STRING || 
              pType == Token.NUMBER)) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            if (NodeUtil.isGet(lhs)) {
                if ((lhs.getType() == Token.GETPROP && ""prototype"".equals(lhs.getLastChild().getString())) || 
                    (lhs.getFirstChild().getType() == Token.GETPROP && 
                     ""prototype"".equals(lhs.getFirstChild().getLastChild().getString()))) {
                    return false;
                }
            }
        }
    }

    // Added additional logic to prevent traversal of nodes that indicate global ""this"" usage
    if (n.getType() == Token.THIS && (parent == null || parent.getType() != Token.FUNCTION)) {
        return false;
    }

    return true;
}",1,0
103,Closure_91,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||

            // object literal keys
            pType == Token.STRING ||
            pType == Token.NUMBER)) {
        return false;
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.isInterface() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
            return false;
        }

        int pType = parent != null ? parent.getType() : Token.EMPTY;
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.NAME ||
              pType == Token.ASSIGN ||
              pType == Token.STRING ||
              pType == Token.NUMBER)) {
            return false;
        }
    }

    // Adjust logic to track global ""this"" usage explicitly
    if (n.getType() == Token.THIS) {
        if (parent == null || parent.getType() != Token.FUNCTION) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP &&
                    ""prototype"".equals(lhs.getLastChild().getString())) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs != null && llhs.getType() == Token.GETPROP &&
                    ""prototype"".equals(llhs.getLastChild().getString())) {
                    return false;
                }
            }
        }
    }

    // New condition to block traversal based on specific parent-child patterns
    if (parent != null && parent.getType() == Token.GETPROP &&
        ""prototype"".equals(n.getString())) {
        return false;
    }

    return true;
}",2,0
103,Closure_91,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||

            // object literal keys
            pType == Token.STRING ||
            pType == Token.NUMBER)) {
        return false;
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.isInterface() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
            return false;
        }

        int pType = parent != null ? parent.getType() : Token.EMPTY;
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.NAME ||
              pType == Token.ASSIGN ||
              pType == Token.STRING ||
              pType == Token.NUMBER)) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            if (NodeUtil.isGet(lhs)) {
                Node llhs = lhs.getFirstChild();
                if ((lhs.getType() == Token.GETPROP && ""prototype"".equals(lhs.getLastChild().getString())) ||
                    (llhs != null && llhs.getType() == Token.GETPROP && ""prototype"".equals(llhs.getLastChild().getString()))) {
                    return false;
                }
            }
        }
    }

    // Different logic: Block traversal of ""this"" in global contexts by checking parent type
    if (n.getType() == Token.THIS) {
        if (parent == null || (parent.getType() != Token.FUNCTION && parent.getType() != Token.GETPROP)) {
            return false;
        }
    }

    return true;
}",3,0
103,Closure_91,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||

            // object literal keys
            pType == Token.STRING ||
            pType == Token.NUMBER)) {
        return false;
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null &&
            (jsDoc.isConstructor() ||
             jsDoc.isInterface() ||
             jsDoc.hasThisType() ||
             jsDoc.isOverride())) {
            return false;
        }

        int pType = parent.getType();
        if (!(pType == Token.BLOCK ||
              pType == Token.SCRIPT ||
              pType == Token.NAME ||
              pType == Token.ASSIGN ||
              pType == Token.STRING ||
              pType == Token.NUMBER)) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP &&
                    lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP &&
                    llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }

    // New approach: Blocking traversal for parent types indicating global scope ""this"" misuse
    if (n.getType() == Token.THIS) {
        if (parent == null || parent.getType() == Token.SCRIPT) {
            return false;
        }
    }

    return true;
}",4,0
104,Closure_92,"void replace() {
      if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
      }

      // Handle the case where there is a duplicate definition for an explicitly
      // provided symbol.
      if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
          Node assignNode = candidateDefinition.getFirstChild();
          Node nameNode = assignNode.getFirstChild();
          if (nameNode.getType() == Token.NAME) {
            // Need to convert this assign to a var declaration.
            Node valueNode = nameNode.getNext();
            assignNode.removeChild(nameNode);
            assignNode.removeChild(valueNode);
            nameNode.addChildToFront(valueNode);
            Node varNode = new Node(Token.VAR, nameNode);
            varNode.copyInformationFrom(candidateDefinition);
            candidateDefinition.getParent().replaceChild(
                candidateDefinition, varNode);
            nameNode.setJSDocInfo(assignNode.getJSDocInfo());
            compiler.reportCodeChange();
            replacementNode = varNode;
          }
        }
      } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
          firstNode.getParent().addChildBefore(replacementNode, firstNode);
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
           int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
                .addChildToBack(replacementNode);
          } else {
            // Add it after the parent namespace.
            ProvidedName parentName =
                providedNames.get(namespace.substring(0, indexOfDot));
            Preconditions.checkNotNull(parentName);
            Preconditions.checkNotNull(parentName.replacementNode);
            parentName.replacementNode.getParent().addChildAfter(
                replacementNode, parentName.replacementNode);
          }
        }
        if (explicitNode != null) {
          explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
      }
    }","void replace() {
    if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
    }

    // Handle the case where there is a duplicate definition for an explicitly
    // provided symbol.
    if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
            Node assignNode = candidateDefinition.getFirstChild();
            Node nameNode = assignNode.getFirstChild();
            if (nameNode != null && nameNode.getType() == Token.NAME) {
                // Need to convert this assign to a var declaration.
                Node valueNode = nameNode.getNext();
                if (valueNode != null) {
                  assignNode.removeChild(nameNode);
                  assignNode.removeChild(valueNode);
                  nameNode.addChildToFront(valueNode);
                  Node varNode = new Node(Token.VAR, nameNode);
                  varNode.copyInformationFrom(candidateDefinition);
                  candidateDefinition.getParent().replaceChild(
                      candidateDefinition, varNode);
                  nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                  compiler.reportCodeChange();
                  replacementNode = varNode;
                }
            }
        }
    } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
            firstNode.getParent().addChildBefore(replacementNode, firstNode);
        } else {
            // In this case, the name was implicitly provided by two independent
            // modules. We need to move this code up to a common module.
            int indexOfDot = namespace.indexOf('.');
            if (indexOfDot == -1) {
                // Any old place is fine.
                compiler.getNodeForCodeInsertion(minimumModule)
                    .addChildToBack(replacementNode);
            } else {
                // Add it after the parent namespace.
                ProvidedName parentName =
                    providedNames.get(namespace.substring(0, indexOfDot));
                Preconditions.checkNotNull(parentName);
                Preconditions.checkNotNull(parentName.replacementNode);
                parentName.replacementNode.getParent().addChildAfter(
                    replacementNode, parentName.replacementNode);
            }
        }
        if (explicitNode != null) {
            explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
    }
}",0,0
104,Closure_92,"void replace() {
      if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
      }

      // Handle the case where there is a duplicate definition for an explicitly
      // provided symbol.
      if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
          Node assignNode = candidateDefinition.getFirstChild();
          Node nameNode = assignNode.getFirstChild();
          if (nameNode.getType() == Token.NAME) {
            // Need to convert this assign to a var declaration.
            Node valueNode = nameNode.getNext();
            assignNode.removeChild(nameNode);
            assignNode.removeChild(valueNode);
            nameNode.addChildToFront(valueNode);
            Node varNode = new Node(Token.VAR, nameNode);
            varNode.copyInformationFrom(candidateDefinition);
            candidateDefinition.getParent().replaceChild(
                candidateDefinition, varNode);
            nameNode.setJSDocInfo(assignNode.getJSDocInfo());
            compiler.reportCodeChange();
            replacementNode = varNode;
          }
        }
      } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
          firstNode.getParent().addChildBefore(replacementNode, firstNode);
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
           int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
                .addChildToBack(replacementNode);
          } else {
            // Add it after the parent namespace.
            ProvidedName parentName =
                providedNames.get(namespace.substring(0, indexOfDot));
            Preconditions.checkNotNull(parentName);
            Preconditions.checkNotNull(parentName.replacementNode);
            parentName.replacementNode.getParent().addChildAfter(
                replacementNode, parentName.replacementNode);
          }
        }
        if (explicitNode != null) {
          explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
      }
    }","void replace() {
    if (firstNode == null) {
        replacementNode = candidateDefinition;
        return;
    }

    if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
            Node assignNode = candidateDefinition.getFirstChild();
            Node nameNode = assignNode != null ? assignNode.getFirstChild() : null;
            if (nameNode != null && nameNode.getType() == Token.NAME) {
                Node valueNode = nameNode.getNext();
                if (valueNode != null) {
                    nameNode.detachChildren();
                    nameNode.addChildToFront(valueNode);
                    Node varNode = new Node(Token.VAR, nameNode);
                    varNode.copyInformationFrom(candidateDefinition);
                    candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);
                    nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                    replacementNode = varNode;
                }
            }
        }
    } else {
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
            firstNode.getParent().addChildBefore(replacementNode, firstNode);
        } else {
            ProvidedName parentName = null;
            int indexOfDot = namespace.indexOf('.');
            if (indexOfDot != -1) {
                parentName = providedNames.get(namespace.substring(0, indexOfDot));
            }
            if (parentName != null && parentName.replacementNode != null) {
                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);
            } else {
                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);
            }
        }
        if (explicitNode != null) {
            explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
    }
}",1,0
104,Closure_92,"void replace() {
      if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
      }

      // Handle the case where there is a duplicate definition for an explicitly
      // provided symbol.
      if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
          Node assignNode = candidateDefinition.getFirstChild();
          Node nameNode = assignNode.getFirstChild();
          if (nameNode.getType() == Token.NAME) {
            // Need to convert this assign to a var declaration.
            Node valueNode = nameNode.getNext();
            assignNode.removeChild(nameNode);
            assignNode.removeChild(valueNode);
            nameNode.addChildToFront(valueNode);
            Node varNode = new Node(Token.VAR, nameNode);
            varNode.copyInformationFrom(candidateDefinition);
            candidateDefinition.getParent().replaceChild(
                candidateDefinition, varNode);
            nameNode.setJSDocInfo(assignNode.getJSDocInfo());
            compiler.reportCodeChange();
            replacementNode = varNode;
          }
        }
      } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
          firstNode.getParent().addChildBefore(replacementNode, firstNode);
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
           int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
                .addChildToBack(replacementNode);
          } else {
            // Add it after the parent namespace.
            ProvidedName parentName =
                providedNames.get(namespace.substring(0, indexOfDot));
            Preconditions.checkNotNull(parentName);
            Preconditions.checkNotNull(parentName.replacementNode);
            parentName.replacementNode.getParent().addChildAfter(
                replacementNode, parentName.replacementNode);
          }
        }
        if (explicitNode != null) {
          explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
      }
    }","void replace() {
    if (firstNode == null) {
        replacementNode = candidateDefinition;
        return;
    }

    if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
            Node assignNode = candidateDefinition.getFirstChild();

            if (assignNode != null) {
                Node nameNode = assignNode.getFirstChild();

                if (nameNode != null && nameNode.getType() == Token.NAME) {
                    Node valueNode = nameNode.getNext();
                    if (valueNode != null) {
                        nameNode.detachChildren();
                        nameNode.addChildToFront(valueNode);
                    }
                    Node varNode = new Node(Token.VAR, nameNode);
                    varNode.copyInformationFrom(candidateDefinition);
                    if (candidateDefinition.getParent() != null) {
                        candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);
                    }
                    nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                    compiler.reportCodeChange();
                    replacementNode = varNode;
                }
            }
        }
    } else {
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
            if (firstNode.getParent() != null) {
                firstNode.getParent().addChildBefore(replacementNode, firstNode);
            }
        } else {
            int indexOfDot = namespace.indexOf('.');
            if (indexOfDot == -1) {
                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);
            } else {
                ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));
                if (parentName != null && parentName.replacementNode != null) {
                    parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);
                }
            }
        }
        if (explicitNode != null) {
            explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
    }
}",2,0
104,Closure_92,"void replace() {
      if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
      }

      // Handle the case where there is a duplicate definition for an explicitly
      // provided symbol.
      if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
          Node assignNode = candidateDefinition.getFirstChild();
          Node nameNode = assignNode.getFirstChild();
          if (nameNode.getType() == Token.NAME) {
            // Need to convert this assign to a var declaration.
            Node valueNode = nameNode.getNext();
            assignNode.removeChild(nameNode);
            assignNode.removeChild(valueNode);
            nameNode.addChildToFront(valueNode);
            Node varNode = new Node(Token.VAR, nameNode);
            varNode.copyInformationFrom(candidateDefinition);
            candidateDefinition.getParent().replaceChild(
                candidateDefinition, varNode);
            nameNode.setJSDocInfo(assignNode.getJSDocInfo());
            compiler.reportCodeChange();
            replacementNode = varNode;
          }
        }
      } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
          firstNode.getParent().addChildBefore(replacementNode, firstNode);
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
           int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
                .addChildToBack(replacementNode);
          } else {
            // Add it after the parent namespace.
            ProvidedName parentName =
                providedNames.get(namespace.substring(0, indexOfDot));
            Preconditions.checkNotNull(parentName);
            Preconditions.checkNotNull(parentName.replacementNode);
            parentName.replacementNode.getParent().addChildAfter(
                replacementNode, parentName.replacementNode);
          }
        }
        if (explicitNode != null) {
          explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
      }
    }","void replace() {
     if (firstNode == null) {
         replacementNode = candidateDefinition;
         return;
     }

     if (candidateDefinition != null && explicitNode != null) {
         explicitNode.detachFromParent();
         compiler.reportCodeChange();

         replacementNode = candidateDefinition;
         if (NodeUtil.isExpressionNode(candidateDefinition)) {
             candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
             Node assignNode = candidateDefinition.getFirstChild();
             if (assignNode != null) {
                 Node nameNode = assignNode.getFirstChild();
                 if (nameNode != null && nameNode.getType() == Token.NAME) {
                     Node valueNode = nameNode.getNext();
                     if (valueNode != null) {
                         assignNode.removeChild(nameNode);
                         assignNode.removeChild(valueNode);
                         nameNode.addChildToFront(valueNode);
                         Node varNode = new Node(Token.VAR, nameNode);
                         varNode.copyInformationFrom(candidateDefinition);
                         candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);
                         nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                         compiler.reportCodeChange();
                         replacementNode = varNode;
                     }
                 }
             }
         }
     } else {
         replacementNode = createDeclarationNode();
         if (firstModule == minimumModule) {
             if (firstNode.getParent() != null) {
                 firstNode.getParent().addChildBefore(replacementNode, firstNode);
             }
         } else {
             int indexOfDot = namespace.indexOf('.');
             if (indexOfDot == -1) {
                 compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);
             } else {
                 ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));
                 if (parentName != null && parentName.replacementNode != null) {
                     parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);
                 }
             }
         }
         if (explicitNode != null) {
             explicitNode.detachFromParent();
         }
         compiler.reportCodeChange();
     }
 }",3,0
104,Closure_92,"void replace() {
      if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
      }

      // Handle the case where there is a duplicate definition for an explicitly
      // provided symbol.
      if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();

        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
          Node assignNode = candidateDefinition.getFirstChild();
          Node nameNode = assignNode.getFirstChild();
          if (nameNode.getType() == Token.NAME) {
            // Need to convert this assign to a var declaration.
            Node valueNode = nameNode.getNext();
            assignNode.removeChild(nameNode);
            assignNode.removeChild(valueNode);
            nameNode.addChildToFront(valueNode);
            Node varNode = new Node(Token.VAR, nameNode);
            varNode.copyInformationFrom(candidateDefinition);
            candidateDefinition.getParent().replaceChild(
                candidateDefinition, varNode);
            nameNode.setJSDocInfo(assignNode.getJSDocInfo());
            compiler.reportCodeChange();
            replacementNode = varNode;
          }
        }
      } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
          firstNode.getParent().addChildBefore(replacementNode, firstNode);
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
           int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
                .addChildToBack(replacementNode);
          } else {
            // Add it after the parent namespace.
            ProvidedName parentName =
                providedNames.get(namespace.substring(0, indexOfDot));
            Preconditions.checkNotNull(parentName);
            Preconditions.checkNotNull(parentName.replacementNode);
            parentName.replacementNode.getParent().addChildAfter(
                replacementNode, parentName.replacementNode);
          }
        }
        if (explicitNode != null) {
          explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
      }
    }","void replace() {
    if (firstNode == null) {
        replacementNode = candidateDefinition;
        return;
    }

    if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();
        
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
            Node assignNode = candidateDefinition.getFirstChild();
            if (assignNode != null) {
                Node nameNode = assignNode.getFirstChild();
                if (nameNode != null && nameNode.getType() == Token.NAME) {
                    Node valueNode = nameNode.getNext();
                    if (valueNode != null) {
                        assignNode.removeChild(nameNode);
                        nameNode.addChildToFront(valueNode);
                        Node varNode = new Node(Token.VAR, nameNode);
                        varNode.copyInformationFrom(candidateDefinition);
                        Node parent = candidateDefinition.getParent();
                        if (parent != null) {
                            parent.replaceChild(candidateDefinition, varNode);
                        }
                        nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                        compiler.reportCodeChange();
                        replacementNode = varNode;
                    }
                }
            }
        }
    } else {
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
            if (firstNode.getParent() != null) {
                firstNode.getParent().addChildBefore(replacementNode, firstNode);
            }
        } else {
            int indexOfDot = namespace.indexOf('.');
            if (indexOfDot == -1) {
                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);
            } else {
                ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));
                if (parentName != null && parentName.replacementNode != null && parentName.replacementNode.getParent() != null) {
                    parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);
                }
            }
        }
        if (explicitNode != null) {
            explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
    }
}",4,0
105,Closure_94,"static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }","static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
        case Token.STRING:
        case Token.NUMBER:
        case Token.TRUE:
        case Token.FALSE:
            return true;

        // Binary operators are only valid if both children are valid.
        case Token.BITAND:
        case Token.BITOR:
        case Token.BITXOR:
            return isValidDefineValue(val.getFirstChild(), defines) &&
                   isValidDefineValue(val.getLastChild(), defines);
        
        // Unary operators are valid if the child is valid.
        case Token.BITNOT:
        case Token.NOT:
        case Token.NEG:
            return isValidDefineValue(val.getFirstChild(), defines);

        // Names are valid if and only if they are defines themselves.
        case Token.NAME:
        case Token.GETPROP:
            if (val.isQualifiedName()) {
                return defines.contains(val.getQualifiedName());
            }
    }
    return false;
}",0,0
105,Closure_94,"static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }","static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
        case Token.STRING:
        case Token.NUMBER:
        case Token.TRUE:
        case Token.FALSE:
            return true;

        // Binary operators are only valid if both children are valid.
        case Token.BITAND:
        case Token.BITOR:
        case Token.BITXOR:
            Node leftChild = val.getFirstChild();
            Node rightChild = leftChild.getNext();
            return isValidDefineValue(leftChild, defines) &&
                   isValidDefineValue(rightChild, defines);
        
        // Unary operators are valid if the child is valid.
        case Token.BITNOT:
        case Token.NOT:
        case Token.NEG:
            return isValidDefineValue(val.getFirstChild(), defines);

        // Names are valid if and only if they are defines themselves.
        case Token.NAME:
        case Token.GETPROP:
            if (val.isQualifiedName()) {
                return defines.contains(val.getQualifiedName());
            }
    }
    return false;
}",1,0
105,Closure_94,"static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }","static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;

      // Binary operators are only valid if both children are valid. Account for additional operators.
      case Token.BITAND:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.ADD:
      case Token.SUB:
      case Token.MUL:
      case Token.DIV:
         return isValidDefineValue(val.getFirstChild(), defines) &&
                isValidDefineValue(val.getLastChild(), defines);

      // Unary operators are valid if the child is valid.
      case Token.BITNOT:
      case Token.NOT:
      case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);

      // Consider simple node values such as null or undefined as valid
      case Token.NULL:
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName()) || val.getQualifiedName().equals(""undefined"");
        }
    }
    return false;
  }",2,0
105,Closure_94,"static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }","static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
        case Token.STRING:
        case Token.NUMBER:
        case Token.TRUE:
        case Token.FALSE:
            return true;

        // Binary operators are valid if both children are valid AND their resulting value is a constant.
        case Token.BITAND:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.ADD:
        case Token.SUB:
        case Token.MUL:
        case Token.DIV: 
            return  isConstant(val) && isValidDefineValue(val.getFirstChild(), defines) &&
                    isValidDefineValue(val.getLastChild(), defines);

        // Unary operators are valid if the child is valid.
        case Token.BITNOT:
        case Token.NOT:
        case Token.NEG:
            return isValidDefineValue(val.getFirstChild(), defines);
                
        // Names are valid if they are defined constants, consider implicit constants like NaN.
        case Token.NAME:
        case Token.GETPROP:
            if (val.isQualifiedName()) {
                return defines.contains(val.getQualifiedName()) ||
                        val.getQualifiedName().equals(""NaN"") || val.getQualifiedName().equals(""undefined"");
            }
    }
    return false;
}

// Helper method to check if node value can be evaluated as constant
private static boolean isConstant(Node val) {
    try {
        double result = evaluateNode(val);
        return !Double.isNaN(result);
    } catch (Exception ex) {
        return false;
    }
}

// Mock-up evaluateNode implementation to mimic constant evaluation
private static double evaluateNode(Node val) throws Exception {
    // Logic involving children nodes to evaluate constant value goes here
    // For instance, returning a mock constant value for demonstration
    return 1.0; 
}",3,0
105,Closure_94,"static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }","static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
         return true;

      // Binary operators are valid only if both children are constants or valid define values.
      case Token.BITAND:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.ADD:
      case Token.SUB:
      case Token.MUL:
      case Token.DIV:
         Node leftChild = val.getFirstChild();
         Node rightChild = leftChild.getNext(); // Use explicit navigation
         return isValidDefineValue(leftChild, defines) && isValidDefineValue(rightChild, defines);

      // Unary operators are valid if the child is valid
      case Token.BITNOT:
      case Token.NOT:
      case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);

      case Token.NAME:
      case Token.GETPROP:
        // Names are valid if and only if they are defines themselves, or are globally recognized keywords
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName()) || isGloballyRecognizedKeyword(val.getQualifiedName());
        }
    }
    return false;
}

// Helper method to check for globally recognized keywords
private static boolean isGloballyRecognizedKeyword(String name) {
  return ""undefined"".equals(name) || ""NaN"".equals(name);
}",4,0
106,Closure_95,"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
      Preconditions.checkArgument(inferred || type != null);

      // Only allow declarations of NAMEs and qualfied names.
      boolean shouldDeclareOnGlobalThis = false;
      if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
      } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
      }
      String variableName = n.getQualifiedName();
      Preconditions.checkArgument(!variableName.isEmpty());

      // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
      } else {
        if (!inferred) {
          setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
          ObjectType globalThis =
              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
          boolean isExtern = input.isExtern();
          if (inferred) {
            globalThis.defineInferredProperty(variableName,
                type == null ?
                    getNativeType(JSTypeNative.NO_TYPE) :
                    type,
                isExtern);
          } else {
            globalThis.defineDeclaredProperty(variableName, type, isExtern);
          }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
          FunctionType fnType = (FunctionType) type;
          if (fnType.isConstructor() || fnType.isInterface()) {
            FunctionType superClassCtor = fnType.getSuperClassConstructor();
            scopeToDeclareIn.declare(variableName + "".prototype"", n,
                fnType.getPrototype(), compiler.getInput(sourceName),
                /* declared iff there's an explicit supertype */
                superClassCtor == null ||
                superClassCtor.getInstanceType().equals(
                    getNativeType(OBJECT_TYPE)));
          }
        }
      }
    }","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);

    // Only allow declarations of NAMEs and qualified names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
    } else if (n.getType() == Token.GETPROP) {
        Preconditions.checkArgument(
            parent.getType() == Token.ASSIGN ||
            parent.getType() == Token.EXPR_RESULT);
    } else {
        throw new IllegalArgumentException(""Node type not supported for declaration"");
    }

    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());

    // If n is a property, then we should really declare it in the
    // scope where the root object appears. This helps out people
    // who declare ""global"" names in an anonymous namespace.
    Scope scopeToDeclareIn = scope;

    // Check if already declared in closest scope
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis =
                typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName,
                    (type == null ? getNativeType(JSTypeNative.NO_TYPE) : type),
                    isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n,
                    fnType.getPrototype(), compiler.getInput(sourceName),
                    /* declared iff there's an explicit supertype */
                    superClassCtor == null ||
                    superClassCtor.getInstanceType().equals(
                        getNativeType(OBJECT_TYPE)));
            }
        }
    }
}",0,0
106,Closure_95,"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
      Preconditions.checkArgument(inferred || type != null);

      // Only allow declarations of NAMEs and qualfied names.
      boolean shouldDeclareOnGlobalThis = false;
      if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
      } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
      }
      String variableName = n.getQualifiedName();
      Preconditions.checkArgument(!variableName.isEmpty());

      // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
      } else {
        if (!inferred) {
          setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
          ObjectType globalThis =
              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
          boolean isExtern = input.isExtern();
          if (inferred) {
            globalThis.defineInferredProperty(variableName,
                type == null ?
                    getNativeType(JSTypeNative.NO_TYPE) :
                    type,
                isExtern);
          } else {
            globalThis.defineDeclaredProperty(variableName, type, isExtern);
          }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
          FunctionType fnType = (FunctionType) type;
          if (fnType.isConstructor() || fnType.isInterface()) {
            FunctionType superClassCtor = fnType.getSuperClassConstructor();
            scopeToDeclareIn.declare(variableName + "".prototype"", n,
                fnType.getPrototype(), compiler.getInput(sourceName),
                /* declared iff there's an explicit supertype */
                superClassCtor == null ||
                superClassCtor.getInstanceType().equals(
                    getNativeType(OBJECT_TYPE)));
          }
        }
      }
    }","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);

    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());

    // Only allow declarations of NAMEs and qualified names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);
    } else if (n.getType() == Token.GETPROP) {
        Preconditions.checkArgument(
            parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT);
    } else {
        throw new IllegalArgumentException(""Node type not supported for declaration"");
    }

    // Need to check if the variable is already declared in the global scope
    Scope scopeToDeclareIn = scope;
    if (scopeToDeclareIn.isDeclared(variableName, true)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName,
                    type == null ? getNativeType(JSTypeNative.NO_TYPE) : type,
                    isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }

        // If we're in the global scope, also declare var.prototype in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n,
                    fnType.getPrototype(), compiler.getInput(sourceName),
                    superClassCtor == null || 
                    superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));
            }
        }
    }
}",1,0
106,Closure_95,"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
      Preconditions.checkArgument(inferred || type != null);

      // Only allow declarations of NAMEs and qualfied names.
      boolean shouldDeclareOnGlobalThis = false;
      if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
      } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
      }
      String variableName = n.getQualifiedName();
      Preconditions.checkArgument(!variableName.isEmpty());

      // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
      } else {
        if (!inferred) {
          setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
          ObjectType globalThis =
              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
          boolean isExtern = input.isExtern();
          if (inferred) {
            globalThis.defineInferredProperty(variableName,
                type == null ?
                    getNativeType(JSTypeNative.NO_TYPE) :
                    type,
                isExtern);
          } else {
            globalThis.defineDeclaredProperty(variableName, type, isExtern);
          }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
          FunctionType fnType = (FunctionType) type;
          if (fnType.isConstructor() || fnType.isInterface()) {
            FunctionType superClassCtor = fnType.getSuperClassConstructor();
            scopeToDeclareIn.declare(variableName + "".prototype"", n,
                fnType.getPrototype(), compiler.getInput(sourceName),
                /* declared iff there's an explicit supertype */
                superClassCtor == null ||
                superClassCtor.getInstanceType().equals(
                    getNativeType(OBJECT_TYPE)));
          }
        }
      }
    }","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);

    // Only allow declarations of NAMEs and qualified names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
    }
    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(!variableName.isEmpty());

    // Declare directly in global scope if it's a qualified name and not already declared
    Scope scopeToDeclareIn = scope;
    if (n.getType() == Token.GETPROP && scope.isGlobal() && !scopeToDeclareIn.isDeclared(variableName, false)) {
        scopeToDeclareIn.declare(variableName, n, type, compiler.getInput(sourceName), inferred);
        return;
    }

    // declared in closest scope?
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis =
                typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName,
                    type == null ?
                        getNativeType(JSTypeNative.NO_TYPE) :
                        type,
                    isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n,
                    fnType.getPrototype(), compiler.getInput(sourceName),
                    /* declared iff there's an explicit supertype */
                    superClassCtor == null ||
                    superClassCtor.getInstanceType().equals(
                        getNativeType(OBJECT_TYPE)));
            }
        }
    }
}",2,0
106,Closure_95,"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
      Preconditions.checkArgument(inferred || type != null);

      // Only allow declarations of NAMEs and qualfied names.
      boolean shouldDeclareOnGlobalThis = false;
      if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
      } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
      }
      String variableName = n.getQualifiedName();
      Preconditions.checkArgument(!variableName.isEmpty());

      // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
      } else {
        if (!inferred) {
          setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
          ObjectType globalThis =
              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
          boolean isExtern = input.isExtern();
          if (inferred) {
            globalThis.defineInferredProperty(variableName,
                type == null ?
                    getNativeType(JSTypeNative.NO_TYPE) :
                    type,
                isExtern);
          } else {
            globalThis.defineDeclaredProperty(variableName, type, isExtern);
          }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
          FunctionType fnType = (FunctionType) type;
          if (fnType.isConstructor() || fnType.isInterface()) {
            FunctionType superClassCtor = fnType.getSuperClassConstructor();
            scopeToDeclareIn.declare(variableName + "".prototype"", n,
                fnType.getPrototype(), compiler.getInput(sourceName),
                /* declared iff there's an explicit supertype */
                superClassCtor == null ||
                superClassCtor.getInstanceType().equals(
                    getNativeType(OBJECT_TYPE)));
          }
        }
      }
    }","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);

    // Define the behavior for NAME nodes
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));
    }
    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(!variableName.isEmpty());

    // Use a different strategy to handle qualified names
    Scope scopeToDeclareIn = n.getType() == Token.GETPROP ? findEnclosingScope(n) : scope;

    // Check if already declared within the chosen scope
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis =
                typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName,
                    type == null ? getNativeType(JSTypeNative.NO_TYPE) : type,
                    isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }

        // Handle global scope declarations for function types
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n,
                    fnType.getPrototype(), compiler.getInput(sourceName),
                    superClassCtor == null ||
                    superClassCtor.getInstanceType().equals(
                        getNativeType(OBJECT_TYPE)));
            }
        }
    }
}

// Utility method to find enclosing scope for a particular node, handling the new logic
private Scope findEnclosingScope(Node n) {
    Node rootObject = n.getFirstChild();
    while (rootObject != null && rootObject.getType() != Token.NAME) {
        rootObject = rootObject.getFirstChild();
    }
    String rootName = rootObject.getQualifiedName();
    return scope.getClosestScopeOfSymbol(rootName);
}",3,0
106,Closure_95,"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
      Preconditions.checkArgument(inferred || type != null);

      // Only allow declarations of NAMEs and qualfied names.
      boolean shouldDeclareOnGlobalThis = false;
      if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR ||
             parent.getType() == Token.FUNCTION);
      } else {
        Preconditions.checkArgument(
            n.getType() == Token.GETPROP &&
            (parent.getType() == Token.ASSIGN ||
             parent.getType() == Token.EXPR_RESULT));
      }
      String variableName = n.getQualifiedName();
      Preconditions.checkArgument(!variableName.isEmpty());

      // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
      } else {
        if (!inferred) {
          setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
          ObjectType globalThis =
              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
          boolean isExtern = input.isExtern();
          if (inferred) {
            globalThis.defineInferredProperty(variableName,
                type == null ?
                    getNativeType(JSTypeNative.NO_TYPE) :
                    type,
                isExtern);
          } else {
            globalThis.defineDeclaredProperty(variableName, type, isExtern);
          }
        }

        // If we're in the global scope, also declare var.prototype
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
          FunctionType fnType = (FunctionType) type;
          if (fnType.isConstructor() || fnType.isInterface()) {
            FunctionType superClassCtor = fnType.getSuperClassConstructor();
            scopeToDeclareIn.declare(variableName + "".prototype"", n,
                fnType.getPrototype(), compiler.getInput(sourceName),
                /* declared iff there's an explicit supertype */
                superClassCtor == null ||
                superClassCtor.getInstanceType().equals(
                    getNativeType(OBJECT_TYPE)));
          }
        }
      }
    }","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);

    // Only allow declarations of NAMEs and qualified names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(
            parent.getType() == Token.FUNCTION ||
            parent.getType() == Token.VAR ||
            parent.getType() == Token.LP ||
            parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() &&
            (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);
    } else if (n.getType() == Token.GETPROP) {
        Preconditions.checkArgument(
            parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT);

        // Specialized handling for GETPROP nodes: Declare in global scope if not already declared
        String rootName = n.getFirstChild().getQualifiedName();
        Scope globalScope = scope.getGlobalScope();
        if (!globalScope.isDeclared(rootName, false)) {
            globalScope.declare(rootName, n.getFirstChild(), null, compiler.getInput(sourceName), true);
        }
    } else {
        throw new IllegalArgumentException(""Node type not supported for declaration"");
    }

    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());

    // Check for declaration in the closest scope
    Scope scopeToDeclareIn = scope;
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(
            sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);

        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName,
                    type == null ? getNativeType(JSTypeNative.NO_TYPE) : type,
                    isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }

        // Handle global scope declarations for function types
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n,
                    fnType.getPrototype(), compiler.getInput(sourceName),
                    superClassCtor == null || 
                    superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));
            }
        }
    }
}",4,0
107,Closure_96,"private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
            parameters.hasNext()) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
         parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
      validator.expectArgumentMatchesParameter(t, argument,
          getJSType(argument), getJSType(parameter), call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
      report(t, call, WRONG_ARGUMENT_COUNT,
              validator.getReadableJSTypeName(call.getFirstChild(), false),
              String.valueOf(numArgs), String.valueOf(minArgs),
              maxArgs != Integer.MAX_VALUE ?
              "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
  }","private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
    Node parameter = null;
    Node argument = null;
    while (arguments.hasNext() &&
            parameters.hasNext()) {
        parameter = parameters.next();
        argument = arguments.next();
        ordinal++;

        validator.expectArgumentMatchesParameter(t, argument,
            getJSType(argument), getJSType(parameter), call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (numArgs < minArgs || numArgs > maxArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT,
                validator.getReadableJSTypeName(call.getFirstChild(), false),
                String.valueOf(numArgs), String.valueOf(minArgs),
                maxArgs != Integer.MAX_VALUE ?
                "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}",0,0
107,Closure_96,"private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
            parameters.hasNext()) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
         parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
      validator.expectArgumentMatchesParameter(t, argument,
          getJSType(argument), getJSType(parameter), call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
      report(t, call, WRONG_ARGUMENT_COUNT,
              validator.getReadableJSTypeName(call.getFirstChild(), false),
              String.valueOf(numArgs), String.valueOf(minArgs),
              maxArgs != Integer.MAX_VALUE ?
              "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
  }","private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
    Node parameter = null;
    Node argument = null;

    while (arguments.hasNext()) {
        if (parameters.hasNext()) {
            parameter = parameters.next();
        } else {
            parameter = null; // for var_args function with extra arguments
        }
        argument = arguments.next();
        ordinal++;

        JSType paramType = parameter != null ? getJSType(parameter) : functionType.getTypeOfVarArgs();
        validator.expectArgumentMatchesParameter(t, argument,
            getJSType(argument), paramType, call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (numArgs < minArgs || numArgs > maxArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT,
                validator.getReadableJSTypeName(call.getFirstChild(), false),
                String.valueOf(numArgs), String.valueOf(minArgs),
                maxArgs != Integer.MAX_VALUE ?
                "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}",1,0
107,Closure_96,"private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
            parameters.hasNext()) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
         parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
      validator.expectArgumentMatchesParameter(t, argument,
          getJSType(argument), getJSType(parameter), call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
      report(t, call, WRONG_ARGUMENT_COUNT,
              validator.getReadableJSTypeName(call.getFirstChild(), false),
              String.valueOf(numArgs), String.valueOf(minArgs),
              maxArgs != Integer.MAX_VALUE ?
              "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
  }","private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
    Node parameter = null;
    Node argument = null;
    while (arguments.hasNext()) {
        if (parameters.hasNext()) {
            parameter = parameters.next();
        } else {
            // Assuming var_args applies
            parameter = null; 
        }
        argument = arguments.next();
        ordinal++;

        JSType paramType = parameter != null ? getJSType(parameter) : functionType.getTypeOfVarArgs();
        validator.expectArgumentMatchesParameter(t, argument,
            getJSType(argument), paramType, call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if ((numArgs < minArgs || numArgs > maxArgs) && parameter == null) {
        report(t, call, WRONG_ARGUMENT_COUNT,
                validator.getReadableJSTypeName(call.getFirstChild(), false),
                String.valueOf(numArgs), String.valueOf(minArgs),
                maxArgs != Integer.MAX_VALUE ?
                "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}",2,0
107,Closure_96,"private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
            parameters.hasNext()) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
         parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
      validator.expectArgumentMatchesParameter(t, argument,
          getJSType(argument), getJSType(parameter), call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
      report(t, call, WRONG_ARGUMENT_COUNT,
              validator.getReadableJSTypeName(call.getFirstChild(), false),
              String.valueOf(numArgs), String.valueOf(minArgs),
              maxArgs != Integer.MAX_VALUE ?
              "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
  }","private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
    Node parameter = null;
    Node argument = null;
    while (arguments.hasNext()) {
        argument = arguments.next();
        if (parameters.hasNext()) {
            parameter = parameters.next();
            JSType paramType = getJSType(parameter);
            validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), paramType, call, ordinal);
        } else {
            JSType varArgsType = functionType.getTypeOfVarArgs();
            validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), varArgsType, call, ordinal);
        }
        ordinal++;
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (numArgs < minArgs || numArgs > maxArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT,
                validator.getReadableJSTypeName(call.getFirstChild(), false),
                String.valueOf(numArgs), String.valueOf(minArgs),
                maxArgs != Integer.MAX_VALUE ?
                "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}",3,0
107,Closure_96,"private void visitParameterList(NodeTraversal t, Node call,
      FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
            parameters.hasNext()) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
         parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
      validator.expectArgumentMatchesParameter(t, argument,
          getJSType(argument), getJSType(parameter), call, ordinal);
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
      report(t, call, WRONG_ARGUMENT_COUNT,
              validator.getReadableJSTypeName(call.getFirstChild(), false),
              String.valueOf(numArgs), String.valueOf(minArgs),
              maxArgs != Integer.MAX_VALUE ?
              "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
  }","private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    arguments.next(); // skip the function name

    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
    Node argument = null;
    while (arguments.hasNext()) {
        argument = arguments.next();
        ordinal++;

        if (parameters.hasNext()) {
            Node parameter = parameters.next();
            validator.expectArgumentMatchesParameter(t, argument,
                    getJSType(argument), getJSType(parameter), call, ordinal);
        } else {
            // Handle extra arguments for functions supporting var_args
            JSType varArgsType = functionType.getTypeOfVarArgs();
            validator.expectArgumentMatchesParameter(t, argument,
                    getJSType(argument), varArgsType, call, ordinal);
        }
    }

    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    if (numArgs < minArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT,
                validator.getReadableJSTypeName(call.getFirstChild(), false),
                String.valueOf(numArgs), String.valueOf(minArgs),
                "" and no fewer than "" + minArgs + "" argument(s)"");
    }
}",4,0
108,Closure_97,"private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

      double result;
      double lval = left.getDouble();
      double rval = right.getDouble();

      // check ranges.  We do not do anything that would clip the double to
      // a 32-bit range, since the user likely does not intend that.
      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
      }

      // only the lower 5 bits are used when shifting, so don't do anything
      // if the shift amount is outside [0,32)
      if (!(rval >= 0 && rval < 32)) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
      }

      // Convert the numbers to ints
      int lvalInt = (int) lval;
      if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
      }

      int rvalInt = (int) rval;
      if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
      }

      switch (n.getType()) {
        case Token.LSH:
          result = lvalInt << rvalInt;
          break;
        case Token.RSH:
          result = lvalInt >> rvalInt;
          break;
        case Token.URSH:
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
              Node.tokenToName(n.getType()));
      }

      Node newNumber = Node.newNumber(result);
      n.getParent().replaceChild(n, newNumber);
      reportCodeChange();

      return newNumber;
    }

    return n;
  }","private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {

        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();

        // check ranges.  We do not do anything that would clip the double to
        // a 32-bit range, since the user likely does not intend that.
        if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
            error(BITWISE_OPERAND_OUT_OF_RANGE, left);
            return n;
        }

        // only the lower 5 bits are used when shifting, so don't do anything
        // if the shift amount is outside [0,32)
        if (!(rval >= 0 && rval < 32)) {
            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return n;
        }

        // Convert the numbers to ints
        int lvalInt = (int) lval;
        if ((double) lvalInt != lval) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }

        int rvalInt = (int) rval;
        if ((double) rvalInt != rval) {
            error(FRACTIONAL_BITWISE_OPERAND, right);
            return n;
        }

        switch (n.getType()) {
            case Token.LSH:
                result = lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                result = lvalInt >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" +
                        Node.tokenToName(n.getType()));
        }

        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();

        return newNumber;
    }

    return n;
}",0,0
108,Closure_97,"private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

      double result;
      double lval = left.getDouble();
      double rval = right.getDouble();

      // check ranges.  We do not do anything that would clip the double to
      // a 32-bit range, since the user likely does not intend that.
      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
      }

      // only the lower 5 bits are used when shifting, so don't do anything
      // if the shift amount is outside [0,32)
      if (!(rval >= 0 && rval < 32)) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
      }

      // Convert the numbers to ints
      int lvalInt = (int) lval;
      if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
      }

      int rvalInt = (int) rval;
      if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
      }

      switch (n.getType()) {
        case Token.LSH:
          result = lvalInt << rvalInt;
          break;
        case Token.RSH:
          result = lvalInt >> rvalInt;
          break;
        case Token.URSH:
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
              Node.tokenToName(n.getType()));
      }

      Node newNumber = Node.newNumber(result);
      n.getParent().replaceChild(n, newNumber);
      reportCodeChange();

      return newNumber;
    }

    return n;
  }","private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {

        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();

        // Convert the numbers to ints
        int lvalInt = (int) lval;
        int rvalInt = (int) rval;

        // Check if left operand conversion changes the value
        if (((double) lvalInt != lval) || !(lvalInt >= Integer.MIN_VALUE && lvalInt <= Integer.MAX_VALUE)) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }

        // Check if right operand conversion changes the value
        if (((double) rvalInt != rval) || !(rvalInt >= 0 && rvalInt < 32)) {
            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return n;
        }

        switch (n.getType()) {
            case Token.LSH:
                result = lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                result = ((long) lvalInt & 0xffffffffL) >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" +
                        Node.tokenToName(n.getType()));
        }

        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();

        return newNumber;
    }

    return n;
}",1,0
108,Closure_97,"private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

      double result;
      double lval = left.getDouble();
      double rval = right.getDouble();

      // check ranges.  We do not do anything that would clip the double to
      // a 32-bit range, since the user likely does not intend that.
      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
      }

      // only the lower 5 bits are used when shifting, so don't do anything
      // if the shift amount is outside [0,32)
      if (!(rval >= 0 && rval < 32)) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
      }

      // Convert the numbers to ints
      int lvalInt = (int) lval;
      if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
      }

      int rvalInt = (int) rval;
      if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
      }

      switch (n.getType()) {
        case Token.LSH:
          result = lvalInt << rvalInt;
          break;
        case Token.RSH:
          result = lvalInt >> rvalInt;
          break;
        case Token.URSH:
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
              Node.tokenToName(n.getType()));
      }

      Node newNumber = Node.newNumber(result);
      n.getParent().replaceChild(n, newNumber);
      reportCodeChange();

      return newNumber;
    }

    return n;
  }","private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {

        double lval = left.getDouble();
        double rval = right.getDouble();

        // Ensure lval is within 32-bit signed integer range and rval is non-negative before conversion to int
        if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < 0) {
            error(BITWISE_OPERAND_OUT_OF_RANGE, left);
            return n;
        }

        // Convert the numbers to ints with additional checks for both operands
        int lvalInt = (int) lval;
        int rvalInt = (int) rval;

        if (lvalInt != lval || rvalInt != rval) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }

        double result = 0;

        switch (n.getType()) {
            case Token.LSH:
                result = (double)(lvalInt << rvalInt);
                break;
            case Token.RSH:
                result = (double)(lvalInt >> rvalInt);
                break;
            case Token.URSH:
                result = (double)((lvalInt & 0xffffffff) >>> rvalInt);
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" + Node.tokenToName(n.getType()));
        }

        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();

        return newNumber;
    }

    return n;
}",2,0
108,Closure_97,"private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

      double result;
      double lval = left.getDouble();
      double rval = right.getDouble();

      // check ranges.  We do not do anything that would clip the double to
      // a 32-bit range, since the user likely does not intend that.
      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
      }

      // only the lower 5 bits are used when shifting, so don't do anything
      // if the shift amount is outside [0,32)
      if (!(rval >= 0 && rval < 32)) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
      }

      // Convert the numbers to ints
      int lvalInt = (int) lval;
      if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
      }

      int rvalInt = (int) rval;
      if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
      }

      switch (n.getType()) {
        case Token.LSH:
          result = lvalInt << rvalInt;
          break;
        case Token.RSH:
          result = lvalInt >> rvalInt;
          break;
        case Token.URSH:
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
              Node.tokenToName(n.getType()));
      }

      Node newNumber = Node.newNumber(result);
      n.getParent().replaceChild(n, newNumber);
      reportCodeChange();

      return newNumber;
    }

    return n;
  }","private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();

        // Convert the numbers to ints before doing checks
        int lvalInt = (int) lval;
        int rvalInt = (int) rval;

        // Ensure the conversion is correct and values are within required ranges
        if ((double) lvalInt != lval || !(lvalInt >= Integer.MIN_VALUE && lvalInt <= Integer.MAX_VALUE)) {
            error(BITWISE_OPERAND_OUT_OF_RANGE, left);
            return n;
        }

        if ((double) rvalInt != rval || !(rvalInt >= 0 && rvalInt < 32)) {
            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return n;
        }

        // Perform the shift operation
        switch (n.getType()) {
            case Token.LSH:
                result = lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                // Use unsigned long shift to mimic JavaScript behavior for URSH
                result = ((long) lvalInt & 0xffffffffL) >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" +
                        Node.tokenToName(n.getType()));
        }

        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();

        return newNumber;
    }

    return n;
}",3,0
108,Closure_97,"private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER &&
        right.getType() == Token.NUMBER) {

      double result;
      double lval = left.getDouble();
      double rval = right.getDouble();

      // check ranges.  We do not do anything that would clip the double to
      // a 32-bit range, since the user likely does not intend that.
      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
        error(BITWISE_OPERAND_OUT_OF_RANGE, left);
        return n;
      }

      // only the lower 5 bits are used when shifting, so don't do anything
      // if the shift amount is outside [0,32)
      if (!(rval >= 0 && rval < 32)) {
        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
        return n;
      }

      // Convert the numbers to ints
      int lvalInt = (int) lval;
      if (lvalInt != lval) {
        error(FRACTIONAL_BITWISE_OPERAND, left);
        return n;
      }

      int rvalInt = (int) rval;
      if (rvalInt != rval) {
        error(FRACTIONAL_BITWISE_OPERAND, right);
        return n;
      }

      switch (n.getType()) {
        case Token.LSH:
          result = lvalInt << rvalInt;
          break;
        case Token.RSH:
          result = lvalInt >> rvalInt;
          break;
        case Token.URSH:
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
              Node.tokenToName(n.getType()));
      }

      Node newNumber = Node.newNumber(result);
      n.getParent().replaceChild(n, newNumber);
      reportCodeChange();

      return newNumber;
    }

    return n;
  }","private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {

        double lval = left.getDouble();
        double rval = right.getDouble();

        // Early return for fractional numbers instead of range check
        if (lval != (int) lval || rval != (int) rval) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }

        int lvalInt = (int) lval;
        int rvalInt = (int) rval;

        // Perform the operation based on the type, handling unsigned right shift separately
        double result;
        switch (n.getType()) {
            case Token.LSH:
                result = (double)(lvalInt << rvalInt);
                break;
            case Token.RSH:
                result = (double)(lvalInt >> rvalInt);
                break;
            case Token.URSH:
                // Apply mask to avoid sign extension in unsigned right shift
                result = (double)((lvalInt & 0xffffffff) >>> rvalInt);
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" + Node.tokenToName(n.getType()));
        }

        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();

        return newNumber;
    }

    return n;
}",4,0
109,Closure_99,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
            return false;
          }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN ||
            pType == Token.EXPR_RESULT)) {
        return false;
      }
    }
  
    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (lhs.getType() == Token.GETPROP &&
            ""prototype"".equals(lhs.getLastChild().getString())) {
          return false;
        }
        if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
          return false;
        }
      }
    }

    return true;
}",0,0
109,Closure_99,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
            return false;
          }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || pType == Token.EXPR_RESULT)) {
            return false;
        }
        
        // Additional check based on node properties
        if (hasPrototypeProperty(n)) {
            return false;
        }
    }
    
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        
        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            if (lhs.getType() == Token.GETPROP && ""prototype"".equals(lhs.getLastChild().getString())) {
                return false;
            }
            if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
                return false;
            }
        }
    }
    
    return true;
}

// Utility method to check property prototype presence
private boolean hasPrototypeProperty(Node node) {
    Node prop = node.getFirstChild();
    while (prop != null) {
        if (""prototype"".equals(prop.getString())) {
            return true;
        }
        prop = prop.getNext();
    }
    return false;
}",1,0
109,Closure_99,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
            return false;
          }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }
      
      // Check if the node is directly within a prototype assignment
      Node grandparent = parent.getParent();
      if (grandparent != null && grandparent.getType() == Token.EXPR_RESULT) {
        Node expr = grandparent.getFirstChild();
        if (expr != null && expr.getType() == Token.GETPROP && ""prototype"".equals(expr.getLastChild().getString())) {
          return false;
        }
      }

      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      
      if (n == lhs) {
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Traverse the right side only if it's not directly modifying a prototype property's subproperty.
        if (isPrototypeAssignment(lhs)) {
          return false;
        }
      }
    }

    return true;
  }

private boolean isPrototypeAssignment(Node lhs) {
    if (lhs == null) {
        return false;
    }
    if (lhs.getType() == Token.GETPROP) {
        Node last = lhs.getLastChild();
        if (last != null && ""prototype"".equals(last.getString())) {
            return true;
        }
    }
    String qualifiedName = lhs.getQualifiedName();
    return qualifiedName != null && qualifiedName.contains("".prototype."");
}",2,0
109,Closure_99,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
            return false;
          }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }

        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {
            return false;
        }

        // Additional logic to prevent traversal of functions in certain prototype constructions
        if (parent.getType() == Token.EXPR_RESULT) {
            Node expr = parent.getFirstChild();
            if (expr != null && expr.getType() == Token.GETPROP) {
                Node propName = expr.getLastChild();
                if (propName != null && ""prototype"".equals(propName.getString())) {
                    return false;
                }
            }
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();

        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                return false;
            }
            if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
                return false;
            }
        }
    }

    return true;
}

// Utility Method
private boolean isPrototypeAssignment(Node node) {
    Node prop = node.getFirstChild();
    while (prop != null) {
        if (""prototype"".equals(prop.getString())) {
            return true;
        }
        prop = prop.getNext();
    }
    return false;
}",3,0
109,Closure_99,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
            return false;
          }
      }
    }

    return true;
  }","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        
        // Add logic to prevent traversal if function belongs to class prototype
        if (parent.getType() == Token.EXPR_RESULT && isPrototypeAssignment(parent.getFirstChild())) {
            return false;
        }
        
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {
            return false;
        }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        
        if (n == lhs) {
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // Prevent traversal on prototype property assignments
            if (isPrototypeAssignment(lhs)) {
                return false;
            }
        }
    }

    return true;
}

// Helper method to check proto assignments
private boolean isPrototypeAssignment(Node node) {
    if (node.getType() == Token.GETPROP) {
        String qualifiedName = node.getQualifiedName();
        if (qualifiedName != null && qualifiedName.contains("".prototype."")) {
            return true;
        }
    }
    return false;
}",4,0
110,Lang_1,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
             if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
             if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

        //Must be a Float, Double, BigDecimal
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        try {
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int prefixLength = 0;
    for (final String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            prefixLength = prefix.length();
            break;
        }
    }

    if (prefixLength > 0) {
        final int hexDigits = str.length() - prefixLength;
        if (hexDigits > 16) {
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            return createLong(str);
        }
        return createInteger(str);
    }

    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    final int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    int numDecimals = 0;
    if (decPos > -1) {
        if (expPos > -1 && expPos < decPos) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }

        if (expPos > -1) {
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        numDecimals = dec.length();
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }

        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");

            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                }
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                }

                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (dec == null && exp == null) {
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        }
        return createBigInteger(str);
    }

    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        if (numDecimals <= 7) {
            final Float f = createFloat(str);
            if (!(f.isInfinite() || (f == 0.0F && !allZeros))) {
                return f;
            }
        }
    } catch (final NumberFormatException nfe) {
    }
    try {
        if (numDecimals <= 16) {
            final Double d = createDouble(str);
            if (!(d.isInfinite() || (d == 0.0D && !allZeros))) {
                return d;
            }
        }
    } catch (final NumberFormatException nfe) {
    }

    return createBigDecimal(str);
}",0,0
110,Lang_1,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
             if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
             if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

        //Must be a Float, Double, BigDecimal
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        try {
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int prefixLength = 0;
    for (final String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            prefixLength = prefix.length();
            break;
        }
    }

    if (prefixLength > 0) {
        final int hexDigits = str.length() - prefixLength;
        if (hexDigits > 16) {
            return createBigInteger(str.substring(prefixLength));
        }
        if (hexDigits > 8) {
            return createLong(str.substring(prefixLength));
        }
        return createInteger(str.substring(prefixLength));
    }

    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;

    int numDecimals = 0;
    if (decPos > -1) {
        if (expPos > -1 && expPos < decPos) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }

        if (expPos > -1) {
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        numDecimals = dec.length();
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }

        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");

            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                }
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                }

                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (dec == null && exp == null) {
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        }
        return createBigInteger(str);
    }

    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        if (numDecimals <= 7) {
            final Float f = createFloat(str);
            if (!(f.isInfinite() || (f == 0.0F && !allZeros))) {
                return f;
            }
        }
    } catch (final NumberFormatException nfe) {
    }
    try {
        if (numDecimals <= 16 || exp != null) {
            final Double d = createDouble(str);
            if (!(d.isInfinite() || (d == 0.0D && !allZeros))) {
                return d;
            }
        }
    } catch (final NumberFormatException nfe) {
    }

    return createBigDecimal(str);
}",1,0
110,Lang_1,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
             if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
             if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

        //Must be a Float, Double, BigDecimal
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        try {
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int prefixLength = 0;
    for (final String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            prefixLength = prefix.length();
            str = str.substring(prefixLength);
            break;
        }
    }

    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    int expPos = str.indexOf('e');
    if (expPos == -1) {
        expPos = str.indexOf('E');
    }

    if (decPos > -1) {
        if (expPos > -1) {
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        mant = expPos > -1 ? str.substring(0, expPos) : str;
        dec = null;
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        final String numeric = str.substring(0, str.length() - 1);
        switch (lastChar) {
            case 'l':
            case 'L':
                try {
                    return createLong(numeric);
                } catch (final NumberFormatException nfe) {
                    return createBigInteger(numeric);
                }
            case 'f':
            case 'F':
                try {
                    return NumberUtils.createFloat(numeric);
                } catch (final NumberFormatException nfe) {
                }
                try {
                    return NumberUtils.createDouble(numeric);
                } catch (final NumberFormatException nfe) {
                }
                return createBigDecimal(numeric);
            case 'd':
            case 'D':
                try {
                    return NumberUtils.createDouble(numeric);
                } catch (final NumberFormatException nfe) {
                }
                return createBigDecimal(numeric);
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (dec == null && exp == null) {
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        }
        return createBigInteger(str);
    }

    try {
        return createDouble(str);
    } catch (final NumberFormatException nfe) {
    }
    return createBigDecimal(str);
}",2,0
110,Lang_1,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
             if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
             if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

        //Must be a Float, Double, BigDecimal
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        try {
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int prefixLength = 0;
    for (final String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            prefixLength = prefix.length();
            str = str.substring(prefixLength);
            break;
        }
    }

    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    int expPosE = str.indexOf('e');
    int expPosECap = str.indexOf('E');
    int expPos = (expPosE > -1) ? expPosE : expPosECap;

    if (decPos > -1) {
        if (expPos > decPos) {
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        mant = expPos > -1 ? str.substring(0, expPos) : str;
        dec = null;
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        final String numeric = str.substring(0, str.length() - 1);
        switch (lastChar) {
            case 'l':
            case 'L':
                try {
                    return createLong(numeric);
                } catch (final NumberFormatException nfe) {
                    return createBigInteger(numeric);
                }
            case 'f':
            case 'F':
                try {
                    return NumberUtils.createFloat(numeric);
                } catch (final NumberFormatException nfe) {
                }
                try {
                    return NumberUtils.createDouble(numeric);
                } catch (final NumberFormatException nfe) {
                }
                return createBigDecimal(numeric);
            case 'd':
            case 'D':
                try {
                    return NumberUtils.createDouble(numeric);
                } catch (final NumberFormatException nfe) {
                }
                return createBigDecimal(numeric);
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (dec == null && exp == null) {
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        }
        return createBigInteger(str);
    }

    try {
        return createDouble(str);
    } catch (final NumberFormatException nfe) {
    }
    return createBigDecimal(str);
}",3,0
110,Lang_1,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
             if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
             if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

        //Must be a Float, Double, BigDecimal
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        try {
            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }",Match failed,4,0
111,Lang_10,"    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
        boolean wasWhite= false;
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
            regex.append(c);
        }
        return regex;
    }
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*+"");
            }
            continue;
        }
        wasWhite = false;
        switch (c) {
            case '\'':
                if (unquote) {
                    if (++i == value.length()) {
                        continue;
                    }
                    c = value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
        }
        regex.append(c);
    }
    return regex;
}",0,0
111,Lang_10,"    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
        boolean wasWhite= false;
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
            regex.append(c);
        }
        return regex;
    }
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    boolean inQuote = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        
        if (unquote && c == '\'') {
            inQuote = !inQuote;
            continue;
        }
        
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*+"");
            }
            continue;
        }
        wasWhite = false;
        
        if (!inQuote) {
            switch (c) {
                case '?':
                case '[':
                case ']':
                case '(':
                case ')':
                case '{':
                case '}':
                case '\\':
                case '|':
                case '*':
                case '+':
                case '^':
                case '$':
                case '.':
                    regex.append('\\');
            }
        }
        
        regex.append(c);
    }
    return regex;
}",1,0
111,Lang_10,"    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
        boolean wasWhite= false;
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
            regex.append(c);
        }
        return regex;
    }
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite= false;
    boolean inQuote = false;
    for(int i= 0; i<value.length(); ++i) {
        char c= value.charAt(i);
        
        if (unquote && c == '\'') {
            inQuote = !inQuote;
            continue;
        }
        
        if(Character.isWhitespace(c)) {
            if(!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*+"");
            }
            continue;
        }
        wasWhite = false;

        if (!inQuote) {
            switch(c) {
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
        }
        regex.append(c);
    }
    return regex;
}",2,0
111,Lang_10,"    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
        boolean wasWhite= false;
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
            regex.append(c);
        }
        return regex;
    }
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s+"");
            }
            continue;
        }
        wasWhite = false;
        if (c == '\'' && unquote) {
            if (++i < value.length()) {
                c = value.charAt(i);
            } else {
                break;
            }
        }
        switch (c) {
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+' :
            case '^':
            case '$':
            case '.':
                regex.append('\\');
        }
        regex.append(c);
    }
    return regex;
}",3,0
111,Lang_10,"    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
        boolean wasWhite= false;
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
            }
            regex.append(c);
        }
        return regex;
    }
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        if(Character.isWhitespace(c)) {
            if(!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*"");
            }
            continue;
        }
        wasWhite = false;
        if(c == '\'' && unquote) {
            if (++i < value.length()) {
                c = value.charAt(i);
            } else {
                break;
            }
        }
        else if (""?[](){}\\|*+^$."".indexOf(c) != -1) {
                regex.append('\\');
        }
        regex.append(c);
    }
    return regex;
}",4,0
112,Lang_11,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                    start = ' ';
                }
            }
        }

        if(end <= start) {
            throw new IllegalArgumentException(""End must be greater than start"");
        }

        char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if ((letters && Character.isLetter(ch))
                    || (numbers && Character.isDigit(ch))
                    || (!letters && !numbers)) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }",0,0
112,Lang_11,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }
    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    }
    if (end <= start) {
        throw new IllegalArgumentException(""End must be greater than start"");
    }

    char[] buffer = new char[count];
    int gap = end - start;

    for (int i = 0; i < count; i++) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(chars.length)];
        }
        if ((letters && Character.isLetter(ch)) || (numbers && Character.isDigit(ch)) || (!letters && !numbers)) {
            buffer[i] = ch;
        } else {
            i--; // retry this iteration
        }
    }
    return new String(buffer);
}",1,0
112,Lang_11,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }
    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    }
    if (end <= start) {
        throw new IllegalArgumentException(""End must be greater than start"");
    }

    char[] buffer = new char[count];
    int gap = end - start;

    for (int i = 0; i < count; i++) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(chars.length)];
        }
        if ((letters && Character.isLetter(ch)) || (numbers && Character.isDigit(ch)) || (!letters && !numbers)) {
            buffer[i] = ch;
        } else {
            buffer[i] = (char) (random.nextInt(gap) + start);  // Ensure new character falls within start-end range
            i--;  // retry this iteration for valid character
        }
    }
    return new String(buffer);
}",2,0
112,Lang_11,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }
    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    }
    if (end <= start) {
        throw new IllegalArgumentException(""End must be greater than start"");
    }

    char[] buffer = new char[count];
    int gap = end - start;

    for (int i = 0; i < count; i++) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(chars.length)];
        }
        if ((letters && Character.isLetter(ch)) || (numbers && Character.isDigit(ch)) || (!letters && !numbers)) {
            if (Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch)) {
                i--; // retry to avoid surrogate code points
            } else {
                buffer[i] = ch;
            }
        } else {
            i--; // retry this iteration
        }
    }
    return new String(buffer);
}",3,0
112,Lang_11,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
        } else if (count < 0) {
            throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
        }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }

        if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                if (!letters && !numbers) {
                    end = Integer.MAX_VALUE;
                } else {
                    end = 'z' + 1;
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }

    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    }

    if (end <= start) {
        throw new IllegalArgumentException(""End must be greater than start"");
    }

    char[] buffer = new char[count];
    int gap = end - start;

    while (count-- != 0) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(chars.length)];
        }
        if ((letters && Character.isLetter(ch)) || (numbers && Character.isDigit(ch)) || (!letters && !numbers)) {
            buffer[count] = ch;
        } else {
            count++;
        }
    }
    return new String(buffer);
}",4,0
113,Lang_12,"public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
 
         if (start == 0 && end == 0) {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
         }
 
         char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if (letters && Character.isLetter(ch)
                    || numbers && Character.isDigit(ch)
                    || !letters && !numbers) {
                if(ch >= 56320 && ch <= 57343) {
                    if(count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random.nextInt(128));
                    }
                } else if(ch >= 55296 && ch <= 56191) {
                    if(count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random.nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if(ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }","public static String random(int count, int start, int end, boolean letters, boolean numbers,
                                char[] chars, Random random) {
        if (count == 0) {
            return """";
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
 
         if (start == 0 && end == 0) {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
         }
 
         char[] buffer = new char[count];
         int gap = end - start;

         while (count-- > 0) {
             char ch;
             if (chars == null) {
                 ch = (char) (random.nextInt(gap) + start);
             } else {
                 ch = chars[random.nextInt(chars.length)];
             }
             if (letters && Character.isLetter(ch)
                     || numbers && Character.isDigit(ch)
                     || !letters && !numbers) {
                 if (ch >= 56320 && ch <= 57343) {
                     if (count == 0) {
                         count++;
                     } else {
                         // low surrogate, insert high surrogate after putting it in
                         buffer[count] = ch;
                         count--;
                         buffer[count] = (char) (55296 + random.nextInt(128));
                     }
                 } else if (ch >= 55296 && ch <= 56191) {
                     if (count == 0) {
                         count++;
                     } else {
                         // high surrogate, insert low surrogate before putting it in
                         buffer[count] = (char) (56320 + random.nextInt(128));
                         count--;
                         buffer[count] = ch;
                     }
                 } else if (ch >= 56192 && ch <= 56319) {
                     // private high surrogate, no effing clue, so skip it
                     count++;
                 } else {
                     buffer[count] = ch;
                 }
             } else {
                 count++;
             }
         }
         return new String(buffer);
     }",0,0
114,Lang_14,"public static boolean equals(CharSequence cs1, CharSequence cs2) {
        if (cs1 == cs2) {
            return true;
        }
         if (cs1 == null || cs2 == null) {
             return false;
         }
             return cs1.equals(cs2);
     }","public static boolean equals(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    // Ensure comparison accounts for CharSequence specifics
    if (cs1.length() != cs2.length()) {
        return false;
    }
    for (int i = 0; i < cs1.length(); i++) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            return false;
        }
    }
    return true;
}",0,0
115,Lang_16,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
             // a wrong value.
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null; // Invalid format protection
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        try {
            return createBigInteger(str); // Handle hexadecimal properly
        } catch (NumberFormatException e) {
            throw new NumberFormatException(str + "" is not a valid number.""); // Invalid hexadecimal
        }
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E')); // Correct handling of 'e'/'E'
    
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null &&
                    (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore and proceed
                }
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // Ignore and proceed
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // Ignore and proceed
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe2) {
                    return createBigInteger(str);
                }
            }
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // Ignore and proceed
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // Ignore and proceed
            }
            return createBigDecimal(str);
        }
    }
}",0,0
115,Lang_16,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
             // a wrong value.
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"") || str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        try {
            return createBigInteger(str); // Handle hexadecimal consistently for all prefixes
        } catch (NumberFormatException e) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec = null;
    String exp = null;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        String numeric = str.substring(0, str.length() - 1);
        switch (lastChar) {
            case 'l':
            case 'L':
                try {
                    return createLong(numeric);
                } catch (NumberFormatException nfe) {
                    return createBigInteger(numeric);
                }
            case 'f':
            case 'F':
                try {
                    return createFloat(numeric);
                } catch (NumberFormatException ignored) {
                }
                break;
            case 'd':
            case 'D':
                try {
                    return createDouble(numeric);
                } catch (NumberFormatException ignored) {
                }
                return createBigDecimal(numeric); // Fallback to BigDecimal for precision
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException ignored) {
            }
            try {
                return createLong(str);
            } catch (NumberFormatException ignored) {
            }
            return createBigInteger(str);
        } else {
            try {
                return createDouble(str);
            } catch (NumberFormatException ignored) {
            }
            return createBigDecimal(str);
        }
    }
}",1,0
115,Lang_16,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
             // a wrong value.
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null; 
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        return createBigInteger(str.startsWith(""-"") ? str.substring(1) : str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos <= decPos || expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l' :
            case 'L' :
                if (dec == null && exp == null && (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f' :
            case 'F' :
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!f.isInfinite() && !(f.floatValue() == 0.0F && !allZeros)) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            case 'd' :
            case 'D' :
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            default :
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe2) {
                    return createBigInteger(str);
                }
            }
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!f.isInfinite() && !(f.floatValue() == 0.0F && !allZeros)) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            }
            try {
                Double d = createDouble(str);
                if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            }
            return createBigDecimal(str);
        }
    }
}",2,0
115,Lang_16,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
             // a wrong value.
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        try {
            return createBigInteger(str);
        } catch (NumberFormatException e) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec = null;
    String exp = null;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        String numeric = str.substring(0, str.length() - 1);
        switch (lastChar) {
            case 'l':
            case 'L':
                try {
                    return createLong(numeric);
                } catch (NumberFormatException nfe) {
                    return createBigInteger(numeric);
                }
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!f.isInfinite()) {
                        return f;
                    }
                } catch (NumberFormatException ignored) {
                }
                return createBigDecimal(numeric); // Fallback to BigDecimal for precision
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!d.isInfinite()) {
                        return d;
                    }
                } catch (NumberFormatException ignored) {
                }
                return createBigDecimal(numeric); 
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException ignored) {
            }
            try {
                return createLong(str);
            } catch (NumberFormatException ignored) {
            }
            return createBigInteger(str);
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Double d = createDouble(str);
                if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {
                    return d;
                }
            } catch (NumberFormatException ignored) {
            }
            return createBigDecimal(str);
        }
    }
}",3,0
115,Lang_16,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
             // a wrong value.
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        try {
            return createBigInteger(str.replaceFirst(""-"","""")); // Use BigInteger for hex calculations
        } catch (NumberFormatException e) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos <= decPos || expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l' :
            case 'L' :
                if (dec == null && exp == null &&
                    (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f' :
            case 'F' :
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException ignored) {}
                //$FALL-THROUGH$
            case 'd' :
            case 'D' :
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException ignored) {}
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            default :
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException ignored) {}
            try {
                return createLong(str);
            } catch (NumberFormatException ignored) {}
            return createBigInteger(str);
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException ignored) {}

            return createBigDecimal(str);
        }
    }
}",4,0
116,Lang_17,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
             return;
         }
         int pos = 0;
         int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
             else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                     if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                     } else {
                         pos++;
                     }
                 }
                 pos--;
             }
             pos++;
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int codepoint = Character.codePointAt(input, pos);
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(codepoint);
            out.write(c);
            pos += Character.charCount(codepoint);
        } else {
            pos += consumed;
        }
    }
}",0,0
116,Lang_17,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
             return;
         }
         int pos = 0;
         int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
             else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                     if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                     } else {
                         pos++;
                     }
                 }
                 pos--;
             }
             pos++;
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = Character.codePointCount(input, 0, input.length());
    while (pos < len) {
        int codepoint = Character.codePointAt(input, pos);
        int consumed = translate(input, pos, out);

        if (consumed == 0) {
            char[] c = Character.toChars(codepoint);
            out.write(c);
            pos += c.length;  // Account for surrogate pairs correctly by using length of char array
        } else {
            pos += consumed;
        }
    }
}",1,0
116,Lang_17,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
             return;
         }
         int pos = 0;
         int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
             else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                     if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                     } else {
                         pos++;
                     }
                 }
                 pos--;
             }
             pos++;
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int codepoint = Character.codePointAt(input, pos);
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            if (Character.isSupplementaryCodePoint(codepoint)) {
                char[] c = Character.toChars(codepoint);
                out.write(c, 0, c.length); // Correctly write all chars for supplementary code points
                pos += c.length; // Skip correct number of positions for surrogate pairs
            } else {
                out.write(codepoint);
                pos++;
            }
        } else {
            pos += consumed;
        }
    }
}",2,0
116,Lang_17,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
             return;
         }
         int pos = 0;
         int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
             else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                     if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                     } else {
                         pos++;
                     }
                 }
                 pos--;
             }
             pos++;
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int codepoint = Character.codePointAt(input, pos);
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(codepoint);
            if (Character.isSupplementaryCodePoint(codepoint)) {
                out.write(c);
                pos += Character.charCount(codepoint);
            } else {
                out.write(c[0]);
                pos++;
            }
        } else {
            pos += consumed;
        }
    }
}",3,0
116,Lang_17,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
             return;
         }
         int pos = 0;
         int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
             else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                     if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                     } else {
                         pos++;
                     }
                 }
                 pos--;
             }
             pos++;
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int codepoint = Character.codePointAt(input, pos);
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            // Write either single character or handle supplementary code point correctly
            if (Character.isBmpCodePoint(codepoint)) {
                out.write(codepoint);
                pos++;
            } else {
                char[] c = Character.toChars(codepoint);
                out.write(c);
                pos += 2; // Supplementary characters consist of two char values
            }
        } else {
            pos += consumed; // translators explicitly handle consumed code points
        }
    }
}",4,0
117,Lang_19,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
             while(input.charAt(end) != ';') 
             {
                 end++;
             }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;

        if (start >= seqEnd) {
            return 0;
        }

        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;

            // Check there's more than just an x after the &#
            if (start >= seqEnd) {
                return 0;
            }
        }

        int end = start;
        // Note that this supports character codes without a ; on the end
        while (end < seqEnd && input.charAt(end) != ';') {
            end++;
        }

        if (end >= seqEnd) {
            return 0;
        }

        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }

        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }

        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}",0,0
117,Lang_19,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
             while(input.charAt(end) != ';') 
             {
                 end++;
             }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    if (index < seqEnd - 2 && input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;

        if (start < seqEnd && (input.charAt(start) == 'x' || input.charAt(start) == 'X')) {
            start++;
            isHex = true;
        }

        int end = start;
        while (end < seqEnd && input.charAt(end) != ';') {
            end++;
        }

        if (end == seqEnd) {
            // Unfinished entity, return failure
            return 0;
        }

        int entityValue;
        try {
            String entity = input.subSequence(start, end).toString();
            entityValue = isHex ? Integer.parseInt(entity, 16) : Integer.parseInt(entity, 10);
        } catch (NumberFormatException e) {
            return 0;
        }

        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }

        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}",1,0
117,Lang_19,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
             while(input.charAt(end) != ';') 
             {
                 end++;
             }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    if (index < seqEnd - 2 && input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;

        if (start < seqEnd && (input.charAt(start) == 'x' || input.charAt(start) == 'X')) {
            start++;
            isHex = true;
        }

        int end = start;
        while (end < seqEnd && input.charAt(end) != ';' && Character.isDigit(input.charAt(end))) {
            end++;
        }

        if (end == seqEnd || !Character.isDigit(input.charAt(end-1))) {
            // Invalid entity, return failure
            return 0;
        }

        int entityValue;
        try {
            String entity = input.subSequence(start, end).toString();
            entityValue = isHex ? Integer.parseInt(entity, 16) : Integer.parseInt(entity, 10);
        } catch (NumberFormatException e) {
            return 0;
        }

        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }

        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}",2,0
117,Lang_19,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
             while(input.charAt(end) != ';') 
             {
                 end++;
             }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }",Match failed,3,0
117,Lang_19,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
             while(input.charAt(end) != ';') 
             {
                 end++;
             }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
                return 0;
            }

            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }


            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
        }
        return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    if (index < seqEnd - 1 && input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        
        if (start < seqEnd && (input.charAt(start) == 'x' || input.charAt(start) == 'X')) {
            start++;
            isHex = true;
        }

        int end = start;
        while (end < seqEnd && input.charAt(end) != ';') {
            end++;
        }
        
        // Ensure valid entity sequence within boundaries
        if (end == seqEnd || start == end) {
            return 0;
        }

        int entityValue;
        try {
            String entity = input.subSequence(start, end).toString();
            entityValue = isHex ? Integer.parseInt(entity, 16) : Integer.parseInt(entity, 10);
        } catch (NumberFormatException e) {
            return 0;
        }

        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }

        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}",4,0
118,Lang_21,"public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
        if (cal1 == null || cal2 == null) {
            throw new IllegalArgumentException(""The date must not be null"");
        }
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
                cal1.getClass() == cal2.getClass());
    }","public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&
            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
            cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
            cal1.getClass() == cal2.getClass());
}",0,0
119,Lang_22,"private static int greatestCommonDivisor(int u, int v) {
         // From Commons Math:
         //if either operand is abs 1, return 1:
         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
             return 1;
         }
         // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        if (u>0) { u=-u; } // make u negative
        if (v>0) { v=-v; } // make v negative
        // B1. [Find power of 2]
        int k=0;
        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...
            u/=2; v/=2; k++; // cast out twos.
        }
        if (k==31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        //     one is odd.
        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t&1)==0) { // while t is even..
                t/=2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t>0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u)/2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t!=0);
        return -u*(1<<k); // gcd is u*2^k
    }","private static int greatestCommonDivisor(int u, int v) {
    // Return the absolute value, as gcd should be positive
    u = Math.abs(u);
    v = Math.abs(v);

    if (u == 0) {
        return v;
    } else if (v == 0) {
        return u;
    }

    // keep using non-negative values and handle overflows correctly
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0) { // while both are even
        u >>= 1;
        v >>= 1;
        k++;
    }
    // Initialize: u and v have been divided by 2^k and at least one is odd.
    while ((u & 1) == 0) {
        u >>= 1;
    }
    
    while (v != 0) {
        while ((v & 1) == 0) {
            v >>= 1;
        }
        // u and v are both odd now, swap if necessary
        if (u > v) {
            int temp = u;
            u = v;
            v = temp;
        }
        v = v - u; // v is even
    }
    return u << k; // return the result
}",0,0
120,Lang_24,"public static boolean isNumber(String str) {
        if (StringUtils.isEmpty(str)) {
            return false;
        }
        char[] chars = str.toCharArray();
        int sz = chars.length;
        boolean hasExp = false;
        boolean hasDecPoint = false;
        boolean allowSigns = false;
        boolean foundDigit = false;
        // deal with any possible sign up front
        int start = (chars[0] == '-') ? 1 : 0;
        if (sz > start + 1) {
            if (chars[start] == '0' && chars[start + 1] == 'x') {
                int i = start + 2;
                if (i == sz) {
                    return false; // str == ""0x""
                }
                // checking hex (it can't be anything else)
                for (; i < chars.length; i++) {
                    if ((chars[i] < '0' || chars[i] > '9')
                        && (chars[i] < 'a' || chars[i] > 'f')
                        && (chars[i] < 'A' || chars[i] > 'F')) {
                        return false;
                    }
                }
                return true;
            }
        }
        sz--; // don't want to loop to the last char, check it afterwords
              // for type qualifiers
        int i = start;
        // loop to the next to last char or to the last char if we need another digit to
        // make a valid number (e.g. chars[0..5] = ""1234E"")
        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                foundDigit = true;
                allowSigns = false;

            } else if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent   
                    return false;
                }
                hasDecPoint = true;
            } else if (chars[i] == 'e' || chars[i] == 'E') {
                // we've already taken care of hex.
                if (hasExp) {
                    // two E's
                    return false;
                }
                if (!foundDigit) {
                    return false;
                }
                hasExp = true;
                allowSigns = true;
            } else if (chars[i] == '+' || chars[i] == '-') {
                if (!allowSigns) {
                    return false;
                }
                allowSigns = false;
                foundDigit = false; // we need a digit after the E
            } else {
                return false;
            }
            i++;
        }
        if (i < chars.length) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                // no type qualifier, OK
                return true;
            }
            if (chars[i] == 'e' || chars[i] == 'E') {
                // can't have an E at the last byte
                return false;
            }
            if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent
                    return false;
                }
                // single trailing decimal point after non-exponent is ok
                return foundDigit;
            }
            if (!allowSigns
                && (chars[i] == 'd'
                    || chars[i] == 'D'
                    || chars[i] == 'f'
                    || chars[i] == 'F')) {
                return foundDigit;
            }
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                 // not allowing L with an exponent or decimal point
                 return foundDigit && !hasExp;
             }
             // last character is illegal
             return false;
        }
        // allowSigns is true iff the val ends in 'E'
        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
        return !allowSigns && foundDigit;
    }","public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    
    int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {
        int i = start + 2;
        if (i == sz) {
            return false; // str == ""0x""
        }
        for (; i < chars.length; i++) {
            if ((chars[i] < '0' || chars[i] > '9') &&
                (chars[i] < 'a' || chars[i] > 'f') &&
                (chars[i] < 'A' || chars[i] > 'F')) {
                return false;
            }
        }
        return true;
    }

    sz--;
    int i = start;
    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            if (hasExp || !foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
            foundDigit = false;
        } else {
            return false;
        }
        i++;
    }

    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
            return false;
        }
        if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                return false;
            }
            return foundDigit;
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
            return foundDigit && !hasExp && !hasDecPoint;
        }
        return false;
    }
    return !allowSigns && foundDigit;
}",0,0
121,Lang_26,"    public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        c.setTime(date);
        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
    }
","public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setMinimalDaysInFirstWeek(4); // Setting minimal first week days to ensure correct week number
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}",0,0
121,Lang_26,"    public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        c.setTime(date);
        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
    }
","public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setFirstDayOfWeek(Calendar.MONDAY); // Set Monday as the first day of the week to ensure correct week number
    c.setMinimalDaysInFirstWeek(1); // Adjust the minimal days in first week to 1 for functionality
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}",1,0
121,Lang_26,"    public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        c.setTime(date);
        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
    }
","public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    if (c.get(Calendar.DAY_OF_YEAR) > 1 && c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {
        c.add(Calendar.DAY_OF_YEAR, -1);
    }
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}",2,0
121,Lang_26,"    public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        c.setTime(date);
        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
    }
","public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    if (c.get(Calendar.WEEK_OF_YEAR) == 1 && c.get(Calendar.MONTH) == Calendar.JANUARY && c.get(Calendar.DAY_OF_MONTH) < 4) {
        c.set(Calendar.YEAR, c.get(Calendar.YEAR) - 1);
    }
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}",3,0
121,Lang_26,"    public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone);
        c.setTime(date);
        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
    }
","public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);

    // Check if the date falls in the last week of the previous year for week count correction
    if (c.get(Calendar.MONTH) == Calendar.JANUARY && c.get(Calendar.WEEK_OF_YEAR) > 50) {
        c.set(Calendar.YEAR, c.get(Calendar.YEAR) - 1);
    }
    
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}",4,0
122,Lang_27,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

         if (decPos > -1) {
 
             if (expPos > -1) {
                 if (expPos < decPos) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                   Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    return createBigInteger(str);
                }
            }
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}",0,0
122,Lang_27,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

         if (decPos > -1) {
 
             if (expPos > -1) {
                 if (expPos < decPos) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }  
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }   
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') != -1 ? str.indexOf('e') : str.indexOf('E');

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l' :
            case 'L' :
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f' :
            case 'F' :
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            case 'd' :
            case 'D' :
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            default :
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    return createBigInteger(str);
                }
            }
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}",1,0
122,Lang_27,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

         if (decPos > -1) {
 
             if (expPos > -1) {
                 if (expPos < decPos) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        if (str.startsWith(""--"")) {
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l':
                case 'L':
                    if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            return createBigInteger(numeric);
                        }
                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f':
                case 'F':
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            return f;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd':
                case 'D':
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default:
                    throw new NumberFormatException(str + "" is not a valid number."");
            }
        } else {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1);
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    try {
                        return createLong(str);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(str);
                    }
                }
            } else {
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigDecimal(str);
            }
        }
    }",2,0
122,Lang_27,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

         if (decPos > -1) {
 
             if (expPos > -1) {
                 if (expPos < decPos) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.contains(""e"") ? str.indexOf('e') : str.indexOf('E');

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null &&
                   (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1);
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    return createBigInteger(str);
                }
            }
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}",3,0
122,Lang_27,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

         if (decPos > -1) {
 
             if (expPos > -1) {
                 if (expPos < decPos) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }

    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e');
    if (expPos == -1) {
        expPos = str.indexOf('E');
    }
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }

    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1);
    } else {
        exp = null;
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
                //$FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (dec == null && exp == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    return createBigInteger(str);
                }
            }
        } else {
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}",4,0
123,Lang_28,"@Override
    public int translate(CharSequence input, int index, Writer out) throws IOException {
        // TODO: Protect from ArrayIndexOutOfBounds
        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;
            }

            int end = start;
            while(input.charAt(end) != ';') {
                end++;
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(NumberFormatException nfe) {
                 return 0;
             }
 
                 out.write(entityValue);
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
    }","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    if (index < 0 || index + 1 >= input.length()) {
        return 0;
    }
    if (input.charAt(index) == '&' && index + 1 < input.length() && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;

        if (start >= input.length()) {
            return 0;
        }

        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
        }

        int end = start;
        while (end < input.length() && input.charAt(end) != ';') {
            end++;
        }

        if (end >= input.length() || end == start) {
            return 0; // substring is not properly terminated
        }

        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            return 0;
        }

        if (entityValue > 0xFFFF) {
            out.write(Character.toChars(entityValue));
        } else {
            out.write(entityValue);
        }

        return 2 + (end - start) + (isHex ? 1 : 0) + 1; // include '#', ';' and 'x' if hex
    }
    return 0;
}",0,0
124,Lang_29,"    static float toJavaVersionInt(String version) {
        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
    }
","static int toJavaVersionInt(String version) {
        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
}",0,0
125,Lang_3,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
            }
        }
        if (pfxLen > 0) { // we have a hex number
            final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16) { // too many for Long
                return createBigInteger(str);
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int pfxLen = 0;
    for(final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen = pfx.length();
            break;
        }
    }
    if (pfxLen > 0) { 
        final int hexDigits = str.length() - pfxLen;
        if (hexDigits > 16) { 
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            return createLong(str);
        }
        return createInteger(str);
    }
    
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec = null;
    String exp = null;
    final int decPos = str.indexOf('.');
    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;

    if (decPos > -1) { 
        if (expPos > -1) { 
            if (expPos < decPos || expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        }
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && (exp == null || isAllZeros(exp));
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                    // ignore
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                    // ignore
                }
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                    // ignore
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                    // ignore
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1);
    }

    if (dec == null && exp == null) { 
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe2) {
                return createBigInteger(str);
            }
        }
    }

    final boolean allZeros = isAllZeros(mant) && (exp == null || isAllZeros(exp));
    try {
        final Float f = createFloat(str);
        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
            return f;
        }
    } catch (final NumberFormatException nfe) {
        // ignore
    }
    try {
        final Double d = createDouble(str);
        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
            return d;
        }
    } catch (final NumberFormatException nfe) {
        // ignore
    }
    return createBigDecimal(str);
}",0,0
125,Lang_3,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
            }
        }
        if (pfxLen > 0) { // we have a hex number
            final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16) { // too many for Long
                return createBigInteger(str);
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int pfxLen = 0;
    for (final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen = pfx.length();
            break;
        }
    }

    if (pfxLen > 0) {
        final int hexDigits = str.length() - pfxLen;
        if (hexDigits > 16) {
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            return createLong(str);
        }
        return createInteger(str);
    }

    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec = null;
    String exp = null;
    final int decPos = str.indexOf('.');
    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        }
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && (exp == null || isAllZeros(exp));
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                break;
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                break;
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1);
    }

    if (dec == null && exp == null) {
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe2) {
                return createBigInteger(str);
            }
        }
    }

    try {
        return createBigDecimal(str);
    } catch (final NumberFormatException nfe) {
        throw new NumberFormatException(str + "" is not a valid number."");
    }
}",1,0
125,Lang_3,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
            }
        }
        if (pfxLen > 0) { // we have a hex number
            final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16) { // too many for Long
                return createBigInteger(str);
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    // Check for hex prefix
    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int hexPrefixLength = 0;
    for (final String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            hexPrefixLength = prefix.length();
            break;
        }
    }
    if (hexPrefixLength > 0) {
        final int hexDigits = str.length() - hexPrefixLength;
        if (hexDigits > 16) {
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            return createLong(str);
        }
        return createInteger(str);
    }

    // Normal number processing
    final char lastChar = str.charAt(str.length() - 1);
    String mantissa;
    String decimal = null;
    String exponent = null;
    final int decimalPosition = str.indexOf('.');
    final int exponentPosition = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decimalPosition > -1) {
        if (exponentPosition > -1) {
            if (exponentPosition < decimalPosition || exponentPosition >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPosition + 1, exponentPosition);
        } else {
            decimal = str.substring(decimalPosition + 1);
        }
        mantissa = str.substring(0, decimalPosition);
    } else {
        if (exponentPosition > -1) {
            if (exponentPosition >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mantissa = str.substring(0, exponentPosition);
        } else {
            mantissa = str;
        }
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (exponentPosition > -1 && exponentPosition < str.length() - 1) {
            exponent = str.substring(exponentPosition + 1, str.length() - 1);
        }
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mantissa) && (exponent == null || isAllZeros(exponent));
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                break;
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                break;
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (exponentPosition > -1 && exponentPosition < str.length() - 1) {
        exponent = str.substring(exponentPosition + 1);
    }

    if (decimal == null && exponent == null) {
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe2) {
                return createBigInteger(str);
            }
        }
    }

    final boolean allZeros = isAllZeros(mantissa) && (exponent == null || isAllZeros(exponent));
    try {
        final Float f = createFloat(str);
        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
            return f;
        }
    } catch (final NumberFormatException nfe) {
        // ignore
    }
    try {
        final Double d = createDouble(str);
        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
            return d;
        }
    } catch (final NumberFormatException nfe) {
        // ignore
    }
    return createBigDecimal(str);
}",2,0
125,Lang_3,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
            }
        }
        if (pfxLen > 0) { // we have a hex number
            final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16) { // too many for Long
                return createBigInteger(str);
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int hexPrefixLength = 0;
    for (final String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            hexPrefixLength = prefix.length();
            break;
        }
    }
    
    if (hexPrefixLength > 0) {
        final int hexDigits = str.length() - hexPrefixLength;
        if (hexDigits > 16) {
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            return createLong(str);
        }
        return createInteger(str);
    }

    final char lastChar = str.charAt(str.length() - 1);
    String mantissa;
    String decimal = null;
    String exponent = null;
    final int decimalPosition = str.indexOf('.');
    final int exponentPosition = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decimalPosition > -1) {
        if (exponentPosition > -1) {
            if (exponentPosition < decimalPosition || exponentPosition >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPosition + 1, exponentPosition);
        } else {
            decimal = str.substring(decimalPosition + 1);
        }
        mantissa = str.substring(0, decimalPosition);
    } else {
        if (exponentPosition > -1) {
            if (exponentPosition >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mantissa = str.substring(0, exponentPosition);
        } else {
            mantissa = str;
        }
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (exponentPosition > -1 && exponentPosition < str.length() - 1) {
            exponent = str.substring(exponentPosition + 1, str.length() - 1);
        }
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mantissa) && (exponent == null || isAllZeros(exponent));
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (exponentPosition > -1 && exponentPosition < str.length() - 1) {
        exponent = str.substring(exponentPosition + 1);
    }

    if (decimal == null && exponent == null) {
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe2) {
                return createBigInteger(str);
            }
        }
    }

    try {
        return createBigDecimal(str);
    } catch (final NumberFormatException nfe) {
        throw new NumberFormatException(str + "" is not a valid number."");
    }
}",3,0
125,Lang_3,"public static Number createNumber(final String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }
        // Need to deal with all possible hex prefixes here
        final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
        int pfxLen = 0;
        for(final String pfx : hex_prefixes) {
            if (str.startsWith(pfx)) {
                pfxLen += pfx.length();
                break;
            }
        }
        if (pfxLen > 0) { // we have a hex number
            final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16) { // too many for Long
                return createBigInteger(str);
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }
        final char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
        // and the parsing which will detect if e or E appear in a number due to using the wrong offset

        int numDecimals = 0; // Check required precision (LANG-693)
        if (decPos > -1) { // there is a decimal point

            if (expPos > -1) { // there is an exponent
                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) { // prevents double exponent causing IOOBE
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            final String numeric = str.substring(0, str.length() - 1);
            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (final NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        final Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        final Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (final NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (final NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        }
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) { // no decimal point and no exponent
            //Must be an Integer, Long, Biginteger
            try {
                return createInteger(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe) { // NOPMD
                // ignore the bad number
            }
            return createBigInteger(str);
        }

         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }

        return createBigDecimal(str);
    }","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }

    // Deal with hexadecimal numbers
    final String[] hexPrefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
    int hexPrefixLength = 0;
    for (final String prefix : hexPrefixes) {
        if (str.startsWith(prefix)) {
            hexPrefixLength = prefix.length();
            break;
        }
    }

    if (hexPrefixLength > 0) {
        final int hexDigits = str.length() - hexPrefixLength;
        if (hexDigits > 16) {
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            return createLong(str);
        }
        return createInteger(str);
    }

    final char lastChar = str.charAt(str.length() - 1);
    String mantissa;
    String decimal = null;
    String exponent = null;
    final int decimalPosition = str.indexOf('.');
    final int exponentPosition = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decimalPosition > -1) {
        if (exponentPosition > -1) {
            if (exponentPosition < decimalPosition || exponentPosition >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPosition + 1, exponentPosition);
        } else {
            decimal = str.substring(decimalPosition + 1);
        }
        mantissa = str.substring(0, decimalPosition);
    } else {
        if (exponentPosition > -1) {
            if (exponentPosition >= str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mantissa = str.substring(0, exponentPosition);
        } else {
            mantissa = str;
        }
    }

    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (exponentPosition > -1 && exponentPosition < str.length() - 1) {
            exponent = str.substring(exponentPosition + 1, str.length() - 1);
        }
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mantissa) && (exponent == null || isAllZeros(exponent));
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                break;
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                break;
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }

    if (exponentPosition > -1 && exponentPosition < str.length() - 1) {
        exponent = str.substring(exponentPosition + 1);
    }

    if (decimal == null && exponent == null) {
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
            try {
                return createLong(str);
            } catch (final NumberFormatException nfe2) {
                return createBigInteger(str);
            }
        }
    }

    final boolean allZeros = isAllZeros(mantissa) && (exponent == null || isAllZeros(exponent));
    try {
        final BigDecimal bd = createBigDecimal(str);
        if (bd.floatValue() == 0.0F && !allZeros) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }
        return bd;
    } catch (final NumberFormatException nfe) {
        throw new NumberFormatException(str + "" is not a valid number."");
    }
}",4,0
126,Lang_31," public static boolean containsAny(CharSequence cs, char[] searchChars) {
  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
   return false;
  }
  int csLength = cs.length();
  int searchLength = searchChars.length;
  for (int i = 0; i < csLength; i++) {
   char ch = cs.charAt(i);
   for (int j = 0; j < searchLength; j++) {
    if (searchChars[j] == ch) {
      // ch is a supplementary character
      // ch is in the Basic Multilingual Plane
      return true;
    }
   }
  }
  return false;
 }","public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    for (int i = 0; i < csLength; i++) {
        int codePoint = Character.codePointAt(cs, i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == codePoint || (Character.isSupplementaryCodePoint(codePoint) && j < searchLength - 1 && searchChars[j] == cs.charAt(i + 1))) {
                return true;
            }
        }
        if (Character.isSupplementaryCodePoint(codePoint)) {
            i++;
        }
    }
    return false;
}",0,0
126,Lang_31," public static boolean containsAny(CharSequence cs, char[] searchChars) {
  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
   return false;
  }
  int csLength = cs.length();
  int searchLength = searchChars.length;
  for (int i = 0; i < csLength; i++) {
   char ch = cs.charAt(i);
   for (int j = 0; j < searchLength; j++) {
    if (searchChars[j] == ch) {
      // ch is a supplementary character
      // ch is in the Basic Multilingual Plane
      return true;
    }
   }
  }
  return false;
 }","public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    for (int i = 0; i < csLength; i++) {
        int codePoint = Character.codePointAt(cs, i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == codePoint) {
                return true;
            }
        }
        if (Character.isSupplementaryCodePoint(codePoint)) {
            i++;
        }
    }
    return false;
}",1,0
126,Lang_31," public static boolean containsAny(CharSequence cs, char[] searchChars) {
  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
   return false;
  }
  int csLength = cs.length();
  int searchLength = searchChars.length;
  for (int i = 0; i < csLength; i++) {
   char ch = cs.charAt(i);
   for (int j = 0; j < searchLength; j++) {
    if (searchChars[j] == ch) {
      // ch is a supplementary character
      // ch is in the Basic Multilingual Plane
      return true;
    }
   }
  }
  return false;
 }","public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                return true;
            }
        }
        if (Character.isHighSurrogate(ch) && i + 1 < csLength && Character.isLowSurrogate(cs.charAt(i + 1))) {
            i++;
            int fullChar = Character.toCodePoint(ch, cs.charAt(i));
            for (int j = 0; j < searchLength; j++) {
                if (Character.toCodePoint(searchChars[j], searchChars[j]) == fullChar) {
                    return true;
                }
            }
        }
    }
    return false;
}",2,0
126,Lang_31," public static boolean containsAny(CharSequence cs, char[] searchChars) {
  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
   return false;
  }
  int csLength = cs.length();
  int searchLength = searchChars.length;
  for (int i = 0; i < csLength; i++) {
   char ch = cs.charAt(i);
   for (int j = 0; j < searchLength; j++) {
    if (searchChars[j] == ch) {
      // ch is a supplementary character
      // ch is in the Basic Multilingual Plane
      return true;
    }
   }
  }
  return false;
 }","public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    outerLoop:
    for (int i = 0; i < csLength; i++) {
        int codePoint = Character.codePointAt(cs, i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == codePoint) {
                return true;
            }
        }
        if (Character.isSupplementaryCodePoint(codePoint)) {
            i++;
        }
    }
    return false;
}",3,0
126,Lang_31," public static boolean containsAny(CharSequence cs, char[] searchChars) {
  if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
   return false;
  }
  int csLength = cs.length();
  int searchLength = searchChars.length;
  for (int i = 0; i < csLength; i++) {
   char ch = cs.charAt(i);
   for (int j = 0; j < searchLength; j++) {
    if (searchChars[j] == ch) {
      // ch is a supplementary character
      // ch is in the Basic Multilingual Plane
      return true;
    }
   }
  }
  return false;
 }",Match failed,4,0
127,Lang_33,"public static Class<?>[] toClass(Object[] array) {
        if (array == null) {
            return null;
        } else if (array.length == 0) {
            return ArrayUtils.EMPTY_CLASS_ARRAY;
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
             classes[i] = array[i].getClass();
         }
         return classes;
     }","public static Class<?>[] toClass(Object[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    Class<?>[] classes = new Class[array.length];
    for (int i = 0; i < array.length; i++) {
        if (array[i] != null) {
            classes[i] = array[i].getClass();
        } else {
            classes[i] = null;
        }
    }
    return classes;
}",0,0
128,Lang_37,"@SuppressWarnings(""unchecked"")
    public static <T> T[] addAll(T[] array1, T... array2) {
        if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
             // Check if problem is incompatible types
         return joinedArray;
     }","@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    final Class<?> type1 = array1.getClass().getComponentType();
    final Class<?> type2 = array2.getClass().getComponentType();
    
    // Ensure that the array types are compatible
    if (!type1.isAssignableFrom(type2) && !type2.isAssignableFrom(type1)) {
        throw new ArrayStoreException(""Incompatible array types: "" + type1 + "" and "" + type2);
    }
    
    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}",0,0
128,Lang_37,"@SuppressWarnings(""unchecked"")
    public static <T> T[] addAll(T[] array1, T... array2) {
        if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
             // Check if problem is incompatible types
         return joinedArray;
     }","@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    final Class<?> type1 = array1.getClass().getComponentType();
    final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    try {
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    } catch (ArrayStoreException e) {
        throw new ArrayStoreException(""Incompatible array types."");
    }
    return joinedArray;
}",1,0
128,Lang_37,"@SuppressWarnings(""unchecked"")
    public static <T> T[] addAll(T[] array1, T... array2) {
        if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
             // Check if problem is incompatible types
         return joinedArray;
     }","@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }

    // Determine the most specific common supertype of array1 and array2
    Class<?> commonType = Object.class;
    final Class<?> type1 = array1.getClass().getComponentType();
    final Class<?> type2 = array2.getClass().getComponentType();

    if (type1.isAssignableFrom(type2)) {
        commonType = type1;
    } else if (type2.isAssignableFrom(type1)) {
        commonType = type2;
    }

    // Create the new array of the common supertype
    T[] joinedArray = (T[]) Array.newInstance(commonType, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}",2,0
128,Lang_37,"@SuppressWarnings(""unchecked"")
    public static <T> T[] addAll(T[] array1, T... array2) {
        if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
             // Check if problem is incompatible types
         return joinedArray;
     }","@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    final Class<?> type1 = array1.getClass().getComponentType();
    final Class<?> type2 = array2.getClass().getComponentType();
    
    // Use the most general common superclass, Object, if types are incompatible
    Class<?> resultType;
    if (type1.isAssignableFrom(type2)) {
        resultType = type1;
    } else if (type2.isAssignableFrom(type1)) {
        resultType = type2;
    } else {
        resultType = Object.class; // Fallback to Object if incompatible
    }
    
    T[] joinedArray = (T[]) Array.newInstance(resultType, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}",3,0
128,Lang_37,"@SuppressWarnings(""unchecked"")
    public static <T> T[] addAll(T[] array1, T... array2) {
        if (array1 == null) {
            return clone(array2);
        } else if (array2 == null) {
            return clone(array1);
        }
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
             // Check if problem is incompatible types
         return joinedArray;
     }","@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }

    // Determine a common supertype based on shared class hierarchy
    Class<?> commonType = findCommonSuperType(array1.getClass().getComponentType(), array2.getClass().getComponentType());

    // If no common type found that can handle both arrays, return concatenation of clones casted to Object[]
    if (commonType == null) {
        throw new ArrayStoreException(""Incompatible array types"");
    }

    T[] joinedArray = (T[]) Array.newInstance(commonType, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}

private static Class<?> findCommonSuperType(Class<?> type1, Class<?> type2) {
    if (type1.isAssignableFrom(type2)) {
        return type1;
    } else if (type2.isAssignableFrom(type1)) {
        return type2;
    } else {
        Class<?> current = type1;
        while (current != null) {
            if (current.isAssignableFrom(type2)) {
                return current;
            }
            current = current.getSuperclass();
        }
    }
    return null;
}",4,0
129,Lang_38,"public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
        return applyRules(calendar, buf);
    }","public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf == null ? new StringBuffer() : buf);
}",0,0
129,Lang_38,"public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
        return applyRules(calendar, buf);
    }","public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    if (buf == null) {
        buf = new StringBuffer();
    }
    return applyRules(calendar, buf);
}",1,0
129,Lang_38,"public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
        return applyRules(calendar, buf);
    }","public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (buf == null) {
        buf = new StringBuffer();
    }
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}",2,0
129,Lang_38,"public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
        return applyRules(calendar, buf);
    }","public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (buf == null) {
        buf = new StringBuffer(); // ensure buf is initialized
    } else {
        buf.setLength(0); // clear the existing buffer content instead of creating a new object
    }
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone(); 
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}",3,0
129,Lang_38,"public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
        return applyRules(calendar, buf);
    }","public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (buf == null) {
        buf = new StringBuffer();
    }
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf == null ? new StringBuffer() : buf);
}",4,0
130,Lang_39,"private static String replaceEach(String text, String[] searchList, String[] replacementList, 
                                      boolean repeat, int timeToLive) 
    {

        // mchyzer Performance note: This creates very few new objects (one major goal)
        // let me know if there are performance requests, we can create a harness to measure

        if (text == null || text.length() == 0 || searchList == null || 
            searchList.length == 0 || replacementList == null || replacementList.length == 0) 
        {
            return text;
        }

        // if recursing, this shouldnt be less than 0
        if (timeToLive < 0) {
            throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
        }

        int searchLength = searchList.length;
        int replacementLength = replacementList.length;

        // make sure lengths are ok, these need to be equal
        if (searchLength != replacementLength) {
            throw new IllegalArgumentException(""Search and Replace array lengths don't match: ""
                + searchLength
                + "" vs ""
                + replacementLength);
        }

        // keep track of which still have matches
        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];

        // index on index that the match was found
        int textIndex = -1;
        int replaceIndex = -1;
        int tempIndex = -1;

        // index of replace array that will replace the search string found
        // NOTE: logic duplicated below START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
                searchList[i].length() == 0 || replacementList[i] == null) 
            {
                continue;
            }
            tempIndex = text.indexOf(searchList[i]);

            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
        // NOTE: logic mostly below END

        // no search strings found, we are done
        if (textIndex == -1) {
            return text;
        }

        int start = 0;

        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
        int increase = 0;
 
         // count the replacement text elements that are larger than their corresponding text being replaced
         for (int i = 0; i < searchList.length; i++) {
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; // assume 3 matches
            }
        }
        // have upper-bound at 20% increase, then let Java take over
        increase = Math.min(increase, text.length() / 5);

        StringBuilder buf = new StringBuilder(text.length() + increase);

        while (textIndex != -1) {

            for (int i = start; i < textIndex; i++) {
                buf.append(text.charAt(i));
            }
            buf.append(replacementList[replaceIndex]);

            start = textIndex + searchList[replaceIndex].length();

            textIndex = -1;
            replaceIndex = -1;
            tempIndex = -1;
            // find the next earliest match
            // NOTE: logic mostly duplicated above START
            for (int i = 0; i < searchLength; i++) {
                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
                    searchList[i].length() == 0 || replacementList[i] == null) 
                {
                    continue;
                }
                tempIndex = text.indexOf(searchList[i], start);

                // see if we need to keep searching for this
                if (tempIndex == -1) {
                    noMoreMatchesForReplIndex[i] = true;
                } else {
                    if (textIndex == -1 || tempIndex < textIndex) {
                        textIndex = tempIndex;
                        replaceIndex = i;
                    }
                }
            }
            // NOTE: logic duplicated above END

        }
        int textLength = text.length();
        for (int i = start; i < textLength; i++) {
            buf.append(text.charAt(i));
        }
        String result = buf.toString();
        if (!repeat) {
            return result;
        }

        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
    }","private static String replaceEach(String text, String[] searchList, String[] replacementList, 
                                  boolean repeat, int timeToLive) 
{
    // mchyzer Performance note: This creates very few new objects (one major goal)
    // let me know if there are performance requests, we can create a harness to measure

    if (text == null || text.length() == 0 || searchList == null || 
        searchList.length == 0 || replacementList == null || replacementList.length == 0) 
    {
        return text;
    }

    if (timeToLive < 0) {
        throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
    }

    int searchLength = searchList.length;
    int replacementLength = replacementList.length;

    if (searchLength != replacementLength) {
        throw new IllegalArgumentException(""Search and Replace array lengths don't match: ""
            + searchLength
            + "" vs ""
            + replacementLength);
    }

    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;

    for (int i = 0; i < searchLength; i++) {
        if (searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) 
        {
            noMoreMatchesForReplIndex[i] = true;
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);

        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }

    if (textIndex == -1) {
        return text;
    }

    int start = 0;
    int increase = 0;
 
    for (int i = 0; i < searchList.length; i++) {
        if (searchList[i] != null && replacementList[i] != null) {
            int greater = replacementList[i].length() - searchList[i].length();
            if (greater > 0) {
                increase += 3 * greater; // assume 3 matches
            }
        }
    }

    increase = Math.min(increase, text.length() / 5);
    StringBuilder buf = new StringBuilder(text.length() + increase);

    while (textIndex != -1) {

        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);

        start = textIndex + searchList[replaceIndex].length();

        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;

        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || 
                searchList[i].length() == 0 || replacementList[i] == null) 
            {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);

            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    }
    int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    String result = buf.toString();

    if (!repeat) {
        return result;
    }

    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}",0,0
131,Lang_40,"public static boolean containsIgnoreCase(String str, String searchStr) {
         if (str == null || searchStr == null) {
             return false;
         }
         return contains(str.toUpperCase(), searchStr.toUpperCase());
     }",Match failed,0,0
131,Lang_40,"public static boolean containsIgnoreCase(String str, String searchStr) {
         if (str == null || searchStr == null) {
             return false;
         }
         return contains(str.toUpperCase(), searchStr.toUpperCase());
     }","public static boolean containsIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    final int length = searchStr.length();
    if (length == 0) {
        return true;
    }
    for (int i = str.length() - length; i >= 0; i--) {
        if (str.regionMatches(true, i, searchStr, 0, length)) {
            return true;
        }
    }
    return false;
}",1,0
132,Lang_42,"public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
             char c = str.charAt(i);
             String entityName = this.entityName(c);
             if (entityName == null) {
                 if (c > 0x7F) {
                     writer.write(""&#"");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');
                } else {
                    writer.write(c);
                }
            } else {
                writer.write('&');
                writer.write(entityName);
                writer.write(';');
            }
        }
    }","public void escape(Writer writer, String str) throws IOException {
    int len = str.length();
    for (int i = 0; i < len; i++) {
        int codePoint = str.codePointAt(i);
        String entityName = this.entityName(codePoint);
        if (Character.isSupplementaryCodePoint(codePoint)) {
            i++; // Skip the next code unit since it's part of a supplementary character
        }
        if (entityName == null) {
            if (codePoint > 0x7F) {
                writer.write(""&#"");
                writer.write(Integer.toString(codePoint, 10));
                writer.write(';');
            } else {
                writer.write(codePoint);
            }
        } else {
            writer.write('&');
            writer.write(entityName);
            writer.write(';');
        }
    }
}",0,0
133,Lang_43,"    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
            StringBuffer appendTo, boolean escapingOn) {
        int start = pos.getIndex();
        char[] c = pattern.toCharArray();
        if (escapingOn && c[start] == QUOTE) {
            return appendTo == null ? null : appendTo.append(QUOTE);
        }
        int lastHold = start;
        for (int i = pos.getIndex(); i < pattern.length(); i++) {
            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(
                        QUOTE);
                pos.setIndex(i + ESCAPED_QUOTE.length());
                lastHold = pos.getIndex();
                continue;
            }
            switch (c[pos.getIndex()]) {
            case QUOTE:
                next(pos);
                return appendTo == null ? null : appendTo.append(c, lastHold,
                        pos.getIndex() - lastHold);
            default:
                next(pos);
            }
        }
        throw new IllegalArgumentException(
                ""Unterminated quoted string at position "" + start);
    }
","private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
        StringBuffer appendTo, boolean escapingOn) {
    int start = pos.getIndex();
    char[] c = pattern.toCharArray();
    if (escapingOn && c[start] == QUOTE) {
        pos.setIndex(start + 1);
        return appendTo == null ? null : appendTo.append(QUOTE);
    }
    int lastHold = start;
    for (int i = pos.getIndex(); i < pattern.length(); i++) {
        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE);
            pos.setIndex(i + ESCAPED_QUOTE.length());
            lastHold = pos.getIndex();
            i = pos.getIndex() - 1; // Adjust loop index because it will increment
            continue;
        }
        switch (c[pos.getIndex()]) {
        case QUOTE:
            next(pos);
            return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);
        default:
            next(pos);
        }
    }
    throw new IllegalArgumentException(""Unterminated quoted string at position "" + start);
}",0,0
134,Lang_44,"    public static Number createNumber(String val) throws NumberFormatException {
        if (val == null) {
            return null;
        }
        if (val.length() == 0) {
            throw new NumberFormatException(""\""\"" is not a valid number."");
        }
        if (val.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
            return createInteger(val);
        }   
        char lastChar = val.charAt(val.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = val.indexOf('.');
        int expPos = val.indexOf('e') + val.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(val + "" is not a valid number."");
                }
                dec = val.substring(decPos + 1, expPos);
            } else {
                dec = val.substring(decPos + 1);
            }
            mant = val.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = val.substring(0, expPos);
            } else {
                mant = val;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = val.substring(0, val.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(val + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // empty catch
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // empty catch
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(val + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(val);
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createLong(val);
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                return createBigInteger(val);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(val);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    Double d = createDouble(val);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }

                return createBigDecimal(val);

            }

        }
    }
","public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // this is protection for poorness in java.lang.BigDecimal.
        // it accepts this as a legal value, but it does not appear 
        // to be in specification of class. OS X Java parses it to 
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }   
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = Math.max(val.indexOf('e'), val.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        //Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l' :
            case 'L' :
                if (dec == null
                    && exp == null
                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        //Too big for a long
                    }
                    return createBigInteger(numeric);

                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f' :
            case 'F' :
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        //If it's too big for a float or the float value = 0 and the string
                        //has non-zeros in it, then float does not have the precision we want
                        return f;
                    }

                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
                //Fall through
            case 'd' :
            case 'D' :
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // empty catch
                }
                //Fall through
            default :
                throw new NumberFormatException(val + "" is not a valid number."");

        }
    } else {
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1);
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            //Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigInteger(val);

        } else {
            //Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }

            return createBigDecimal(val);

        }

    }
}",0,0
134,Lang_44,"    public static Number createNumber(String val) throws NumberFormatException {
        if (val == null) {
            return null;
        }
        if (val.length() == 0) {
            throw new NumberFormatException(""\""\"" is not a valid number."");
        }
        if (val.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
            return createInteger(val);
        }   
        char lastChar = val.charAt(val.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = val.indexOf('.');
        int expPos = val.indexOf('e') + val.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(val + "" is not a valid number."");
                }
                dec = val.substring(decPos + 1, expPos);
            } else {
                dec = val.substring(decPos + 1);
            }
            mant = val.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = val.substring(0, expPos);
            } else {
                mant = val;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = val.substring(0, val.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(val + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // empty catch
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // empty catch
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(val + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < val.length() - 1) {
                exp = val.substring(expPos + 1, val.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(val);
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createLong(val);
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                return createBigInteger(val);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(val);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    Double d = createDouble(val);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }

                return createBigDecimal(val);

            }

        }
    }
","public static Number createNumber(String val) throws NumberFormatException {
    if (val == null || val.isEmpty() || val.startsWith(""--"")) {
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }   
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = Math.max(val.indexOf('e'), val.indexOf('E'));

    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
                // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // empty catch
                }
                // Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        // User doesn't have a preference on the return type, so let's start small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1);
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int, long, bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigInteger(val);
        } else {
            // Must be a float, double, BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigDecimal(val);
        }
    }
}",1,0
135,Lang_45,"public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
        // initial parameter checks
        if (str == null) {
            return null;
        }
        if (str.length() == 0) {
            return StringUtils.EMPTY;
        }
 
         // if the lower value is greater than the length of the string,
         // set to the length of the string
         // if the upper value is -1 (i.e. no limit) or is greater
         // than the length of the string, set to the length of the string
         if (upper == -1 || upper > str.length()) {
            upper = str.length();
        }
        // if upper is less than lower, raise it to lower
        if (upper < lower) {
            upper = lower;
        }

        StringBuffer result = new StringBuffer();
        int index = StringUtils.indexOf(str, "" "", lower);
        if (index == -1) {
            result.append(str.substring(0, upper));
            // only if abbreviation has occured do we append the appendToEnd value
            if (upper != str.length()) {
                result.append(StringUtils.defaultString(appendToEnd));
            }
        } else if (index > upper) {
            result.append(str.substring(0, upper));
            result.append(StringUtils.defaultString(appendToEnd));
        } else {
            result.append(str.substring(0, index));
            result.append(StringUtils.defaultString(appendToEnd));
        }
        return result.toString();
    }","public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
    // initial parameter checks
    if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return StringUtils.EMPTY;
    }

    // fix: ensure lower does not exceed string length, if so, set to the length of the string
    if (lower > str.length()) {
        lower = str.length();
    }

    // fix: if the upper value is -1 (i.e. no limit) or is greater than the length of the string, set to the length of the string
    if (upper == -1 || upper > str.length()) {
        upper = str.length();
    }
    // if upper is less than lower, raise it to lower
    if (upper < lower) {
        upper = lower;
    }

    StringBuffer result = new StringBuffer();
    int index = StringUtils.indexOf(str, ' ', lower);
    if (index == -1 || index > upper) {
        result.append(str.substring(0, upper));
        // only if abbreviation has occurred do we append the appendToEnd value
        if (upper != str.length()) {
            result.append(StringUtils.defaultString(appendToEnd));
        }
    } else {
        result.append(str.substring(0, index));
        result.append(StringUtils.defaultString(appendToEnd));
    }
    return result.toString();
}",0,0
136,Lang_49,"    public Fraction reduce() {
        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
        if (gcd == 1) {
            return this;
        }
        return Fraction.getFraction(numerator / gcd, denominator / gcd);
    }
","public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}",0,0
136,Lang_49,"    public Fraction reduce() {
        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
        if (gcd == 1) {
            return this;
        }
        return Fraction.getFraction(numerator / gcd, denominator / gcd);
    }
","public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}",1,0
136,Lang_49,"    public Fraction reduce() {
        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
        if (gcd == 1) {
            return this;
        }
        return Fraction.getFraction(numerator / gcd, denominator / gcd);
    }
","public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));
    if (gcd == Math.abs(denominator)) {
        return new Fraction((numerator < 0 ? -1 : 1) * (Math.abs(numerator) / gcd), 1);
    }
    return (gcd == 1) ? this : Fraction.getFraction(numerator / gcd, denominator / gcd);
}",2,0
136,Lang_49,"    public Fraction reduce() {
        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
        if (gcd == 1) {
            return this;
        }
        return Fraction.getFraction(numerator / gcd, denominator / gcd);
    }
","public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));
    int reducedNumerator = numerator / gcd;
    int reducedDenominator = denominator / gcd;
    if (reducedDenominator < 0) {
        reducedNumerator = -reducedNumerator;
        reducedDenominator = -reducedDenominator;
    }
    return (gcd == 1) ? this : Fraction.getFraction(reducedNumerator, reducedDenominator);
}",3,0
136,Lang_49,"    public Fraction reduce() {
        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
        if (gcd == 1) {
            return this;
        }
        return Fraction.getFraction(numerator / gcd, denominator / gcd);
    }
","public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));
    int reducedNumerator = numerator / gcd;
    int reducedDenominator = denominator / gcd;
    if (denominator < 0) {
        reducedNumerator = -reducedNumerator;
        reducedDenominator = -reducedDenominator;
    }
    return (gcd == 1) ? this : Fraction.getFraction(reducedNumerator, reducedDenominator);
}",4,0
137,Lang_5,"public static Locale toLocale(final String str) {
        if (str == null) {
            return null;
        }
        final int len = str.length();
        if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 2) {
                return new Locale(str);
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            }
            if (len < 7) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }","public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(0) == '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (len < 5) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    if (ch3 == '_') {
        return new Locale(str.substring(0, 2), """", str.substring(4));
    }
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    if (len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",0,0
137,Lang_5,"public static Locale toLocale(final String str) {
        if (str == null) {
            return null;
        }
        final int len = str.length();
        if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 2) {
                return new Locale(str);
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            }
            if (len < 7) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }","public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(0) == '_') {
        if (len == 3) {
            return new Locale("""", str.substring(1, 3));
        } else if (len > 4 && str.charAt(3) == '_') {
            return new Locale("""", str.substring(1, 3), str.substring(4));
        } else {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
    }
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (len < 5) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    if (ch3 == '_') {
        return new Locale(str.substring(0, 2), """", str.substring(4));
    }
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    if (len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",1,0
137,Lang_5,"public static Locale toLocale(final String str) {
        if (str == null) {
            return null;
        }
        final int len = str.length();
        if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 2) {
                return new Locale(str);
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            }
            if (len < 7) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }","public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (str.startsWith(""_"")) {
        if (len == 3) {
            return new Locale("""", str.substring(1, 3));
        } else if (len > 4 && str.charAt(3) == '_') {
            return new Locale("""", str.substring(1, 3), str.substring(4));
        } else {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
    }
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (len < 5) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    if (!Character.isUpperCase(ch3)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 4) {
        return new Locale(str.substring(0, 2), str.substring(3));
    }
    if (len < 7 || str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",2,0
137,Lang_5,"public static Locale toLocale(final String str) {
        if (str == null) {
            return null;
        }
        final int len = str.length();
        if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 2) {
                return new Locale(str);
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            }
            if (len < 7) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }","public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.startsWith(""_"")) {
        // Handle special case for language-less locales
        if (len < 3 || len > 7 || (len >= 4 && str.charAt(3) != '_')) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 3) {
            return new Locale("""", str.substring(1, 3));
        }
        return new Locale("""", str.substring(1, 3), str.substring(4));
    } else {
        // Handle standard locale formats
        if (len < 2 || len > 7 || (len > 2 && str.charAt(2) != '_')) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        final char ch0 = str.charAt(0);
        final char ch1 = str.charAt(1);
        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 2) {
            return new Locale(str);
        }
        if (len == 5) {
            final char ch3 = str.charAt(3);
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5));
        }
        if (len == 7) {
            final char ch3 = str.charAt(3);
            final char ch4 = str.charAt(4);
            final char ch6 = str.charAt(6);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4) || str.charAt(5) != '_' || !Character.isLetterOrDigit(ch6)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
        }
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
}",3,0
137,Lang_5,"public static Locale toLocale(final String str) {
        if (str == null) {
            return null;
        }
        final int len = str.length();
        if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 2) {
                return new Locale(str);
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(2) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
            final char ch4 = str.charAt(4);
            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            }
            if (len < 7) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }","public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.startsWith(""_"")) {
        // Check for language-less locales
        if (len == 3) {
            return new Locale("""", str.substring(1, 3));
        } else if (len > 4 && str.charAt(3) == '_') {
            return new Locale("""", str.substring(1, 3), str.substring(4));
        } else {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
    }
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (len < 5) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    if (ch3 == '_') {
        return new Locale(str.substring(0, 2), """", str.substring(4));
    }
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    if (len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len > 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",4,0
138,Lang_51,"public static boolean toBoolean(String str) {
        // Previously used equalsIgnoreCase, which was fast for interned 'true'.
        // Non interned 'true' matched 15 times slower.
        // 
        // Optimisation provides same performance as before for interned 'true'.
        // Similar performance for null, 'false', and other strings not length 2/3/4.
        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
        if (str == ""true"") {
            return true;
        }
        if (str == null) {
            return false;
        }
        switch (str.length()) {
            case 2: {
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                return 
                    (ch0 == 'o' || ch0 == 'O') &&
                    (ch1 == 'n' || ch1 == 'N');
            }
            case 3: {
                char ch = str.charAt(0);
                if (ch == 'y') {
                    return 
                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
                        (str.charAt(2) == 's' || str.charAt(2) == 'S');
                }
                if (ch == 'Y') {
                    return 
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
             }
             case 4: {
                 char ch = str.charAt(0);
                if (ch == 't') {
                    return 
                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&
                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&
                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');
                }
                if (ch == 'T') {
                    return 
                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&
                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&
                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');
                }
            }
        }
        return false;
    }","public static boolean toBoolean(String str) {
    if (str == null) {
        return false;
    }

    switch (str.length()) {
        case 2: {
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            return 
                (ch0 == 'o' || ch0 == 'O') &&
                (ch1 == 'n' || ch1 == 'N');
        }
        case 3: {
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char ch2 = str.charAt(2);
            return 
                (ch0 == 'y' || ch0 == 'Y') &&
                (ch1 == 'e' || ch1 == 'E') &&
                (ch2 == 's' || ch2 == 'S');
        }
        case 4: {
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char ch2 = str.charAt(2);
            char ch3 = str.charAt(3);
            return 
                (ch0 == 't' || ch0 == 'T') &&
                (ch1 == 'r' || ch1 == 'R') &&
                (ch2 == 'u' || ch2 == 'U') &&
                (ch3 == 'e' || ch3 == 'E');
        }
        default:
            return false;
    }
}",0,0
139,Lang_52,"private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (str == null) {
            return;
        }
        int sz;
        sz = str.length();
        for (int i = 0; i < sz; i++) {
            char ch = str.charAt(i);

            // handle unicode
            if (ch > 0xfff) {
                out.write(""\\u"" + hex(ch));
            } else if (ch > 0xff) {
                out.write(""\\u0"" + hex(ch));
            } else if (ch > 0x7f) {
                out.write(""\\u00"" + hex(ch));
            } else if (ch < 32) {
                switch (ch) {
                    case '\b':
                        out.write('\\');
                        out.write('b');
                        break;
                    case '\n':
                        out.write('\\');
                        out.write('n');
                        break;
                    case '\t':
                        out.write('\\');
                        out.write('t');
                        break;
                    case '\f':
                        out.write('\\');
                        out.write('f');
                        break;
                    case '\r':
                        out.write('\\');
                        out.write('r');
                        break;
                    default :
                        if (ch > 0xf) {
                            out.write(""\\u00"" + hex(ch));
                        } else {
                            out.write(""\\u000"" + hex(ch));
                        }
                        break;
                }
            } else {
                switch (ch) {
                    case '\'':
                        if (escapeSingleQuote) {
                          out.write('\\');
                        }
                        out.write('\'');
                        break;
                    case '""':
                        out.write('\\');
                        out.write('""');
                        break;
                    case '\\':
                         out.write('\\');
                         out.write('\\');
                         break;
                     default :
                         out.write(ch);
                         break;
                }
            }
        }
    }","private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (str == null) {
        return;
    }
    int sz = str.length();
    for (int i = 0; i < sz; i++) {
        char ch = str.charAt(i);

        // handle unicode
        if (ch > 0xfff) {
            out.write(""\\u"" + hex(ch));
        } else if (ch > 0xff) {
            out.write(""\\u0"" + hex(ch));
        } else if (ch > 0x7f) {
            out.write(""\\u00"" + hex(ch));
        } else if (ch < 32) {
            switch (ch) {
                case '\b':
                    out.write('\\');
                    out.write('b');
                    break;
                case '\n':
                    out.write('\\');
                    out.write('n');
                    break;
                case '\t':
                    out.write('\\');
                    out.write('t');
                    break;
                case '\f':
                    out.write('\\');
                    out.write('f');
                    break;
                case '\r':
                    out.write('\\');
                    out.write('r');
                    break;
                default:
                    if (ch > 0xf) {
                        out.write(""\\u00"" + hex(ch));
                    } else {
                        out.write(""\\u000"" + hex(ch));
                    }
                    break;
            }
        } else {
            switch (ch) {
                case '\'':
                    if (escapeSingleQuote) {
                        out.write('\\');
                    }
                    out.write('\'');
                    break;
                case '""':
                    out.write('\\');
                    out.write('""');
                    break;
                case '\\':
                    out.write('\\');
                    out.write('\\');
                    break;
                case '/': // fixed handling for forward slash
                    out.write('\\');
                    out.write('/');
                    break;
                default:
                    out.write(ch);
                    break;
            }
        }
    }
}",0,0
140,Lang_53,"private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        
        if (field == Calendar.MILLISECOND) {
            return;
        }

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.

        Date date = val.getTime();
        long time = date.getTime();
        boolean done = false;

        // truncate milliseconds
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
         if (field == Calendar.SECOND) {
             done = true;
             }
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
         if (field == Calendar.MINUTE) {
             done = true;
             }
         }
 
         // truncate minutes
        int minutes = val.get(Calendar.MINUTE);
        if (!done && (!round || minutes < 30)) {
            time = time - (minutes * 60000L);
        }

        // reset time
        if (date.getTime() != time) {
            date.setTime(time);
            val.setTime(date);
        }
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
            if (offset != 0) {
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
            }
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    
    if (field == Calendar.MILLISECOND) {
        return;
    }

    Date date = val.getTime();
    long time = date.getTime();

    // Truncate milliseconds
    int millisecs = val.get(Calendar.MILLISECOND);
    if (!round || millisecs < 500) {
        time = time - millisecs;
        if (field == Calendar.SECOND) {
            val.setTime(new Date(time));
            return;
        }
    }

    // Truncate seconds
    int seconds = val.get(Calendar.SECOND);
    if (!round || seconds < 30) {
        time = time - (seconds * 1000L);
        if (field == Calendar.MINUTE) {
            val.setTime(new Date(time));
            return;
        }
    }

    // Truncate minutes
    int minutes = val.get(Calendar.MINUTE);
    if (!round || minutes < 30) {
        time = time - (minutes * 60000L);
    }

    if (date.getTime() != time) {
        date.setTime(time);
        val.setTime(date);
    }

    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }

        int offset = 0;
        boolean offsetSet = false;
        
        switch (field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    offset = val.get(Calendar.DATE) - 1;
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            offset = val.get(fields[i][0]) - min;
            roundUp = offset > ((max - min) / 2);
        }
        
        if (offset != 0) {
            val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}",0,0
140,Lang_53,"private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        
        if (field == Calendar.MILLISECOND) {
            return;
        }

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.

        Date date = val.getTime();
        long time = date.getTime();
        boolean done = false;

        // truncate milliseconds
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
         if (field == Calendar.SECOND) {
             done = true;
             }
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
         if (field == Calendar.MINUTE) {
             done = true;
             }
         }
 
         // truncate minutes
        int minutes = val.get(Calendar.MINUTE);
        if (!done && (!round || minutes < 30)) {
            time = time - (minutes * 60000L);
        }

        // reset time
        if (date.getTime() != time) {
            date.setTime(time);
            val.setTime(date);
        }
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
            if (offset != 0) {
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
            }
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    if (field == Calendar.MILLISECOND) {
        return;
    }

    Date date = val.getTime();
    long time = date.getTime();
    boolean truncateCompleted = false;

    // Truncate milliseconds, seconds and minutes sequentially
    int millisecs = val.get(Calendar.MILLISECOND);
    if (millisecs > 0) {
        time -= millisecs;
        if (!round || millisecs < 500) {
            val.setTime(new Date(time));
        }
        if (field == Calendar.SECOND) {
            truncateCompleted = true;
        }
    }

    if (!truncateCompleted) {
        int seconds = val.get(Calendar.SECOND);
        if (seconds > 0) {
            time -= seconds * 1000L;
            if (!round || seconds < 30) {
                val.setTime(new Date(time));
            }
            if (field == Calendar.MINUTE) {
                truncateCompleted = true;
            }
        }
    }

    if (!truncateCompleted) {
        int minutes = val.get(Calendar.MINUTE);
        if (minutes > 0) {
            time -= minutes * 60000L;
            if (!round || minutes < 30) {
                val.setTime(new Date(time));
            }
        }
    }

    boolean roundUp = false;
    for (int[] fieldGroup : fields) {
        for (int f : fieldGroup) {
            if (f == field) {
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        val.add(fieldGroup[0], 1);
                    }
                }
                return;
            }
        }
    }

    int offset = 0;
    switch (field) {
        case DateUtils.SEMI_MONTH:
            offset = val.get(Calendar.DATE) - 1;
            if (offset >= 15) {
                offset -= 15;
            }
            roundUp = offset > 7;
            break;

        case Calendar.AM_PM:
            offset = val.get(Calendar.HOUR_OF_DAY);
            if (offset >= 12) {
                offset -= 12;
            }
            roundUp = offset > 6;
            break;

        default:
            int min = val.getActualMinimum(Calendar.HOUR_OF_DAY);
            int max = val.getActualMaximum(Calendar.HOUR_OF_DAY);
            offset = val.get(Calendar.HOUR_OF_DAY) - min;
            roundUp = offset > ((max - min) / 2);
            break;
    }

    if (offset > 0) {
        val.set(fields[0][0], val.get(fields[0][0]) - offset);
    }

    throw new IllegalArgumentException(""Unsupported field for rounding operation: "" + field);
}",1,0
140,Lang_53,"private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        
        if (field == Calendar.MILLISECOND) {
            return;
        }

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.

        Date date = val.getTime();
        long time = date.getTime();
        boolean done = false;

        // truncate milliseconds
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
         if (field == Calendar.SECOND) {
             done = true;
             }
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
         if (field == Calendar.MINUTE) {
             done = true;
             }
         }
 
         // truncate minutes
        int minutes = val.get(Calendar.MINUTE);
        if (!done && (!round || minutes < 30)) {
            time = time - (minutes * 60000L);
        }

        // reset time
        if (date.getTime() != time) {
            date.setTime(time);
            val.setTime(date);
        }
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
            if (offset != 0) {
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
            }
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    if (field == Calendar.MILLISECOND) {
        return;
    }

    Date date = val.getTime();
    long time = date.getTime();

    boolean roundUp = false;
    int millisecs = val.get(Calendar.MILLISECOND);
    int seconds = val.get(Calendar.SECOND);
    int minutes = val.get(Calendar.MINUTE);

    // Adjust time based on truncation logic
    if (!round) {
        time -= millisecs;
        time -= (seconds * 1000L);
        time -= (minutes * 60000L);
        val.setTime(new Date(time));
    }

    int offset = 0;
    switch (field) {
        case DateUtils.SEMI_MONTH:
            offset = val.get(Calendar.DATE) - 1;
            if (offset >= 15) {
                offset -= 15;
            }
            roundUp = offset > 7;
            break;

        case Calendar.AM_PM:
            offset = val.get(Calendar.HOUR_OF_DAY);
            if (offset >= 12) {
                offset -= 12;
            }
            roundUp = offset > 6;
            break;

        default:
            int min = val.getActualMinimum(field);
            int max = val.getActualMaximum(field);
            offset = val.get(field) - min;
            roundUp = offset > ((max - min) / 2);
            break;
    }
    
    // Apply offset if needed
    if (!roundUp && offset != 0 && !round) {
        val.set(field, val.get(field) - offset);
    } else if (roundUp && round) { 
        val.set(field, val.get(field) + (max - min - offset));
    }
}",2,0
140,Lang_53,"private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        
        if (field == Calendar.MILLISECOND) {
            return;
        }

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.

        Date date = val.getTime();
        long time = date.getTime();
        boolean done = false;

        // truncate milliseconds
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
         if (field == Calendar.SECOND) {
             done = true;
             }
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
         if (field == Calendar.MINUTE) {
             done = true;
             }
         }
 
         // truncate minutes
        int minutes = val.get(Calendar.MINUTE);
        if (!done && (!round || minutes < 30)) {
            time = time - (minutes * 60000L);
        }

        // reset time
        if (date.getTime() != time) {
            date.setTime(time);
            val.setTime(date);
        }
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
            if (offset != 0) {
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
            }
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    if (field == Calendar.MILLISECOND) {
        return;
    }

    Date date = val.getTime();
    long time = date.getTime();

    // Truncate milliseconds, seconds, and minutes based on thresholds
    int millisecs = val.get(Calendar.MILLISECOND);
    time -= millisecs;

    if (field == Calendar.SECOND) {
        if (!round || millisecs < 500) {
            val.setTime(new Date(time));
            return;
        }
    }

    int seconds = val.get(Calendar.SECOND);
    time -= seconds * 1000L;

    if (field == Calendar.MINUTE) {
        if (!round || seconds < 30) {
            val.setTime(new Date(time));
            return;
        }
    }

    int minutes = val.get(Calendar.MINUTE);
    if (!round || minutes < 30) {
        time -= minutes * 60000L;
        val.setTime(new Date(time));
    }

    // Handle higher-order fields with rounding logic
    boolean roundUp = false;
    for (int[] fieldGroup : fields) {
        for (int f : fieldGroup) {
            if (f == field) {
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        val.add(fieldGroup[0], 1);
                    }
                }
                return;
            }
        }
    }

    int min = val.getActualMinimum(field);
    int max = val.getActualMaximum(field);
    int offset = val.get(field) - min;
    roundUp = offset > ((max - min) / 2);

    if (offset != 0) {
        if (roundUp && round) {
            val.set(field, val.get(field) + (max - min - offset));
        } else {
            val.set(field, val.get(field) - offset);
        }
    }
}",3,0
140,Lang_53,"private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        
        if (field == Calendar.MILLISECOND) {
            return;
        }

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.

        Date date = val.getTime();
        long time = date.getTime();
        boolean done = false;

        // truncate milliseconds
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
         if (field == Calendar.SECOND) {
             done = true;
             }
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
         if (field == Calendar.MINUTE) {
             done = true;
             }
         }
 
         // truncate minutes
        int minutes = val.get(Calendar.MINUTE);
        if (!done && (!round || minutes < 30)) {
            time = time - (minutes * 60000L);
        }

        // reset time
        if (date.getTime() != time) {
            date.setTime(time);
            val.setTime(date);
        }
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
            if (offset != 0) {
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
            }
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    if (field == Calendar.MILLISECOND) {
        return;
    }

    Date date = val.getTime();
    long time = date.getTime();

    int millisecs = val.get(Calendar.MILLISECOND);
    int seconds = val.get(Calendar.SECOND);
    int minutes = val.get(Calendar.MINUTE);

    // Reset time based on truncation logic
    if (!round) {
        time -= millisecs;
        time -= (seconds * 1000L);
        time -= (minutes * 60000L);
        val.setTime(new Date(time));
    } else {
        if (millisecs >= 500 || seconds >= 30 || minutes >= 30) {
            val.add(field, 1);
        } else {
            time -= millisecs;
            time -= (seconds * 1000L);
            time -= (minutes * 60000L);
            val.setTime(new Date(time));
        }
    }

    boolean roundUp = false;
    for (int[] fieldGroup : fields) {
        for (int f : fieldGroup) {
            if (f == field) {
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        val.add(fieldGroup[0], 1);
                    }
                }
                return;
            }
        }
    }

    int offset = 0;
    switch (field) {
        case DateUtils.SEMI_MONTH:
            offset = val.get(Calendar.DATE) - 1;
            if (offset >= 15) {
                offset -= 15;
            }
            roundUp = offset > 7;
            break;

        case Calendar.AM_PM:
            offset = val.get(Calendar.HOUR_OF_DAY);
            if (offset >= 12) {
                offset -= 12;
            }
            roundUp = offset > 6;
            break;

        default:
            int min = val.getActualMinimum(field);
            int max = val.getActualMaximum(field);
            offset = val.get(field) - min;
            roundUp = offset > ((max - min) / 2);
            break;
    }

    if (!round && offset != 0) {
        val.set(field, val.get(field) - offset);
    } else if (round && roundUp) {
        val.set(field, val.get(field) + (val.getActualMaximum(field) - offset));
    }
}",4,0
141,Lang_54,"public static Locale toLocale(String str) {
        if (str == null) {
            return null;
        }
        int len = str.length();
        if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch0 = str.charAt(0);
        char ch1 = str.charAt(1);
        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 2) {
            return new Locale(str, """");
        } else {
            if (str.charAt(2) != '_') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException(""Invalid locale format: "" + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }
    }","public static Locale toLocale(String str) {
    if (str == null) {
        return null;
    }
    int len = str.length();
    if (len != 2 && len != 5 && len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    char ch0 = str.charAt(0);
    char ch1 = str.charAt(1);
    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        // language only
        return new Locale(str, """");
    } else {
        if (str.charAt(2) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch3 = str.charAt(3);
        char ch4 = str.charAt(4);
        if (len == 5) {
            // language and country
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5));
        } else {
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            // language, country, and variant
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
        }
    }
}",0,0
141,Lang_54,"public static Locale toLocale(String str) {
        if (str == null) {
            return null;
        }
        int len = str.length();
        if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch0 = str.charAt(0);
        char ch1 = str.charAt(1);
        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 2) {
            return new Locale(str, """");
        } else {
            if (str.charAt(2) != '_') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException(""Invalid locale format: "" + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }
    }","public static Locale toLocale(String str) {
    if (str == null) {
        return null;
    }
    int len = str.length();
    if (len < 2 || (len != 2 && len != 5 && len < 7)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    char ch0 = str.charAt(0);
    char ch1 = str.charAt(1);
    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str, """");
    } else {
        if (str.charAt(2) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch3 = len >= 4 ? str.charAt(3) : 0;
        char ch4 = len >= 5 ? str.charAt(4) : 0;
        if (len == 5) {
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5));
        } else {
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
        }
    }
}",1,0
141,Lang_54,"public static Locale toLocale(String str) {
        if (str == null) {
            return null;
        }
        int len = str.length();
        if (len != 2 && len != 5 && len < 7) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch0 = str.charAt(0);
        char ch1 = str.charAt(1);
        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 2) {
            return new Locale(str, """");
        } else {
            if (str.charAt(2) != '_') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 5) {
                return new Locale(str.substring(0, 2), str.substring(3, 5));
            } else {
                if (str.charAt(5) != '_') {
                    throw new IllegalArgumentException(""Invalid locale format: "" + str);
                }
                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
            }
        }
    }","public static Locale toLocale(String str) {
    if (str == null) {
        return null;
    }
    int len = str.length();
    if (len < 2 || (len != 2 && len != 5 && len < 7)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    char ch0 = str.charAt(0);
    char ch1 = str.charAt(1);
    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str, """");
    }
    if (str.contains(""__"")) {
        String[] parts = str.split(""__"");
        if (parts.length != 2 || parts[0].length() != 2 || parts[0].charAt(0) < 'a' || parts[0].charAt(0) > 'z'
                || parts[0].charAt(1) < 'a' || parts[0].charAt(1) > 'z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        return new Locale(parts[0], """", parts[1]);
    } else {
        if (str.charAt(2) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch3 = str.charAt(3);
        char ch4 = str.charAt(4);
        if (len == 5) {
            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5));
        } else {
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
        }
    }
}",2,0
142,Lang_55,"public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
             stopTime = System.currentTimeMillis();
         this.runningState = STATE_STOPPED;
     }","public void stop() {
    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch must be running to stop."");
    }
    this.stopTime = System.currentTimeMillis(); // Ensure stopTime is updated properly
    this.runningState = STATE_STOPPED; // Update state to stopped after recording stop time
}",0,0
142,Lang_55,"public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
             stopTime = System.currentTimeMillis();
         this.runningState = STATE_STOPPED;
     }","public void stop() {
    if (this.runningState == STATE_STOPPED) {
        throw new IllegalStateException(""Stopwatch is already stopped."");
    }
    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch must be running or suspended to stop."");
    }
    if (this.runningState == STATE_RUNNING) {
        this.stopTime = System.currentTimeMillis(); // Record time only if the stopwatch was running
    }
    this.runningState = STATE_STOPPED; // Update state to stopped
}",1,0
143,Lang_57,"    public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
    }
","public static boolean isAvailableLocale(Locale locale) {
    if (locale == null || cAvailableLocaleSet == null) {
        return false;
    }
    return cAvailableLocaleSet.contains(locale);
}",0,0
144,Lang_58,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                 case 'L' :
                     if (dec == null
                         && exp == null
                         && isDigits(numeric.substring(1))
                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null; // Invalid input
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mantissa;
    String decimal;
    String exponent;
    int decimalPos = str.indexOf('.');
    int exponentPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decimalPos > -1) {
        if (exponentPos > -1) {
            if (exponentPos < decimalPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPos + 1, exponentPos);
        } else {
            decimal = str.substring(decimalPos + 1);
        }
        mantissa = str.substring(0, decimalPos);
    } else {
        if (exponentPos > -1) {
            mantissa = str.substring(0, exponentPos);
        } else {
            mantissa = str;
        }
        decimal = null;
    }

    if (!Character.isDigit(lastChar)) {
        if (exponentPos > -1 && exponentPos < str.length() - 1) {
            exponent = str.substring(exponentPos + 1, str.length() - 1);
        } else {
            exponent = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);

        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric.substring(1))
                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException ignored) {
                }
                // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException ignored) {
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException ignored) {
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (exponentPos > -1 && exponentPos < str.length() - 1) {
            exponent = str.substring(exponentPos + 1);
        } else {
            exponent = null;
        }

        if (decimal == null && exponent == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException ignored) {
            }
            try {
                return createLong(str);
            } catch (NumberFormatException ignored) {
            }
            return createBigInteger(str);
        } else {
            boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException ignored) {
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException ignored) {
            }
            return createBigDecimal(str);
        }
    }
}",0,0
144,Lang_58,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                 case 'L' :
                     if (dec == null
                         && exp == null
                         && isDigits(numeric.substring(1))
                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null; // Invalid input
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mantissa;
    String decimal;
    String exponent;
    int decimalPos = str.indexOf('.');
    int exponentPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decimalPos > -1) {
        if (exponentPos > -1) {
            if (exponentPos < decimalPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPos + 1, exponentPos);
        } else {
            decimal = str.substring(decimalPos + 1);
        }
        mantissa = str.substring(0, decimalPos);
    } else {
        if (exponentPos > -1) {
            mantissa = str.substring(0, exponentPos);
        } else {
            mantissa = str;
        }
        decimal = null;
    }

    if (!Character.isDigit(lastChar)) {
        if (exponentPos > -1 && exponentPos < str.length() - 1) {
            exponent = str.substring(exponentPos + 1, str.length() - 1);
        } else {
            exponent = null;
        }
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);

        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)
                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException ignored) {
                }
                if (!numeric.contains(""."")) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException ignored) {
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException ignored) {
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (exponentPos > -1 && exponentPos < str.length() - 1) {
            exponent = str.substring(exponentPos + 1);
        } else {
            exponent = null;
        }

        if (decimal == null && exponent == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException ignored) {
            }
            try {
                return createLong(str);
            } catch (NumberFormatException ignored) {
            }
            return createBigInteger(str);
        } else {
            boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);
            if (!str.contains(""."")) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException ignored) {
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException ignored) {
            }
            return createBigDecimal(str);
        }
    }
}",1,0
144,Lang_58,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                 case 'L' :
                     if (dec == null
                         && exp == null
                         && isDigits(numeric.substring(1))
                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null; // Invalid input case
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }

    char lastChar = str.charAt(str.length() - 1);
    String mantissa, decimal, exponent;
    int decimalPos = str.indexOf('.');
    int exponentPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decimalPos > -1) {
        if (exponentPos > -1) {
            if (exponentPos < decimalPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            decimal = str.substring(decimalPos + 1, exponentPos);
        } else {
            decimal = str.substring(decimalPos + 1);
        }
        mantissa = str.substring(0, decimalPos);
    } else {
        if (exponentPos > -1) {
            mantissa = str.substring(0, exponentPos);
        } else {
            mantissa = str;
        }
        decimal = null;
    }

    if (!Character.isDigit(lastChar)) {
        String numeric = str.substring(0, str.length() - 1);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException ignored) {
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    return NumberUtils.createFloat(numeric);
                } catch (NumberFormatException ignored) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            case 'd':
            case 'D':
                try {
                    return NumberUtils.createDouble(numeric);
                } catch (NumberFormatException ignored) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (decimalPos > -1 || exponentPos > -1) {
            try {
                return createBigDecimal(str);
            } catch (NumberFormatException e) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
        }
        try {
            return createInteger(str);
        } catch (NumberFormatException ignored) {
        }
        try {
            return createLong(str);
        } catch (NumberFormatException ignored) {
        }
        return createBigInteger(str);
    }
}",2,0
144,Lang_58,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                 case 'L' :
                     if (dec == null
                         && exp == null
                         && isDigits(numeric.substring(1))
                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null || StringUtils.isBlank(str)) {
        throw new NumberFormatException(""Input is null or blank"");
    }
    if (str.startsWith(""--"")) {
        return null; // Invalid input format
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }

    char lastChar = str.charAt(str.length() - 1);
    String mantissa, decimal, exponent = null;
    int decimalPos = str.indexOf('.');
    int exponentPos = str.indexOf('e') > -1 ? str.indexOf('e') : str.indexOf('E');

    if (decimalPos > -1) {
        if (exponentPos > -1 && exponentPos < decimalPos) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }
        decimal = (exponentPos > -1) ? str.substring(decimalPos + 1, exponentPos) : str.substring(decimalPos + 1);
        mantissa = str.substring(0, decimalPos);
    } else {
        mantissa = (exponentPos > -1) ? str.substring(0, exponentPos) : str;
        decimal = null;
    }

    if (exponentPos > -1 && exponentPos < str.length() - 1) {
        exponent = str.substring(exponentPos + 1);
    }

    if (!Character.isDigit(lastChar)) {
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mantissa) && isAllZeros(exponent);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException e) {
                        return createBigInteger(numeric);
                    }
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!f.isInfinite() && (f.floatValue() != 0.0F || allZeros)) {
                        return f;
                    }
                } catch (NumberFormatException e) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                // Fall through if invalid
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!d.isInfinite() && (d.doubleValue() != 0.0D || allZeros)) {
                        return d;
                    }
                } catch (NumberFormatException e) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (decimal == null && exponent == null) {
            try {
                return createInteger(str);
            } catch (NumberFormatException ignored) {
            }
            try {
                return createLong(str);
            } catch (NumberFormatException ignored) {
            }
            return createBigInteger(str);
        } else {
            try {
                return createBigDecimal(str);
            } catch (NumberFormatException e) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
        }
    }
}",3,0
144,Lang_58,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar)) {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                 case 'L' :
                     if (dec == null
                         && exp == null
                         && isDigits(numeric.substring(1))
                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //Fall through
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //Fall through
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null || StringUtils.isBlank(str)) {
        throw new NumberFormatException(""Input is null or blank"");
    }
    if (str.startsWith(""--"")) {
        return null; // Invalid input
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }

    char lastChar = str.charAt(str.length() - 1);
    String mantissa, decimal, exponent = null;
    int decimalPos = str.indexOf('.');
    int exponentPos = Math.max(str.indexOf('e'), str.indexOf('E'));

    if (decimalPos > -1) {
        if (exponentPos > -1 && exponentPos < decimalPos) {
            throw new NumberFormatException(str + "" is not a valid number."");
        }
        decimal = (exponentPos > -1) ? str.substring(decimalPos + 1, exponentPos) : str.substring(decimalPos + 1);
        mantissa = str.substring(0, decimalPos);
    } else {
        mantissa = (exponentPos > -1) ? str.substring(0, exponentPos) : str;
        decimal = null;
    }

    if (exponentPos > -1 && exponentPos < str.length() - 1) {
        exponent = str.substring(exponentPos + 1);
    }

    if (!Character.isDigit(lastChar)) {
        String numeric = str.substring(0, str.length() - 1);
        switch (lastChar) {
            case 'l':
            case 'L':
                if (decimal == null && exponent == null && isDigits(numeric)) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException ignored) {
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    return NumberUtils.createFloat(numeric);
                } catch (NumberFormatException ignored) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            case 'd':
            case 'D':
                try {
                    return NumberUtils.createDouble(numeric);
                } catch (NumberFormatException ignored) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        if (decimalPos > -1 || exponentPos > -1) {
            try {
                return createBigDecimal(str);
            } catch (NumberFormatException e) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
        }
        try {
            return createInteger(str);
        } catch (NumberFormatException ignored) {
        }
        try {
            return createLong(str);
        } catch (NumberFormatException ignored) {
        }
        return createBigInteger(str);
    }
}",4,0
145,Lang_59,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
        if (width > 0) {
            ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, strLen, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
                for (int i = 0; i < padLen; i++) {
                    buffer[size + strLen + i] = padChar;
                }
            }
            size += width;
        }
        return this;
    }","public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = str.length();
        if (strLen >= width) {
            // Only copy up to the specified width to avoid StringIndexOutOfBoundsException.
            str.getChars(0, width, buffer, size);
        } else {
            int padLen = width - strLen;
            str.getChars(0, strLen, buffer, size);
            for (int i = 0; i < padLen; i++) {
                buffer[size + strLen + i] = padChar;
            }
        }
        size += width;
    }
    return this;
}",0,0
146,Lang_6,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
            return;
        }
        int pos = 0;
        int len = input.length();
        while (pos < len) {
            int consumed = translate(input, pos, out);
            if (consumed == 0) {
                char[] c = Character.toChars(Character.codePointAt(input, pos));
                out.write(c);
                pos+= c.length;
                continue;
            }
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            pos += c.length;
        } else {
            // Adjust the position correctly, ensuring the surrogate pairs are handled properly
            for (int pt = 0; pt < consumed; pt++) {
                pos += Character.charCount(Character.codePointAt(input, pos));
            }
        }
    }
}",0,0
146,Lang_6,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
            return;
        }
        int pos = 0;
        int len = input.length();
        while (pos < len) {
            int consumed = translate(input, pos, out);
            if (consumed == 0) {
                char[] c = Character.toChars(Character.codePointAt(input, pos));
                out.write(c);
                pos+= c.length;
                continue;
            }
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = 0;
        if (Character.isHighSurrogate(input.charAt(pos)) && pos + 1 < len && Character.isLowSurrogate(input.charAt(pos + 1))) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            consumed = c.length;
        } else {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            consumed = c.length;
        }
        pos += consumed;
    }
}",1,0
146,Lang_6,"public final void translate(CharSequence input, Writer out) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (input == null) {
            return;
        }
        int pos = 0;
        int len = input.length();
        while (pos < len) {
            int consumed = translate(input, pos, out);
            if (consumed == 0) {
                char[] c = Character.toChars(Character.codePointAt(input, pos));
                out.write(c);
                pos+= c.length;
                continue;
            }
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            pos += c.length;
        } else {
            // Handle valid codepoints only, skipping potential invalid surrogate pairs
            for (int pt = 0; pt < consumed; pt++) {
                if (pos >= len) {
                    break; // Prevent out-of-bounds access
                }
                pos += Character.charCount(Character.codePointAt(input, pos));
            }
        }
    }
}",2,0
147,Lang_61,"public int indexOf(String str, int startIndex) {
        startIndex = (startIndex < 0 ? 0 : startIndex);
        if (str == null || startIndex >= size) {
            return -1;
        }
        int strLen = str.length();
        if (strLen == 1) {
            return indexOf(str.charAt(0), startIndex);
        }
        if (strLen == 0) {
            return startIndex;
        }
        if (strLen > size) {
             return -1;
         }
         char[] thisBuf = buffer;
         int len = thisBuf.length - strLen;
         outer:
         for (int i = startIndex; i < len; i++) {
             for (int j = 0; j < strLen; j++) {
                if (str.charAt(j) != thisBuf[i + j]) {
                    continue outer;
                }
            }
            return i;
        }
        return -1;
    }","public int indexOf(String str, int startIndex) {
    startIndex = Math.max(startIndex, 0);
    if (str == null || startIndex >= size || str.length() > size) {
        return -1;
    }
    
    int strLen = str.length();
    if (strLen == 1) {
        return indexOf(str.charAt(0), startIndex);
    }
    if (strLen == 0) {
        return startIndex;
    }
    
    char[] thisBuf = buffer;
    int len = size - strLen + 1;
    outer:
    for (int i = startIndex; i < len; i++) {
        for (int j = 0; j < strLen; j++) {
            if (str.charAt(j) != thisBuf[i + j]) {
                continue outer;
            }
        }
        return i;
    }
    return -1;
}",0,0
148,Lang_65,"    private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.


        // truncate milliseconds

        // truncate seconds

        // truncate minutes

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }
","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
 
    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                //This is our field... we stop looping
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        //This is a special case that's hard to generalize
                        //If the date is 1, we round up to 16, otherwise
                        //  we subtract 15 days and add 1 month
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        //We need at add one to this field since the
                        // last number causes us to round up
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }
        //We have various fields that are not easy roundings
        int offset = 0;
        boolean offsetSet = false;
        //These are special types of fields that require different rounding rules
        switch (field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    offset = val.get(Calendar.DATE) - 1;
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            offset = val.get(fields[i][0]) - min;
            roundUp = offset > ((max - min) / 2);
        }
        val.set(fields[i][0], val.get(fields[i][0]) - offset);
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}",0,0
148,Lang_65,"    private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.


        // truncate milliseconds

        // truncate seconds

        // truncate minutes

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }
","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    
    // Manually truncate smaller units to address truncation issues
    if (field >= Calendar.MILLISECOND) {
        val.set(Calendar.MILLISECOND, 0);
    }
    if (field >= Calendar.SECOND) {
        val.set(Calendar.SECOND, 0);
    }
    if (field >= Calendar.MINUTE) {
        val.set(Calendar.MINUTE, 0);
    }

    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                int offset = computeOffset(val, fields[i][0], round);
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
                if (round && roundUp) {
                    val.add(fields[i][0], 1);
                }
                return;
            }
        }
    }

    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}

private static int computeOffset(Calendar val, int field, boolean round) {
    int offset = 0;
    switch (field) {
        case DateUtils.SEMI_MONTH:
            offset = val.get(Calendar.DATE) - 1;
            if (offset >= 15) {
                offset -= 15;
            }
            roundUp = offset > 7;
            break;
        case Calendar.AM_PM:
            offset = val.get(Calendar.HOUR_OF_DAY);
            if (offset >= 12) {
                offset -= 12;
            }
            roundUp = offset > 6;
            break;
        default:
            int min = val.getActualMinimum(field);
            int max = val.getActualMaximum(field);
            offset = val.get(field) - min;
            roundUp = offset > ((max - min) / 2);
    }
    return offset;
}",1,0
148,Lang_65,"    private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.


        // truncate milliseconds

        // truncate seconds

        // truncate minutes

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }
","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }

    // Handle truncation specifics for time fields
    if (field == Calendar.MILLISECOND || field == Calendar.SECOND || field == Calendar.MINUTE) {
        val.add(field, 0);
        return;
    }

    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                int offset = computeOffset(val, fields[i][0], round);
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
                if (round && roundUp) {
                    val.add(fields[i][0], 1);
                }
                return;
            }
        }
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}

private static int computeOffset(Calendar val, int field, boolean round) {
    int offset = 0;
    switch (field) {
        case DateUtils.SEMI_MONTH:
            offset = val.get(Calendar.DATE) - 1;
            if (offset >= 15) {
                offset -= 15;
            }
            roundUp = offset > 7;
            break;
        case Calendar.AM_PM:
            offset = val.get(Calendar.HOUR_OF_DAY);
            if (offset >= 12) {
                offset -= 12;
            }
            roundUp = offset > 6;
            break;
        default:
            int min = val.getActualMinimum(field);
            int max = val.getActualMaximum(field);
            offset = val.get(field) - min;
            roundUp = offset > ((max - min) / 2);
    }
    return offset;
}",2,0
148,Lang_65,"    private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.


        // truncate milliseconds

        // truncate seconds

        // truncate minutes

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }
","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }

    boolean roundUp = false;
    int offset = 0;
    
    // Round handling for time fields
    if (field == Calendar.SECOND) {
        val.set(Calendar.MILLISECOND, 0);
    } else if (field == Calendar.MINUTE) {
        val.set(Calendar.MILLISECOND, 0);
        val.set(Calendar.SECOND, 0);
    }

    // Calculate offset based on manual truncation for specific fields
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                if (round && roundUp) {
                    val.add(fields[i][0], 1);
                }
                return;
            }
        }

        switch (field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    offset = (val.get(Calendar.DATE) - 1) % 15;
                    roundUp = offset >= 7;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    offset = val.get(Calendar.HOUR_OF_DAY) % 12;
                    roundUp = offset >= 6;
                }
                break;
            default:
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                offset = val.get(fields[i][0]) - min;
                roundUp = offset > ((max - min) / 2);
        }
        if (offset > 0) {
            val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
    }

    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}",3,0
148,Lang_65,"    private static void modify(Calendar val, int field, boolean round) {
        if (val.get(Calendar.YEAR) > 280000000) {
            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
        }
        

        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.


        // truncate milliseconds

        // truncate seconds

        // truncate minutes

        // reset time
        // ----------------- Fix for LANG-59 ----------------------- END ----------------

        boolean roundUp = false;
        for (int i = 0; i < fields.length; i++) {
            for (int j = 0; j < fields[i].length; j++) {
                if (fields[i][j] == field) {
                    //This is our field... we stop looping
                    if (round && roundUp) {
                        if (field == DateUtils.SEMI_MONTH) {
                            //This is a special case that's hard to generalize
                            //If the date is 1, we round up to 16, otherwise
                            //  we subtract 15 days and add 1 month
                            if (val.get(Calendar.DATE) == 1) {
                                val.add(Calendar.DATE, 15);
                            } else {
                                val.add(Calendar.DATE, -15);
                                val.add(Calendar.MONTH, 1);
                            }
                        } else {
                            //We need at add one to this field since the
                            //  last number causes us to round up
                            val.add(fields[i][0], 1);
                        }
                    }
                    return;
                }
            }
            //We have various fields that are not easy roundings
            int offset = 0;
            boolean offsetSet = false;
            //These are special types of fields that require different rounding rules
            switch (field) {
                case DateUtils.SEMI_MONTH:
                    if (fields[i][0] == Calendar.DATE) {
                        //If we're going to drop the DATE field's value,
                        //  we want to do this our own way.
                        //We need to subtrace 1 since the date has a minimum of 1
                        offset = val.get(Calendar.DATE) - 1;
                        //If we're above 15 days adjustment, that means we're in the
                        //  bottom half of the month and should stay accordingly.
                        if (offset >= 15) {
                            offset -= 15;
                        }
                        //Record whether we're in the top or bottom half of that range
                        roundUp = offset > 7;
                        offsetSet = true;
                    }
                    break;
                case Calendar.AM_PM:
                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                        //If we're going to drop the HOUR field's value,
                        //  we want to do this our own way.
                        offset = val.get(Calendar.HOUR_OF_DAY);
                        if (offset >= 12) {
                            offset -= 12;
                        }
                        roundUp = offset > 6;
                        offsetSet = true;
                    }
                    break;
            }
            if (!offsetSet) {
                int min = val.getActualMinimum(fields[i][0]);
                int max = val.getActualMaximum(fields[i][0]);
                //Calculate the offset from the minimum allowed value
                offset = val.get(fields[i][0]) - min;
                //Set roundUp if this is more than half way between the minimum and maximum
                roundUp = offset > ((max - min) / 2);
            }
            //We need to remove this field
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
        throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

    }
","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }

    boolean roundUp = false;
    int offset = 0;

    // Using proper truncation and rounding for specified fields
    switch (field) {
        case Calendar.MILLISECOND:
            val.set(Calendar.MILLISECOND, 0);
            break;
        case Calendar.SECOND:
            val.set(Calendar.SECOND, 0);
            break;
        case Calendar.MINUTE:
            val.set(Calendar.MINUTE, 0);
            break;
        case DateUtils.SEMI_MONTH:
            offset = val.get(Calendar.DATE) - 1;
            if (offset >= 15) {
                offset -= 15;
                roundUp = offset > 7;
            }
            val.set(Calendar.DATE, val.get(Calendar.DATE) - offset);
            break;
        case Calendar.AM_PM:
            offset = val.get(Calendar.HOUR_OF_DAY);
            if (offset >= 12) {
                offset -= 12;
                roundUp = offset > 6;
            }
            val.set(Calendar.HOUR_OF_DAY, val.get(Calendar.HOUR_OF_DAY) - offset);
            break;
        default:
            offset = computeGenericOffset(val, field, round);
            val.set(field, val.get(field) - offset);
    }

    if (round && roundUp) {
        if (field == DateUtils.SEMI_MONTH) {
            val.add(Calendar.DATE, 15);
        } else {
            val.add(field, 1);
        }
    }
}

private static int computeGenericOffset(Calendar val, int field, boolean round) {
    int min = val.getActualMinimum(field);
    int max = val.getActualMaximum(field);
    int offset = val.get(field) - min;
    return offset > ((max - min) / 2) ? offset : 0;
}",4,0
149,Lang_9,"private void init() {
        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex= new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher= formatPattern.matcher(pattern);
        if(!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField= patternMatcher.group();
        Strategy currentStrategy= getStrategy(currentFormatField);
        for(;;) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if(!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField= patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if(currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
        currentFormatField= null;
        strategies= collector.toArray(new Strategy[collector.size()]);
        parsePattern= Pattern.compile(regex.toString());
    }","private void init() {
    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();

    StringBuilder regex = new StringBuilder();
    List<Strategy> collector = new ArrayList<Strategy>();

    Matcher patternMatcher = formatPattern.matcher(pattern);
    if (!patternMatcher.lookingAt()) {
        throw new IllegalArgumentException(""Invalid pattern"");
    }

    currentFormatField = patternMatcher.group();
    Strategy currentStrategy = getStrategy(currentFormatField);
    for (;;) {
        patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
        if (!patternMatcher.lookingAt()) {
            nextStrategy = null;
            break;
        }
        String nextFormatField = patternMatcher.group();
        nextStrategy = getStrategy(nextFormatField);
        if (currentStrategy.addRegex(this, regex)) {
            collector.add(currentStrategy);
        }
        currentFormatField = nextFormatField;
        currentStrategy = nextStrategy;
    }
    if (currentStrategy.addRegex(this, regex)) {
        collector.add(currentStrategy);
    }
    currentFormatField = null;
    strategies = collector.toArray(new Strategy[collector.size()]);
    if (regex.length() == 0) {
        throw new IllegalArgumentException(""Invalid regex pattern"");
    }
    parsePattern = Pattern.compile(regex.toString());
}",0,0
149,Lang_9,"private void init() {
        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex= new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher= formatPattern.matcher(pattern);
        if(!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField= patternMatcher.group();
        Strategy currentStrategy= getStrategy(currentFormatField);
        for(;;) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if(!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField= patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if(currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
        currentFormatField= null;
        strategies= collector.toArray(new Strategy[collector.size()]);
        parsePattern= Pattern.compile(regex.toString());
    }","private void init() {
    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();

    StringBuilder regex = new StringBuilder();
    List<Strategy> collector = new ArrayList<Strategy>();

    Matcher patternMatcher = formatPattern.matcher(pattern);
    if (!patternMatcher.lookingAt()) {
        throw new IllegalArgumentException(""Invalid pattern"");
    }

    currentFormatField = patternMatcher.group();
    Strategy currentStrategy = getStrategy(currentFormatField);
    while (patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()).lookingAt()) {
        String nextFormatField = patternMatcher.group();
        Strategy nextStrategy = getStrategy(nextFormatField);

        currentStrategy = nextStrategy;
        currentFormatField = nextFormatField;

        if (currentStrategy.addRegex(this, regex)) {
            collector.add(currentStrategy);
        }
    }
    if (regex.length() == 0) {
        throw new IllegalArgumentException(""Invalid regex pattern"");
    }
    currentFormatField = null;
    strategies = collector.toArray(new Strategy[collector.size()]);
    parsePattern = Pattern.compile(regex.toString());
}",1,0
149,Lang_9,"private void init() {
        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex= new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher= formatPattern.matcher(pattern);
        if(!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField= patternMatcher.group();
        Strategy currentStrategy= getStrategy(currentFormatField);
        for(;;) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if(!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField= patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if(currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
        currentFormatField= null;
        strategies= collector.toArray(new Strategy[collector.size()]);
        parsePattern= Pattern.compile(regex.toString());
    }","private void init() {
    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();

    StringBuilder regex = new StringBuilder();
    List<Strategy> collector = new ArrayList<Strategy>();

    Matcher patternMatcher = formatPattern.matcher(pattern);
    if (!patternMatcher.lookingAt()) {
        throw new IllegalArgumentException(""Invalid pattern"");
    }

    currentFormatField = patternMatcher.group();
    Strategy currentStrategy = getStrategy(currentFormatField);
    while (true) {
        // Adjusting the logic to correctly handle quoted text patterns
        if (currentFormatField.charAt(0) == '\'') {
            currentStrategy.addRegex(this, regex);
            collector.add(currentStrategy);
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if (!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
        } else {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if (!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField = patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if (currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
            currentFormatField = nextFormatField;
            currentStrategy = nextStrategy;
        }
    }
    if (currentStrategy.addRegex(this, regex)) {
        collector.add(currentStrategy);
    }
    currentFormatField = null;
    strategies = collector.toArray(new Strategy[collector.size()]);
    if (regex.length() == 0) {
        throw new IllegalArgumentException(""Invalid regex pattern"");
    }
    parsePattern = Pattern.compile(regex.toString());
}",2,0
149,Lang_9,"private void init() {
        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex= new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher= formatPattern.matcher(pattern);
        if(!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField= patternMatcher.group();
        Strategy currentStrategy= getStrategy(currentFormatField);
        for(;;) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if(!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField= patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if(currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
        currentFormatField= null;
        strategies= collector.toArray(new Strategy[collector.size()]);
        parsePattern= Pattern.compile(regex.toString());
    }","private void init() {
    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();

    StringBuilder regex = new StringBuilder();
    List<Strategy> collector = new ArrayList<Strategy>();

    Matcher patternMatcher = formatPattern.matcher(pattern);
    if (!patternMatcher.lookingAt()) {
        throw new IllegalArgumentException(""Invalid pattern"");
    }

    currentFormatField = patternMatcher.group();
    Strategy currentStrategy = getStrategy(currentFormatField);

    while (true) {
        patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
        if (!patternMatcher.lookingAt()) {
            nextStrategy = null;
            break;
        }
        String nextFormatField = patternMatcher.group();
        nextStrategy = getStrategy(nextFormatField);

        if (currentFormatField.charAt(0) == '\'' && currentFormatField.length() > 2) {
            // Handle quoted pattern fields separately
            currentStrategy = new CopyQuotedStrategy(currentFormatField.substring(1, currentFormatField.length() - 1));
        }

        if (currentStrategy.addRegex(this, regex)) {
            collector.add(currentStrategy);
        }

        currentFormatField = nextFormatField;
        currentStrategy = nextStrategy;
    }

    if (currentStrategy.addRegex(this, regex)) {
        collector.add(currentStrategy);
    }

    currentFormatField = null;
    strategies = collector.toArray(new Strategy[collector.size()]);
    if (regex.length() == 0) {
        throw new IllegalArgumentException(""Invalid regex pattern"");
    }
    parsePattern = Pattern.compile(regex.toString());
}",3,0
149,Lang_9,"private void init() {
        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

        StringBuilder regex= new StringBuilder();
        List<Strategy> collector = new ArrayList<Strategy>();

        Matcher patternMatcher= formatPattern.matcher(pattern);
        if(!patternMatcher.lookingAt()) {
            throw new IllegalArgumentException(""Invalid pattern"");
        }

        currentFormatField= patternMatcher.group();
        Strategy currentStrategy= getStrategy(currentFormatField);
        for(;;) {
            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
            if(!patternMatcher.lookingAt()) {
                nextStrategy = null;
                break;
            }
            String nextFormatField= patternMatcher.group();
            nextStrategy = getStrategy(nextFormatField);
            if(currentStrategy.addRegex(this, regex)) {
                collector.add(currentStrategy);
            }
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
        currentFormatField= null;
        strategies= collector.toArray(new Strategy[collector.size()]);
        parsePattern= Pattern.compile(regex.toString());
    }","private void init() {
    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();

    StringBuilder regex = new StringBuilder();
    List<Strategy> collector = new ArrayList<Strategy>();

    Matcher patternMatcher = formatPattern.matcher(pattern);
    if (!patternMatcher.lookingAt()) {
        throw new IllegalArgumentException(""Invalid pattern"");
    }

    currentFormatField = patternMatcher.group();
    Strategy currentStrategy = getStrategy(currentFormatField);

    while (true) {
        patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
        if (!patternMatcher.lookingAt()) {
            nextStrategy = null;
            break;
        }
        String nextFormatField = patternMatcher.group();
        nextStrategy = getStrategy(nextFormatField);

        // Avoid switching strategies on quoted fields
        if (currentFormatField.charAt(0) == '\'') {
            currentStrategy.addRegex(this, regex);
            collector.add(currentStrategy);
        }

        if (currentStrategy.addRegex(this, regex)) {
            collector.add(currentStrategy);
        }

        currentFormatField = nextFormatField;
        currentStrategy = nextStrategy;
    }

    if (currentStrategy.addRegex(this, regex)) {
        collector.add(currentStrategy);
    }
    
    currentFormatField = null;
    strategies = collector.toArray(new Strategy[collector.size()]);
    if (regex.length() == 0) {
        throw new IllegalArgumentException(""Invalid regex pattern"");
    }
    parsePattern = Pattern.compile(regex.toString());
}",4,0
150,Math_10,"public void atan2(final double[] y, final int yOffset,
                      final double[] x, final int xOffset,
                      final double[] result, final int resultOffset) {

        // compute r = sqrt(x^2+y^2)
        double[] tmp1 = new double[getSize()];
        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
        double[] tmp2 = new double[getSize()];
        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)

        if (x[xOffset] >= 0) {

            // compute atan2(y, x) = 2 atan(y / (r + x))
            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
            for (int i = 0; i < tmp2.length; ++i) {
                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
            }

        } else {

            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
            result[resultOffset] =
                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
            for (int i = 1; i < tmp2.length; ++i) {
                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))
            }

         }
 
         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
 
     }","public void atan2(final double[] y, final int yOffset,
                      final double[] x, final int xOffset,
                      final double[] result, final int resultOffset) {

    // compute r = sqrt(x^2+y^2)
    double[] tmp1 = new double[getSize()];
    multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
    double[] tmp2 = new double[getSize()];
    multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
    add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
    rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)

    if ((x[xOffset] == 0 && y[yOffset] == 0) || Double.isNaN(x[xOffset]) || Double.isNaN(y[yOffset])) {
        result[resultOffset] = Double.NaN;
        return;
    }

    if (x[xOffset] >= 0) {
        // compute atan2(y, x) = 2 atan(y / (r + x))
        add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
        for (int i = 0; i < tmp2.length; ++i) {
            result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
        }

    } else {
        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
        subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
        result[resultOffset] =
                ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
        for (int i = 1; i < tmp2.length; ++i) {
            result[resultOffset + i] = -2 * tmp2[i]; // -2 * atan(y / (r - x))
        }
    }
}",0,0
150,Math_10,"public void atan2(final double[] y, final int yOffset,
                      final double[] x, final int xOffset,
                      final double[] result, final int resultOffset) {

        // compute r = sqrt(x^2+y^2)
        double[] tmp1 = new double[getSize()];
        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
        double[] tmp2 = new double[getSize()];
        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)

        if (x[xOffset] >= 0) {

            // compute atan2(y, x) = 2 atan(y / (r + x))
            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
            for (int i = 0; i < tmp2.length; ++i) {
                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
            }

        } else {

            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
            result[resultOffset] =
                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
            for (int i = 1; i < tmp2.length; ++i) {
                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))
            }

         }
 
         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
 
     }","public void atan2(final double[] y, final int yOffset,
                  final double[] x, final int xOffset,
                  final double[] result, final int resultOffset) {

    // compute r = sqrt(x^2+y^2)
    double[] tmp1 = new double[getSize()];
    multiply(x, xOffset, x, xOffset, tmp1, 0); // x^2
    double[] tmp2 = new double[getSize()];
    multiply(y, yOffset, y, yOffset, tmp2, 0); // y^2
    add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2
    rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2)

    if (Double.isNaN(x[xOffset]) || Double.isNaN(y[yOffset]) || (x[xOffset] == 0 && y[yOffset] == 0)) {
        result[resultOffset] = Double.NaN;
        return;
    }

    if (x[xOffset] >= 0) {
        // compute atan2(y, x) = 2 atan(y / (r + x))
        add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
        for (int i = 0; i < tmp2.length; ++i) {
            result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
        }

    } else {
        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
        subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
        result[resultOffset] =
                ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
        for (int i = 1; i < tmp2.length; ++i) {
            result[resultOffset + i] = ((tmp2[0] <= 0) ? -2 * tmp2[i] : 2 * tmp2[i]); // +/- 2 * atan(y / (r - x))
        }
    }
}",1,0
150,Math_10,"public void atan2(final double[] y, final int yOffset,
                      final double[] x, final int xOffset,
                      final double[] result, final int resultOffset) {

        // compute r = sqrt(x^2+y^2)
        double[] tmp1 = new double[getSize()];
        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
        double[] tmp2 = new double[getSize()];
        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)

        if (x[xOffset] >= 0) {

            // compute atan2(y, x) = 2 atan(y / (r + x))
            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
            for (int i = 0; i < tmp2.length; ++i) {
                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
            }

        } else {

            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
            result[resultOffset] =
                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
            for (int i = 1; i < tmp2.length; ++i) {
                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))
            }

         }
 
         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
 
     }","public void atan2(final double[] y, final int yOffset,
                  final double[] x, final int xOffset,
                  final double[] result, final int resultOffset) {

    // compute r = sqrt(x^2+y^2)
    double[] tmp1 = new double[getSize()];
    multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
    double[] tmp2 = new double[getSize()];
    multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
    add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
    rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)

    if (x[xOffset] == 0 && y[yOffset] == 0) {
        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);
        return;
    }

    if (x[xOffset] >= 0) {
        // compute atan2(y, x) = 2 atan(y / (r + x))
        add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
        for (int i = 0; i < tmp2.length; ++i) {
            result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
        }

    } else {
        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
        subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
        result[resultOffset] =
                ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
        for (int i = 1; i < tmp2.length; ++i) {
            result[resultOffset + i] = -2 * tmp2[i]; // +/- 2 * atan(y / (r - x))
        }
    }
}",2,0
151,Math_101,"public Complex parse(String source, ParsePosition pos) {
        int initialIndex = pos.getIndex();

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse real
        Number re = parseNumber(source, getRealFormat(), pos);
        if (re == null) {
            // invalid real number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse sign
        int startIndex = pos.getIndex();
        char c = parseNextCharacter(source, pos);
        int sign = 0;
        switch (c) {
        case 0 :
            // no sign
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-' :
            sign = -1;
            break;
        case '+' :
            sign = 1;
            break;
        default :
            // invalid sign
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse imaginary
        Number im = parseNumber(source, getRealFormat(), pos);
        if (im == null) {
            // invalid imaginary number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse imaginary character
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
         if (
             source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             // set index back to initial, error index should be the start index
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }
        pos.setIndex(endIndex);

        return new Complex(re.doubleValue(), im.doubleValue() * sign);
    }","public Complex parse(String source, ParsePosition pos) {
    int initialIndex = pos.getIndex();

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse real
    Number re = parseNumber(source, getRealFormat(), pos);
    if (re == null) {
        // invalid real number
        // set index back to initial, error index should already be set
        pos.setIndex(initialIndex);
        return null;
    }

    // parse sign
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    int sign = 0;
    switch (c) {
    case 0 :
        // no sign
        return new Complex(re.doubleValue(), 0.0);
    case '-' :
        sign = -1;
        break;
    case '+' :
        sign = 1;
        break;
    default :
        // invalid sign
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse imaginary
    Number im = parseNumber(source, getRealFormat(), pos);
    if (im == null) {
        // invalid imaginary number
        pos.setIndex(initialIndex);
        return null;
    }

    // parse imaginary character
    int n = getImaginaryCharacter().length();
    startIndex = pos.getIndex();
    int endIndex = startIndex + n;
    if (startIndex <= source.length() - n && source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {
        pos.setIndex(endIndex);
        return new Complex(re.doubleValue(), im.doubleValue() * sign);
    } else {
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }
}",0,0
152,Math_102,"public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
        if ((expected.length < 2) || (expected.length != observed.length)) {
            throw new IllegalArgumentException(
                    ""observed, expected array lengths incorrect"");
        }
        if (!isPositive(expected) || !isNonNegative(observed)) {
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }","public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
    if ((expected == null) || (observed == null) || (expected.length < 2) || (expected.length != observed.length)) {
        throw new IllegalArgumentException(""observed, expected array lengths incorrect"");
    }
    if (!isPositive(expected) || !isNonNegative(observed)) {
        throw new IllegalArgumentException(""observed counts must be non-negative and expected counts must be positive"");
    }
    double sumSq = 0.0d;
    for (int i = 0; i < observed.length; i++) {
        double dev = ((double) observed[i] - expected[i]);
        sumSq += dev * dev / expected[i];
    }
    return sumSq;
}",0,0
152,Math_102,"public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
        if ((expected.length < 2) || (expected.length != observed.length)) {
            throw new IllegalArgumentException(
                    ""observed, expected array lengths incorrect"");
        }
        if (!isPositive(expected) || !isNonNegative(observed)) {
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }","public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
    if ((expected == null) || (observed == null) || (expected.length < 2) || (expected.length != observed.length)) {
        throw new IllegalArgumentException(""observed, expected array lengths incorrect"");
    }
    if (!isPositive(expected) || !isNonNegative(observed)) {
        throw new IllegalArgumentException(""observed counts must be non-negative and expected counts must be positive"");
    }
    double sumSq = 0.0d;
    for (int i = 0; i < observed.length; i++) {
        if (expected[i] == 0) {
            throw new IllegalArgumentException(""Expected count must not be zero"");
        }
        double dev = ((double) observed[i] - expected[i]);
        sumSq += dev * dev / expected[i];
    }
    return sumSq;
}",1,0
152,Math_102,"public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
        if ((expected.length < 2) || (expected.length != observed.length)) {
            throw new IllegalArgumentException(
                    ""observed, expected array lengths incorrect"");
        }
        if (!isPositive(expected) || !isNonNegative(observed)) {
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }","public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
    if ((expected == null) || (observed == null) || (expected.length < 2) || (expected.length != observed.length)) {
        throw new IllegalArgumentException(""observed, expected array lengths incorrect"");
    }
    if (!isPositive(expected) || !isNonNegative(observed)) {
        throw new IllegalArgumentException(""observed counts must be non-negative and expected counts must be positive"");
    }
    double sumSq = 0.0d;
    for (int i = 0; i < observed.length; i++) {
        if (observed[i] < 0 || expected[i] <= 0) {
            throw new IllegalArgumentException(""Invalid count values in observed or expected"");
        }
        double dev = ((double) observed[i] - expected[i]);
        sumSq += Math.pow(dev, 2) / Math.abs(expected[i]);
    }
    return sumSq;
}",2,0
152,Math_102,"public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
        if ((expected.length < 2) || (expected.length != observed.length)) {
            throw new IllegalArgumentException(
                    ""observed, expected array lengths incorrect"");
        }
        if (!isPositive(expected) || !isNonNegative(observed)) {
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }","public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
    if ((expected == null) || (observed == null) || (expected.length < 2) || (expected.length != observed.length)) {
        throw new IllegalArgumentException(""observed, expected array lengths incorrect"");
    }
    if (!isPositive(expected) || !isNonNegative(observed)) {
        throw new IllegalArgumentException(""observed counts must be non-negative and expected counts must be positive"");
    }
    double sumSq = 0.0d;
    for (int i = 0; i < observed.length; i++) {
        double dev = ((double) observed[i] - expected[i]);
        double correction = (expected[i] - observed[i]) / expected[i];
        sumSq += (dev * dev / expected[i]) * (1 - correction * correction);
    }
    return sumSq;
}",3,0
152,Math_102,"public double chiSquare(double[] expected, long[] observed)
        throws IllegalArgumentException {
        if ((expected.length < 2) || (expected.length != observed.length)) {
            throw new IllegalArgumentException(
                    ""observed, expected array lengths incorrect"");
        }
        if (!isPositive(expected) || !isNonNegative(observed)) {
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }","public double chiSquare(double[] expected, long[] observed) throws IllegalArgumentException {
    if ((expected == null) || (observed == null) || (expected.length < 2) || (expected.length != observed.length)) {
        throw new IllegalArgumentException(""observed, expected array lengths incorrect"");
    }
    if (!isPositive(expected) || !isNonNegative(observed)) {
        throw new IllegalArgumentException(""observed counts must be non-negative and expected counts must be positive"");
    }
    double sumSq = 0.0d;
    for (int i = 0; i < observed.length; i++) {
        double dev = ((double) observed[i] - expected[i]);

        // Applying Yates's correction for continuity
        if (Math.abs(dev) > 0.5) {
            dev -= dev > 0 ? 0.5 : -0.5;
        }

        sumSq += dev * dev / expected[i];
    }
    return sumSq;
}",4,0
153,Math_103,"    public double cumulativeProbability(double x) throws MathException {
            return 0.5 * (1.0 + Erf.erf((x - mean) /
                    (standardDeviation * Math.sqrt(2.0))));
    }
",Match failed,0,0
153,Math_103,"    public double cumulativeProbability(double x) throws MathException {
            return 0.5 * (1.0 + Erf.erf((x - mean) /
                    (standardDeviation * Math.sqrt(2.0))));
    }
","public double cumulativeProbability(double x) throws MathException {
    double threshold = 20; // Arbirtrary threshold to handle extreme values
    if (Math.abs(x - mean) > threshold * standardDeviation) {
        return x < mean ? 0.0 : 1.0; // Return extreme probabilities directly
    }
    
    try {
        return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));
    } catch (MaxIterationsExceededException e) {
        throw new MathException(""Maximum number of iterations exceeded"", e);
    }
}",1,0
154,Math_105,"    public double getSumSquaredErrors() {
        return sumYY - sumXY * sumXY / sumXX;
    }
","public double getSumSquaredErrors() {
    if (sumXX == 0) { 
        return Double.NaN; 
    }
    return sumYY - (sumXY * sumXY / sumXX);
}",0,0
154,Math_105,"    public double getSumSquaredErrors() {
        return sumYY - sumXY * sumXY / sumXX;
    }
","public double getSumSquaredErrors() {
    // Ensure no division by zero, which may cause inaccuracies
    if (sumXX == 0) {
        return sumYY; // When sumXX is zero, return sumYY as it represents the total squared errors in absence of correlation
    }
    // Restrict the result to be non-negative by using Math.max to prevent from returning negative errors
    return Math.max(0, sumYY - (sumXY * sumXY / sumXX));
}",1,0
154,Math_105,"    public double getSumSquaredErrors() {
        return sumYY - sumXY * sumXY / sumXX;
    }
","public double getSumSquaredErrors() {
    // Consider cases where sumXX might be negative due to data error or precision issues
    if (sumXX <= 0) {
        return Double.NaN; // invalid data state that prevents meaningful calculation
    }
    double sse = sumYY - (sumXY * sumXY / sumXX);
    return sse < 0 ? Double.NaN : sse; // return NaN if result is negative, indicating inconsistency
}",2,0
154,Math_105,"    public double getSumSquaredErrors() {
        return sumYY - sumXY * sumXY / sumXX;
    }
","public double getSumSquaredErrors() {
    // Adjust calculation to ensure positive sum squared errors and handle edge case
    if (sumXX <= 0) {
        return Double.NaN;
    }
    double correlationFactor = sumXY * sumXY / sumXX;
    if (sumYY < correlationFactor) {
        return 0; // Negative error adjusted to zero as sum squared errors can't be negative
    }
    return sumYY - correlationFactor;
}",3,0
155,Math_106,"    public Fraction parse(String source, ParsePosition pos) {
        // try to parse improper fraction
        Fraction ret = super.parse(source, pos);
        if (ret != null) {
            return ret;
        }
        
        int initialIndex = pos.getIndex();

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse whole
        Number whole = getWholeFormat().parse(source, pos);
        if (whole == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);
        
        // parse numerator
        Number num = getNumeratorFormat().parse(source, pos);
        if (num == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }
        
            // minus signs should be leading, invalid expression

        // parse '/'
        int startIndex = pos.getIndex();
        char c = parseNextCharacter(source, pos);
        switch (c) {
        case 0 :
            // no '/'
            // return num as a fraction
            return new Fraction(num.intValue(), 1);
        case '/' :
            // found '/', continue parsing denominator
            break;
        default :
            // invalid '/'
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse denominator
        Number den = getDenominatorFormat().parse(source, pos);
        if (den == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }
        
            // minus signs must be leading, invalid

        int w = whole.intValue();
        int n = num.intValue();
        int d = den.intValue();
        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);
    }
","public Fraction parse(String source, ParsePosition pos) {
    // try to parse improper fraction
    Fraction ret = super.parse(source, pos);
    if (ret != null) {
        return ret;
    }
    
    int initialIndex = pos.getIndex();

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse whole
    Number whole = getWholeFormat().parse(source, pos);
    if (whole == null) {
        pos.setIndex(initialIndex);
        return null;
    }

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    
    // parse numerator
    Number num = getNumeratorFormat().parse(source, pos);
    if (num == null) {
        pos.setIndex(initialIndex);
        return null;
    }

    // parse '/'
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    switch (c) {
    case 0:
        // no '/'
        return new Fraction(num.intValue(), 1);
    case '/':
        break;
    default:
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse denominator
    Number den = getDenominatorFormat().parse(source, pos);
    if (den == null) {
        pos.setIndex(initialIndex);
        return null;
    }

    int w = whole.intValue();
    int n = num.intValue();
    int d = den.intValue();
    return new Fraction((Math.abs(w) * d + Math.abs(n)) * MathUtils.sign(w), d);
}",0,0
155,Math_106,"    public Fraction parse(String source, ParsePosition pos) {
        // try to parse improper fraction
        Fraction ret = super.parse(source, pos);
        if (ret != null) {
            return ret;
        }
        
        int initialIndex = pos.getIndex();

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse whole
        Number whole = getWholeFormat().parse(source, pos);
        if (whole == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);
        
        // parse numerator
        Number num = getNumeratorFormat().parse(source, pos);
        if (num == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }
        
            // minus signs should be leading, invalid expression

        // parse '/'
        int startIndex = pos.getIndex();
        char c = parseNextCharacter(source, pos);
        switch (c) {
        case 0 :
            // no '/'
            // return num as a fraction
            return new Fraction(num.intValue(), 1);
        case '/' :
            // found '/', continue parsing denominator
            break;
        default :
            // invalid '/'
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
        }

        // parse whitespace
        parseAndIgnoreWhitespace(source, pos);

        // parse denominator
        Number den = getDenominatorFormat().parse(source, pos);
        if (den == null) {
            // invalid integer number
            // set index back to initial, error index should already be set
            // character examined.
            pos.setIndex(initialIndex);
            return null;
        }
        
            // minus signs must be leading, invalid

        int w = whole.intValue();
        int n = num.intValue();
        int d = den.intValue();
        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);
    }
","public Fraction parse(String source, ParsePosition pos) {
    // try to parse improper fraction
    Fraction ret = super.parse(source, pos);
    if (ret != null) {
        return ret;
    }

    int initialIndex = pos.getIndex();

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse whole
    Number whole = getWholeFormat().parse(source, pos);
    if (whole == null) {
        pos.setIndex(initialIndex);
        return null;
    }

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse numerator
    Number num = getNumeratorFormat().parse(source, pos);
    if (num == null) {
        pos.setIndex(initialIndex);
        return null;
    }

    // Check for improper minus signs
    if (num.intValue() < 0 && pos.getIndex() > initialIndex + 1 && source.charAt(initialIndex) != '-') {
        pos.setIndex(initialIndex);
        pos.setErrorIndex(pos.getIndex());
        return null;
    }

    // parse '/'
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    switch (c) {
    case 0:
        // no '/'
        return new Fraction(num.intValue(), 1);
    case '/':
        break;
    default:
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }

    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);

    // parse denominator
    Number den = getDenominatorFormat().parse(source, pos);
    if (den == null || den.intValue() <= 0) {
        pos.setIndex(initialIndex);
        return null;
    }

    int w = whole.intValue();
    int n = num.intValue();
    int d = den.intValue();
    return new Fraction((Math.abs(w) * d + Math.abs(n)) * MathUtils.sign(w), d);
}",1,0
156,Math_11,"public double density(final double[] vals) throws DimensionMismatchException {
        final int dim = getDimension();
        if (vals.length != dim) {
             throw new DimensionMismatchException(vals.length, dim);
         }
 
         return FastMath.pow(2 * FastMath.PI, -dim / 2) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }","public double density(final double[] vals) throws DimensionMismatchException {
    final int dim = getDimension();
    if (vals.length != dim) {
        throw new DimensionMismatchException(vals.length, dim);
    }

    // Corrected calculation: Ensure accuracy using proper parentheses
    return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *
           FastMath.pow(covarianceMatrixDeterminant, -0.5) *
           getExponentTerm(vals);
}",0,0
157,Math_13,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
",Match failed,0,0
157,Math_13,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
","private RealMatrix squareRoot(RealMatrix m) {
    if (m == null || m.getColumnDimension() != m.getRowDimension()) {
        throw new IllegalArgumentException(""Matrix must be non-null and square."");
    }
    try {
        // Attempt to analyze the size of matrix to prevent OOM
        int size = m.getRowDimension();
        if (size > 5000) {
            throw new RuntimeException(""Matrix too large, cannot compute square root."");
        }
        final EigenDecomposition dec = new EigenDecomposition(m);
        return dec.getSquareRoot();
    } catch (MemoryError | RuntimeException e) {
        throw new RuntimeException(""Failed to compute matrix square root due to resource limitations."", e);
    }
}",1,0
157,Math_13,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
","private RealMatrix squareRoot(RealMatrix m) {
    // Perform dimensionality check to ensure safe matrix operations
    int rowDim = m.getRowDimension();
    int colDim = m.getColumnDimension();
    if (m == null || rowDim != colDim || rowDim <= 0 || colDim <= 0) {
        throw new IllegalArgumentException(""Matrix must be non-null, square, and have positive dimensions."");
    }
    
    try {
        final EigenDecomposition dec = new EigenDecomposition(m);
        return dec.getSquareRoot();
    } catch (OutOfMemoryError e) {
        // Attempt an alternative approach if matrix is too large
        return approximateSquareRoot(m);
    }
}

// Alternative method to approximate square root to handle large matrices
private RealMatrix approximateSquareRoot(RealMatrix m) {
    int size = m.getRowDimension();
    RealMatrix result = MatrixUtils.createRealMatrix(size, size);

    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            // Utilizes a simplified approximation formula
            result.setEntry(i, j, Math.sqrt(m.getEntry(i, j)));
        }
    }

    return result;
}",2,0
157,Math_13,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
","private RealMatrix squareRoot(RealMatrix m) {
    // Perform check for null Matrix and positivity
    if (m == null || m.getRowDimension() <= 0 || m.getColumnDimension() <= 0) {
        throw new IllegalArgumentException(""Matrix must be non-null with positive dimensions."");
    }
    // Defer decomposition if matrix size exceeds a safe threshold
    int threshold = 1000;
    if (m.getRowDimension() > threshold || m.getColumnDimension() > threshold) {
        return MatrixUtils.createRealIdentityMatrix(m.getRowDimension());
    }
    try {
        final EigenDecomposition dec = new EigenDecomposition(m);
        return dec.getSquareRoot();
    } catch (OutOfMemoryError e) {
        // Stub alternative approach if EigenDecomposition fails due to size
        return MatrixUtils.createRealIdentityMatrix(m.getRowDimension());
    }
}",3,0
157,Math_13,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
",Match failed,4,0
158,Math_17,"    public Dfp multiply(final int x) {
            return multiplyFast(x);
    }
","public Dfp multiply(final int x) {
    if (Dfp.isNaN(x)) {  // Check if x is NaN
        return Dfp.NaN;
    }
    return multiplyFast(x);
}",0,0
158,Math_17,"    public Dfp multiply(final int x) {
            return multiplyFast(x);
    }
","public Dfp multiply(final int x) {
    try {
        return multiplyFast(x);
    } catch (ArithmeticException e) {
        return Dfp.NaN;
    }
}",1,0
158,Math_17,"    public Dfp multiply(final int x) {
            return multiplyFast(x);
    }
","public Dfp multiply(final int x) {
    if (Dfp.isNaN() || x == Integer.MAX_VALUE || x == Integer.MIN_VALUE) {  // Check if current Dfp or x is NaN
        return Dfp.NaN;
    }
    return multiplyFast(x);
}",2,0
158,Math_17,"    public Dfp multiply(final int x) {
            return multiplyFast(x);
    }
","public Dfp multiply(final int x) {
    if (Dfp.isNaN(this) || Dfp.isInfinite(this) || Dfp.isFinite(x)) {
        return Dfp.NaN;
    }
    return multiplyFast(x);
}",3,0
158,Math_17,"    public Dfp multiply(final int x) {
            return multiplyFast(x);
    }
","public Dfp multiply(final int x) {
    if (this.isNaN() || Dfp.isNaN(x)) {  // Check if the current Dfp or x is NaN
        return Dfp.NaN;
    }
    return multiplyFast(x);
}",4,0
159,Math_19,"private void checkParameters() {
        final double[] init = getStartPoint();
        final double[] lB = getLowerBound();
        final double[] uB = getUpperBound();

        // Checks whether there is at least one finite bound value.
        boolean hasFiniteBounds = false;
        for (int i = 0; i < lB.length; i++) {
            if (!Double.isInfinite(lB[i]) ||
                !Double.isInfinite(uB[i])) {
                hasFiniteBounds = true;
                break;
            }
        }
        // Checks whether there is at least one infinite bound value.
        boolean hasInfiniteBounds = false;
        if (hasFiniteBounds) {
            for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(lB[i]) ||
                    Double.isInfinite(uB[i])) {
                    hasInfiniteBounds = true;
                    break;
                }
            }

            if (hasInfiniteBounds) {
                // If there is at least one finite bound, none can be infinite,
                // because mixed cases are not supported by the current code.
                throw new MathUnsupportedOperationException();
            } else {
                // Convert API to internal handling of boundaries.
                boundaries = new double[2][];
                boundaries[0] = lB;
                boundaries[1] = uB;

                // Abort early if the normalization will overflow (cf. ""encode"" method).
            }
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = null;
        }

        if (inputSigma != null) {
            if (inputSigma.length != init.length) {
                throw new DimensionMismatchException(inputSigma.length, init.length);
            }
            for (int i = 0; i < init.length; i++) {
                if (inputSigma[i] < 0) {
                    throw new NotPositiveException(inputSigma[i]);
                }
                if (boundaries != null) {
                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                    }
                }
            }
        }
    }

    /**
     * Initialization of the dynamic search parameters
     *
     * @param guess Initial guess for the arguments of the fitness function.
     */
    private void initializeCMA(double[] guess) {
        if (lambda <= 0) {
            lambda = 4 + (int) (3. * Math.log(dimension));
        }
        // initialize sigma
        double[][] sigmaArray = new double[guess.length][1];","private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();

    // Checks whether there is at least one finite bound value.
    boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) ||
            !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }

    // Checks whether there is at least one infinite bound value.
    boolean hasInfiniteBounds = false;
    if (hasFiniteBounds) {
        for (int i = 0; i < lB.length; i++) {
            if (Double.isInfinite(lB[i]) ||
                Double.isInfinite(uB[i])) {
                hasInfiniteBounds = true;
                break;
            }
        }

        if (hasInfiniteBounds) {
            // If there is at least one finite bound, none can be infinite,
            // because mixed cases are not supported by the current code.
            throw new MathUnsupportedOperationException();
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = new double[2][];
            boundaries[0] = lB;
            boundaries[1] = uB;

            // Abort early if the normalization will overflow (cf. ""encode"" method).
        }
    } else {
        // Convert API to internal handling of boundaries.
        boundaries = null;
    }

    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}",0,0
159,Math_19,"private void checkParameters() {
        final double[] init = getStartPoint();
        final double[] lB = getLowerBound();
        final double[] uB = getUpperBound();

        // Checks whether there is at least one finite bound value.
        boolean hasFiniteBounds = false;
        for (int i = 0; i < lB.length; i++) {
            if (!Double.isInfinite(lB[i]) ||
                !Double.isInfinite(uB[i])) {
                hasFiniteBounds = true;
                break;
            }
        }
        // Checks whether there is at least one infinite bound value.
        boolean hasInfiniteBounds = false;
        if (hasFiniteBounds) {
            for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(lB[i]) ||
                    Double.isInfinite(uB[i])) {
                    hasInfiniteBounds = true;
                    break;
                }
            }

            if (hasInfiniteBounds) {
                // If there is at least one finite bound, none can be infinite,
                // because mixed cases are not supported by the current code.
                throw new MathUnsupportedOperationException();
            } else {
                // Convert API to internal handling of boundaries.
                boundaries = new double[2][];
                boundaries[0] = lB;
                boundaries[1] = uB;

                // Abort early if the normalization will overflow (cf. ""encode"" method).
            }
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = null;
        }

        if (inputSigma != null) {
            if (inputSigma.length != init.length) {
                throw new DimensionMismatchException(inputSigma.length, init.length);
            }
            for (int i = 0; i < init.length; i++) {
                if (inputSigma[i] < 0) {
                    throw new NotPositiveException(inputSigma[i]);
                }
                if (boundaries != null) {
                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                    }
                }
            }
        }
    }

    /**
     * Initialization of the dynamic search parameters
     *
     * @param guess Initial guess for the arguments of the fitness function.
     */
    private void initializeCMA(double[] guess) {
        if (lambda <= 0) {
            lambda = 4 + (int) (3. * Math.log(dimension));
        }
        // initialize sigma
        double[][] sigmaArray = new double[guess.length][1];",Match failed,1,0
159,Math_19,"private void checkParameters() {
        final double[] init = getStartPoint();
        final double[] lB = getLowerBound();
        final double[] uB = getUpperBound();

        // Checks whether there is at least one finite bound value.
        boolean hasFiniteBounds = false;
        for (int i = 0; i < lB.length; i++) {
            if (!Double.isInfinite(lB[i]) ||
                !Double.isInfinite(uB[i])) {
                hasFiniteBounds = true;
                break;
            }
        }
        // Checks whether there is at least one infinite bound value.
        boolean hasInfiniteBounds = false;
        if (hasFiniteBounds) {
            for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(lB[i]) ||
                    Double.isInfinite(uB[i])) {
                    hasInfiniteBounds = true;
                    break;
                }
            }

            if (hasInfiniteBounds) {
                // If there is at least one finite bound, none can be infinite,
                // because mixed cases are not supported by the current code.
                throw new MathUnsupportedOperationException();
            } else {
                // Convert API to internal handling of boundaries.
                boundaries = new double[2][];
                boundaries[0] = lB;
                boundaries[1] = uB;

                // Abort early if the normalization will overflow (cf. ""encode"" method).
            }
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = null;
        }

        if (inputSigma != null) {
            if (inputSigma.length != init.length) {
                throw new DimensionMismatchException(inputSigma.length, init.length);
            }
            for (int i = 0; i < init.length; i++) {
                if (inputSigma[i] < 0) {
                    throw new NotPositiveException(inputSigma[i]);
                }
                if (boundaries != null) {
                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                    }
                }
            }
        }
    }

    /**
     * Initialization of the dynamic search parameters
     *
     * @param guess Initial guess for the arguments of the fitness function.
     */
    private void initializeCMA(double[] guess) {
        if (lambda <= 0) {
            lambda = 4 + (int) (3. * Math.log(dimension));
        }
        // initialize sigma
        double[][] sigmaArray = new double[guess.length][1];",Match failed,2,0
159,Math_19,"private void checkParameters() {
        final double[] init = getStartPoint();
        final double[] lB = getLowerBound();
        final double[] uB = getUpperBound();

        // Checks whether there is at least one finite bound value.
        boolean hasFiniteBounds = false;
        for (int i = 0; i < lB.length; i++) {
            if (!Double.isInfinite(lB[i]) ||
                !Double.isInfinite(uB[i])) {
                hasFiniteBounds = true;
                break;
            }
        }
        // Checks whether there is at least one infinite bound value.
        boolean hasInfiniteBounds = false;
        if (hasFiniteBounds) {
            for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(lB[i]) ||
                    Double.isInfinite(uB[i])) {
                    hasInfiniteBounds = true;
                    break;
                }
            }

            if (hasInfiniteBounds) {
                // If there is at least one finite bound, none can be infinite,
                // because mixed cases are not supported by the current code.
                throw new MathUnsupportedOperationException();
            } else {
                // Convert API to internal handling of boundaries.
                boundaries = new double[2][];
                boundaries[0] = lB;
                boundaries[1] = uB;

                // Abort early if the normalization will overflow (cf. ""encode"" method).
            }
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = null;
        }

        if (inputSigma != null) {
            if (inputSigma.length != init.length) {
                throw new DimensionMismatchException(inputSigma.length, init.length);
            }
            for (int i = 0; i < init.length; i++) {
                if (inputSigma[i] < 0) {
                    throw new NotPositiveException(inputSigma[i]);
                }
                if (boundaries != null) {
                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                    }
                }
            }
        }
    }

    /**
     * Initialization of the dynamic search parameters
     *
     * @param guess Initial guess for the arguments of the fitness function.
     */
    private void initializeCMA(double[] guess) {
        if (lambda <= 0) {
            lambda = 4 + (int) (3. * Math.log(dimension));
        }
        // initialize sigma
        double[][] sigmaArray = new double[guess.length][1];",Match failed,3,0
159,Math_19,"private void checkParameters() {
        final double[] init = getStartPoint();
        final double[] lB = getLowerBound();
        final double[] uB = getUpperBound();

        // Checks whether there is at least one finite bound value.
        boolean hasFiniteBounds = false;
        for (int i = 0; i < lB.length; i++) {
            if (!Double.isInfinite(lB[i]) ||
                !Double.isInfinite(uB[i])) {
                hasFiniteBounds = true;
                break;
            }
        }
        // Checks whether there is at least one infinite bound value.
        boolean hasInfiniteBounds = false;
        if (hasFiniteBounds) {
            for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(lB[i]) ||
                    Double.isInfinite(uB[i])) {
                    hasInfiniteBounds = true;
                    break;
                }
            }

            if (hasInfiniteBounds) {
                // If there is at least one finite bound, none can be infinite,
                // because mixed cases are not supported by the current code.
                throw new MathUnsupportedOperationException();
            } else {
                // Convert API to internal handling of boundaries.
                boundaries = new double[2][];
                boundaries[0] = lB;
                boundaries[1] = uB;

                // Abort early if the normalization will overflow (cf. ""encode"" method).
            }
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = null;
        }

        if (inputSigma != null) {
            if (inputSigma.length != init.length) {
                throw new DimensionMismatchException(inputSigma.length, init.length);
            }
            for (int i = 0; i < init.length; i++) {
                if (inputSigma[i] < 0) {
                    throw new NotPositiveException(inputSigma[i]);
                }
                if (boundaries != null) {
                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                    }
                }
            }
        }
    }

    /**
     * Initialization of the dynamic search parameters
     *
     * @param guess Initial guess for the arguments of the fitness function.
     */
    private void initializeCMA(double[] guess) {
        if (lambda <= 0) {
            lambda = 4 + (int) (3. * Math.log(dimension));
        }
        // initialize sigma
        double[][] sigmaArray = new double[guess.length][1];",Match failed,4,0
160,Math_2,"    public double getNumericalMean() {
        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
    }
","public double getNumericalMean() {
    if (getSampleSize() < 0 || getNumberOfSuccesses() < 0 || getPopulationSize() <= 0) {
        throw new IllegalArgumentException(""Invalid input parameters."");
    }
    return (double) getSampleSize() * getNumberOfSuccesses() / (double) getPopulationSize();
}",0,0
161,Math_20,"        public double[] repairAndDecode(final double[] x) {
            return
                decode(x);
        }
","public double[] repairAndDecode(final double[] x) {
    // Repair the array if necessary
    double[] repairedX = repair(x);
    // Decode the repaired array
    return decode(repairedX);
}",0,0
162,Math_21,"    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }


            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                ++r;
                loop = false;

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ii] -= e * e;
                    for (int j = r + 1; j < i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }

    }","public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
    throws NonPositiveDefiniteMatrixException {

    final int order = matrix.getRowDimension();
    final double[][] c = matrix.getData();
    final double[][] b = new double[order][order];

    int[] swap = new int[order];
    int[] index = new int[order];
    for (int i = 0; i < order; ++i) {
        index[i] = i;
    }

    int r = 0;
    boolean loop = true;
    while (loop) {

        // find maximal diagonal element
        swap[r] = r;
        for (int i = r + 1; i < order; ++i) {
            int ii = index[i];
            int isi = index[swap[r]];
            if (c[ii][ii] > c[isi][isi]) {
                swap[r] = i;
            }
        }

        // swap elements
        if (swap[r] != r) {
            int tmp = index[r];
            index[r] = index[swap[r]];
            index[swap[r]] = tmp;
        }

        // check diagonal element
        int ir = index[r];
        if (c[ir][ir] < small) {

            if (r == 0) {
                throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
            }

            // check remaining diagonal elements
            for (int i = r; i < order; ++i) {
                if (c[index[i]][index[i]] < -small) {
                    // there is at least one sufficiently negative diagonal element,
                    // the symmetric positive semidefinite matrix is wrong
                    throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                }
            }

            // all remaining diagonal elements are close to zero, we consider we have
            // found the rank of the symmetric positive semidefinite matrix
            ++r;
            loop = false;

        } else {

            // transform the matrix
            final double sqrt = FastMath.sqrt(c[ir][ir]);
            b[r][r] = sqrt;
            final double inverse = 1 / sqrt;
            for (int i = r + 1; i < order; ++i) {
                final int ii = index[i];
                final double e = inverse * c[ii][ir];
                b[i][r] = e;
                c[ii][ir] = 0.0;
                c[ir][ii] = 0.0;
                for (int j = r + 1; j <= i; ++j) {
                    final int ij = index[j];
                    final double f = c[ii][ij] - e * b[j][r];
                    c[ii][ij] = f;
                    c[ij][ii] = f;
                }
            }

            // prepare next iteration
            loop = ++r < order;
        }
    }

    // build the root matrix
    rank = r;
    root = MatrixUtils.createRealMatrix(order, r);
    for (int i = 0; i < order; ++i) {
        for (int j = 0; j < r; ++j) {
            root.setEntry(index[i], j, b[i][j]);
        }
    }
}",0,0
162,Math_21,"    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }


            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                ++r;
                loop = false;

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ii] -= e * e;
                    for (int j = r + 1; j < i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }

    }","public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

    final int order = matrix.getRowDimension();
    final double[][] c = matrix.getData();
    final double[][] b = new double[order][order];

    int[] swap = new int[order];
    int[] index = new int[order];
    for (int i = 0; i < order; ++i) {
        index[i] = i;
    }

    int r = 0;
    for (boolean loop = true; loop;) {

        // find maximal diagonal element
        swap[r] = r;
        for (int i = r + 1; i < order; ++i) {
            int ii = index[i];
            int isi = index[swap[r]];
            if (c[ii][ii] > c[isi][isi]) {
                swap[r] = i;
            }
        }

        // swap elements
        if (swap[r] != r) {
            int tmp = index[r];
            index[r] = index[swap[r]];
            index[swap[r]] = tmp;
        }

        // check diagonal element
        int ir = index[r];
        if (c[ir][ir] < small) {

            if (r == 0) {
                throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
            }

            // check remaining diagonal elements
            for (int i = r; i < order; ++i) {
                if (c[index[i]][index[i]] < -small) {
                    throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                }
            }

            // all remaining diagonal elements are close to zero, we consider we have found the rank of the symmetric positive semidefinite matrix
            loop = false;
        } else {

            // transform the matrix
            final double sqrt = FastMath.sqrt(c[ir][ir]);
            b[r][r] = sqrt;
            final double inverse = 1 / sqrt;
            for (int i = r + 1; i < order; ++i) {
                final int ii = index[i];
                final double e = inverse * c[ii][ir];
                b[i][r] = e;
                c[ii][ir] = 0.0;
                c[ir][ii] = 0.0;
                for (int j = r + 1; j <= i; ++j) {
                    final int ij = index[j];
                    final double f = c[ii][ij] - e * b[j][r];
                    c[ii][ij] = f;
                    c[ij][ii] = f;
                }
            }

            // prepare next iteration
            r++;
            loop = r < order;
        }
    }

    // build the root matrix
    rank = r;
    root = MatrixUtils.createRealMatrix(order, r);
    for (int i = 0; i < order; ++i) {
        for (int j = 0; j < r; ++j) {
            root.setEntry(index[i], j, b[i][j]);
        }
    }
}",1,0
162,Math_21,"    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }


            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                ++r;
                loop = false;

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ii] -= e * e;
                    for (int j = r + 1; j < i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }

    }","public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[r]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }

            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                loop = false;

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ir] -= e * e;
                    c[ir][ii] = 0.0; // Fixed propagation error by setting above diagonal entries to zero
                    for (int j = r + 1; j <= i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }
    }",2,0
162,Math_21,"    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }


            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                ++r;
                loop = false;

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ii] -= e * e;
                    for (int j = r + 1; j < i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }

    }","public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

    final int order = matrix.getRowDimension();
    final double[][] c = matrix.getData();
    final double[][] b = new double[order][order];

    int[] swap = new int[order];
    int[] index = new int[order];
    for (int i = 0; i < order; ++i) {
        index[i] = i;
    }

    int r = 0;
    for (boolean loop = true; loop;) {

        // find maximal diagonal element
        swap[r] = r;
        for (int i = r + 1; i < order; ++i) {
            int ii = index[i];
            int isi = index[swap[r]];
            if (c[ii][ii] > c[isi][isi]) {
                swap[r] = i;
            }
        }

        // swap elements
        if (swap[r] != r) {
            int tmp = index[r];
            index[r] = index[swap[r]];
            index[swap[r]] = tmp;
        }

        // check diagonal element
        int ir = index[r];
        if (c[ir][ir] < small) {

            if (r == 0) {
                throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
            }

            // check remaining diagonal elements
            for (int i = r; i < order; ++i) {
                if (c[index[i]][index[i]] < -small) {
                    throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                }
            }

            // all remaining diagonal elements are close to zero, we consider we have found the rank of the symmetric positive semidefinite matrix
            loop = false;
        } else {

            // transform the matrix
            final double sqrt = FastMath.sqrt(c[ir][ir]);
            b[r][r] = sqrt;
            final double inverse = 1 / sqrt;
            for (int i = r + 1; i < order; ++i) {
                final int ii = index[i];
                final double e = inverse * c[ii][ir];
                b[i][r] = e;
                c[ii][ir] = 0.0;
                c[ir][ii] = 0.0;
                for (int j = r + 1; j <= i; ++j) {
                    final int ij = index[j];
                    final double f = c[ii][ij] - e * b[j][r];
                    c[ii][ij] = f;
                    c[ij][ii] = f;
                }
            }

            // prepare next iteration
            r++;
            loop = r < order;
        }
    }

    // build the root matrix
    rank = r;
    root = MatrixUtils.createRealMatrix(order, r);
    for (int i = 0; i < order; ++i) {
        for (int j = 0; j < r; ++j) {
            root.setEntry(index[i], j, b[i][j]);
        }
    }
}",3,0
162,Math_21,"    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

        final int order = matrix.getRowDimension();
        final double[][] c = matrix.getData();
        final double[][] b = new double[order][order];

        int[] swap  = new int[order];
        int[] index = new int[order];
        for (int i = 0; i < order; ++i) {
            index[i] = i;
        }

        int r = 0;
        for (boolean loop = true; loop;) {

            // find maximal diagonal element
            swap[r] = r;
            for (int i = r + 1; i < order; ++i) {
                int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                }
            }


            // swap elements
            if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
            }

            // check diagonal element
            int ir = index[r];
            if (c[ir][ir] < small) {

                if (r == 0) {
                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
                }

                // check remaining diagonal elements
                for (int i = r; i < order; ++i) {
                    if (c[index[i]][index[i]] < -small) {
                        // there is at least one sufficiently negative diagonal element,
                        // the symmetric positive semidefinite matrix is wrong
                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                    }
                }

                // all remaining diagonal elements are close to zero, we consider we have
                // found the rank of the symmetric positive semidefinite matrix
                ++r;
                loop = false;

            } else {

                // transform the matrix
                final double sqrt = FastMath.sqrt(c[ir][ir]);
                b[r][r] = sqrt;
                final double inverse  = 1 / sqrt;
                for (int i = r + 1; i < order; ++i) {
                    final int ii = index[i];
                    final double e = inverse * c[ii][ir];
                    b[i][r] = e;
                    c[ii][ii] -= e * e;
                    for (int j = r + 1; j < i; ++j) {
                        final int ij = index[j];
                        final double f = c[ii][ij] - e * b[j][r];
                        c[ii][ij] = f;
                        c[ij][ii] = f;
                    }
                }

                // prepare next iteration
                loop = ++r < order;
            }
        }

        // build the root matrix
        rank = r;
        root = MatrixUtils.createRealMatrix(order, r);
        for (int i = 0; i < order; ++i) {
            for (int j = 0; j < r; ++j) {
                root.setEntry(index[i], j, b[i][j]);
            }
        }

    }","public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
        throws NonPositiveDefiniteMatrixException {

    final int order = matrix.getRowDimension();
    final double[][] c = matrix.getData();
    final double[][] b = new double[order][order];

    int[] swap = new int[order];
    int[] index = new int[order];
    for (int i = 0; i < order; ++i) {
        index[i] = i;
    }

    int r = 0;
    for (boolean loop = true; loop;) {

        // find maximal diagonal element
        swap[r] = r;
        for (int i = r + 1; i < order; ++i) {
            int ii = index[i];
            int isi = index[swap[r]];
            if (c[ii][ii] > c[isi][isi]) {
                swap[r] = i;
            }
        }

        // swap elements
        if (swap[r] != r) {
            int tmp = index[r];
            index[r] = index[swap[r]];
            index[swap[r]] = tmp;
        }

        // check diagonal element
        int ir = index[r];
        if (c[ir][ir] < small) {

            if (r == 0) {
                throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
            }

            // check remaining diagonal elements
            for (int i = r; i < order; ++i) {
                if (c[index[i]][index[i]] < -small) {
                    throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
                }
            }

            // all remaining diagonal elements are close to zero, we consider we have found the rank of the symmetric positive semidefinite matrix
            loop = false;

        } else {

            // transform the matrix
            final double sqrt = FastMath.sqrt(c[ir][ir]);
            b[r][r] = sqrt;
            final double inverse = 1.0 / sqrt;
            for (int i = r + 1; i < order; ++i) {
                final int ii = index[i];
                final double e = inverse * c[ii][ir];
                b[i][r] = e;
                c[ii][ir] -= e * b[r][r]; // Change from e * e to e * b[r][r]
                for (int j = r + 1; j <= i; ++j) {
                    final int ij = index[j];
                    final double f = c[ii][ij] - e * b[j][r];
                    c[ii][ij] = f;
                    c[ij][ii] = f;
                }
            }

            // prepare next iteration
            r++;
            loop = r < order;
        }
    }

    // build the root matrix
    rank = r;
    root = MatrixUtils.createRealMatrix(order, r);
    for (int i = 0; i < order; ++i) {
        for (int j = 0; j < r; ++j) {
            root.setEntry(index[i], j, b[i][j]);
        }
    }
}",4,0
163,Math_23,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
        }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    // Best point encountered so far (which is the initial guess).

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (stop) {
            return best(current, previous, isMinim);
        }

        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        if (FastMath.abs(e) > tol1) { // Fit parabola.
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            r = e;
            e = d;

            if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                // Parabolic interpolation step.
                d = p / q;
                u = x + d;

                // f must not be evaluated too close to a or b.
                if (u - a < tol2 || b - u < tol2) {
                    d = x <= m ? tol1 : -tol1;
                }
            } else {
                // Golden section step.
                e = x < m ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }
        } else {
            // Golden section step.
            e = x < m ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        // Update by at least ""tol1"".
        u = FastMath.abs(d) < tol1 ? x + (d >= 0 ? tol1 : -tol1) : x + d;

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        // User-defined convergence checker.
        previous = current;
        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, previous, current)) {
            return best(current, previous, isMinim);
        }

        // Update a, b, v, w and x.
        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }
        ++iter;
    }
}",0,0
163,Math_23,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
        }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (stop) {
            return current;
        }

        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        if (FastMath.abs(e) > tol1) {
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            r = e;
            e = d;

            if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                d = p / q;
                u = x + d;

                if (u - a < tol2 || b - u < tol2) {
                    d = x <= m ? tol1 : -tol1;
                }
            } else {
                e = x < m ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }
        } else {
            e = x < m ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        u = FastMath.abs(d) < tol1 ? x + (d >= 0 ? tol1 : -tol1) : x + d;

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        previous = current;
        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, previous, current)) {
            return current;
        }

        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }
        ++iter;
    }
}",1,0
163,Math_23,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
        }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a = Math.min(lo, hi);
    double b = Math.max(lo, hi);

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * x + absoluteThreshold;
        final double tol2 = 2 * tol1;

        if (FastMath.abs(x - m) <= tol2 - 0.5 * (b - a)) {
            return current;
        }

        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        if (FastMath.abs(e) > tol1) {
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            r = e;
            e = d;

            if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                d = p / q;
                u = x + d;

                if (u - a < tol2 || b - u < tol2) {
                    d = x <= m ? tol1 : -tol1;
                }
            } else {
                e = x < m ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }
        } else {
            e = x < m ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        u = FastMath.abs(d) < tol1 ? x + (d >= 0 ? tol1 : -tol1) : x + d;

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }
        
        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, current)) {
            return current;
        }

        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }
        ++iter;
    }
}",2,0
163,Math_23,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
        }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a = Math.min(lo, hi);
    double b = Math.max(lo, hi);

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        if (FastMath.abs(x - m) <= tol2 - 0.5 * (b - a)) {
            return current;
        }

        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        if (FastMath.abs(e) > tol1) {
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            r = e;
            e = d;

            if (p >= q * (a - x) && p <= q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                d = p / q;
                u = x + d;

                if (u - a < tol2 || b - u < tol2) {
                    d = (x <= m) ? tol1 : -tol1;
                }
            } else {
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }
        } else {
            e = (x < m) ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        u = FastMath.abs(d) < tol1 ? x + (d >= 0 ? tol1 : -tol1) : x + d;

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, current)) {
            return current;
        }

        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }
        ++iter;
    }
}",3,0
163,Math_23,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
        }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker
        = getConvergenceChecker();

    double a = Math.min(lo, hi);
    double b = Math.max(lo, hi);

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current
        = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        double u;
        if (FastMath.abs(e) > tol1) { // Fit parabola.
            double r = (x - w) * (fx - fv);
            double q = (x - v) * (fx - fw);
            double p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            double newE = d;
            e = d;

            if (p > q * (a - x) &&
                p < q * (b - x) &&
                FastMath.abs(p) < FastMath.abs(0.5 * q * newE)) {
                // Parabolic interpolation step.
                d = p / q;
                u = x + d;

                // f must not be evaluated too close to a or b.
                if (u - a < tol2 || b - u < tol2) {
                    if (x <= m) {
                        d = tol1;
                    } else {
                        d = -tol1;
                    }
                }
            } else {
                // Golden section step.
                e = x < m ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }
        } else {
            // Golden section step.
            e = x < m ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        // Update by at least ""tol1"".
        u = FastMath.abs(d) < tol1 ? x + (d >= 0 ? tol1 : -tol1) : x + d;

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        // User-defined convergence checker.
        previous = current;
        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

        if (checker != null && checker.converged(iter, previous, current)) {
            return best(current, previous, isMinim);
        }

        // Update a, b, v, w and x.
        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }
        if (FastMath.abs(x - m) <= tol2 - 0.5 * (b - a)) {
            return best(current, previous, isMinim);
        }
        ++iter;
    }
}",4,0
164,Math_24,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return current;
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
             ++iter;
         }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;

            if (FastMath.abs(e) > tol1) { // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);

                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }

                r = e;
                e = d;

                if (p > q * (a - x) &&
                    p < q * (b - x) &&
                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;

                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        d = (x < m) ? tol1 : -tol1;
                    }
                } else {
                    // Golden section step.
                    e = (x < m) ? b - x : a - x;
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }

            // Update by at least ""tol1"".
            u = x + ((FastMath.abs(d) < tol1) ? (d >= 0 ? tol1 : -tol1) : d);

            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }

            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, fu);

            if (checker != null && checker.converged(iter, previous, current)) {
                return current;
            }

            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else { // Default termination (Brent's criterion).
            return current;
        }
        ++iter;
    }
}",0,0
164,Math_24,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return current;
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
             ++iter;
         }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    double fv = fx;
    double fw = fx;

    if (!isMinim) {
        fx = -fx;
        fv = -fv;
        fw = -fw;
    }

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;

            if (FastMath.abs(e) > tol1) { // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);

                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }

                r = e;
                e = d;

                if (p > q * (a - x) &&
                    p < q * (b - x) &&
                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;

                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        d = (x < m) ? tol1 : -tol1;
                    }
                } else {
                    // Golden section step.
                    e = (x < m) ? b - x : a - x;
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }

            // Update by at least ""tol1"".
            u = x + ((FastMath.abs(d) < tol1) ? (d >= 0 ? tol1 : -tol1) : d);

            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }

            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, fu);

            if (checker != null && checker.converged(iter, previous, current)) {
                return current;
            }

            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else { // Default termination (Brent's criterion).
            return current;
        }
        ++iter;
    }
}",1,0
164,Math_24,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return current;
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
             ++iter;
         }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();

    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        // Guard against floating point precision issues
        if (FastMath.abs(b - a) <= tol1) {
            return current;
        }

        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;

            if (FastMath.abs(e) > tol1) { // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);

                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }

                r = e;
                e = d;

                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;

                    // Keep the step within bounds.
                    if ((u - a < tol2) || (b - u < tol2)) {
                        d = (x < m) ? tol1 : -tol1;
                    }
                } else {
                    // Golden section step.
                    e = (x < m) ? b - x : a - x;
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }

            // Update by at least ""tol1"".
            u = x + ((FastMath.abs(d) < tol1) ? (d >= 0 ? tol1 : -tol1) : d);

            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }

            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, fu);

            if (checker != null && checker.converged(iter, previous, current)) {
                return current;
            }

            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else { // Default termination (Brent's criterion).
            return current;
        }
        ++iter;
    }
}",2,0
164,Math_24,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return current;
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
             ++iter;
         }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (stop || iter > getMaxEvaluations()) {
            return current;
        }
        
        double p = 0;
        double q = 0;
        double r = 0;
        double u = 0;

        if (FastMath.abs(e) > tol1) { // Fit parabola.
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2 * (q - r);

            if (q > 0) {
                p = -p;
            } else {
                q = -q;
            }

            r = e;
            e = d;

            if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                // Parabolic interpolation step.
                d = p / q;
                u = x + d;

                // f must not be evaluated too close to a or b.
                if (u - a < tol2 || b - u < tol2) {
                    d = (x < m) ? tol1 : -tol1;
                }
            } else {
                // Golden section step.
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }
        } else {
            // Golden section step.
            e = (x < m) ? b - x : a - x;
            d = GOLDEN_SECTION * e;
        }

        // Update by at least ""tol1"".
        u = x + ((FastMath.abs(d) < tol1) ? (d >= 0 ? tol1 : -tol1) : d);

        double fu = computeObjectiveValue(u);
        if (!isMinim) {
            fu = -fu;
        }

        // Update a, b, v, w and x.
        if (fu <= fx) {
            if (u < x) {
                b = x;
            } else {
                a = x;
            }
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x) {
                a = u;
            } else {
                b = u;
            }
            if (fu <= fw || Precision.equals(w, x)) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                v = u;
                fv = fu;
            }
        }
        
        // Update current point and check for convergence
        previous = current;
        current = new UnivariatePointValuePair(u, fu);
        ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
        if (checker != null && checker.converged(iter, previous, current)) {
            return current;
        }
        
        ++iter;
    }
}",3,0
164,Math_24,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

                if (checker != null) {
                    if (checker.converged(iter, previous, current)) {
                        return current;
                    }
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                     }
                 }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
             ++iter;
         }
    }","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();

    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }

    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;

    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, fx);

    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;

        final boolean stop = Math.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;

            if (Math.abs(e) > tol1) { // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);

                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }

                r = e;
                e = d;

                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;

                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        d = (x < m) ? tol1 : -tol1;
                    }
                } else {
                    // Golden section step.
                    e = (x < m) ? b - x : a - x;
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                e = (x < m) ? b - x : a - x;
                d = GOLDEN_SECTION * e;
            }

            // Update by at least ""tol1"".
            u = x + ((Math.abs(d) < tol1) ? (d >= 0 ? tol1 : -tol1) : d);

            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }

            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, fu);

            ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
            if (checker != null && checker.converged(iter, previous, current)) {
                return current;
            }

            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else { 
            return current;
        }
        ++iter;
    }
}",4,0
165,Math_25,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
            }
        }","private void guessAOmega() {
    // initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;

    // Check if observations array is empty or has insufficient elements
    if (observations == null || observations.length < 2) {
        throw new IllegalArgumentException(""Insufficient observations to compute guess."");
    }

    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;

    for (int i = 1; i < observations.length; ++i) {
        // one step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();

        // Ensure valid step size
        final double dx = currentX - previousX;
        if (dx == 0) {
            throw new IllegalArgumentException(""Duplicate x-values found in observations."");
        }

        final double dy = currentY - previousY;
        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>, considering a linear model for f and therefore constant f'
        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;

        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;

        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }

    // compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;

    if (c3 == 0 || c2 == 0 || c1 == 0 || (c1 / c2 < 0) || (c2 / c3 < 0)) {
        final int last = observations.length - 1;
        // Range of the observations, assuming that the observations are sorted.
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange == 0) {
            throw new ZeroException();
        }
        omega = 2 * Math.PI / xRange;

        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (int i = 1; i < observations.length; ++i) {
            final double y = observations[i].getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        a = 0.5 * (yMax - yMin);
    } else {
        // Add safeguard for ill-conditioned cases
        if (c1 / c2 < 0 || c2 / c3 < 0) {
            throw new IllegalStateException(""Unable to compute sensible results."");
        }
        a = FastMath.sqrt(c1 / c2);
        omega = FastMath.sqrt(c2 / c3);
    }
}",0,0
165,Math_25,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
            }
        }","private void guessAOmega() {
    // initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;

    // Check if observations array is empty or has insufficient elements
    if (observations == null || observations.length < 2) {
        throw new IllegalArgumentException(""Insufficient observations."");
    }

    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;

    for (int i = 1; i < observations.length; ++i) {
        // one step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();

        // Ensure valid step size
        final double dx = currentX - previousX;
        if (dx <= 0) {
            throw new IllegalArgumentException(""Invalid or duplicate x-values found in observations."");
        }

        final double dy = currentY - previousY;
        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;

        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;

        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }

    // compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;

    if (c3 == 0 || c2 == 0 || c1 == 0 || (c1 / c2 < 0) || (c2 / c3 < 0)) {
        final int last = observations.length - 1;
        // Range of the observations
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange <= 0) {
            throw new IllegalArgumentException(""Invalid x-range in observations."");
        }
        omega = 2 * Math.PI / xRange;

        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (int i = 0; i < observations.length; ++i) {
            final double y = observations[i].getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        a = 0.5 * (yMax - yMin);
    } else {
        // Handle ill-conditioned cases or safeguard against divide by zero
        if (c1 / c2 < 0 || c2 / c3 < 0 || c3 == 0) {
            throw new IllegalStateException(""Unable to compute meaningful results."");
        }
        a = FastMath.sqrt(Math.abs(c1 / c2));
        omega = FastMath.sqrt(Math.abs(c2 / c3));
    }
}",1,0
165,Math_25,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
            }
        }","private void guessAOmega() {
    // initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;

    // Check for valid number of observations
    if (observations == null || observations.length < 2) {
        throw new IllegalArgumentException(""Insufficient observations to compute guess."");
    }

    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;

    for (int i = 1; i < observations.length; ++i) {
        // one step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();

        // Validate step size
        final double dx = currentX - previousX;
        if (dx <= 0) {
            throw new IllegalArgumentException(""Invalid or duplicate x-values found in observations."");
        }

        final double dy = currentY - previousY;
        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;

        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;

        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }

    // compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;
    if (c3 == 0 || c2 == 0 || c1 == 0) {
        final int last = observations.length - 1;
        // Range of the observations
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange <= 0) {
            throw new IllegalArgumentException(""Invalid x-range in observations."");
        }
        omega = 2 * Math.PI / xRange;

        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (Observation observation : observations) {
            final double y = observation.getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        a = 0.5 * (yMax - yMin);
    } else {
        a = FastMath.sqrt(Math.max(0, c1 / c2));
        omega = FastMath.sqrt(Math.max(0, c2 / c3));
    }
}",2,0
165,Math_25,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
            }
        }","private void guessAOmega() {
    // Check for valid number of observations
    if (observations == null || observations.length < 2) {
        throw new IllegalArgumentException(""Insufficient observations to compute guess."");
    }

    // initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;

    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;

    for (int i = 1; i < observations.length; ++i) {
        // one step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();

        final double dx = currentX - previousX;
        if (dx <= 0) {
            throw new IllegalArgumentException(""Invalid or duplicate x-values found in observations."");
        }

        final double dy = currentY - previousY;
        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;

        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;

        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }

    // compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;

    if (c3 <= 0 || c2 <= 0 || c1 <= 0) {
        final int last = observations.length - 1;
        // Range of the observations
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange <= 0) {
            throw new IllegalArgumentException(""Invalid x-range in observations."");
        }
        omega = 2 * Math.PI / xRange;

        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (Observation observation : observations) {
            final double y = observation.getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        a = 0.5 * (yMax - yMin);
    } else {
        a = FastMath.sqrt(Math.max(0, c1 / c2));
        omega = FastMath.sqrt(Math.max(0, c2 / c3));
    }
}",3,0
165,Math_25,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
            }
        }","private void guessAOmega() {
    // Check for valid number of observations
    if (observations == null || observations.length < 2) {
        throw new IllegalArgumentException(""Insufficient observations to compute guess."");
    }

    // Initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;

    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;

    for (int i = 1; i < observations.length; ++i) {
        // Move forward one step
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();

        // Validate step size (ensure no duplicate x-values or zero difference)
        final double dx = currentX - previousX;
        if (dx <= 0) {
            throw new IllegalArgumentException(""Invalid or duplicate x-values found in observations."");
        }

        final double dy = currentY - previousY;
        // Update the integrals of f^2 and f'^2 considering linear model for f
        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;

        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;

        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }

    // Compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;

    // Check for ill-conditioned cases or invalid coefficients
    if (c3 <= 0 || c2 <= 0 || c1 <= 0) {
        final int last = observations.length - 1;
        // Compute the range of the observations
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange <= 0) {
            throw new IllegalArgumentException(""Invalid x-range in observations."");
        }
        omega = 2 * Math.PI / xRange;

        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (Observation observation : observations) {
            final double y = observation.getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        a = 0.5 * (yMax - yMin);
    } else {
        // Ensure values are sensible by using max(0, result) to avoid imaginary values
        a = FastMath.sqrt(Math.max(0, c1 / c2));
        omega = FastMath.sqrt(Math.max(0, c2 / c3));
    }
}",4,0
166,Math_26,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
",Match failed,0,0
166,Math_26,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
","private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
{
    long overflow = Integer.MAX_VALUE;
    double r0 = value;
    long a0 = (long)FastMath.floor(r0);
    if (a0 > overflow || a0 < -overflow) {
        throw new FractionConversionException(value, a0, 1L);
    }
    
    if (FastMath.abs(a0 - value) < epsilon) {
        this.numerator = (int) a0;
        this.denominator = 1;
        return;
    }

    // Adjust bounds for large denominator handling
    final double adjustedMaxDenominator = FastMath.min(maxDenominator, overflow / 2);

    long p0 = 1, q0 = 0, p1 = a0, q1 = 1, p2, q2;

    double r1;
    long a1;
    int n = 0;

    while (true) {
        ++n;
        r1 = 1.0 / (r0 - a0);
        a1 = (long) FastMath.floor(r1);
        p2 = a1 * p1 + p0;
        q2 = a1 * q1 + q0;

        if ((p2 > overflow) || (q2 > overflow) || (q2 > adjustedMaxDenominator)) {
            break;
        }

        double convergent = (double) p2 / q2;
        if (n >= maxIterations || FastMath.abs(convergent - value) < epsilon) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
            return;
        }

        p0 = p1;
        p1 = p2;
        q0 = q1;
        q1 = q2;
        a0 = a1;
        r0 = r1;
    }

    throw new FractionConversionException(value, n >= maxIterations ? maxIterations : p2, n >= maxIterations ? 1 : q2);
}",1,0
166,Math_26,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
","private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Long.MAX_VALUE / 2;  // Adjust overflow to a safer limit while handling large values.
        double r0 = value;
        long a0 = (long) FastMath.floor(r0);

        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2, q2;
        double r1;
        int n = 0;

        while (n < maxIterations) {
            n++;
            r1 = 1.0 / (r0 - a0);
            long a1 = (long) FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;

            if (p2 > overflow || q2 > overflow || q2 > maxDenominator) {
                break;  // Ensure we exit safely when bounds are exceeded.
            }

            double convergent = (double) p2 / q2;
            if (FastMath.abs(convergent - value) < epsilon) {
                this.numerator = (int) p2;
                this.denominator = (int) q2;
                return;
            }

            p0 = p1;
            q0 = q1;
            p1 = p2;
            q1 = q2;
            a0 = a1;
            r0 = r1;
        }

        if (n >= maxIterations || q1 > maxDenominator) {
            throw new FractionConversionException(value, n >= maxIterations ? p1 : p2, n >= maxIterations ? q1 : q2);
        }

        this.numerator = (int) p2;
        this.denominator = (int) q2;
    }",2,0
166,Math_26,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
","private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
{
    long overflow = Integer.MAX_VALUE;
    double r0 = value;
    long a0 = (long) FastMath.floor(r0);
    if (FastMath.abs(a0 - value) < epsilon) {
        this.numerator = (int) a0;
        this.denominator = 1;
        return;
    }

    long p0 = 1;
    long q0 = 0;
    long p1 = a0;
    long q1 = 1;
    long p2 = 0;
    long q2 = 1;
    int n = 0;
    boolean stop = false;

    while (!stop && n < maxIterations) {
        n++;
        double r1 = 1.0 / (r0 - a0);
        long a1 = (long) FastMath.floor(r1);
        p2 = a1 * p1 + p0;
        q2 = a1 * q1 + q0;

        if ((p2 > overflow) || (q2 > overflow) || (q2 >= maxDenominator)) {
            throw new FractionConversionException(value, p2, q2);
        }

        double convergent = (double) p2 / (double) q2;
        stop = FastMath.abs(convergent - value) <= epsilon;

        if (!stop) {
            p0 = p1;
            p1 = p2;
            q0 = q1;
            q1 = q2;
            a0 = a1;
            r0 = r1;
        }
    }

    if (!stop) {
        throw new FractionConversionException(value, maxIterations);
    }

    this.numerator = (int) p2;
    this.denominator = (int) q2;
}",3,0
166,Math_26,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go
        // to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
","private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
{
    long maxLongValue = Long.MAX_VALUE / 2;  // Use Long instead of Integer to prevent overflow for large values
    double r0 = value;
    long a0 = (long) FastMath.floor(r0);

    // Short circuit for cases where value is near an integer
    if (FastMath.abs(a0 - value) < epsilon) {
        this.numerator = (int) a0;
        this.denominator = 1;
        return;
    }

    long p0 = 1;
    long q0 = 0;
    long p1 = a0;
    long q1 = 1;

    long p2, q2;
    double r1;
    int n = 0;
    boolean stop = false;

    while (!stop && n < maxIterations) {
        n++;
        r1 = 1.0 / (r0 - a0);
        long a1 = (long) FastMath.floor(r1);
        p2 = (a1 * p1) + p0;
        q2 = (a1 * q1) + q0;

        // Check for overflow using Long limits
        if ((p2 > maxLongValue) || (q2 > maxLongValue) || (q2 > maxDenominator)) {
            throw new FractionConversionException(value, p2, q2);
        }

        double convergent = (double) p2 / (double) q2;
        if (FastMath.abs(convergent - value) <= epsilon || q2 > maxDenominator) {
            stop = true;
            if (q2 > maxDenominator) {
                this.numerator = (int) p1;
                this.denominator = (int) q1;
            } else {
                this.numerator = (int) p2;
                this.denominator = (int) q2;
            }
        } else {
            p0 = p1;
            p1 = p2;
            q0 = q1;
            q1 = q2;
            a0 = a1;
            r0 = r1;
        }
    }

    if (!stop) {
        throw new FractionConversionException(value, maxIterations);
    }
}",4,0
167,Math_27,"    public double percentageValue() {
        return multiply(100).doubleValue();
    }
","public double percentageValue() {
    return this.multiply(new Fraction(100)).doubleValue();
}",0,0
167,Math_27,"    public double percentageValue() {
        return multiply(100).doubleValue();
    }
",Match failed,1,0
167,Math_27,"    public double percentageValue() {
        return multiply(100).doubleValue();
    }
","public double percentageValue() {
    return new Fraction(numerator * 100, denominator).doubleValue();
}",2,0
167,Math_27,"    public double percentageValue() {
        return multiply(100).doubleValue();
    }
","public double percentageValue() {
    return numerator * 100.0 / denominator;
}",3,0
168,Math_28,"private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);

            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                final double ratio = rhs / entry;
                // check if the entry is strictly equal to the current min ratio
                // do not use a ulp/epsilon check
                final int cmp = Double.compare(ratio, minRatio);
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions = new ArrayList<Integer>();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.size() == 0) {
            return null;
        } else if (minRatioPositions.size() > 1) {
            // there's a degeneracy as indicated by a tie in the minimum ratio test

            // 1. check if there's an artificial variable that can be forced out of the basis
                for (Integer row : minRatioPositions) {
                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                        int column = i + tableau.getArtificialVariableOffset();
                        final double entry = tableau.getEntry(row, column);
                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                            return row;
                        }
                    }
                }

            // 2. apply Bland's rule to prevent cycling:
            //    take the row for which the corresponding basic variable has the smallest index
            //
            // see http://www.stanford.edu/class/msande310/blandrule.pdf
            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
            //
            // Additional heuristic: if we did not get a solution after half of maxIterations
            //                       revert to the simple case of just returning the top-most row
            // This heuristic is based on empirical data gathered while investigating MATH-828.
                Integer minRow = null;
                int minIndex = tableau.getWidth();
                for (Integer row : minRatioPositions) {
                    int i = tableau.getNumObjectiveFunctions();
                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
                        if (row == tableau.getBasicRow(i)) {
                            if (i < minIndex) {
                                minIndex = i;
                                minRow = row;
                            }
                        }
                     }
                 }
                 return minRow;
         }
         return minRatioPositions.get(0);
     }","private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);

            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                final double ratio = rhs / entry;
                // check if the entry is strictly equal to the current min ratio
                // do not use a ulp/epsilon check
                final int cmp = Double.compare(ratio, minRatio);
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions.clear();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.isEmpty()) {
            return null;
        } else if (minRatioPositions.size() > 1) {
            // there's a degeneracy as indicated by a tie in the minimum ratio test

            // 1. check if there's an artificial variable that can be forced out of the basis
            for (Integer row : minRatioPositions) {
                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                    int column = i + tableau.getArtificialVariableOffset();
                    final double entry = tableau.getEntry(row, column);
                    if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                        return row;
                    }
                }
            }

            // 2. apply Bland's rule to prevent cycling:
            //    take the row for which the corresponding basic variable has the smallest index
            //
            // see http://www.stanford.edu/class/msande310/blandrule.pdf
            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
            //
            // Additional heuristic: if we did not get a solution after half of maxIterations
            //                       revert to the simple case of just returning the top-most row
            // This heuristic is based on empirical data gathered while investigating MATH-828.
            Integer minRow = null;
            int minIndex = Integer.MAX_VALUE; // Fix: Initialize minIndex to maximum integer value
            
            for (Integer row : minRatioPositions) {
                for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {
                    if (row.equals(tableau.getBasicRow(i))) {
                        if (i < minIndex) { // Fix: Properly compare indices
                            minIndex = i;
                            minRow = row;
                            break; // Fix: Break out of inner loop when minRow is updated
                        }
                    }
                }
            }
            return minRow;
        }
        return minRatioPositions.get(0);
    }",0,0
168,Math_28,"private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);

            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                final double ratio = rhs / entry;
                // check if the entry is strictly equal to the current min ratio
                // do not use a ulp/epsilon check
                final int cmp = Double.compare(ratio, minRatio);
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions = new ArrayList<Integer>();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.size() == 0) {
            return null;
        } else if (minRatioPositions.size() > 1) {
            // there's a degeneracy as indicated by a tie in the minimum ratio test

            // 1. check if there's an artificial variable that can be forced out of the basis
                for (Integer row : minRatioPositions) {
                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                        int column = i + tableau.getArtificialVariableOffset();
                        final double entry = tableau.getEntry(row, column);
                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                            return row;
                        }
                    }
                }

            // 2. apply Bland's rule to prevent cycling:
            //    take the row for which the corresponding basic variable has the smallest index
            //
            // see http://www.stanford.edu/class/msande310/blandrule.pdf
            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
            //
            // Additional heuristic: if we did not get a solution after half of maxIterations
            //                       revert to the simple case of just returning the top-most row
            // This heuristic is based on empirical data gathered while investigating MATH-828.
                Integer minRow = null;
                int minIndex = tableau.getWidth();
                for (Integer row : minRatioPositions) {
                    int i = tableau.getNumObjectiveFunctions();
                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
                        if (row == tableau.getBasicRow(i)) {
                            if (i < minIndex) {
                                minIndex = i;
                                minRow = row;
                            }
                        }
                     }
                 }
                 return minRow;
         }
         return minRatioPositions.get(0);
     }","private Integer getPivotRow(SimplexTableau tableau, final int col) {
    List<Integer> minRatioPositions = new ArrayList<Integer>();
    double minRatio = Double.MAX_VALUE;

    // Iterate through rows to find the minimum ratio for pivot
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);

        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            final double ratio = rhs / entry;
            // Track rows with the minimum ratio
            if (Double.compare(ratio, minRatio) < 0) {
                minRatio = ratio;
                minRatioPositions.clear();
                minRatioPositions.add(i);
            } else if (Double.compare(ratio, minRatio) == 0) {
                minRatioPositions.add(i);
            }
        }
    }

    if (minRatioPositions.isEmpty()) {
        return null;
    }

    // Resolve degeneracy condition
    if (minRatioPositions.size() > 1) {
        // Prioritize removing artificial variables if possible
        for (Integer row : minRatioPositions) {
            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                int column = i + tableau.getArtificialVariableOffset();
                final double entry = tableau.getEntry(row, column);
                if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                    return row;
                }
            }
        }

        // Apply Bland's rule: Choose the row with smallest index
        Integer minRow = null;
        int minIndex = Integer.MAX_VALUE;
        for (Integer row : minRatioPositions) {
            for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {
                if (row.equals(tableau.getBasicRow(i)) && i < minIndex) {
                    minIndex = i;
                    minRow = row;
                    break;
                }
            }
        }
        return minRow;
    }

    // Default: Return the first row in the list
    return minRatioPositions.get(0);
}",1,0
168,Math_28,"private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);

            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                final double ratio = rhs / entry;
                // check if the entry is strictly equal to the current min ratio
                // do not use a ulp/epsilon check
                final int cmp = Double.compare(ratio, minRatio);
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions = new ArrayList<Integer>();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.size() == 0) {
            return null;
        } else if (minRatioPositions.size() > 1) {
            // there's a degeneracy as indicated by a tie in the minimum ratio test

            // 1. check if there's an artificial variable that can be forced out of the basis
                for (Integer row : minRatioPositions) {
                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                        int column = i + tableau.getArtificialVariableOffset();
                        final double entry = tableau.getEntry(row, column);
                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                            return row;
                        }
                    }
                }

            // 2. apply Bland's rule to prevent cycling:
            //    take the row for which the corresponding basic variable has the smallest index
            //
            // see http://www.stanford.edu/class/msande310/blandrule.pdf
            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
            //
            // Additional heuristic: if we did not get a solution after half of maxIterations
            //                       revert to the simple case of just returning the top-most row
            // This heuristic is based on empirical data gathered while investigating MATH-828.
                Integer minRow = null;
                int minIndex = tableau.getWidth();
                for (Integer row : minRatioPositions) {
                    int i = tableau.getNumObjectiveFunctions();
                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
                        if (row == tableau.getBasicRow(i)) {
                            if (i < minIndex) {
                                minIndex = i;
                                minRow = row;
                            }
                        }
                     }
                 }
                 return minRow;
         }
         return minRatioPositions.get(0);
     }","private Integer getPivotRow(SimplexTableau tableau, final int col) {
    List<Integer> minRatioPositions = new ArrayList<Integer>();
    double minRatio = Double.MAX_VALUE;

    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);

        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            final double ratio = rhs / entry;
            if (Double.compare(ratio, minRatio) < 0) {
                minRatio = ratio;
                minRatioPositions.clear();
                minRatioPositions.add(i);
            } else if (Double.compare(ratio, minRatio) == 0) {
                minRatioPositions.add(i);
            }
        }
    }

    if (minRatioPositions.isEmpty()) {
        return null;
    }

    if (minRatioPositions.size() > 1) {
        Integer minRow = null;
        double minDifference = Double.MAX_VALUE;

        for (Integer row : minRatioPositions) {
            double difference = tableau.getEntry(row, tableau.getWidth() - 1) - minRatio * tableau.getEntry(row, col);
            if (difference < minDifference) {
                minDifference = difference;
                minRow = row;
            }
        }
        return minRow;
    }

    return minRatioPositions.get(0);
}",2,0
169,Math_3,"    public static double linearCombination(final double[] a, final double[] b)
        throws DimensionMismatchException {
        final int len = a.length;
        if (len != b.length) {
            throw new DimensionMismatchException(len, b.length);
        }

            // Revert to scalar multiplication.

        final double[] prodHigh = new double[len];
        double prodLowSum = 0;

        for (int i = 0; i < len; i++) {
            final double ai = a[i];
            final double ca = SPLIT_FACTOR * ai;
            final double aHigh = ca - (ca - ai);
            final double aLow = ai - aHigh;

            final double bi = b[i];
            final double cb = SPLIT_FACTOR * bi;
            final double bHigh = cb - (cb - bi);
            final double bLow = bi - bHigh;
            prodHigh[i] = ai * bi;
            final double prodLow = aLow * bLow - (((prodHigh[i] -
                                                    aHigh * bHigh) -
                                                   aLow * bHigh) -
                                                  aHigh * bLow);
            prodLowSum += prodLow;
        }


        final double prodHighCur = prodHigh[0];
        double prodHighNext = prodHigh[1];
        double sHighPrev = prodHighCur + prodHighNext;
        double sPrime = sHighPrev - prodHighNext;
        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);

        final int lenMinusOne = len - 1;
        for (int i = 1; i < lenMinusOne; i++) {
            prodHighNext = prodHigh[i + 1];
            final double sHighCur = sHighPrev + prodHighNext;
            sPrime = sHighCur - prodHighNext;
            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
            sHighPrev = sHighCur;
        }

        double result = sHighPrev + (prodLowSum + sLowSum);

        if (Double.isNaN(result)) {
            // either we have split infinite numbers or some coefficients were NaNs,
            // just rely on the naive implementation and let IEEE754 handle this
            result = 0;
            for (int i = 0; i < len; ++i) {
                result += a[i] * b[i];
            }
        }

        return result;
    }","public static double linearCombination(final double[] a, final double[] b)
        throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }

    final double[] prodHigh = new double[len];
    double prodLowSum = 0;

    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;

        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;

        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] -
                                                aHigh * bHigh) -
                                               aLow * bHigh) -
                                              aHigh * bLow);
        prodLowSum += prodLow;
    }

    double result = prodHigh[0];
    double sLowSum = 0;

    for (int i = 1; i < len; i++) {
        double prodHighCur = prodHigh[i];
        double sHighCur = result + prodHighCur;
        double sPrime = sHighCur - prodHighCur;
        sLowSum += (prodHighCur - (sHighCur - sPrime)) + (result - sPrime);
        result = sHighCur;
    }

    result += (prodLowSum + sLowSum); 

    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }

    return result;
}",0,0
170,Math_30,"private double calculateAsymptoticPValue(final double Umin,
                                             final int n1,
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
         final int n1n2prod = n1 * n2;
 
         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
         final double EU = n1n2prod / 2.0;
        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;

        final double z = (Umin - EU) / FastMath.sqrt(VarU);

        final NormalDistribution standardNormal = new NormalDistribution(0, 1);

        return 2 * standardNormal.cumulativeProbability(z);
    }","private double calculateAsymptoticPValue(final double Umin,
                                             final int n1,
                                             final int n2)
        throws ConvergenceException, MaxCountExceededException {

    final int n1n2prod = n1 * n2;

    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
    final double EU = n1n2prod / 2.0;
    final double VarU = n1n2prod * (double)(n1 + n2 + 1) / 12.0;  // Cast to double to prevent negative variance

    if (VarU < 0) {
        throw new IllegalArgumentException(""Variance should be non-negative"");
    }

    final double z = (Umin - EU) / FastMath.sqrt(VarU);

    final NormalDistribution standardNormal = new NormalDistribution(0, 1);

    return 2 * standardNormal.cumulativeProbability(z);
}",0,0
171,Math_31,"public double evaluate(double x, double epsilon, int maxIterations) {
        final double small = 1e-50;
        double hPrev = getA(0, x);

        // use the value of small as epsilon criteria for zero checks
        if (Precision.equals(hPrev, 0.0, small)) {
            hPrev = small;
        }

        int n = 1;
        double dPrev = 0.0;
        double p0 = 1.0;
        double q1 = 1.0;
        double cPrev = hPrev;
        double hN = hPrev;

        while (n < maxIterations) {
            final double a = getA(n, x);
            final double b = getB(n, x);

            double cN = a * hPrev + b * p0;
            double q2 = a * q1 + b * dPrev;
            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
                double scaleFactor = 1d;
                double lastScaleFactor = 1d;
                final int maxPower = 5;
                final double scale = FastMath.max(a,b);
                if (scale <= 0) {  // Can't scale
                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
                }
                for (int i = 0; i < maxPower; i++) {
                    lastScaleFactor = scaleFactor;
                    scaleFactor *= scale;
                    if (a != 0.0 && a > b) {
                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                    } else if (b != 0) {
                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                    }
                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                        break;
                    }
                }
            }

            final double deltaN = cN / q2 / cPrev;
            hN = cPrev * deltaN;

            if (Double.isInfinite(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
                                               x);
            }
            if (Double.isNaN(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
                                               x);
            }

            if (FastMath.abs(deltaN - 1.0) < epsilon) {
                 break;
             }
 
             dPrev = q1;
             cPrev = cN / q2;
             p0 = hPrev;
             hPrev = cN;
             q1 = q2;
             n++;
         }
 
        if (n >= maxIterations) {
            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,
                                                maxIterations, x);
        }

        return hN;
    }","public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);

    // use the value of small as epsilon criteria for zero checks
    if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }

    int n = 1;
    double dPrev = 0.0;
    double p0 = 1.0;
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;

    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);

        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;
        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
            double scaleFactor = 1d;
            double lastScaleFactor = 1d;
            final int maxPower = 5;
            final double scale = FastMath.max(FastMath.abs(a), FastMath.abs(b));
            if (scale <= 0) {  // Can't scale
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
            }
            for (int i = 0; i < maxPower; i++) {
                lastScaleFactor = scaleFactor;
                scaleFactor *= scale;
                if (a != 0.0 && a > b) {
                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                } else if (b != 0) {
                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                }
                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                    break;
                }
            }
        }

        if (q2 == 0) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_ZERO_Q2, x);
        }

        final double deltaN = cN / q2 / cPrev;
        hN = cPrev * deltaN;

        if (Double.isInfinite(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
        }
        if (Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }

        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            break;
        }

        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }

    if (n >= maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
    }

    return hN;
}",0,0
171,Math_31,"public double evaluate(double x, double epsilon, int maxIterations) {
        final double small = 1e-50;
        double hPrev = getA(0, x);

        // use the value of small as epsilon criteria for zero checks
        if (Precision.equals(hPrev, 0.0, small)) {
            hPrev = small;
        }

        int n = 1;
        double dPrev = 0.0;
        double p0 = 1.0;
        double q1 = 1.0;
        double cPrev = hPrev;
        double hN = hPrev;

        while (n < maxIterations) {
            final double a = getA(n, x);
            final double b = getB(n, x);

            double cN = a * hPrev + b * p0;
            double q2 = a * q1 + b * dPrev;
            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
                double scaleFactor = 1d;
                double lastScaleFactor = 1d;
                final int maxPower = 5;
                final double scale = FastMath.max(a,b);
                if (scale <= 0) {  // Can't scale
                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
                }
                for (int i = 0; i < maxPower; i++) {
                    lastScaleFactor = scaleFactor;
                    scaleFactor *= scale;
                    if (a != 0.0 && a > b) {
                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                    } else if (b != 0) {
                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                    }
                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                        break;
                    }
                }
            }

            final double deltaN = cN / q2 / cPrev;
            hN = cPrev * deltaN;

            if (Double.isInfinite(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
                                               x);
            }
            if (Double.isNaN(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
                                               x);
            }

            if (FastMath.abs(deltaN - 1.0) < epsilon) {
                 break;
             }
 
             dPrev = q1;
             cPrev = cN / q2;
             p0 = hPrev;
             hPrev = cN;
             q1 = q2;
             n++;
         }
 
        if (n >= maxIterations) {
            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,
                                                maxIterations, x);
        }

        return hN;
    }","public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);

    // Adjust initial hPrev if zero or close to zero
    hPrev = Precision.equals(hPrev, 0.0, small) ? small : hPrev;

    int n = 1;
    double dPrev = 1.0; // Changed from 0.0
    double p0 = 0.0; // Changed from 1.0 to ensure correct initialization for previous P
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;

    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);

        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;

        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
        }

        if (q2 == 0.0) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_ZERO_Q2, x);
        }

        final double deltaN = cN / q2 / cPrev;
        hN = cPrev * deltaN;

        if (Double.isInfinite(hN) || Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }

        // Convergence check
        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            return hN;
        }

        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }

    if (n >= maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
    }

    return hN;
}",1,0
171,Math_31,"public double evaluate(double x, double epsilon, int maxIterations) {
        final double small = 1e-50;
        double hPrev = getA(0, x);

        // use the value of small as epsilon criteria for zero checks
        if (Precision.equals(hPrev, 0.0, small)) {
            hPrev = small;
        }

        int n = 1;
        double dPrev = 0.0;
        double p0 = 1.0;
        double q1 = 1.0;
        double cPrev = hPrev;
        double hN = hPrev;

        while (n < maxIterations) {
            final double a = getA(n, x);
            final double b = getB(n, x);

            double cN = a * hPrev + b * p0;
            double q2 = a * q1 + b * dPrev;
            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
                double scaleFactor = 1d;
                double lastScaleFactor = 1d;
                final int maxPower = 5;
                final double scale = FastMath.max(a,b);
                if (scale <= 0) {  // Can't scale
                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
                }
                for (int i = 0; i < maxPower; i++) {
                    lastScaleFactor = scaleFactor;
                    scaleFactor *= scale;
                    if (a != 0.0 && a > b) {
                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                    } else if (b != 0) {
                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                    }
                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                        break;
                    }
                }
            }

            final double deltaN = cN / q2 / cPrev;
            hN = cPrev * deltaN;

            if (Double.isInfinite(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
                                               x);
            }
            if (Double.isNaN(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
                                               x);
            }

            if (FastMath.abs(deltaN - 1.0) < epsilon) {
                 break;
             }
 
             dPrev = q1;
             cPrev = cN / q2;
             p0 = hPrev;
             hPrev = cN;
             q1 = q2;
             n++;
         }
 
        if (n >= maxIterations) {
            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,
                                                maxIterations, x);
        }

        return hN;
    }","public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);

    if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }

    int n = 1;
    double dPrev = 0.0;
    double p0 = 1.0;
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;

    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);

        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;
        if (Double.isInfinite(cN) || Double.isInfinite(q2) || Precision.equals(q2, 0.0, small)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
        }

        final double deltaN = cN / q2 / cPrev;
        hN = cPrev * deltaN;

        if (Double.isInfinite(hN) || Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }

        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            return hN;
        }

        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }

    throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
}",2,0
171,Math_31,"public double evaluate(double x, double epsilon, int maxIterations) {
        final double small = 1e-50;
        double hPrev = getA(0, x);

        // use the value of small as epsilon criteria for zero checks
        if (Precision.equals(hPrev, 0.0, small)) {
            hPrev = small;
        }

        int n = 1;
        double dPrev = 0.0;
        double p0 = 1.0;
        double q1 = 1.0;
        double cPrev = hPrev;
        double hN = hPrev;

        while (n < maxIterations) {
            final double a = getA(n, x);
            final double b = getB(n, x);

            double cN = a * hPrev + b * p0;
            double q2 = a * q1 + b * dPrev;
            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
                double scaleFactor = 1d;
                double lastScaleFactor = 1d;
                final int maxPower = 5;
                final double scale = FastMath.max(a,b);
                if (scale <= 0) {  // Can't scale
                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
                }
                for (int i = 0; i < maxPower; i++) {
                    lastScaleFactor = scaleFactor;
                    scaleFactor *= scale;
                    if (a != 0.0 && a > b) {
                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                    } else if (b != 0) {
                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                    }
                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                        break;
                    }
                }
            }

            final double deltaN = cN / q2 / cPrev;
            hN = cPrev * deltaN;

            if (Double.isInfinite(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
                                               x);
            }
            if (Double.isNaN(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
                                               x);
            }

            if (FastMath.abs(deltaN - 1.0) < epsilon) {
                 break;
             }
 
             dPrev = q1;
             cPrev = cN / q2;
             p0 = hPrev;
             hPrev = cN;
             q1 = q2;
             n++;
         }
 
        if (n >= maxIterations) {
            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,
                                                maxIterations, x);
        }

        return hN;
    }","public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);

    if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }

    int n = 1;
    double dPrev = 0.0;
    double p0 = 1.0;
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;

    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);

        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;

        // Introduce logic to handle zero convergence case
        if (q2 == 0) {
            // Apply perturbation to break cycles when q2 becomes zero
            q2 = small;
        }

        final double deltaN = cN / q2 / cPrev;
        hN = cPrev * deltaN;

        if (Double.isInfinite(hN) || Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }

        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            return hN;
        }

        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }

    throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
}",3,0
171,Math_31,"public double evaluate(double x, double epsilon, int maxIterations) {
        final double small = 1e-50;
        double hPrev = getA(0, x);

        // use the value of small as epsilon criteria for zero checks
        if (Precision.equals(hPrev, 0.0, small)) {
            hPrev = small;
        }

        int n = 1;
        double dPrev = 0.0;
        double p0 = 1.0;
        double q1 = 1.0;
        double cPrev = hPrev;
        double hN = hPrev;

        while (n < maxIterations) {
            final double a = getA(n, x);
            final double b = getB(n, x);

            double cN = a * hPrev + b * p0;
            double q2 = a * q1 + b * dPrev;
            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
                double scaleFactor = 1d;
                double lastScaleFactor = 1d;
                final int maxPower = 5;
                final double scale = FastMath.max(a,b);
                if (scale <= 0) {  // Can't scale
                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
                }
                for (int i = 0; i < maxPower; i++) {
                    lastScaleFactor = scaleFactor;
                    scaleFactor *= scale;
                    if (a != 0.0 && a > b) {
                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                    } else if (b != 0) {
                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                    }
                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                        break;
                    }
                }
            }

            final double deltaN = cN / q2 / cPrev;
            hN = cPrev * deltaN;

            if (Double.isInfinite(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
                                               x);
            }
            if (Double.isNaN(hN)) {
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
                                               x);
            }

            if (FastMath.abs(deltaN - 1.0) < epsilon) {
                 break;
             }
 
             dPrev = q1;
             cPrev = cN / q2;
             p0 = hPrev;
             hPrev = cN;
             q1 = q2;
             n++;
         }
 
        if (n >= maxIterations) {
            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,
                                                maxIterations, x);
        }

        return hN;
    }","public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);

    if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }

    int n = 1;
    double dPrev = 0.0;
    double p0 = 1.0;
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;

    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);

        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;
        
        // Skip iteration if q2 becomes effectively zero
        if (Math.abs(q2) < small) {
            hN = hPrev; // Maintain previous result
            break;
        }
        
        final double deltaN = cN / q2 / cPrev;
        hN = cPrev * deltaN;

        if (Double.isInfinite(hN) || Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }
        
        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            return hN;
        }

        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }

    if (n >= maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
    }

    return hN;
}",4,0
172,Math_32,"@Override
    protected void computeGeometricalProperties() {

        final Vector2D[][] v = getVertices();
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
             if ((Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
            } else {
                setSize(0);
                setBarycenter(new Vector2D(0, 0));
            }
        } else if (v[0][0] == null) {
            // there is at least one open-loop: the polygon is infinite
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            // all loops are closed, we compute some integrals around the shape

            double sum  = 0;
            double sumX = 0;
            double sumY = 0;

            for (Vector2D[] loop : v) {
                double x1 = loop[loop.length - 1].getX();
                double y1 = loop[loop.length - 1].getY();
                for (final Vector2D point : loop) {
                    final double x0 = x1;
                    final double y0 = y1;
                    x1 = point.getX();
                    y1 = point.getY();
                    final double factor = x0 * y1 - y0 * x1;
                    sum  += factor;
                    sumX += factor * (x0 + x1);
                    sumY += factor * (y0 + y1);
                }
            }

            if (sum < 0) {
                // the polygon as a finite outside surrounded by an infinite inside
                setSize(Double.POSITIVE_INFINITY);
                setBarycenter(Vector2D.NaN);
            } else {
                setSize(sum / 2);
                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
            }

        }

    }","@Override
protected void computeGeometricalProperties() {

    final Vector2D[][] v = getVertices();

    if (v.length == 0) {
        final BSPTree<Euclidean2D> tree = getTree(false);
        Object attribute = tree.getAttribute();
        if (attribute instanceof Boolean && (Boolean) attribute) {
            // the instance covers the whole space
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(0);
            setBarycenter(new Vector2D(0, 0));
        }
    } else if (v[0][0] == null) {
        // there is at least one open-loop: the polygon is infinite
        setSize(Double.POSITIVE_INFINITY);
        setBarycenter(Vector2D.NaN);
    } else {
        // all loops are closed, we compute some integrals around the shape

        double sum  = 0;
        double sumX = 0;
        double sumY = 0;

        for (Vector2D[] loop : v) {
            double x1 = loop[loop.length - 1].getX();
            double y1 = loop[loop.length - 1].getY();
            for (final Vector2D point : loop) {
                final double x0 = x1;
                final double y0 = y1;
                x1 = point.getX();
                y1 = point.getY();
                final double factor = x0 * y1 - y0 * x1;
                sum  += factor;
                sumX += factor * (x0 + x1);
                sumY += factor * (y0 + y1);
            }
        }

        if (sum < 0) {
            // the polygon has a finite outside surrounded by an infinite inside
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(sum / 2);
            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
        }
    }
}",0,0
173,Math_33,"protected void dropPhase1Objective() {
        if (getNumObjectiveFunctions() == 1) {
            return;
        }

        List<Integer> columnsToDrop = new ArrayList<Integer>();
        columnsToDrop.add(0);

         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }

        // non-basic artificial variables
        for (int i = 0; i < getNumArtificialVariables(); i++) {
          int col = i + getArtificialVariableOffset();
          if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
          }
        }

        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
        for (int i = 1; i < getHeight(); i++) {
          int col = 0;
          for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
              matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
          }
        }

        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
          columnLabels.remove((int) columnsToDrop.get(i));
        }

        this.tableau = new Array2DRowRealMatrix(matrix);
        this.numArtificialVariables = 0;
    }","protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }

    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);

    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }

    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }

    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }

    Collections.sort(columnsToDrop, Collections.reverseOrder()); // Sort columns in descending order
    for (int colToDrop : columnsToDrop) {
        columnLabels.remove(colToDrop); // Can safely remove by index due to sorted list
    }

    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}",0,0
173,Math_33,"protected void dropPhase1Objective() {
        if (getNumObjectiveFunctions() == 1) {
            return;
        }

        List<Integer> columnsToDrop = new ArrayList<Integer>();
        columnsToDrop.add(0);

         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }

        // non-basic artificial variables
        for (int i = 0; i < getNumArtificialVariables(); i++) {
          int col = i + getArtificialVariableOffset();
          if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
          }
        }

        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
        for (int i = 1; i < getHeight(); i++) {
          int col = 0;
          for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
              matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
          }
        }

        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
          columnLabels.remove((int) columnsToDrop.get(i));
        }

        this.tableau = new Array2DRowRealMatrix(matrix);
        this.numArtificialVariables = 0;
    }","protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }

    Set<Integer> columnsToDrop = new HashSet<>();
    columnsToDrop.add(0);

    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }

    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }

    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }

    List<Integer> sortedColumnsToDrop = new ArrayList<>(columnsToDrop);
    Collections.sort(sortedColumnsToDrop, Collections.reverseOrder()); // Sort columns in descending order

    for (int colToDrop : sortedColumnsToDrop) {
        columnLabels.remove(colToDrop); // Can safely remove by index due to sorted list
    }

    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}",1,0
173,Math_33,"protected void dropPhase1Objective() {
        if (getNumObjectiveFunctions() == 1) {
            return;
        }

        List<Integer> columnsToDrop = new ArrayList<Integer>();
        columnsToDrop.add(0);

         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }

        // non-basic artificial variables
        for (int i = 0; i < getNumArtificialVariables(); i++) {
          int col = i + getArtificialVariableOffset();
          if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
          }
        }

        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
        for (int i = 1; i < getHeight(); i++) {
          int col = 0;
          for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
              matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
          }
        }

        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
          columnLabels.remove((int) columnsToDrop.get(i));
        }

        this.tableau = new Array2DRowRealMatrix(matrix);
        this.numArtificialVariables = 0;
    }","protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }

    int artificialOffset = getArtificialVariableOffset();

    Set<Integer> columnsToDrop = new HashSet<>();
    columnsToDrop.add(0);

    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < artificialOffset; i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }

    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + artificialOffset;
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }

    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }

    // Only remove from column labels after constructing the new matrix
    columnsToDrop.forEach(columnLabels::remove);

    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}",2,0
173,Math_33,"protected void dropPhase1Objective() {
        if (getNumObjectiveFunctions() == 1) {
            return;
        }

        List<Integer> columnsToDrop = new ArrayList<Integer>();
        columnsToDrop.add(0);

         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }

        // non-basic artificial variables
        for (int i = 0; i < getNumArtificialVariables(); i++) {
          int col = i + getArtificialVariableOffset();
          if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
          }
        }

        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
        for (int i = 1; i < getHeight(); i++) {
          int col = 0;
          for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
              matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
          }
        }

        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
          columnLabels.remove((int) columnsToDrop.get(i));
        }

        this.tableau = new Array2DRowRealMatrix(matrix);
        this.numArtificialVariables = 0;
    }","protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }

    boolean[] dropColumnFlags = new boolean[getWidth()];
    dropColumnFlags[0] = true; // Always drop the phase 1 objective column

    // Set flags for positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            dropColumnFlags[i] = true;
        }
    }

    // Set flags for non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            dropColumnFlags[col] = true;
        }
    }

    int newWidth = getWidth();
    for (boolean flag : dropColumnFlags) {
        if (flag) {
            newWidth--;
        }
    }

    double[][] matrix = new double[getHeight() - 1][newWidth];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!dropColumnFlags[j]) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }

    ArrayList<Integer> columnsToDrop = new ArrayList<>();
    for (int j = 0; j < getWidth(); j++) {
        if (dropColumnFlags[j]) {
            columnsToDrop.add(j);
        }
    }
    
    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
        columnLabels.remove((int) columnsToDrop.get(i));
    }

    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}",3,0
173,Math_33,"protected void dropPhase1Objective() {
        if (getNumObjectiveFunctions() == 1) {
            return;
        }

        List<Integer> columnsToDrop = new ArrayList<Integer>();
        columnsToDrop.add(0);

         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }

        // non-basic artificial variables
        for (int i = 0; i < getNumArtificialVariables(); i++) {
          int col = i + getArtificialVariableOffset();
          if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
          }
        }

        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
        for (int i = 1; i < getHeight(); i++) {
          int col = 0;
          for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
              matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
          }
        }

        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
          columnLabels.remove((int) columnsToDrop.get(i));
        }

        this.tableau = new Array2DRowRealMatrix(matrix);
        this.numArtificialVariables = 0;
    }","protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }

    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);

    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }

    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }

    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }

    // Sorting the columns to be dropped ensures indices are handled correctly
    Collections.sort(columnsToDrop);
    for (int index = columnsToDrop.size() - 1; index >= 0; index--) {
        int colToDrop = columnsToDrop.get(index);
        columnLabels.remove(colToDrop);
    }

    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}",4,0
174,Math_34,"    public Iterator<Chromosome> iterator() {
        return chromosomes.iterator();
    }
",Match failed,0,0
174,Math_34,"    public Iterator<Chromosome> iterator() {
        return chromosomes.iterator();
    }
","public Iterator<Chromosome> iterator() {
    return new Iterator<Chromosome>() {
        private final Iterator<Chromosome> iter = chromosomes.iterator();

        @Override
        public boolean hasNext() {
            return iter.hasNext();
        }

        @Override
        public Chromosome next() {
            return iter.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException(""remove"");
        }
    };
}",1,0
175,Math_38,"private void prelim(double[] lowerBound,
                        double[] upperBound) {
        printMethod(); // XXX

        final int n = currentBest.getDimension();
        final int npt = numberOfInterpolationPoints;
        final int ndim = bMatrix.getRowDimension();

        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
        final double recip = 1d / rhosq;
        final int np = n + 1;

        // Set XBASE to the initial vector of variables, and set the initial
        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

        for (int j = 0; j < n; j++) {
            originShift.setEntry(j, currentBest.getEntry(j));
            for (int k = 0; k < npt; k++) {
                interpolationPoints.setEntry(k, j, ZERO);
            }
            for (int i = 0; i < ndim; i++) {
                bMatrix.setEntry(i, j, ZERO);
            }
        }
        for (int i = 0, max = n * np / 2; i < max; i++) {
            modelSecondDerivativesValues.setEntry(i, ZERO);
        }
        for (int k = 0; k < npt; k++) {
            modelSecondDerivativesParameters.setEntry(k, ZERO);
            for (int j = 0, max = npt - np; j < max; j++) {
                zMatrix.setEntry(k, j, ZERO);
            }
        }

        // Begin the initialization procedure. NF becomes one more than the number
        // of function values so far. The coordinates of the displacement of the
        // next initial interpolation point from XBASE are set in XPT(NF+1,.).

        int ipt = 0;
        int jpt = 0;
        double fbeg = Double.NaN;
        do {
            final int nfm = getEvaluations();
            final int nfx = nfm - n;
            final int nfmm = nfm - 1;
            final int nfxm = nfx - 1;
            double stepa = 0;
            double stepb = 0;
            if (nfm <= 2 * n) {
                if (nfm >= 1 &&
                    nfm <= n) {
                    stepa = initialTrustRegionRadius;
                    if (upperDifference.getEntry(nfmm) == ZERO) {
                        stepa = -stepa;
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfmm, stepa);
                } else if (nfm > n) {
                    stepa = interpolationPoints.getEntry(nfx, nfxm);
                    stepb = -initialTrustRegionRadius;
                    if (lowerDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    if (upperDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfxm, stepb);
                }
            } else {
                final int tmp1 = (nfm - np) / n;
                jpt = nfm - tmp1 * n - n;
                ipt = jpt + tmp1;
                if (ipt > n) {
                    final int tmp2 = jpt;
                    jpt = ipt - n;
                    ipt = tmp2;
                    throw new PathIsExploredException(); // XXX
                }
                final int iptMinus1 = ipt;
                final int jptMinus1 = jpt;
                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
            }

            // Calculate the next value of F. The least function value so far and
            // its index are required.

            for (int j = 0; j < n; j++) {
                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                                                 upperBound[j]));
                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                    currentBest.setEntry(j, lowerBound[j]);
                }
                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                    currentBest.setEntry(j, upperBound[j]);
                }
            }

            final double objectiveValue = computeObjectiveValue(currentBest.toArray());
            final double f = isMinimize ? objectiveValue : -objectiveValue;
            final int numEval = getEvaluations(); // nfm + 1
            fAtInterpolationPoints.setEntry(nfm, f);

            if (numEval == 1) {
                fbeg = f;
                trustRegionCenterInterpolationPointIndex = 0;
            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
                trustRegionCenterInterpolationPointIndex = nfm;
            }

            // Set the nonzero initial elements of BMAT and the quadratic model in the
            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
            // of the NF-th and (NF-N)-th interpolation points may be switched, in
            // order that the function value at the first of them contributes to the
            // off-diagonal second derivative terms of the initial quadratic model.

            if (numEval <= 2 * n + 1) {
                if (numEval >= 2 &&
                    numEval <= n + 1) {
                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                    if (npt < numEval + n) {
                        final double oneOverStepA = ONE / stepa;
                        bMatrix.setEntry(0, nfmm, -oneOverStepA);
                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                        throw new PathIsExploredException(); // XXX
                    }
                } else if (numEval >= n + 2) {
                    final int ih = nfx * (nfx + 1) / 2 - 1;
                    final double tmp = (f - fbeg) / stepb;
                    final double diff = stepb - stepa;
                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                    if (stepa * stepb < ZERO) {
                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                            fAtInterpolationPoints.setEntry(nfm - n, f);
                            if (trustRegionCenterInterpolationPointIndex == nfm) {
                                trustRegionCenterInterpolationPointIndex = nfm - n;
                            }
                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                            interpolationPoints.setEntry(nfm, nfxm, stepa);
                        }
                    }
                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                    bMatrix.setEntry(nfm - n, nfxm,
                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                    zMatrix.setEntry(nfm - n, nfxm,
                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
                }

                // Set the off-diagonal second derivatives of the Lagrange functions and
                // the initial quadratic model.

            } else {
                zMatrix.setEntry(0, nfxm, recip);
                zMatrix.setEntry(nfm, nfxm, recip);
                zMatrix.setEntry(ipt, nfxm, -recip);
                zMatrix.setEntry(jpt, nfxm, -recip);

                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                throw new PathIsExploredException(); // XXX
            }
        } while (getEvaluations() < npt);
    } // prelim","private void prelim(double[] lowerBound,
                    double[] upperBound) {
    printMethod(); // XXX

    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();

    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;

    // Set XBASE to the initial vector of variables, and set the initial
    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }

    // Begin the initialization procedure. NF becomes one more than the number
    // of function values so far. The coordinates of the displacement of the
    // next initial interpolation point from XBASE are set in XPT(NF+1,.).

    int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    do {
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;
        if (nfm <= 2 * n) {
            if (nfm >= 1 &&
                nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    stepa = -stepa;
                    // throw new PathIsExploredException(); // Removed the exception
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                if (lowerDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                    // throw new PathIsExploredException(); // Removed the exception
                }
                if (upperDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                    // throw new PathIsExploredException(); // Removed the exception
                }
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            if (ipt > n) {
                final int tmp2 = jpt;
                jpt = ipt - n;
                ipt = tmp2;
                // throw new PathIsExploredException(); // Removed the exception
            }
            final int iptMinus1 = ipt;
            final int jptMinus1 = jpt;
            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
        }

        // Calculate the next value of F. The least function value so far and
        // its index are required.

        for (int j = 0; j < n; j++) {
            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                                                      originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                                             upperBound[j]));
            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                currentBest.setEntry(j, lowerBound[j]);
            }
            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                currentBest.setEntry(j, upperBound[j]);
            }
        }

        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
        final int numEval = getEvaluations(); // nfm + 1
        fAtInterpolationPoints.setEntry(nfm, f);

        if (numEval == 1) {
            fbeg = f;
            trustRegionCenterInterpolationPointIndex = 0;
        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
            trustRegionCenterInterpolationPointIndex = nfm;
        }

        // Set the nonzero initial elements of BMAT and the quadratic model in the
        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
        // of the NF-th and (NF-N)-th interpolation points may be switched, in
        // order that the function value at the first of them contributes to the
        // off-diagonal second derivative terms of the initial quadratic model.

        if (numEval <= 2 * n + 1) {
            if (numEval >= 2 &&
                numEval <= n + 1) {
                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                if (npt < numEval + n) {
                    final double oneOverStepA = ONE / stepa;
                    bMatrix.setEntry(0, nfmm, -oneOverStepA);
                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                }
            } else if (numEval >= n + 2) {
                final int ih = nfx * (nfx + 1) / 2 - 1;
                final double tmp = (f - fbeg) / stepb;
                final double diff = stepb - stepa;
                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                if (stepa * stepb < ZERO) {
                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                        fAtInterpolationPoints.setEntry(nfm - n, f);
                        if (trustRegionCenterInterpolationPointIndex == nfm) {
                            trustRegionCenterInterpolationPointIndex = nfm - n;
                        }
                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                        interpolationPoints.setEntry(nfm, nfxm, stepa);
                    }
                }
                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                bMatrix.setEntry(nfm - n, nfxm,
                              -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                zMatrix.setEntry(nfm - n, nfxm,
                              -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
            }

            // Set the off-diagonal second derivatives of the Lagrange functions and
            // the initial quadratic model.

        } else {
            zMatrix.setEntry(0, nfxm, recip);
            zMatrix.setEntry(nfm, nfxm, recip);
            zMatrix.setEntry(ipt, nfxm, -recip);
            zMatrix.setEntry(jpt, nfxm, -recip);

            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
        }
    } while (getEvaluations() < npt);
}",0,0
175,Math_38,"private void prelim(double[] lowerBound,
                        double[] upperBound) {
        printMethod(); // XXX

        final int n = currentBest.getDimension();
        final int npt = numberOfInterpolationPoints;
        final int ndim = bMatrix.getRowDimension();

        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
        final double recip = 1d / rhosq;
        final int np = n + 1;

        // Set XBASE to the initial vector of variables, and set the initial
        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

        for (int j = 0; j < n; j++) {
            originShift.setEntry(j, currentBest.getEntry(j));
            for (int k = 0; k < npt; k++) {
                interpolationPoints.setEntry(k, j, ZERO);
            }
            for (int i = 0; i < ndim; i++) {
                bMatrix.setEntry(i, j, ZERO);
            }
        }
        for (int i = 0, max = n * np / 2; i < max; i++) {
            modelSecondDerivativesValues.setEntry(i, ZERO);
        }
        for (int k = 0; k < npt; k++) {
            modelSecondDerivativesParameters.setEntry(k, ZERO);
            for (int j = 0, max = npt - np; j < max; j++) {
                zMatrix.setEntry(k, j, ZERO);
            }
        }

        // Begin the initialization procedure. NF becomes one more than the number
        // of function values so far. The coordinates of the displacement of the
        // next initial interpolation point from XBASE are set in XPT(NF+1,.).

        int ipt = 0;
        int jpt = 0;
        double fbeg = Double.NaN;
        do {
            final int nfm = getEvaluations();
            final int nfx = nfm - n;
            final int nfmm = nfm - 1;
            final int nfxm = nfx - 1;
            double stepa = 0;
            double stepb = 0;
            if (nfm <= 2 * n) {
                if (nfm >= 1 &&
                    nfm <= n) {
                    stepa = initialTrustRegionRadius;
                    if (upperDifference.getEntry(nfmm) == ZERO) {
                        stepa = -stepa;
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfmm, stepa);
                } else if (nfm > n) {
                    stepa = interpolationPoints.getEntry(nfx, nfxm);
                    stepb = -initialTrustRegionRadius;
                    if (lowerDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    if (upperDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfxm, stepb);
                }
            } else {
                final int tmp1 = (nfm - np) / n;
                jpt = nfm - tmp1 * n - n;
                ipt = jpt + tmp1;
                if (ipt > n) {
                    final int tmp2 = jpt;
                    jpt = ipt - n;
                    ipt = tmp2;
                    throw new PathIsExploredException(); // XXX
                }
                final int iptMinus1 = ipt;
                final int jptMinus1 = jpt;
                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
            }

            // Calculate the next value of F. The least function value so far and
            // its index are required.

            for (int j = 0; j < n; j++) {
                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                                                 upperBound[j]));
                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                    currentBest.setEntry(j, lowerBound[j]);
                }
                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                    currentBest.setEntry(j, upperBound[j]);
                }
            }

            final double objectiveValue = computeObjectiveValue(currentBest.toArray());
            final double f = isMinimize ? objectiveValue : -objectiveValue;
            final int numEval = getEvaluations(); // nfm + 1
            fAtInterpolationPoints.setEntry(nfm, f);

            if (numEval == 1) {
                fbeg = f;
                trustRegionCenterInterpolationPointIndex = 0;
            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
                trustRegionCenterInterpolationPointIndex = nfm;
            }

            // Set the nonzero initial elements of BMAT and the quadratic model in the
            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
            // of the NF-th and (NF-N)-th interpolation points may be switched, in
            // order that the function value at the first of them contributes to the
            // off-diagonal second derivative terms of the initial quadratic model.

            if (numEval <= 2 * n + 1) {
                if (numEval >= 2 &&
                    numEval <= n + 1) {
                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                    if (npt < numEval + n) {
                        final double oneOverStepA = ONE / stepa;
                        bMatrix.setEntry(0, nfmm, -oneOverStepA);
                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                        throw new PathIsExploredException(); // XXX
                    }
                } else if (numEval >= n + 2) {
                    final int ih = nfx * (nfx + 1) / 2 - 1;
                    final double tmp = (f - fbeg) / stepb;
                    final double diff = stepb - stepa;
                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                    if (stepa * stepb < ZERO) {
                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                            fAtInterpolationPoints.setEntry(nfm - n, f);
                            if (trustRegionCenterInterpolationPointIndex == nfm) {
                                trustRegionCenterInterpolationPointIndex = nfm - n;
                            }
                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                            interpolationPoints.setEntry(nfm, nfxm, stepa);
                        }
                    }
                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                    bMatrix.setEntry(nfm - n, nfxm,
                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                    zMatrix.setEntry(nfm - n, nfxm,
                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
                }

                // Set the off-diagonal second derivatives of the Lagrange functions and
                // the initial quadratic model.

            } else {
                zMatrix.setEntry(0, nfxm, recip);
                zMatrix.setEntry(nfm, nfxm, recip);
                zMatrix.setEntry(ipt, nfxm, -recip);
                zMatrix.setEntry(jpt, nfxm, -recip);

                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                throw new PathIsExploredException(); // XXX
            }
        } while (getEvaluations() < npt);
    } // prelim","private void prelim(double[] lowerBound,
                    double[] upperBound) {
    printMethod(); // XXX

    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();

    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;

    // Set XBASE to the initial vector of variables, and set the initial
    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }

    // Begin the initialization procedure. NF becomes one more than the number
    // of function values so far. The coordinates of the displacement of the
    // next initial interpolation point from XBASE are set in XPT(NF+1,.).

    int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    do {
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;

        if (nfm <= 2 * n) {
            if (nfm >= 1 &&
                nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    stepa = -stepa;
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                stepb = resolveStepBounds(stepb, nfxm);
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            swapPointsIfNecessary(ipt, jpt);
            interpolationPoints.setEntry(nfm, ipt - 1, interpolationPoints.getEntry(ipt, ipt - 1));
            interpolationPoints.setEntry(nfm, jpt - 1, interpolationPoints.getEntry(jpt, jpt - 1));
        }

        updateCurrentBest(lowerBound, upperBound, nfm);

        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
        final int numEval = getEvaluations();
        fAtInterpolationPoints.setEntry(nfm, f);

        updateTrustRegionCenter(numEval, fbeg, f, nfm);

        adjustQuadraticModel(numEval, stepa, nfx, nfxm, fbeg, f, stepb);

    } while (getEvaluations() < npt);
}

private double resolveStepBounds(double stepb, int nfxm) {
    if (lowerDifference.getEntry(nfxm) == ZERO) {
        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
    }
    if (upperDifference.getEntry(nfxm) == ZERO) {
        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
    }
    return stepb;
}

private void swapPointsIfNecessary(int ipt, int jpt) {
    if (ipt > jpt) {
        int temp = jpt;
        jpt = ipt - jpt;
        ipt = temp;
    }
}

private void updateCurrentBest(double[] lowerBound, double[] upperBound, int nfm) {
    for (int j = 0; j < currentBest.getDimension(); j++) {
        currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));
        if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
            currentBest.setEntry(j, lowerBound[j]);
        }
        if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
            currentBest.setEntry(j, upperBound[j]);
        }
    }
}

private void updateTrustRegionCenter(int numEval, double fbeg, double f, int nfm) {
    if (numEval == 1) {
        fbeg = f;
        trustRegionCenterInterpolationPointIndex = 0;
    } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
        trustRegionCenterInterpolationPointIndex = nfm;
    }
}

private void adjustQuadraticModel(int numEval, double stepa, int nfx, int nfxm, double fbeg, double f, double stepb) {
    if (numEval <= 2 * currentBest.getDimension() + 1) {
        if (numEval >= 2 && numEval <= currentBest.getDimension() + 1) {
            gradientAtTrustRegionCenter.setEntry(numEval - 1, (f - fbeg) / stepa);
            initializeBMatrix(numEval, numEval - 1, stepa);
        } else if (numEval >= currentBest.getDimension() + 2) {
            updateModelSecondDerivativesValues(fbeg, stepa, stepb, nfx, nfxm);
        }
    } else {
        setInitialQuadraticModelValues(stepb, nfxm);
    }
}

private void initializeBMatrix(int numEval, int nfxm, double stepa) {
    if (numberOfInterpolationPoints < numEval + currentBest.getDimension()) {
        final double oneOverStepA = ONE / stepa;
        bMatrix.setEntry(0, nfxm, -oneOverStepA);
        bMatrix.setEntry(numEval, nfxm, oneOverStepA);
        bMatrix.setEntry(numberOfInterpolationPoints + nfxm, nfxm, -HALF * (initialTrustRegionRadius * initialTrustRegionRadius));
    }
}

private void updateModelSecondDerivativesValues(double fbeg, double stepa, double stepb, int nfx, int nfxm) {
    final int ih = nfx * (nfx + 1) / 2 - 1;
    final double tmp = (computeObjectiveValue(currentBest.toArray()) - fbeg) / stepb;
    final double diff = stepb - stepa;
    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
    if (stepa * stepb < ZERO) {
        adjustInterpolationPointIfNecessary(nfxm, computeObjectiveValue(currentBest.toArray()));
    }
}

private void adjustInterpolationPointIfNecessary(int nfxm, double f) {
    if (f < fAtInterpolationPoints.getEntry(getEvaluations() - currentBest.getDimension())) {
        fAtInterpolationPoints.setEntry(getEvaluations(), fAtInterpolationPoints.getEntry(getEvaluations() - currentBest.getDimension()));
        fAtInterpolationPoints.setEntry(getEvaluations() - currentBest.getDimension(), f);
        if (trustRegionCenterInterpolationPointIndex == getEvaluations()) {
            trustRegionCenterInterpolationPointIndex = getEvaluations() - currentBest.getDimension();
        }
        interpolationPoints.setEntry(getEvaluations() - currentBest.getDimension(), nfxm, -initialTrustRegionRadius);
        interpolationPoints.setEntry(getEvaluations(), nfxm, initialTrustRegionRadius);
    }
}

private void setInitialQuadraticModelValues(double stepb, int nfxm) {
    zMatrix.setEntry(0, nfxm, ONE / (initialTrustRegionRadius * initialTrustRegionRadius));
    zMatrix.setEntry(getEvaluations(), nfxm, ONE / (initialTrustRegionRadius * initialTrustRegionRadius));
    zMatrix.setEntry(getEvaluations() - currentBest.getDimension(), nfxm, -ONE / (initialTrustRegionRadius * initialTrustRegionRadius));
    zMatrix.setEntry(getEvaluations() + currentBest.getDimension(), nfxm, -ONE / (initialTrustRegionRadius * initialTrustRegionRadius));

    final int ih = (getEvaluations() - currentBest.getDimension()) * (getEvaluations() - currentBest.getDimension() - 1) / 2 + getEvaluations() + currentBest.getDimension() - 1;
    final double tmp = interpolationPoints.getEntry(getEvaluations(), getEvaluations() - currentBest.getDimension()) * interpolationPoints.getEntry(getEvaluations(), getEvaluations() + currentBest.getDimension() - 1);
    modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(getEvaluations() - currentBest.getDimension()) - fAtInterpolationPoints.getEntry(getEvaluations() + currentBest.getDimension() - 1) + computeObjectiveValue(currentBest.toArray())) / tmp);
}",1,0
175,Math_38,"private void prelim(double[] lowerBound,
                        double[] upperBound) {
        printMethod(); // XXX

        final int n = currentBest.getDimension();
        final int npt = numberOfInterpolationPoints;
        final int ndim = bMatrix.getRowDimension();

        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
        final double recip = 1d / rhosq;
        final int np = n + 1;

        // Set XBASE to the initial vector of variables, and set the initial
        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

        for (int j = 0; j < n; j++) {
            originShift.setEntry(j, currentBest.getEntry(j));
            for (int k = 0; k < npt; k++) {
                interpolationPoints.setEntry(k, j, ZERO);
            }
            for (int i = 0; i < ndim; i++) {
                bMatrix.setEntry(i, j, ZERO);
            }
        }
        for (int i = 0, max = n * np / 2; i < max; i++) {
            modelSecondDerivativesValues.setEntry(i, ZERO);
        }
        for (int k = 0; k < npt; k++) {
            modelSecondDerivativesParameters.setEntry(k, ZERO);
            for (int j = 0, max = npt - np; j < max; j++) {
                zMatrix.setEntry(k, j, ZERO);
            }
        }

        // Begin the initialization procedure. NF becomes one more than the number
        // of function values so far. The coordinates of the displacement of the
        // next initial interpolation point from XBASE are set in XPT(NF+1,.).

        int ipt = 0;
        int jpt = 0;
        double fbeg = Double.NaN;
        do {
            final int nfm = getEvaluations();
            final int nfx = nfm - n;
            final int nfmm = nfm - 1;
            final int nfxm = nfx - 1;
            double stepa = 0;
            double stepb = 0;
            if (nfm <= 2 * n) {
                if (nfm >= 1 &&
                    nfm <= n) {
                    stepa = initialTrustRegionRadius;
                    if (upperDifference.getEntry(nfmm) == ZERO) {
                        stepa = -stepa;
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfmm, stepa);
                } else if (nfm > n) {
                    stepa = interpolationPoints.getEntry(nfx, nfxm);
                    stepb = -initialTrustRegionRadius;
                    if (lowerDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    if (upperDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfxm, stepb);
                }
            } else {
                final int tmp1 = (nfm - np) / n;
                jpt = nfm - tmp1 * n - n;
                ipt = jpt + tmp1;
                if (ipt > n) {
                    final int tmp2 = jpt;
                    jpt = ipt - n;
                    ipt = tmp2;
                    throw new PathIsExploredException(); // XXX
                }
                final int iptMinus1 = ipt;
                final int jptMinus1 = jpt;
                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
            }

            // Calculate the next value of F. The least function value so far and
            // its index are required.

            for (int j = 0; j < n; j++) {
                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                                                 upperBound[j]));
                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                    currentBest.setEntry(j, lowerBound[j]);
                }
                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                    currentBest.setEntry(j, upperBound[j]);
                }
            }

            final double objectiveValue = computeObjectiveValue(currentBest.toArray());
            final double f = isMinimize ? objectiveValue : -objectiveValue;
            final int numEval = getEvaluations(); // nfm + 1
            fAtInterpolationPoints.setEntry(nfm, f);

            if (numEval == 1) {
                fbeg = f;
                trustRegionCenterInterpolationPointIndex = 0;
            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
                trustRegionCenterInterpolationPointIndex = nfm;
            }

            // Set the nonzero initial elements of BMAT and the quadratic model in the
            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
            // of the NF-th and (NF-N)-th interpolation points may be switched, in
            // order that the function value at the first of them contributes to the
            // off-diagonal second derivative terms of the initial quadratic model.

            if (numEval <= 2 * n + 1) {
                if (numEval >= 2 &&
                    numEval <= n + 1) {
                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                    if (npt < numEval + n) {
                        final double oneOverStepA = ONE / stepa;
                        bMatrix.setEntry(0, nfmm, -oneOverStepA);
                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                        throw new PathIsExploredException(); // XXX
                    }
                } else if (numEval >= n + 2) {
                    final int ih = nfx * (nfx + 1) / 2 - 1;
                    final double tmp = (f - fbeg) / stepb;
                    final double diff = stepb - stepa;
                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                    if (stepa * stepb < ZERO) {
                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                            fAtInterpolationPoints.setEntry(nfm - n, f);
                            if (trustRegionCenterInterpolationPointIndex == nfm) {
                                trustRegionCenterInterpolationPointIndex = nfm - n;
                            }
                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                            interpolationPoints.setEntry(nfm, nfxm, stepa);
                        }
                    }
                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                    bMatrix.setEntry(nfm - n, nfxm,
                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                    zMatrix.setEntry(nfm - n, nfxm,
                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
                }

                // Set the off-diagonal second derivatives of the Lagrange functions and
                // the initial quadratic model.

            } else {
                zMatrix.setEntry(0, nfxm, recip);
                zMatrix.setEntry(nfm, nfxm, recip);
                zMatrix.setEntry(ipt, nfxm, -recip);
                zMatrix.setEntry(jpt, nfxm, -recip);

                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                throw new PathIsExploredException(); // XXX
            }
        } while (getEvaluations() < npt);
    } // prelim","private void prelim(double[] lowerBound, double[] upperBound) {
    printMethod(); // XXX

    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();

    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;

    // Set XBASE to the initial vector of variables, and set the initial
    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }

    // Begin the initialization procedure. NF becomes one more than the number
    // of function values so far. The coordinates of the displacement of the
    // next initial interpolation point from XBASE are set in XPT(NF+1,).

    int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    boolean pathExplored = false;

    do {
        pathExplored = false;
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;
        if (nfm <= 2 * n) {
            if (nfm >= 1 && nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    pathExplored = true;
                    stepa = -stepa;
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                if (lowerDifference.getEntry(nfxm) == ZERO) {
                    pathExplored = true;
                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                }
                if (upperDifference.getEntry(nfxm) == ZERO) {
                    pathExplored = true;
                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                }
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            if (ipt > n) {
                pathExplored = true;
                final int tmp2 = jpt;
                jpt = ipt - n;
                ipt = tmp2;
            }
            interpolationPoints.setEntry(nfm, ipt, interpolationPoints.getEntry(ipt, ipt));
            interpolationPoints.setEntry(nfm, jpt, interpolationPoints.getEntry(jpt, jpt));
        }

        // Calculate the next value of F. The least function value so far and
        // its index are required.

        for (int j = 0; j < n; j++) {
            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                    originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                    upperBound[j]));
            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                currentBest.setEntry(j, lowerBound[j]);
            }
            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                currentBest.setEntry(j, upperBound[j]);
            }
        }

        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
        final int numEval = getEvaluations(); // nfm + 1
        fAtInterpolationPoints.setEntry(nfm, f);

        if (numEval == 1) {
            fbeg = f;
            trustRegionCenterInterpolationPointIndex = 0;
        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
            trustRegionCenterInterpolationPointIndex = nfm;
        }

        // Set the nonzero initial elements of BMAT and the quadratic model in the
        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
        // of the NF-th and (NF-N)-th interpolation points may be switched, in
        // order that the function value at the first of them contributes to the
        // off-diagonal second derivative terms of the initial quadratic model.

        if (numEval <= 2 * n + 1) {
            if (numEval >= 2 && numEval <= n + 1) {
                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                if (npt < numEval + n) {
                    final double oneOverStepA = ONE / stepa;
                    bMatrix.setEntry(0, nfmm, -oneOverStepA);
                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                    pathExplored = true;
                }
            } else if (numEval >= n + 2) {
                final int ih = nfx * (nfx + 1) / 2 - 1;
                final double tmp = (f - fbeg) / stepb;
                final double diff = stepb - stepa;
                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                if (stepa * stepb < ZERO) {
                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                        fAtInterpolationPoints.setEntry(nfm - n, f);
                        if (trustRegionCenterInterpolationPointIndex == nfm) {
                            trustRegionCenterInterpolationPointIndex = nfm - n;
                        }
                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                        interpolationPoints.setEntry(nfm, nfxm, stepa);
                    }
                }
                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                bMatrix.setEntry(nfm - n, nfxm,
                        -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                zMatrix.setEntry(nfm - n, nfxm,
                        -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
            }

            // Set the off-diagonal second derivatives of the Lagrange functions and
            // the initial quadratic model.

        } else {
            zMatrix.setEntry(0, nfxm, recip);
            zMatrix.setEntry(nfm, nfxm, recip);
            zMatrix.setEntry(ipt, nfxm, -recip);
            zMatrix.setEntry(jpt, nfxm, -recip);

            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
            pathExplored = true;
        }

    } while (pathExplored && getEvaluations() < npt);
}",2,0
175,Math_38,"private void prelim(double[] lowerBound,
                        double[] upperBound) {
        printMethod(); // XXX

        final int n = currentBest.getDimension();
        final int npt = numberOfInterpolationPoints;
        final int ndim = bMatrix.getRowDimension();

        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
        final double recip = 1d / rhosq;
        final int np = n + 1;

        // Set XBASE to the initial vector of variables, and set the initial
        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

        for (int j = 0; j < n; j++) {
            originShift.setEntry(j, currentBest.getEntry(j));
            for (int k = 0; k < npt; k++) {
                interpolationPoints.setEntry(k, j, ZERO);
            }
            for (int i = 0; i < ndim; i++) {
                bMatrix.setEntry(i, j, ZERO);
            }
        }
        for (int i = 0, max = n * np / 2; i < max; i++) {
            modelSecondDerivativesValues.setEntry(i, ZERO);
        }
        for (int k = 0; k < npt; k++) {
            modelSecondDerivativesParameters.setEntry(k, ZERO);
            for (int j = 0, max = npt - np; j < max; j++) {
                zMatrix.setEntry(k, j, ZERO);
            }
        }

        // Begin the initialization procedure. NF becomes one more than the number
        // of function values so far. The coordinates of the displacement of the
        // next initial interpolation point from XBASE are set in XPT(NF+1,.).

        int ipt = 0;
        int jpt = 0;
        double fbeg = Double.NaN;
        do {
            final int nfm = getEvaluations();
            final int nfx = nfm - n;
            final int nfmm = nfm - 1;
            final int nfxm = nfx - 1;
            double stepa = 0;
            double stepb = 0;
            if (nfm <= 2 * n) {
                if (nfm >= 1 &&
                    nfm <= n) {
                    stepa = initialTrustRegionRadius;
                    if (upperDifference.getEntry(nfmm) == ZERO) {
                        stepa = -stepa;
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfmm, stepa);
                } else if (nfm > n) {
                    stepa = interpolationPoints.getEntry(nfx, nfxm);
                    stepb = -initialTrustRegionRadius;
                    if (lowerDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    if (upperDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfxm, stepb);
                }
            } else {
                final int tmp1 = (nfm - np) / n;
                jpt = nfm - tmp1 * n - n;
                ipt = jpt + tmp1;
                if (ipt > n) {
                    final int tmp2 = jpt;
                    jpt = ipt - n;
                    ipt = tmp2;
                    throw new PathIsExploredException(); // XXX
                }
                final int iptMinus1 = ipt;
                final int jptMinus1 = jpt;
                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
            }

            // Calculate the next value of F. The least function value so far and
            // its index are required.

            for (int j = 0; j < n; j++) {
                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                                                 upperBound[j]));
                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                    currentBest.setEntry(j, lowerBound[j]);
                }
                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                    currentBest.setEntry(j, upperBound[j]);
                }
            }

            final double objectiveValue = computeObjectiveValue(currentBest.toArray());
            final double f = isMinimize ? objectiveValue : -objectiveValue;
            final int numEval = getEvaluations(); // nfm + 1
            fAtInterpolationPoints.setEntry(nfm, f);

            if (numEval == 1) {
                fbeg = f;
                trustRegionCenterInterpolationPointIndex = 0;
            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
                trustRegionCenterInterpolationPointIndex = nfm;
            }

            // Set the nonzero initial elements of BMAT and the quadratic model in the
            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
            // of the NF-th and (NF-N)-th interpolation points may be switched, in
            // order that the function value at the first of them contributes to the
            // off-diagonal second derivative terms of the initial quadratic model.

            if (numEval <= 2 * n + 1) {
                if (numEval >= 2 &&
                    numEval <= n + 1) {
                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                    if (npt < numEval + n) {
                        final double oneOverStepA = ONE / stepa;
                        bMatrix.setEntry(0, nfmm, -oneOverStepA);
                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                        throw new PathIsExploredException(); // XXX
                    }
                } else if (numEval >= n + 2) {
                    final int ih = nfx * (nfx + 1) / 2 - 1;
                    final double tmp = (f - fbeg) / stepb;
                    final double diff = stepb - stepa;
                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                    if (stepa * stepb < ZERO) {
                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                            fAtInterpolationPoints.setEntry(nfm - n, f);
                            if (trustRegionCenterInterpolationPointIndex == nfm) {
                                trustRegionCenterInterpolationPointIndex = nfm - n;
                            }
                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                            interpolationPoints.setEntry(nfm, nfxm, stepa);
                        }
                    }
                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                    bMatrix.setEntry(nfm - n, nfxm,
                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                    zMatrix.setEntry(nfm - n, nfxm,
                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
                }

                // Set the off-diagonal second derivatives of the Lagrange functions and
                // the initial quadratic model.

            } else {
                zMatrix.setEntry(0, nfxm, recip);
                zMatrix.setEntry(nfm, nfxm, recip);
                zMatrix.setEntry(ipt, nfxm, -recip);
                zMatrix.setEntry(jpt, nfxm, -recip);

                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                throw new PathIsExploredException(); // XXX
            }
        } while (getEvaluations() < npt);
    } // prelim","private void prelim(double[] lowerBound, double[] upperBound) {
    printMethod(); // XXX

    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();

    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;

    // Set XBASE to the initial vector of variables, and set the initial
    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }

    // Begin the initialization procedure. NF becomes one more than the number
    // of function values so far. The coordinates of the displacement of the
    // next initial interpolation point from XBASE are set in XPT(NF+1,.).

    int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    while (true) {
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;
        if (nfm <= 2 * n) {
            if (nfm >= 1 && nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    stepa = -stepa;
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                if (lowerDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                }
                if (upperDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                }
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            if (ipt > n) {
                final int tmp2 = jpt;
                jpt = ipt - n;
                ipt = tmp2;
            }
            final int iptMinus1 = ipt;
            final int jptMinus1 = jpt;
            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
        }

        // Calculate the next value of F. The least function value so far and
        // its index are required.

        for (int j = 0; j < n; j++) {
            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                    originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                    upperBound[j]));
            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                currentBest.setEntry(j, lowerBound[j]);
            }
            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                currentBest.setEntry(j, upperBound[j]);
            }
        }

        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
        final int numEval = getEvaluations(); // nfm + 1
        fAtInterpolationPoints.setEntry(nfm, f);

        if (numEval == 1) {
            fbeg = f;
            trustRegionCenterInterpolationPointIndex = 0;
        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
            trustRegionCenterInterpolationPointIndex = nfm;
        }

        // Set the nonzero initial elements of BMAT and the quadratic model in the
        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
        // of the NF-th and (NF-N)-th interpolation points may be switched, in
        // order that the function value at the first of them contributes to the
        // off-diagonal second derivative terms of the initial quadratic model.

        if (numEval <= 2 * n + 1) {
            if (numEval >= 2 && numEval <= n + 1) {
                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                if (npt < numEval + n) {
                    final double oneOverStepA = ONE / stepa;
                    bMatrix.setEntry(0, nfmm, -oneOverStepA);
                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                }
            } else if (numEval >= n + 2) {
                final int ih = nfx * (nfx + 1) / 2 - 1;
                final double tmp = (f - fbeg) / stepb;
                final double diff = stepb - stepa;
                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                if (stepa * stepb < ZERO) {
                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                        fAtInterpolationPoints.setEntry(nfm - n, f);
                        if (trustRegionCenterInterpolationPointIndex == nfm) {
                            trustRegionCenterInterpolationPointIndex = nfm - n;
                        }
                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                        interpolationPoints.setEntry(nfm, nfxm, stepa);
                    }
                }
                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                bMatrix.setEntry(nfm - n, nfxm,
                        -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                zMatrix.setEntry(nfm - n, nfxm,
                        -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
            }
        } else {
            zMatrix.setEntry(0, nfxm, recip);
            zMatrix.setEntry(nfm, nfxm, recip);
            zMatrix.setEntry(ipt, nfxm, -recip);
            zMatrix.setEntry(jpt, nfxm, -recip);

            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
        }

        if (getEvaluations() >= npt) {
            break;
        }
    }
}",3,0
175,Math_38,"private void prelim(double[] lowerBound,
                        double[] upperBound) {
        printMethod(); // XXX

        final int n = currentBest.getDimension();
        final int npt = numberOfInterpolationPoints;
        final int ndim = bMatrix.getRowDimension();

        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
        final double recip = 1d / rhosq;
        final int np = n + 1;

        // Set XBASE to the initial vector of variables, and set the initial
        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

        for (int j = 0; j < n; j++) {
            originShift.setEntry(j, currentBest.getEntry(j));
            for (int k = 0; k < npt; k++) {
                interpolationPoints.setEntry(k, j, ZERO);
            }
            for (int i = 0; i < ndim; i++) {
                bMatrix.setEntry(i, j, ZERO);
            }
        }
        for (int i = 0, max = n * np / 2; i < max; i++) {
            modelSecondDerivativesValues.setEntry(i, ZERO);
        }
        for (int k = 0; k < npt; k++) {
            modelSecondDerivativesParameters.setEntry(k, ZERO);
            for (int j = 0, max = npt - np; j < max; j++) {
                zMatrix.setEntry(k, j, ZERO);
            }
        }

        // Begin the initialization procedure. NF becomes one more than the number
        // of function values so far. The coordinates of the displacement of the
        // next initial interpolation point from XBASE are set in XPT(NF+1,.).

        int ipt = 0;
        int jpt = 0;
        double fbeg = Double.NaN;
        do {
            final int nfm = getEvaluations();
            final int nfx = nfm - n;
            final int nfmm = nfm - 1;
            final int nfxm = nfx - 1;
            double stepa = 0;
            double stepb = 0;
            if (nfm <= 2 * n) {
                if (nfm >= 1 &&
                    nfm <= n) {
                    stepa = initialTrustRegionRadius;
                    if (upperDifference.getEntry(nfmm) == ZERO) {
                        stepa = -stepa;
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfmm, stepa);
                } else if (nfm > n) {
                    stepa = interpolationPoints.getEntry(nfx, nfxm);
                    stepb = -initialTrustRegionRadius;
                    if (lowerDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    if (upperDifference.getEntry(nfxm) == ZERO) {
                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                        throw new PathIsExploredException(); // XXX
                    }
                    interpolationPoints.setEntry(nfm, nfxm, stepb);
                }
            } else {
                final int tmp1 = (nfm - np) / n;
                jpt = nfm - tmp1 * n - n;
                ipt = jpt + tmp1;
                if (ipt > n) {
                    final int tmp2 = jpt;
                    jpt = ipt - n;
                    ipt = tmp2;
                    throw new PathIsExploredException(); // XXX
                }
                final int iptMinus1 = ipt;
                final int jptMinus1 = jpt;
                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
            }

            // Calculate the next value of F. The least function value so far and
            // its index are required.

            for (int j = 0; j < n; j++) {
                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                                                 upperBound[j]));
                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                    currentBest.setEntry(j, lowerBound[j]);
                }
                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                    currentBest.setEntry(j, upperBound[j]);
                }
            }

            final double objectiveValue = computeObjectiveValue(currentBest.toArray());
            final double f = isMinimize ? objectiveValue : -objectiveValue;
            final int numEval = getEvaluations(); // nfm + 1
            fAtInterpolationPoints.setEntry(nfm, f);

            if (numEval == 1) {
                fbeg = f;
                trustRegionCenterInterpolationPointIndex = 0;
            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
                trustRegionCenterInterpolationPointIndex = nfm;
            }

            // Set the nonzero initial elements of BMAT and the quadratic model in the
            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
            // of the NF-th and (NF-N)-th interpolation points may be switched, in
            // order that the function value at the first of them contributes to the
            // off-diagonal second derivative terms of the initial quadratic model.

            if (numEval <= 2 * n + 1) {
                if (numEval >= 2 &&
                    numEval <= n + 1) {
                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                    if (npt < numEval + n) {
                        final double oneOverStepA = ONE / stepa;
                        bMatrix.setEntry(0, nfmm, -oneOverStepA);
                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                        throw new PathIsExploredException(); // XXX
                    }
                } else if (numEval >= n + 2) {
                    final int ih = nfx * (nfx + 1) / 2 - 1;
                    final double tmp = (f - fbeg) / stepb;
                    final double diff = stepb - stepa;
                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                    if (stepa * stepb < ZERO) {
                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                            fAtInterpolationPoints.setEntry(nfm - n, f);
                            if (trustRegionCenterInterpolationPointIndex == nfm) {
                                trustRegionCenterInterpolationPointIndex = nfm - n;
                            }
                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                            interpolationPoints.setEntry(nfm, nfxm, stepa);
                        }
                    }
                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                    bMatrix.setEntry(nfm - n, nfxm,
                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                    zMatrix.setEntry(nfm - n, nfxm,
                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
                }

                // Set the off-diagonal second derivatives of the Lagrange functions and
                // the initial quadratic model.

            } else {
                zMatrix.setEntry(0, nfxm, recip);
                zMatrix.setEntry(nfm, nfxm, recip);
                zMatrix.setEntry(ipt, nfxm, -recip);
                zMatrix.setEntry(jpt, nfxm, -recip);

                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                throw new PathIsExploredException(); // XXX
            }
        } while (getEvaluations() < npt);
    } // prelim","private void prelim(double[] lowerBound, double[] upperBound) {
    printMethod(); // XXX

    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();

    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;

    // Set XBASE to the initial vector of variables, and set the initial
    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }

    // Begin the initialization procedure. NF becomes one more than the number
    // of function values so far. The coordinates of the displacement of the
    // next initial interpolation point from XBASE are set in XPT(NF+1,.).

    int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    for (int iter = 0; iter < npt; iter++) {
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;
        if (nfm <= 2 * n) {
            if (nfm >= 1 && nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    stepa = -stepa;
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                if (lowerDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                }
                if (upperDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                }
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            if (ipt > n) {
                final int tmp2 = jpt;
                jpt = ipt - n;
                ipt = tmp2;
            }
            final int iptMinus1 = ipt;
            final int jptMinus1 = jpt;
            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
        }

        // Calculate the next value of F. The least function value so far and
        // its index are required.

        for (int j = 0; j < n; j++) {
            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
                    originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
                    upperBound[j]));
            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                currentBest.setEntry(j, lowerBound[j]);
            }
            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                currentBest.setEntry(j, upperBound[j]);
            }
        }

        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
        final int numEval = getEvaluations(); // nfm + 1
        fAtInterpolationPoints.setEntry(nfm, f);

        if (numEval == 1) {
            fbeg = f;
            trustRegionCenterInterpolationPointIndex = 0;
        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
            trustRegionCenterInterpolationPointIndex = nfm;
        }

        // Set the nonzero initial elements of BMAT and the quadratic model in the
        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
        // of the NF-th and (NF-N)-th interpolation points may be switched, in
        // order that the function value at the first of them contributes to the
        // off-diagonal second derivative terms of the initial quadratic model.

        if (numEval <= 2 * n + 1) {
            if (numEval >= 2 && numEval <= n + 1) {
                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                if (npt < numEval + n) {
                    final double oneOverStepA = ONE / stepa;
                    bMatrix.setEntry(0, nfmm, -oneOverStepA);
                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                }
            } else if (numEval >= n + 2) {
                final int ih = nfx * (nfx + 1) / 2 - 1;
                final double tmp = (f - fbeg) / stepb;
                final double diff = stepb - stepa;
                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                if (stepa * stepb < ZERO) {
                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                        fAtInterpolationPoints.setEntry(nfm - n, f);
                        if (trustRegionCenterInterpolationPointIndex == nfm) {
                            trustRegionCenterInterpolationPointIndex = nfm - n;
                        }
                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                        interpolationPoints.setEntry(nfm, nfxm, stepa);
                    }
                }
                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                bMatrix.setEntry(nfm - n, nfxm,
                        -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                zMatrix.setEntry(nfm - n, nfxm,
                        -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
            }
        } else {
            zMatrix.setEntry(0, nfxm, recip);
            zMatrix.setEntry(nfm, nfxm, recip);
            zMatrix.setEntry(ipt, nfxm, -recip);
            zMatrix.setEntry(jpt, nfxm, -recip);

            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
        }
    }
}",4,0
176,Math_39,"@Override
  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0  = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp    = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
                              equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart         = equations.getTime();
    double  hNew      = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

      interpolator.shift();

      // iterate over step size, ensuring local normalized error is smaller than 1
      double error = 10;
      while (error >= 1.0) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[mainSetDimension];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
              }
          } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
              }
          }
          hNew = initializeStep(forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
         }
 
         stepSize = hNew;
 
         // next stages
         for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error >= 1.0) {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              FastMath.min(maxGrowth,
                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // local error is small enough: accept the step, trigger events and step handlers
      interpolator.storeTime(stepStart + stepSize);
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
      stepStart = acceptStep(interpolator, y, yDotTmp, t);
      System.arraycopy(y, 0, yTmp, 0, y.length);

      if (!isLastStep) {

          // prepare next step
          interpolator.storeTime(stepStart);

          if (fsal) {
              // save the last evaluation for the next step
              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
          }

          // stepsize control for next step
          final double factor =
              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          final double  scaledH    = stepSize * factor;
          final double  nextT      = stepStart + scaledH;
          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
          hNew = filterStep(scaledH, forward, nextIsLast);

          final double  filteredNextT      = stepStart + hNew;
          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
          if (filteredNextIsLast) {
              hNew = t - stepStart;
          }

      }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

  }","@Override
public void integrate(final ExpandableStatefulODE equations, final double t)
        throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

        interpolator.shift();

        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {

            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }

            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }

            stepSize = hNew;

            // next stages
            for (int k = 1; k < stages; ++k) {

                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }

                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }

            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }

        }

        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);

        if (!isLastStep) {

            // prepare next step
            interpolator.storeTime(stepStart);

            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }

            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);

            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }

        }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

}",0,0
176,Math_39,"@Override
  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0  = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp    = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
                              equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart         = equations.getTime();
    double  hNew      = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

      interpolator.shift();

      // iterate over step size, ensuring local normalized error is smaller than 1
      double error = 10;
      while (error >= 1.0) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[mainSetDimension];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
              }
          } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
              }
          }
          hNew = initializeStep(forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
         }
 
         stepSize = hNew;
 
         // next stages
         for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error >= 1.0) {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              FastMath.min(maxGrowth,
                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // local error is small enough: accept the step, trigger events and step handlers
      interpolator.storeTime(stepStart + stepSize);
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
      stepStart = acceptStep(interpolator, y, yDotTmp, t);
      System.arraycopy(y, 0, yTmp, 0, y.length);

      if (!isLastStep) {

          // prepare next step
          interpolator.storeTime(stepStart);

          if (fsal) {
              // save the last evaluation for the next step
              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
          }

          // stepsize control for next step
          final double factor =
              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          final double  scaledH    = stepSize * factor;
          final double  nextT      = stepStart + scaledH;
          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
          hNew = filterStep(scaledH, forward, nextIsLast);

          final double  filteredNextT      = stepStart + hNew;
          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
          if (filteredNextIsLast) {
              hNew = t - stepStart;
          }

      }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

  }","@Override
public void integrate(final ExpandableStatefulODE equations, final double t)
        throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];

    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    stepStart = equations.getTime();
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    isLastStep = false;
    do {
        interpolator.shift();
        double error;
        do {
            if (firstTime || !fsal) {
                computeDerivatives(stepStart, y, yDotK[0]);
            }

            if (firstTime) {
                double hNew = initializeStep(forward, getOrder(), computeScale(y), stepStart, y, yDotK[0], yTmp, yDotK[1]);
                stepSize = hNew;
                firstTime = false;
            } else {
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                stepSize *= factor;
            }

            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }

            for (int j = 0; j < y.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            error = estimateError(yDotK, y, yTmp, stepSize);
        } while (error >= 1.0);

        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);

        if (!isLastStep) {
            interpolator.storeTime(stepStart);
            if (fsal) {
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y.length);
            }
        }
    } while (!isLastStep);

    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}

private double[] computeScale(double[] y) {
    final double[] scale = new double[mainSetDimension];
    if (vecAbsoluteTolerance == null) {
        for (int i = 0; i < scale.length; ++i) {
            scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
        }
    } else {
        for (int i = 0; i < scale.length; ++i) {
            scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
        }
    }
    return scale;
}",1,0
176,Math_39,"@Override
  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0  = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp    = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
                              equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart         = equations.getTime();
    double  hNew      = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

      interpolator.shift();

      // iterate over step size, ensuring local normalized error is smaller than 1
      double error = 10;
      while (error >= 1.0) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[mainSetDimension];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
              }
          } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
              }
          }
          hNew = initializeStep(forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
         }
 
         stepSize = hNew;
 
         // next stages
         for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error >= 1.0) {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              FastMath.min(maxGrowth,
                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // local error is small enough: accept the step, trigger events and step handlers
      interpolator.storeTime(stepStart + stepSize);
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
      stepStart = acceptStep(interpolator, y, yDotTmp, t);
      System.arraycopy(y, 0, yTmp, 0, y.length);

      if (!isLastStep) {

          // prepare next step
          interpolator.storeTime(stepStart);

          if (fsal) {
              // save the last evaluation for the next step
              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
          }

          // stepsize control for next step
          final double factor =
              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          final double  scaledH    = stepSize * factor;
          final double  nextT      = stepStart + scaledH;
          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
          hNew = filterStep(scaledH, forward, nextIsLast);

          final double  filteredNextT      = stepStart + hNew;
          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
          if (filteredNextIsLast) {
              hNew = t - stepStart;
          }

      }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

  }",Match failed,2,0
176,Math_39,"@Override
  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0  = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp    = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
                              equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart         = equations.getTime();
    double  hNew      = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

      interpolator.shift();

      // iterate over step size, ensuring local normalized error is smaller than 1
      double error = 10;
      while (error >= 1.0) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[mainSetDimension];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
              }
          } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
              }
          }
          hNew = initializeStep(forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
         }
 
         stepSize = hNew;
 
         // next stages
         for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error >= 1.0) {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              FastMath.min(maxGrowth,
                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // local error is small enough: accept the step, trigger events and step handlers
      interpolator.storeTime(stepStart + stepSize);
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
      stepStart = acceptStep(interpolator, y, yDotTmp, t);
      System.arraycopy(y, 0, yTmp, 0, y.length);

      if (!isLastStep) {

          // prepare next step
          interpolator.storeTime(stepStart);

          if (fsal) {
              // save the last evaluation for the next step
              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
          }

          // stepsize control for next step
          final double factor =
              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          final double  scaledH    = stepSize * factor;
          final double  nextT      = stepStart + scaledH;
          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
          hNew = filterStep(scaledH, forward, nextIsLast);

          final double  filteredNextT      = stepStart + hNew;
          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
          if (filteredNextIsLast) {
              hNew = t - stepStart;
          }

      }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

  }","@Override
public void integrate(final ExpandableStatefulODE equations, final double t)
        throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    boolean rejectedStep = false;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

        interpolator.shift();

        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {

            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
                if (rejectedStep) {
                    hNew *= 0.5; // attempt to fix by reducing step size of previously rejected step
                }
            }

            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }

            stepSize = hNew;

            // next stages
            for (int k = 1; k < stages; ++k) {

                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }

                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);

            }

            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                rejectedStep = true;
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            } else {
                rejectedStep = false;
            }

        }

        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);

        if (!isLastStep) {

            // prepare next step
            interpolator.storeTime(stepStart);

            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }

            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);

            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }

        }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

}",3,0
176,Math_39,"@Override
  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0  = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp    = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
                              equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart         = equations.getTime();
    double  hNew      = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {

      interpolator.shift();

      // iterate over step size, ensuring local normalized error is smaller than 1
      double error = 10;
      while (error >= 1.0) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[mainSetDimension];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
              }
          } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
              }
          }
          hNew = initializeStep(forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
         }
 
         stepSize = hNew;
 
         // next stages
         for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error >= 1.0) {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              FastMath.min(maxGrowth,
                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // local error is small enough: accept the step, trigger events and step handlers
      interpolator.storeTime(stepStart + stepSize);
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
      stepStart = acceptStep(interpolator, y, yDotTmp, t);
      System.arraycopy(y, 0, yTmp, 0, y.length);

      if (!isLastStep) {

          // prepare next step
          interpolator.storeTime(stepStart);

          if (fsal) {
              // save the last evaluation for the next step
              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
          }

          // stepsize control for next step
          final double factor =
              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          final double  scaledH    = stepSize * factor;
          final double  nextT      = stepStart + scaledH;
          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
          hNew = filterStep(scaledH, forward, nextIsLast);

          final double  filteredNextT      = stepStart + hNew;
          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
          if (filteredNextIsLast) {
              hNew = t - stepStart;
          }

      }

    } while (!isLastStep);

    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);

    resetInternalState();

  }","@Override
public void integrate(final ExpandableStatefulODE equations, final double t)
        throws MathIllegalStateException, MathIllegalArgumentException {

    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();

    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];

    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());

    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);

    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        double error = 10;
        do {
            if (firstTime || !fsal) {
                computeDerivatives(stepStart, y, yDotK[0]);
            }

            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            } else {
                final double safetyFactor = 0.9; // Added safety factor
                final double factor = safetyFactor * FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
                stepSize = hNew;
            }

            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }

            for (int j = 0; j < y.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            error = estimateError(yDotK, y, yTmp, stepSize);
        } while (error >= 1.0);

        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);

        if (!isLastStep) {
            interpolator.storeTime(stepStart);
            if (fsal) {
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y.length);
            }
        }
    } while (!isLastStep);

    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}",4,0
177,Math_40,"@Override
    protected double doSolve() {

        // prepare arrays with the first points
        final double[] x = new double[maximalOrder + 1];
        final double[] y = new double[maximalOrder + 1];
        x[0] = getMin();
        x[1] = getStartValue();
        x[2] = getMax();
        verifySequence(x[0], x[1], x[2]);

        // evaluate initial guess
        y[1] = computeObjectiveValue(x[1]);
        if (Precision.equals(y[1], 0.0, 1)) {
            // return the initial guess if it is a perfect root.
            return x[1];
        }

        // evaluate first  endpoint
        y[0] = computeObjectiveValue(x[0]);
        if (Precision.equals(y[0], 0.0, 1)) {
            // return the first endpoint if it is a perfect root.
            return x[0];
        }

        int nbPoints;
        int signChangeIndex;
        if (y[0] * y[1] < 0) {

            // reduce interval if it brackets the root
            nbPoints        = 2;
            signChangeIndex = 1;

        } else {

            // evaluate second endpoint
            y[2] = computeObjectiveValue(x[2]);
            if (Precision.equals(y[2], 0.0, 1)) {
                // return the second endpoint if it is a perfect root.
                return x[2];
            }

            if (y[1] * y[2] < 0) {
                // use all computed point as a start sampling array for solving
                nbPoints        = 3;
                signChangeIndex = 2;
            } else {
                throw new NoBracketingException(x[0], x[2], y[0], y[2]);
            }

        }

        // prepare a work array for inverse polynomial interpolation
        final double[] tmpX = new double[x.length];

        // current tightest bracketing of the root
        double xA    = x[signChangeIndex - 1];
        double yA    = y[signChangeIndex - 1];
        double absYA = FastMath.abs(yA);
        int agingA   = 0;
        double xB    = x[signChangeIndex];
        double yB    = y[signChangeIndex];
        double absYB = FastMath.abs(yB);
        int agingB   = 0;

        // search loop
        while (true) {

            // check convergence of bracketing interval
            final double xTol = getAbsoluteAccuracy() +
                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
                switch (allowed) {
                case ANY_SIDE :
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE :
                    return xA;
                case RIGHT_SIDE :
                    return xB;
                case BELOW_SIDE :
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE :
                    return (yA <  0) ? xB : xA;
                default :
                    // this should never happen
                    throw new MathInternalError(null);
                }
            }

            // target for the next evaluation point
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
            }

            // make a few attempts to guess a root,
            double nextX;
            int start = 0;
            int end   = nbPoints;
            do {

                // guess a value for current target, using inverse polynomial interpolation
                System.arraycopy(x, start, tmpX, start, end - start);
                nextX = guessX(targetY, tmpX, y, start, end);

                if (!((nextX > xA) && (nextX < xB))) {
                    // the guessed root is not strictly inside of the tightest bracketing interval

                    // the guessed root is either not strictly inside the interval or it
                    // is a NaN (which occurs when some sampling points share the same y)
                    // we try again with a lower interpolation order
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        // we have more points before the sign change, drop the lowest point
                        ++start;
                    } else {
                        // we have more points after sign change, drop the highest point
                        --end;
                    }

                    // we need to do one more attempt
                    nextX = Double.NaN;

                }

            } while (Double.isNaN(nextX) && (end - start > 1));

            if (Double.isNaN(nextX)) {
                // fall back to bisection
                nextX = xA + 0.5 * (xB - xA);
                start = signChangeIndex - 1;
                end   = signChangeIndex;
            }

            // evaluate the function at the guessed root
            final double nextY = computeObjectiveValue(nextX);
            if (Precision.equals(nextY, 0.0, 1)) {
                // we have found an exact root, since it is not an approximation
                // we don't need to bother about the allowed solutions setting
                return nextX;
            }

            if ((nbPoints > 2) && (end - start != nbPoints)) {

                // we have been forced to ignore some points to keep bracketing,
                // they are probably too far from the root, drop them from now on
                nbPoints = end - start;
                System.arraycopy(x, start, x, 0, nbPoints);
                System.arraycopy(y, start, y, 0, nbPoints);
                signChangeIndex -= start;

            } else  if (nbPoints == x.length) {

                // we have to drop one point in order to insert the new one
                nbPoints--;

                // keep the tightest bracketing interval as centered as possible
                if (signChangeIndex >= (x.length + 1) / 2) {
                    // we drop the lowest point, we have to shift the arrays and the index
                    System.arraycopy(x, 1, x, 0, nbPoints);
                    System.arraycopy(y, 1, y, 0, nbPoints);
                    --signChangeIndex;
                }

            }

            // insert the last computed point
            //(by construction, we know it lies inside the tightest bracketing interval)
            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
            x[signChangeIndex] = nextX;
            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
            y[signChangeIndex] = nextY;
            ++nbPoints;

            // update the bracketing interval
            if (nextY * yA <= 0) {
                // the sign change occurs before the inserted point
                xB = nextX;
                yB = nextY;
                absYB = FastMath.abs(yB);
                ++agingA;
                agingB = 0;
            } else {
                // the sign change occurs after the inserted point
                xA = nextX;
                yA = nextY;
                absYA = FastMath.abs(yA);
                agingA = 0;
                ++agingB;

                // update the sign change index
                signChangeIndex++;

            }

        }

    }","@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);

    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        return x[1];
    }

    // evaluate first endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        return x[0];
    }

    int nbPoints;
    int signChangeIndex;
    
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            return x[2];
        }

        if (y[1] * y[2] < 0) {
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }

    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];

    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;

    // search loop
    while (true) {
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if ((xB - xA <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch (allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    throw new MathInternalError(null);
            }
        }

        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            targetY = 0;
        }

        double nextX = Double.NaN;
        int start = 0;
        int end = nbPoints;
        while (Double.isNaN(nextX)) {
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                if (nextX <= tmpX[start] || nextX >= tmpX[end - 1]) {
                    nextX = Double.NaN;
                } else {
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        ++start;
                    } else {
                        --end;
                    }
                }
                nextX = Double.NaN; 
            } 
            }
            if (Double.isNaN(nextX)) {
                nextX = xA + 0.5 * (xB - xA);
          start =signChangeIndex;
end++;
            }
final double nextY=computeObjectiveValue();}",0,0
177,Math_40,"@Override
    protected double doSolve() {

        // prepare arrays with the first points
        final double[] x = new double[maximalOrder + 1];
        final double[] y = new double[maximalOrder + 1];
        x[0] = getMin();
        x[1] = getStartValue();
        x[2] = getMax();
        verifySequence(x[0], x[1], x[2]);

        // evaluate initial guess
        y[1] = computeObjectiveValue(x[1]);
        if (Precision.equals(y[1], 0.0, 1)) {
            // return the initial guess if it is a perfect root.
            return x[1];
        }

        // evaluate first  endpoint
        y[0] = computeObjectiveValue(x[0]);
        if (Precision.equals(y[0], 0.0, 1)) {
            // return the first endpoint if it is a perfect root.
            return x[0];
        }

        int nbPoints;
        int signChangeIndex;
        if (y[0] * y[1] < 0) {

            // reduce interval if it brackets the root
            nbPoints        = 2;
            signChangeIndex = 1;

        } else {

            // evaluate second endpoint
            y[2] = computeObjectiveValue(x[2]);
            if (Precision.equals(y[2], 0.0, 1)) {
                // return the second endpoint if it is a perfect root.
                return x[2];
            }

            if (y[1] * y[2] < 0) {
                // use all computed point as a start sampling array for solving
                nbPoints        = 3;
                signChangeIndex = 2;
            } else {
                throw new NoBracketingException(x[0], x[2], y[0], y[2]);
            }

        }

        // prepare a work array for inverse polynomial interpolation
        final double[] tmpX = new double[x.length];

        // current tightest bracketing of the root
        double xA    = x[signChangeIndex - 1];
        double yA    = y[signChangeIndex - 1];
        double absYA = FastMath.abs(yA);
        int agingA   = 0;
        double xB    = x[signChangeIndex];
        double yB    = y[signChangeIndex];
        double absYB = FastMath.abs(yB);
        int agingB   = 0;

        // search loop
        while (true) {

            // check convergence of bracketing interval
            final double xTol = getAbsoluteAccuracy() +
                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
                switch (allowed) {
                case ANY_SIDE :
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE :
                    return xA;
                case RIGHT_SIDE :
                    return xB;
                case BELOW_SIDE :
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE :
                    return (yA <  0) ? xB : xA;
                default :
                    // this should never happen
                    throw new MathInternalError(null);
                }
            }

            // target for the next evaluation point
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
            }

            // make a few attempts to guess a root,
            double nextX;
            int start = 0;
            int end   = nbPoints;
            do {

                // guess a value for current target, using inverse polynomial interpolation
                System.arraycopy(x, start, tmpX, start, end - start);
                nextX = guessX(targetY, tmpX, y, start, end);

                if (!((nextX > xA) && (nextX < xB))) {
                    // the guessed root is not strictly inside of the tightest bracketing interval

                    // the guessed root is either not strictly inside the interval or it
                    // is a NaN (which occurs when some sampling points share the same y)
                    // we try again with a lower interpolation order
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        // we have more points before the sign change, drop the lowest point
                        ++start;
                    } else {
                        // we have more points after sign change, drop the highest point
                        --end;
                    }

                    // we need to do one more attempt
                    nextX = Double.NaN;

                }

            } while (Double.isNaN(nextX) && (end - start > 1));

            if (Double.isNaN(nextX)) {
                // fall back to bisection
                nextX = xA + 0.5 * (xB - xA);
                start = signChangeIndex - 1;
                end   = signChangeIndex;
            }

            // evaluate the function at the guessed root
            final double nextY = computeObjectiveValue(nextX);
            if (Precision.equals(nextY, 0.0, 1)) {
                // we have found an exact root, since it is not an approximation
                // we don't need to bother about the allowed solutions setting
                return nextX;
            }

            if ((nbPoints > 2) && (end - start != nbPoints)) {

                // we have been forced to ignore some points to keep bracketing,
                // they are probably too far from the root, drop them from now on
                nbPoints = end - start;
                System.arraycopy(x, start, x, 0, nbPoints);
                System.arraycopy(y, start, y, 0, nbPoints);
                signChangeIndex -= start;

            } else  if (nbPoints == x.length) {

                // we have to drop one point in order to insert the new one
                nbPoints--;

                // keep the tightest bracketing interval as centered as possible
                if (signChangeIndex >= (x.length + 1) / 2) {
                    // we drop the lowest point, we have to shift the arrays and the index
                    System.arraycopy(x, 1, x, 0, nbPoints);
                    System.arraycopy(y, 1, y, 0, nbPoints);
                    --signChangeIndex;
                }

            }

            // insert the last computed point
            //(by construction, we know it lies inside the tightest bracketing interval)
            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
            x[signChangeIndex] = nextX;
            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
            y[signChangeIndex] = nextY;
            ++nbPoints;

            // update the bracketing interval
            if (nextY * yA <= 0) {
                // the sign change occurs before the inserted point
                xB = nextX;
                yB = nextY;
                absYB = FastMath.abs(yB);
                ++agingA;
                agingB = 0;
            } else {
                // the sign change occurs after the inserted point
                xA = nextX;
                yA = nextY;
                absYA = FastMath.abs(yA);
                agingA = 0;
                ++agingB;

                // update the sign change index
                signChangeIndex++;

            }

        }

    }","@Override
protected double doSolve() {

    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);

    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        return x[1];
    }

    // evaluate first endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        return x[0];
    }

    int nbPoints;
    int signChangeIndex;

    if (y[0] * y[1] < 0) {
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            return x[2];
        }

        if (y[1] * y[2] < 0) {
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }

    final double[] tmpX = new double[x.length];
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;

    while (true) {
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if ((xB - xA <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            return (absYA < absYB) ? xA : xB;
        }

        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            targetY = 0;
        }

        double nextX = Double.NaN;
        int start = 0;
        int end = nbPoints;
        while (Double.isNaN(nextX) && (end - start > 1)) {
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);

            if (Double.isNaN(nextX) || !(nextX > xA && nextX < xB)) {
                nextX = Double.NaN;
                if (signChangeIndex - start >= end - signChangeIndex) {
                    ++start;
                } else {
                    --end;
                }
            }
        }

        if (Double.isNaN(nextX)) {
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }

        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            return nextX;
        }

        if ((nbPoints > 2) && (end - start != nbPoints)) {
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            nbPoints--;
            if (signChangeIndex >= (x.length + 1) / 2) {
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }

        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;

        if (nextY * yA <= 0) {
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            signChangeIndex++;
        }
    }
}",1,0
177,Math_40,"@Override
    protected double doSolve() {

        // prepare arrays with the first points
        final double[] x = new double[maximalOrder + 1];
        final double[] y = new double[maximalOrder + 1];
        x[0] = getMin();
        x[1] = getStartValue();
        x[2] = getMax();
        verifySequence(x[0], x[1], x[2]);

        // evaluate initial guess
        y[1] = computeObjectiveValue(x[1]);
        if (Precision.equals(y[1], 0.0, 1)) {
            // return the initial guess if it is a perfect root.
            return x[1];
        }

        // evaluate first  endpoint
        y[0] = computeObjectiveValue(x[0]);
        if (Precision.equals(y[0], 0.0, 1)) {
            // return the first endpoint if it is a perfect root.
            return x[0];
        }

        int nbPoints;
        int signChangeIndex;
        if (y[0] * y[1] < 0) {

            // reduce interval if it brackets the root
            nbPoints        = 2;
            signChangeIndex = 1;

        } else {

            // evaluate second endpoint
            y[2] = computeObjectiveValue(x[2]);
            if (Precision.equals(y[2], 0.0, 1)) {
                // return the second endpoint if it is a perfect root.
                return x[2];
            }

            if (y[1] * y[2] < 0) {
                // use all computed point as a start sampling array for solving
                nbPoints        = 3;
                signChangeIndex = 2;
            } else {
                throw new NoBracketingException(x[0], x[2], y[0], y[2]);
            }

        }

        // prepare a work array for inverse polynomial interpolation
        final double[] tmpX = new double[x.length];

        // current tightest bracketing of the root
        double xA    = x[signChangeIndex - 1];
        double yA    = y[signChangeIndex - 1];
        double absYA = FastMath.abs(yA);
        int agingA   = 0;
        double xB    = x[signChangeIndex];
        double yB    = y[signChangeIndex];
        double absYB = FastMath.abs(yB);
        int agingB   = 0;

        // search loop
        while (true) {

            // check convergence of bracketing interval
            final double xTol = getAbsoluteAccuracy() +
                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
                switch (allowed) {
                case ANY_SIDE :
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE :
                    return xA;
                case RIGHT_SIDE :
                    return xB;
                case BELOW_SIDE :
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE :
                    return (yA <  0) ? xB : xA;
                default :
                    // this should never happen
                    throw new MathInternalError(null);
                }
            }

            // target for the next evaluation point
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
            }

            // make a few attempts to guess a root,
            double nextX;
            int start = 0;
            int end   = nbPoints;
            do {

                // guess a value for current target, using inverse polynomial interpolation
                System.arraycopy(x, start, tmpX, start, end - start);
                nextX = guessX(targetY, tmpX, y, start, end);

                if (!((nextX > xA) && (nextX < xB))) {
                    // the guessed root is not strictly inside of the tightest bracketing interval

                    // the guessed root is either not strictly inside the interval or it
                    // is a NaN (which occurs when some sampling points share the same y)
                    // we try again with a lower interpolation order
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        // we have more points before the sign change, drop the lowest point
                        ++start;
                    } else {
                        // we have more points after sign change, drop the highest point
                        --end;
                    }

                    // we need to do one more attempt
                    nextX = Double.NaN;

                }

            } while (Double.isNaN(nextX) && (end - start > 1));

            if (Double.isNaN(nextX)) {
                // fall back to bisection
                nextX = xA + 0.5 * (xB - xA);
                start = signChangeIndex - 1;
                end   = signChangeIndex;
            }

            // evaluate the function at the guessed root
            final double nextY = computeObjectiveValue(nextX);
            if (Precision.equals(nextY, 0.0, 1)) {
                // we have found an exact root, since it is not an approximation
                // we don't need to bother about the allowed solutions setting
                return nextX;
            }

            if ((nbPoints > 2) && (end - start != nbPoints)) {

                // we have been forced to ignore some points to keep bracketing,
                // they are probably too far from the root, drop them from now on
                nbPoints = end - start;
                System.arraycopy(x, start, x, 0, nbPoints);
                System.arraycopy(y, start, y, 0, nbPoints);
                signChangeIndex -= start;

            } else  if (nbPoints == x.length) {

                // we have to drop one point in order to insert the new one
                nbPoints--;

                // keep the tightest bracketing interval as centered as possible
                if (signChangeIndex >= (x.length + 1) / 2) {
                    // we drop the lowest point, we have to shift the arrays and the index
                    System.arraycopy(x, 1, x, 0, nbPoints);
                    System.arraycopy(y, 1, y, 0, nbPoints);
                    --signChangeIndex;
                }

            }

            // insert the last computed point
            //(by construction, we know it lies inside the tightest bracketing interval)
            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
            x[signChangeIndex] = nextX;
            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
            y[signChangeIndex] = nextY;
            ++nbPoints;

            // update the bracketing interval
            if (nextY * yA <= 0) {
                // the sign change occurs before the inserted point
                xB = nextX;
                yB = nextY;
                absYB = FastMath.abs(yB);
                ++agingA;
                agingB = 0;
            } else {
                // the sign change occurs after the inserted point
                xA = nextX;
                yA = nextY;
                absYA = FastMath.abs(yA);
                agingA = 0;
                ++agingB;

                // update the sign change index
                signChangeIndex++;

            }

        }

    }","@Override
protected double doSolve() {

    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);

    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        return x[1];
    }

    // evaluate first endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        return x[0];
    }

    int nbPoints;
    int signChangeIndex;

    if (y[0] * y[1] < 0) {
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            return x[2];
        }

        if (y[1] * y[2] < 0) {
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }

    final double[] tmpX = new double[x.length];
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;

    while (true) {
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if ((xB - xA <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            return (absYA < absYB) ? xA : xB;
        }

        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            targetY = 0;
        }

        double nextX = Double.NaN;
        int start = 0;
        int end = nbPoints;
        while (Double.isNaN(nextX) && (end - start > 1)) {
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);

            if (!(nextX > xA && nextX < xB)) {
                nextX = Double.NaN;
                if (signChangeIndex - start >= end - signChangeIndex) {
                    ++start;
                } else {
                    --end;
                }
            }
        }

        if (Double.isNaN(nextX)) {
            nextX = xA + 0.5 * (xB - xA);
        }

        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            return nextX;
        }

        if ((nbPoints > 2) && (end - start != nbPoints)) {
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            nbPoints--;
            if (signChangeIndex >= (x.length + 1) / 2) {
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }

        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;

        if (nextY * yA <= 0) {
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            signChangeIndex++;
        }

    }
}",2,0
177,Math_40,"@Override
    protected double doSolve() {

        // prepare arrays with the first points
        final double[] x = new double[maximalOrder + 1];
        final double[] y = new double[maximalOrder + 1];
        x[0] = getMin();
        x[1] = getStartValue();
        x[2] = getMax();
        verifySequence(x[0], x[1], x[2]);

        // evaluate initial guess
        y[1] = computeObjectiveValue(x[1]);
        if (Precision.equals(y[1], 0.0, 1)) {
            // return the initial guess if it is a perfect root.
            return x[1];
        }

        // evaluate first  endpoint
        y[0] = computeObjectiveValue(x[0]);
        if (Precision.equals(y[0], 0.0, 1)) {
            // return the first endpoint if it is a perfect root.
            return x[0];
        }

        int nbPoints;
        int signChangeIndex;
        if (y[0] * y[1] < 0) {

            // reduce interval if it brackets the root
            nbPoints        = 2;
            signChangeIndex = 1;

        } else {

            // evaluate second endpoint
            y[2] = computeObjectiveValue(x[2]);
            if (Precision.equals(y[2], 0.0, 1)) {
                // return the second endpoint if it is a perfect root.
                return x[2];
            }

            if (y[1] * y[2] < 0) {
                // use all computed point as a start sampling array for solving
                nbPoints        = 3;
                signChangeIndex = 2;
            } else {
                throw new NoBracketingException(x[0], x[2], y[0], y[2]);
            }

        }

        // prepare a work array for inverse polynomial interpolation
        final double[] tmpX = new double[x.length];

        // current tightest bracketing of the root
        double xA    = x[signChangeIndex - 1];
        double yA    = y[signChangeIndex - 1];
        double absYA = FastMath.abs(yA);
        int agingA   = 0;
        double xB    = x[signChangeIndex];
        double yB    = y[signChangeIndex];
        double absYB = FastMath.abs(yB);
        int agingB   = 0;

        // search loop
        while (true) {

            // check convergence of bracketing interval
            final double xTol = getAbsoluteAccuracy() +
                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
                switch (allowed) {
                case ANY_SIDE :
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE :
                    return xA;
                case RIGHT_SIDE :
                    return xB;
                case BELOW_SIDE :
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE :
                    return (yA <  0) ? xB : xA;
                default :
                    // this should never happen
                    throw new MathInternalError(null);
                }
            }

            // target for the next evaluation point
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
            }

            // make a few attempts to guess a root,
            double nextX;
            int start = 0;
            int end   = nbPoints;
            do {

                // guess a value for current target, using inverse polynomial interpolation
                System.arraycopy(x, start, tmpX, start, end - start);
                nextX = guessX(targetY, tmpX, y, start, end);

                if (!((nextX > xA) && (nextX < xB))) {
                    // the guessed root is not strictly inside of the tightest bracketing interval

                    // the guessed root is either not strictly inside the interval or it
                    // is a NaN (which occurs when some sampling points share the same y)
                    // we try again with a lower interpolation order
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        // we have more points before the sign change, drop the lowest point
                        ++start;
                    } else {
                        // we have more points after sign change, drop the highest point
                        --end;
                    }

                    // we need to do one more attempt
                    nextX = Double.NaN;

                }

            } while (Double.isNaN(nextX) && (end - start > 1));

            if (Double.isNaN(nextX)) {
                // fall back to bisection
                nextX = xA + 0.5 * (xB - xA);
                start = signChangeIndex - 1;
                end   = signChangeIndex;
            }

            // evaluate the function at the guessed root
            final double nextY = computeObjectiveValue(nextX);
            if (Precision.equals(nextY, 0.0, 1)) {
                // we have found an exact root, since it is not an approximation
                // we don't need to bother about the allowed solutions setting
                return nextX;
            }

            if ((nbPoints > 2) && (end - start != nbPoints)) {

                // we have been forced to ignore some points to keep bracketing,
                // they are probably too far from the root, drop them from now on
                nbPoints = end - start;
                System.arraycopy(x, start, x, 0, nbPoints);
                System.arraycopy(y, start, y, 0, nbPoints);
                signChangeIndex -= start;

            } else  if (nbPoints == x.length) {

                // we have to drop one point in order to insert the new one
                nbPoints--;

                // keep the tightest bracketing interval as centered as possible
                if (signChangeIndex >= (x.length + 1) / 2) {
                    // we drop the lowest point, we have to shift the arrays and the index
                    System.arraycopy(x, 1, x, 0, nbPoints);
                    System.arraycopy(y, 1, y, 0, nbPoints);
                    --signChangeIndex;
                }

            }

            // insert the last computed point
            //(by construction, we know it lies inside the tightest bracketing interval)
            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
            x[signChangeIndex] = nextX;
            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
            y[signChangeIndex] = nextY;
            ++nbPoints;

            // update the bracketing interval
            if (nextY * yA <= 0) {
                // the sign change occurs before the inserted point
                xB = nextX;
                yB = nextY;
                absYB = FastMath.abs(yB);
                ++agingA;
                agingB = 0;
            } else {
                // the sign change occurs after the inserted point
                xA = nextX;
                yA = nextY;
                absYA = FastMath.abs(yA);
                agingA = 0;
                ++agingB;

                // update the sign change index
                signChangeIndex++;

            }

        }

    }","@Override
protected double doSolve() {
    // initialize arrays for bracketing and evaluating
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);

    // evaluate at initial guess and endpoints
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        return x[1];
    }
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;

    // interval reduction based on signs
    if (y[0] * y[1] < 0) {
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }

    final double[] tmpX = new double[x.length];
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYA = FastMath.abs(yA);
    double absYB = FastMath.abs(yB);

    // use updated intervals in the loop
    while (true) {
        final double xTol = getAbsoluteAccuracy() +
                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if ((xB - xA <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            return absYA < absYB ? xA : xB;
        }

        double nextX = xA + 0.5 * (xB - xA);  // fallback to bisection
        double nextY = computeObjectiveValue(nextX);

        // adjust bounds based on next evaluation
        if (nextY * yA <= 0) {
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
        } else {
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
        }
    }
}",3,0
177,Math_40,"@Override
    protected double doSolve() {

        // prepare arrays with the first points
        final double[] x = new double[maximalOrder + 1];
        final double[] y = new double[maximalOrder + 1];
        x[0] = getMin();
        x[1] = getStartValue();
        x[2] = getMax();
        verifySequence(x[0], x[1], x[2]);

        // evaluate initial guess
        y[1] = computeObjectiveValue(x[1]);
        if (Precision.equals(y[1], 0.0, 1)) {
            // return the initial guess if it is a perfect root.
            return x[1];
        }

        // evaluate first  endpoint
        y[0] = computeObjectiveValue(x[0]);
        if (Precision.equals(y[0], 0.0, 1)) {
            // return the first endpoint if it is a perfect root.
            return x[0];
        }

        int nbPoints;
        int signChangeIndex;
        if (y[0] * y[1] < 0) {

            // reduce interval if it brackets the root
            nbPoints        = 2;
            signChangeIndex = 1;

        } else {

            // evaluate second endpoint
            y[2] = computeObjectiveValue(x[2]);
            if (Precision.equals(y[2], 0.0, 1)) {
                // return the second endpoint if it is a perfect root.
                return x[2];
            }

            if (y[1] * y[2] < 0) {
                // use all computed point as a start sampling array for solving
                nbPoints        = 3;
                signChangeIndex = 2;
            } else {
                throw new NoBracketingException(x[0], x[2], y[0], y[2]);
            }

        }

        // prepare a work array for inverse polynomial interpolation
        final double[] tmpX = new double[x.length];

        // current tightest bracketing of the root
        double xA    = x[signChangeIndex - 1];
        double yA    = y[signChangeIndex - 1];
        double absYA = FastMath.abs(yA);
        int agingA   = 0;
        double xB    = x[signChangeIndex];
        double yB    = y[signChangeIndex];
        double absYB = FastMath.abs(yB);
        int agingB   = 0;

        // search loop
        while (true) {

            // check convergence of bracketing interval
            final double xTol = getAbsoluteAccuracy() +
                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
                switch (allowed) {
                case ANY_SIDE :
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE :
                    return xA;
                case RIGHT_SIDE :
                    return xB;
                case BELOW_SIDE :
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE :
                    return (yA <  0) ? xB : xA;
                default :
                    // this should never happen
                    throw new MathInternalError(null);
                }
            }

            // target for the next evaluation point
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
            }

            // make a few attempts to guess a root,
            double nextX;
            int start = 0;
            int end   = nbPoints;
            do {

                // guess a value for current target, using inverse polynomial interpolation
                System.arraycopy(x, start, tmpX, start, end - start);
                nextX = guessX(targetY, tmpX, y, start, end);

                if (!((nextX > xA) && (nextX < xB))) {
                    // the guessed root is not strictly inside of the tightest bracketing interval

                    // the guessed root is either not strictly inside the interval or it
                    // is a NaN (which occurs when some sampling points share the same y)
                    // we try again with a lower interpolation order
                    if (signChangeIndex - start >= end - signChangeIndex) {
                        // we have more points before the sign change, drop the lowest point
                        ++start;
                    } else {
                        // we have more points after sign change, drop the highest point
                        --end;
                    }

                    // we need to do one more attempt
                    nextX = Double.NaN;

                }

            } while (Double.isNaN(nextX) && (end - start > 1));

            if (Double.isNaN(nextX)) {
                // fall back to bisection
                nextX = xA + 0.5 * (xB - xA);
                start = signChangeIndex - 1;
                end   = signChangeIndex;
            }

            // evaluate the function at the guessed root
            final double nextY = computeObjectiveValue(nextX);
            if (Precision.equals(nextY, 0.0, 1)) {
                // we have found an exact root, since it is not an approximation
                // we don't need to bother about the allowed solutions setting
                return nextX;
            }

            if ((nbPoints > 2) && (end - start != nbPoints)) {

                // we have been forced to ignore some points to keep bracketing,
                // they are probably too far from the root, drop them from now on
                nbPoints = end - start;
                System.arraycopy(x, start, x, 0, nbPoints);
                System.arraycopy(y, start, y, 0, nbPoints);
                signChangeIndex -= start;

            } else  if (nbPoints == x.length) {

                // we have to drop one point in order to insert the new one
                nbPoints--;

                // keep the tightest bracketing interval as centered as possible
                if (signChangeIndex >= (x.length + 1) / 2) {
                    // we drop the lowest point, we have to shift the arrays and the index
                    System.arraycopy(x, 1, x, 0, nbPoints);
                    System.arraycopy(y, 1, y, 0, nbPoints);
                    --signChangeIndex;
                }

            }

            // insert the last computed point
            //(by construction, we know it lies inside the tightest bracketing interval)
            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
            x[signChangeIndex] = nextX;
            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
            y[signChangeIndex] = nextY;
            ++nbPoints;

            // update the bracketing interval
            if (nextY * yA <= 0) {
                // the sign change occurs before the inserted point
                xB = nextX;
                yB = nextY;
                absYB = FastMath.abs(yB);
                ++agingA;
                agingB = 0;
            } else {
                // the sign change occurs after the inserted point
                xA = nextX;
                yA = nextY;
                absYA = FastMath.abs(yA);
                agingA = 0;
                ++agingB;

                // update the sign change index
                signChangeIndex++;

            }

        }

    }","@Override
protected double doSolve() {

    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);

    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        return x[1];
    }

    // evaluate the first endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        return x[0];
    }

    int nbPoints;
    int signChangeIndex;

    if (y[0] * y[1] < 0) {
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            return x[2];
        }

        if (y[1] * y[2] < 0) {
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }

    final double[] tmpX = new double[x.length];
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;

    while (true) {
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if ((xB - xA <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch (allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    throw new MathInternalError(null);
            }
        }

        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            targetY = 0;
        }

        double nextX = Double.NaN;
        int start = 0;
        int end = nbPoints;
        do {
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);

            if (!(nextX > xA && nextX < xB) || Double.isNaN(nextX)) {
                if (signChangeIndex - start >= end - signChangeIndex) {
                    ++start;
                } else {
                    --end;
                }
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));

        if (Double.isNaN(nextX)) {
            nextX = xA + 0.5 * (xB - xA);
        }

        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            return nextX;
        }

        if ((nbPoints > 2) && (end - start != nbPoints)) {
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            nbPoints--;
            if (signChangeIndex >= (x.length + 1) / 2) {
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }

        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;

        if (nextY * yA <= 0) {
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            signChangeIndex++;
        }
    }
}",4,0
178,Math_41,"public double evaluate(final double[] values, final double[] weights,
                           final double mean, final int begin, final int length) {

        double var = Double.NaN;

        if (test(values, weights, begin, length)) {
            if (length == 1) {
                var = 0.0;
            } else if (length > 1) {
                double accum = 0.0;
                double dev = 0.0;
                double accum2 = 0.0;
                for (int i = begin; i < begin + length; i++) {
                    dev = values[i] - mean;
                    accum += weights[i] * (dev * dev);
                    accum2 += weights[i] * dev;
                 }
 
                 double sumWts = 0;
                 for (int i = 0; i < weights.length; i++) {
                     sumWts += weights[i];
                 }
 
                if (isBiasCorrected) {
                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
                } else {
                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
                }
            }
        }
        return var;
    }","public double evaluate(final double[] values, final double[] weights,
                           final double mean, final int begin, final int length) {

        double var = Double.NaN;

        if (test(values, weights, begin, length)) {
            if (length == 1) {
                var = 0.0;
            } else if (length > 1) {
                double accum = 0.0;
                double dev = 0.0;
                double accum2 = 0.0;
                for (int i = begin; i < begin + length; i++) {
                    dev = values[i] - mean;
                    accum += weights[i] * (dev * dev);
                    accum2 += weights[i] * dev;
                }

                double sumWts = 0;
                for (int i = begin; i < begin + length; i++) {
                    sumWts += weights[i];
                }

                if (isBiasCorrected) {
                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
                } else {
                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
                }
            }
        }
        return var;
    }",0,0
179,Math_42,"protected RealPointValuePair getSolution() {
      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

      Set<Integer> basicRows = new HashSet<Integer>();
      double[] coefficients = new double[getOriginalNumDecisionVariables()];
      for (int i = 0; i < coefficients.length; i++) {
          int colIndex = columnLabels.indexOf(""x"" + i);
          if (colIndex < 0) {
            coefficients[i] = 0;
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
      return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
    Integer negativeVarBasicRow = negativeVarColumn >= 0 ? getBasicRow(negativeVarColumn) : null;

    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

    Set<Integer> basicRows = new HashSet<>();
    double[] coefficients = new double[getOriginalNumDecisionVariables()];

    for (int i = 0; i < coefficients.length; i++) {
        int colIndex = columnLabels.indexOf(""x"" + i);
        if (colIndex < 0) {
            coefficients[i] = 0;
            continue;
        }

        Integer basicRow = getBasicRow(colIndex);
        if (basicRow != null && basicRows.contains(basicRow)) {
            coefficients[i] = 0;
        } else {
            basicRows.add(basicRow);
            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                             (restrictToNonNegative ? 0 : mostNegative);
        }
    }

    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,0
179,Math_42,"protected RealPointValuePair getSolution() {
      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

      Set<Integer> basicRows = new HashSet<Integer>();
      double[] coefficients = new double[getOriginalNumDecisionVariables()];
      for (int i = 0; i < coefficients.length; i++) {
          int colIndex = columnLabels.indexOf(""x"" + i);
          if (colIndex < 0) {
            coefficients[i] = 0;
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
      return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }",Match failed,1,0
179,Math_42,"protected RealPointValuePair getSolution() {
      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

      Set<Integer> basicRows = new HashSet<Integer>();
      double[] coefficients = new double[getOriginalNumDecisionVariables()];
      for (int i = 0; i < coefficients.length; i++) {
          int colIndex = columnLabels.indexOf(""x"" + i);
          if (colIndex < 0) {
            coefficients[i] = 0;
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
      return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
    Integer negativeVarBasicRow = negativeVarColumn >= 0 ? getBasicRow(negativeVarColumn) : null;
    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

    Set<Integer> basicRows = new HashSet<>();
    double[] coefficients = new double[getOriginalNumDecisionVariables()];

    for (int i = 0; i < coefficients.length; i++) {
        int colIndex = columnLabels.indexOf(""x"" + i);
        if (colIndex < 0) {
            coefficients[i] = 0;
            continue;
        }

        Integer basicRow = getBasicRow(colIndex);
        if (basicRow != null && basicRows.contains(basicRow)) {
            coefficients[i] = 0;
        } else {
            basicRows.add(basicRow);
            // Modify coefficients calculation logic to handle negative variables correctly
            coefficients[i] = basicRow != null ? getEntry(basicRow, getRhsOffset()) : (restrictToNonNegative ? 0 : -mostNegative);
        }
    }

    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",2,0
179,Math_42,"protected RealPointValuePair getSolution() {
      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

      Set<Integer> basicRows = new HashSet<Integer>();
      double[] coefficients = new double[getOriginalNumDecisionVariables()];
      for (int i = 0; i < coefficients.length; i++) {
          int colIndex = columnLabels.indexOf(""x"" + i);
          if (colIndex < 0) {
            coefficients[i] = 0;
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
      return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
    Integer negativeVarBasicRow = negativeVarColumn >= 0 ? getBasicRow(negativeVarColumn) : null;
    double mostNegative = negativeVarBasicRow != null ? getEntry(negativeVarBasicRow, getRhsOffset()) : 0;

    Set<Integer> basicRows = new HashSet<>();
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    
    for (int i = 0; i < coefficients.length; i++) {
        int colIndex = columnLabels.indexOf(""x"" + i);
        if (colIndex < 0) {
            coefficients[i] = 0;
            continue;
        }

        Integer basicRow = getBasicRow(colIndex);
        if (basicRow != null && !basicRows.contains(basicRow)) {
            basicRows.add(basicRow);
            coefficients[i] = getEntry(basicRow, getRhsOffset()) - (restrictToNonNegative ? 0 : mostNegative);
        } else {
            coefficients[i] = 0;
        }
    }

    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",3,0
179,Math_42,"protected RealPointValuePair getSolution() {
      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

      Set<Integer> basicRows = new HashSet<Integer>();
      double[] coefficients = new double[getOriginalNumDecisionVariables()];
      for (int i = 0; i < coefficients.length; i++) {
          int colIndex = columnLabels.indexOf(""x"" + i);
          if (colIndex < 0) {
            coefficients[i] = 0;
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
      return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
    Integer negativeVarBasicRow = negativeVarColumn >= 0 ? getBasicRow(negativeVarColumn) : null;
    double mostNegative = negativeVarBasicRow != null ? getEntry(negativeVarBasicRow, getRhsOffset()) : 0;

    Set<Integer> basicRows = new HashSet<>();
    double[] coefficients = new double[getOriginalNumDecisionVariables()];

    for (int i = 0; i < coefficients.length; i++) {
        int colIndex = columnLabels.indexOf(""x"" + i);
        if (colIndex < 0) {
            coefficients[i] = 0;
            continue;
        }
        
        Integer basicRow = getBasicRow(colIndex);
        
        if (basicRow != null && basicRows.add(basicRow)) {
            // Unconstrained variables should have a coefficient of zero
            if (basicRow.equals(negativeVarBasicRow)) {
                coefficients[i] = restrictToNonNegative ? getEntry(basicRow, getRhsOffset()) : 0;
            } else {
                // Subtract the mostNegative value only if 'restrictToNonNegative' is false and 
                // the basic row is different from the negative variable row
                coefficients[i] = getEntry(basicRow, getRhsOffset()) - 
                                 ((basicRow != negativeVarBasicRow && !restrictToNonNegative) ? mostNegative : 0);
            }
        } else {
            coefficients[i] = 0;
        }
    }

    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",4,0
180,Math_43,"public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        sumLogImpl.increment(value);
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
         if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
         if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
         if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
    }","public void addValue(double value) {
    sumImpl.increment(value);
    sumsqImpl.increment(value);
    minImpl.increment(value);
    maxImpl.increment(value);
    sumLogImpl.increment(value);
    secondMoment.increment(value);
    
    // Check if mean, variance or geomean have been overridden
    if (!(meanImpl instanceof Mean)) {
        meanImpl.increment(value);
    }
    if (!(varianceImpl instanceof Variance)) {
        varianceImpl.increment(value);
    }
    if (!(geoMeanImpl instanceof GeometricMean)) {
        geoMeanImpl.increment(value);
    }
    
    // Increment count
    n++;

    // Ensure the overridden mean, variance, or geometric mean are updated correctly
    if (meanImpl instanceof Mean) {
        ((Mean) meanImpl).increment(value);
    }

    if (varianceImpl instanceof Variance) {
        ((Variance) varianceImpl).increment(value);
    }

    if (geoMeanImpl instanceof GeometricMean) {
        ((GeometricMean) geoMeanImpl).increment(value);
    }
}",0,0
180,Math_43,"public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        sumLogImpl.increment(value);
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
         if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
         if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
         if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
    }","public void addValue(double value) {
    // Ensure initial increment is done only when n is less than 1 for correct internal state setup
    if (n < 1) {
        sumImpl.clear();
        sumsqImpl.clear();
        minImpl.clear();
        maxImpl.clear();
        sumLogImpl.clear();
        secondMoment.clear();
        meanImpl.clear();
        varianceImpl.clear();
        geoMeanImpl.clear();
    }
    
    // Increment sums and counts
    sumImpl.increment(value);
    sumsqImpl.increment(value);
    minImpl.increment(value);
    maxImpl.increment(value);
    sumLogImpl.increment(value);
    secondMoment.increment(value);
    n++;

    // Conditionally update overridden statistic implementations
    if (meanImpl instanceof Mean) {
        ((Mean) meanImpl).increment(value);
    } else {
        meanImpl.increment(value);
    }

    if (varianceImpl instanceof Variance) {
        ((Variance) varianceImpl).increment(value);
    } else {
        varianceImpl.increment(value);
    }

    if (geoMeanImpl instanceof GeometricMean) {
        ((GeometricMean) geoMeanImpl).increment(value);
    } else {
        geoMeanImpl.increment(value);
    }
}",1,0
180,Math_43,"public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        sumLogImpl.increment(value);
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
         if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
         if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
         if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
    }","public void addValue(double value) {
        // Ensure all statistics are consistently updated along with overridden implementations
        updateStatistic(sumImpl, value);
        updateStatistic(sumsqImpl, value);
        updateStatistic(minImpl, value);
        updateStatistic(maxImpl, value);
        updateStatistic(sumLogImpl, value);
        secondMoment.increment(value);
        
        n++;
    }

private void updateStatistic(StorelessUnivariateStatistic stat, double value) {
    try {
        stat.increment(value);
    } catch (Exception e) {
        // Handle potential exceptions from overridden implementations
        // This ensures that if the implementation fails, it does not affect other calculations
    }
}",2,0
180,Math_43,"public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        sumLogImpl.increment(value);
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
         if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
         if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
         if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
    }","public void addValue(double value) {
    sumImpl.increment(value);
    sumsqImpl.increment(value);
    minImpl.increment(value);
    maxImpl.increment(value);
    sumLogImpl.increment(value);
    secondMoment.increment(value);
    n++;

    if (meanImpl instanceof Mean && value != 0) {
        meanImpl.increment(value);
    }

    if (varianceImpl instanceof Variance && value != 0) {
        varianceImpl.increment(value);
    }

    if (geoMeanImpl instanceof GeometricMean && value > 0) {
        geoMeanImpl.increment(value);
    }
}",3,0
180,Math_43,"public void addValue(double value) {
        sumImpl.increment(value);
        sumsqImpl.increment(value);
        minImpl.increment(value);
        maxImpl.increment(value);
        sumLogImpl.increment(value);
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
         if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
         if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
         if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
    }","public void addValue(double value) {
    // Increment value for all generic statistics
    sumImpl.increment(value);
    sumsqImpl.increment(value);
    minImpl.increment(value);
    maxImpl.increment(value);
    sumLogImpl.increment(value);
    secondMoment.increment(value);
    n++;

    // Separate handling for overridden and non-overridden stats
    boolean isOverridden = false;
    if (!(meanImpl instanceof Mean)) {
        meanImpl.increment(value);
        isOverridden = true;
    }
    if (!(varianceImpl instanceof Variance)) {
        varianceImpl.increment(value);
        isOverridden = true;
    }
    if (!(geoMeanImpl instanceof GeometricMean)) {
        geoMeanImpl.increment(value);
        isOverridden = true;
    }

    // Skip overridden implementations if isOverridden flag is set
    if (!isOverridden) {
        if (meanImpl instanceof Mean) {
            ((Mean) meanImpl).increment(value);
        }
        if (varianceImpl instanceof Variance) {
            ((Variance) varianceImpl).increment(value);
        }
        if (geoMeanImpl instanceof GeometricMean) {
            ((GeometricMean) geoMeanImpl).increment(value);
        }
    }
}",4,0
181,Math_44,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                            final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (!statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occurringEvents.add(state);
                }
            }

            while (!occurringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occurringEvents.iterator();
                EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    computeDerivatives(eventT, y, yDot);
                    resetOccurred = true;
                    return eventT;
                }

                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occurringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            System.arraycopy(currentY, 0, y, 0, y.length);

            return currentT;

    }",0,0
181,Math_44,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (!statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    occurringEvents.add(state);
                }
            }

            while (!occurringEvents.isEmpty()) {

                final Iterator<EventState> iterator = occurringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    computeDerivatives(eventT, y, yDot);
                    resetOccurred = true;
                    return eventT;
                }

                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                if (currentEvent.evaluateStep(interpolator)) {
                    occurringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                if (state.stop() && currentT < previousT) {
                    throw new MathIllegalStateException(""going backard in time! (%g < %g)"", currentT, previousT);
                }
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            System.arraycopy(currentY, 0, y, 0, y.length);

            return currentT;

    }",1,0
181,Math_44,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                            final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();
    resetOccurred = false;

    // Initialize the events states if needed
    if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }

    // Search for next events that may occur during the step
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });

    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            occurringEvents.add(state);
        }
    }

    while (!occurringEvents.isEmpty()) {

        // Handle the chronologically first event
        final Iterator<EventState> iterator = occurringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();

        // Restrict the interpolator to the first part of the step, up to the event
        final double eventT = currentEvent.getEventTime();
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);

        // Trigger the event
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState();
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();

        // Handle the first part of the step, up to the event
        for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }

        if (isLastStep) {
            // The event asked to stop integration
            System.arraycopy(eventY, 0, y, 0, y.length);
            return eventT;
        }

        if (currentEvent.reset(eventT, eventY)) {
            // Some event handler has triggered changes that invalidate the derivatives, we need to recompute them
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            return eventT;
        }

        // Prepare handling of the remaining part of the step
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);

        // Check if the same event occurs again in the remaining part of the step
        if (currentEvent.evaluateStep(interpolator)) {
            occurringEvents.add(currentEvent);
        }
    }

    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

    // Handle the remaining part of the step, after all events if any
    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }

    System.arraycopy(currentY, 0, y, 0, y.length);

    return currentT;
}",2,0
181,Math_44,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                            final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();
    resetOccurred = false;

    // Initialize the events states if needed
    if (! statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }

    // Search for next events that may occur during the step
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });

    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            occurringEvents.add(state);
        }
    }

    while (!occurringEvents.isEmpty()) {

        // Handle the chronologically first event
        final Iterator<EventState> iterator = occurringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();

        // Restrict the interpolator to the first part of the step, up to the event
        final double eventT = currentEvent.getEventTime();
        if (eventT < previousT) {
            throw new MathIllegalStateException(""Event time is before previous time."");
        }
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);

        // Trigger the event
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState();
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();

        // Handle the first part of the step, up to the event
        for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }

        if (isLastStep) {
            // The event asked to stop integration
            System.arraycopy(eventY, 0, y, 0, y.length);
            return eventT;
        }

        if (currentEvent.reset(eventT, eventY)) {
            // Some event handler has triggered changes that invalidate the derivatives, need recompute
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            return eventT;
        }

        // Prepare handling of the remaining part of the step
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);

        // Check if the same event occurs again in the remaining part of the step
        if (currentEvent.evaluateStep(interpolator)) {
            occurringEvents.add(currentEvent);
        }
    }

    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

    // Handle the remaining part of the step, after all events if any
    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }

    System.arraycopy(currentY, 0, y, 0, y.length);

    return currentT;
}",3,0
181,Math_44,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // trigger the event
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState();
                currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    return eventT;
                }

                if (currentEvent.reset(eventT, eventY)) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                            final double[] y, final double[] yDot, final double tEnd)
        throws MathIllegalStateException {

    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();
    resetOccurred = false;

    // Initialize the events states if needed
    if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }

    // Search for next events that may occur during the step
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });

    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            occurringEvents.add(state);
        }
    }

    // Use previous event time to ensure no regression occurs
    double previousEventTime = Double.NaN;

    while (!occurringEvents.isEmpty()) {

        // Handle the chronologically first event
        final Iterator<EventState> iterator = occurringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();

        // Prevent backward time progression
        final double eventT = currentEvent.getEventTime();
        if (!Double.isNaN(previousEventTime) && eventT < previousEventTime) {
            throw new MathIllegalStateException(""Event time regression detected!"");
        }
        previousEventTime = eventT;

        // Restrict the interpolator to the first part of the step, up to the event
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);

        // Trigger the event
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState();
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();

        // Handle the first part of the step, up to the event
        for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }

        if (isLastStep) {
            // The event asked to stop integration
            System.arraycopy(eventY, 0, y, 0, y.length);
            return eventT;
        }

        if (currentEvent.reset(eventT, eventY)) {
            // Event handler triggered changes; recompute derivatives
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            return eventT;
        }

        // Prepare handling of the remaining part of the step
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);

        // Check if the same event occurs again in the remaining part of the step
        if (currentEvent.evaluateStep(interpolator)) {
            occurringEvents.add(currentEvent);
        }
    }

    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

    // Handle the remaining part of the step, after all events if any
    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }

    System.arraycopy(currentY, 0, y, 0, y.length);

    return currentT;
}",4,0
182,Math_45,"    public OpenMapRealMatrix(int rowDimension, int columnDimension) {
        super(rowDimension, columnDimension);
        this.rows = rowDimension;
        this.columns = columnDimension;
        this.entries = new OpenIntToDoubleHashMap(0.0);
    }
","public OpenMapRealMatrix(int rowDimension, int columnDimension) {
    super(rowDimension, columnDimension);
    if (rowDimension < 1 || columnDimension < 1) {
        throw new IllegalArgumentException(""Matrix dimensions must be positive"");
    }
    if ((long) rowDimension * (long) columnDimension > Integer.MAX_VALUE) {
        throw new NumberIsTooLargeException(Integer.MAX_VALUE, rowDimension * columnDimension, true);
    }

    this.rows = rowDimension;
    this.columns = columnDimension;
    this.entries = new OpenIntToDoubleHashMap(0.0);
}",0,0
183,Math_48,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals.
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it.
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // Interval inversion.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Detect early stagnation or convergence issues.
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        // Update interval [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;

        // Check if function value accuracy condition met.
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        // Check if interval size satisfies accuracy conditions.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }

        // Guard for maximum iterations (throw exception if needed, prevents infinite loop).
        if (getEvaluations() >= getMaxEvaluations()) {
            throw new TooManyEvaluationsException(getMaxEvaluations());
        }
    }
}",0,0
183,Math_48,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    verifyBracketing(x0, x1);

    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    boolean inverted = false;

    int iterationLimit = getMaxEvaluations(); // New limit to avoid infinite loops.
    int iterationCount = 0;

    while (iterationCount < iterationLimit) {
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        if (fx == 0.0) {
            return x;
        }

        iterationCount++;

        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    f0 = Math.signum(f0) * Math.min(Math.abs(f0), Math.abs(fx)); // Force convergence strategy.
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        x1 = x;
        f1 = fx;

        if (FastMath.abs(f1) <= ftol) {
            return x1;
        }

        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            return inverted ? x1 : x0;
        }
    }
    throw new TooManyEvaluationsException(getMaxEvaluations());
}",1,0
183,Math_48,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    verifyBracketing(x0, x1);

    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    boolean inverted = false;

    int iterationCount = 0;
    int maxIterations = getMaxEvaluations();

    while (true) {
        if (iterationCount >= maxIterations) {
            throw new TooManyEvaluationsException(maxIterations);
        }

        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        if (fx == 0.0) {
            return x;
        }

        iterationCount++;

        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    f0 = f0 * fx / (f0 + fx); // Adjust for potential convergence issues
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        x1 = x;
        f1 = fx;

        if (FastMath.abs(f1) <= ftol) {
            return x1;
        }

        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            return inverted ? x1 : x0;
        }
    }
}",2,0
183,Math_48,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    verifyBracketing(x0, x1);

    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    boolean inverted = false;

    int iterationCount = 0;

    while (true) {
        iterationCount++;
        if (iterationCount > getMaxEvaluations()) {
            throw new TooManyEvaluationsException(getMaxEvaluations());
        }

        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        if (fx == 0.0) {
            return x;
        }

        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    if (FastMath.abs(f0) < ftol) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        x1 = x;
        f1 = fx;

        if (FastMath.abs(f1) <= ftol) {
            return x1;
        }

        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            return inverted ? x1 : x0;
        }
    }
}",3,0
183,Math_48,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    verifyBracketing(x0, x1);

    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    boolean inverted = false;
    int maxIterations = getMaxEvaluations();
    int iterationCount = 0;

    while (iterationCount < maxIterations) {
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        if (Double.isNaN(x) || Double.isInfinite(x)) {
            throw new ConvergenceException();
        }
        final double fx = computeObjectiveValue(x);

        if (fx == 0.0) {
            return x;
        }

        iterationCount++;

        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    f0 = Math.signum(f0) * Math.min(Math.abs(f0), Math.abs(fx));
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        x1 = x;
        f1 = fx;

        if (FastMath.abs(f1) <= ftol) {
            return handleAllowedSolutions(x1, inverted, f1);
        }

        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            return inverted ? x1 : x0;
        }
    }

    throw new TooManyEvaluationsException(maxIterations);
}

private double handleAllowedSolutions(double x1, boolean inverted, double f1) {
    switch (allowed) {
        case ANY_SIDE:
            return x1;
        case LEFT_SIDE:
            if (inverted) {
                return x1;
            }
            break;
        case RIGHT_SIDE:
            if (!inverted) {
                return x1;
            }
            break;
        case BELOW_SIDE:
            if (f1 <= 0) {
                return x1;
            }
            break;
        case ABOVE_SIDE:
            if (f1 >= 0) {
                return x1;
            }
            break;
        default:
            throw new MathInternalError();
    }
    return x1; // Default case fallback
}",4,0
184,Math_5,"public Complex reciprocal() {
        if (isNaN) {
            return NaN;
         }
 
         if (real == 0.0 && imaginary == 0.0) {
             return NaN;
         }
 
         if (isInfinite) {
            return ZERO;
        }

        if (FastMath.abs(real) < FastMath.abs(imaginary)) {
            double q = real / imaginary;
            double scale = 1. / (real * q + imaginary);
            return createComplex(scale * q, -scale);
        } else {
            double q = imaginary / real;
            double scale = 1. / (imaginary * q + real);
            return createComplex(scale, -scale * q);
        }
    }","public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }

    if (real == 0.0 && imaginary == 0.0) {
        return NaN; // updated to return NaN instead of Infinity
    }

    if (isInfinite) {
        return ZERO;
    }

    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (imaginary * q + real); // corrected denominator calculation
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (real * q + imaginary); // corrected denominator calculation
        return createComplex(scale, -scale * q);
    }
}",0,0
184,Math_5,"public Complex reciprocal() {
        if (isNaN) {
            return NaN;
         }
 
         if (real == 0.0 && imaginary == 0.0) {
             return NaN;
         }
 
         if (isInfinite) {
            return ZERO;
        }

        if (FastMath.abs(real) < FastMath.abs(imaginary)) {
            double q = real / imaginary;
            double scale = 1. / (real * q + imaginary);
            return createComplex(scale * q, -scale);
        } else {
            double q = imaginary / real;
            double scale = 1. / (imaginary * q + real);
            return createComplex(scale, -scale * q);
        }
    }","public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }

    if (real == 0.0 && imaginary == 0.0) {
        return NaN; // updated to return NaN for zero denominator
    }

    if (isInfinite) {
        return new Complex(Double.POSITIVE_INFINITY, 0.0); // adjusted to return positive infinity for infinite inputs
    }

    double denominator = real * real + imaginary * imaginary; // compute correct denominator based on magnitude
    return createComplex(real / denominator, -imaginary / denominator); // simplified computation using the denominator
}",1,0
184,Math_5,"public Complex reciprocal() {
        if (isNaN) {
            return NaN;
         }
 
         if (real == 0.0 && imaginary == 0.0) {
             return NaN;
         }
 
         if (isInfinite) {
            return ZERO;
        }

        if (FastMath.abs(real) < FastMath.abs(imaginary)) {
            double q = real / imaginary;
            double scale = 1. / (real * q + imaginary);
            return createComplex(scale * q, -scale);
        } else {
            double q = imaginary / real;
            double scale = 1. / (imaginary * q + real);
            return createComplex(scale, -scale * q);
        }
    }","public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }

    if (real == 0.0 && imaginary == 0.0) {
        return NaN; // Handle zero denominator explicitly
    }

    if (isInfinite) {
        return createComplex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); // Adjust handling for infinite inputs
    }

    double denominator = FastMath.pow(real, 2) + FastMath.pow(imaginary, 2); // Use accurate magnitude calculation
    if (denominator == 0.0) {
        return NaN; // Add safeguard for zero denominator
    }

    return createComplex(real / denominator, -imaginary / denominator); // Correct computation using magnitude
}",2,0
184,Math_5,"public Complex reciprocal() {
        if (isNaN) {
            return NaN;
         }
 
         if (real == 0.0 && imaginary == 0.0) {
             return NaN;
         }
 
         if (isInfinite) {
            return ZERO;
        }

        if (FastMath.abs(real) < FastMath.abs(imaginary)) {
            double q = real / imaginary;
            double scale = 1. / (real * q + imaginary);
            return createComplex(scale * q, -scale);
        } else {
            double q = imaginary / real;
            double scale = 1. / (imaginary * q + real);
            return createComplex(scale, -scale * q);
        }
    }","public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }

    if (real == 0.0 && imaginary == 0.0) {
        return NaN; // Correctly return NaN for zero denominator
    }

    if (isInfinite) {
        return NaN; // Explicitly handle infinite cases as undefined
    }

    double denominator = real * real + imaginary * imaginary; // Improved computation of magnitude
    return createComplex(real / denominator, -imaginary / denominator); // Use straightforward formula
}",3,0
184,Math_5,"public Complex reciprocal() {
        if (isNaN) {
            return NaN;
         }
 
         if (real == 0.0 && imaginary == 0.0) {
             return NaN;
         }
 
         if (isInfinite) {
            return ZERO;
        }

        if (FastMath.abs(real) < FastMath.abs(imaginary)) {
            double q = real / imaginary;
            double scale = 1. / (real * q + imaginary);
            return createComplex(scale * q, -scale);
        } else {
            double q = imaginary / real;
            double scale = 1. / (imaginary * q + real);
            return createComplex(scale, -scale * q);
        }
    }","public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }

    if (real == 0.0 && imaginary == 0.0) {
        return NaN; // Explicitly handle zero denominator case
    }

    if (isInfinite) {
        return createComplex(0.0, 0.0); // Return complex representation suitable for infinite inputs
    }

    double magSquared = real * real + imaginary * imaginary; // Compute squared magnitude
    if (magSquared == 0.0) {
        return NaN; // Safeguard against any division by zero
    }

    return createComplex(real / magSquared, -imaginary / magSquared); // Use denominator derived from magnitude squared
}",4,0
185,Math_50,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     if (x == x1) {
                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                         f0 = computeObjectiveValue(x0);
                     }
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Adjust for stagnation when x equals one of the bounds.
                    if (x == x1 || FastMath.abs(x - x1) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }",0,0
185,Math_50,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     if (x == x1) {
                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                         f0 = computeObjectiveValue(x0);
                     }
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it.
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
            case ILLINOIS:
                f0 *= 0.5;
                break;
            case PEGASUS:
                f0 *= f1 / (f1 + fx);
                break;
            case REGULA_FALSI:
                if (x == x1 || FastMath.abs(x - x1) < atol) {
                    x0 = 0.5 * (x0 + x1);
                    f0 = computeObjectiveValue(x0);
                }
                break;
            default:
                throw new MathInternalError();
            }
        }

        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;

        // If the current interval is within the given accuracies, return.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            return inverted ? x1 : x0;
        }
        
        if (FastMath.abs(f1) <= ftol) {
            return x1;
        }
    }
}",1,0
185,Math_50,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     if (x == x1) {
                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                         f0 = computeObjectiveValue(x0);
                     }
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution
    verifyBracketing(x0, x1);

    // Get accuracies
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals
    boolean inverted = false;

    // Keep finding better approximations
    while (true) {
        // Calculate the next approximation
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
            case ILLINOIS:
                f0 *= 0.5;
                break;
            case PEGASUS:
                f0 *= f1 / (f1 + fx);
                break;
            case REGULA_FALSI:
                if (x == x1) {
                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                    f0 = computeObjectiveValue(x0);
                } else {
                    f0 *= 0.5;
                }
                break;
            default:
                throw new MathInternalError();
            }
        }

        // Update from [x0, x1] to [x0, x]
        x1 = x;
        f1 = fx;

        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
            case ANY_SIDE:
                return x1;
            case LEFT_SIDE:
                return inverted ? x1 : x0;
            case RIGHT_SIDE:
                return inverted ? x0 : x1;
            case BELOW_SIDE:
                return (f1 <= 0) ? x1 : x0;
            case ABOVE_SIDE:
                return (f1 >= 0) ? x1 : x0;
            default:
                throw new MathInternalError();
            }
        }

        // If the current interval is within the given accuracies, we are satisfied with the current approximation
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
            case ANY_SIDE:
                return x1;
            case LEFT_SIDE:
                return inverted ? x1 : x0;
            case RIGHT_SIDE:
                return inverted ? x0 : x1;
            case BELOW_SIDE:
                return (f1 <= 0) ? x1 : x0;
            case ABOVE_SIDE:
                return (f1 >= 0) ? x1 : x0;
            default:
                throw new MathInternalError();
            }
        }
    }
}",2,0
185,Math_50,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     if (x == x1) {
                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                         f0 = computeObjectiveValue(x0);
                     }
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals.
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation using the Regula-Falsi formula.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // Return if new approximation is the exact root.
        if (fx == 0.0) {
            return x;
        }

        // Update bounds.
        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    if (x == x1 || FastMath.abs(x - x1) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
                        // Adjust bounds to avoid stagnation in Regula-Falsi
                        double step = FastMath.max(rtol * FastMath.abs(x1), atol);
                        x0 = x0 - step;
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;

        // If within function value accuracy, we're close enough to the root.
        if (FastMath.abs(f1) <= ftol) {
            return (allowed == AllowedSolution.ANY_SIDE || allowed == AllowedSolution.LEFT_SIDE && inverted || allowed == AllowedSolution.RIGHT_SIDE && !inverted || allowed == AllowedSolution.BELOW_SIDE && f1 <= 0 || allowed == AllowedSolution.ABOVE_SIDE && f1 >= 0) ? x1 : x0;
        }

        // If current interval is within given accuracies, return the best approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",3,0
185,Math_50,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     if (x == x1) {
                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                         f0 = computeObjectiveValue(x0);
                     }
                     break;
                 default:
                     // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }",Match failed,4,0
186,Math_51,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }

        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                default:
                    // Should never happen.
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;

        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }

        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }

        // Check for maximum evaluations.
        incrementEvaluationCount();
    }
}",0,0
186,Math_51,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }",Match failed,1,0
186,Math_51,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;

    // Keep finding better approximations.
    while (true) {
        // Increment evaluation count to avoid infinite loops
        incrementEvaluationCount();

        // Calculate the next approximation using the Regula Falsi formula
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        // If the new approximation is the exact root, return it.
        if (fx == 0.0) {
            return x;
        }

        // Adjust the bounds based on the computed value
        if (f1 * fx < 0) {
            // Update x0 to x1 and f0 to f1, invert the interval
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            // Depending on the method, adjust f0 to improve convergence
            switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                default:
                    // Unexpected method, should not happen
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x]
        x1 = x;
        f1 = fx;

        // Check function value accuracy
        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return f1 <= 0 ? x1 : x0;
                case ABOVE_SIDE:
                    return f1 >= 0 ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }

        // Check interval accuracy
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return f1 <= 0 ? x1 : x0;
                case ABOVE_SIDE:
                    return f1 >= 0 ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",2,0
186,Math_51,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    if (f0 * f1 > 0) {
        throw new NoBracketingException(x0, x1, f0, f1);
    }

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    boolean inverted = false;

    while (true) {
        incrementEvaluationCount();

        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);

        if (fx == 0.0) {
            return x;
        }

        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            x0 = x;
            f0 = fx;
        }
        x1 = x;
        f1 = fx;

        if (FastMath.abs(f1) <= ftol) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return f1 <= 0 ? x1 : x0;
                case ABOVE_SIDE:
                    return f1 >= 0 ? x1 : x0;
            }
        }

        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return f1 <= 0 ? x1 : x0;
                case ABOVE_SIDE:
                    return f1 >= 0 ? x1 : x0;
            }
        }
    }
}",3,0
186,Math_51,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);

    // If one of the bounds is the exact root, return it.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }

    // Verify bracketing of initial solution.
    if (f0 * f1 > 0) {
        throw new NoBracketingException(x0, x1, f0, f1);
    }

    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();

    // Track the number of evaluations to avoid an infinite loop
    int evaluations = 0;

    boolean inverted = false;

    while (true) {
        incrementEvaluationCount();

        final double x = (x0 * f1 - x1 * f0) / (f1 - f0);
        final double fx = computeObjectiveValue(x);

        if (fx == 0.0) {
            return x;
        }

        if (evaluations >= getMaxEvaluations()) {
            throw new TooManyEvaluationsException(evaluations);
        }

        if (f1 * fx < 0) {
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        }

        x1 = x;
        f1 = fx;
        evaluations++;

        if (FastMath.abs(f1) <= ftol || FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return f1 <= 0 ? x1 : x0;
                case ABOVE_SIDE:
                    return f1 >= 0 ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",4,0
187,Math_52,"  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

  // norms computation
  double u1u1 = u1.getNormSq();
  double u2u2 = u2.getNormSq();
  double v1v1 = v1.getNormSq();
  double v2v2 = v2.getNormSq();
  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
  }

  // normalize v1 in order to have (v1'|v1') = (u1|u1)
  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
  double u1u2   = u1.dotProduct(u2);
  double v1v2   = v1.dotProduct(v2);
  double coeffU = u1u2 / u1u1;
  double coeffV = v1v2 / u1u1;
  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
  double alpha  = coeffU - beta * coeffV;
  v2 = new Vector3D(alpha, v1, beta, v2);

  // preliminary computation
  Vector3D uRef  = u1;
  Vector3D vRef  = v1;
  Vector3D v1Su1 = v1.subtract(u1);
  Vector3D v2Su2 = v2.subtract(u2);
  Vector3D k     = v1Su1.crossProduct(v2Su2);
  Vector3D u3    = u1.crossProduct(u2);
  double c       = k.dotProduct(u3);
  if (c == 0) {
    // the (q1, q2, q3) vector is close to the (u1, u2) plane
    // we try other vectors
    Vector3D v3 = Vector3D.crossProduct(v1, v2);
    Vector3D v3Su3 = v3.subtract(u3);
    k = v1Su1.crossProduct(v3Su3);
    Vector3D u2Prime = u1.crossProduct(u3);
    c = k.dotProduct(u2Prime);

    if (c == 0) {
      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
      k = v2Su2.crossProduct(v3Su3);;
      c = k.dotProduct(u2.crossProduct(u3));;

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

  }

  // compute the vectorial part
  c = FastMath.sqrt(c);
  double inv = 1.0 / (c + c);
  q1 = inv * k.getX();
  q2 = inv * k.getY();
  q3 = inv * k.getZ();

  // compute the scalar part
   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                    uRef.getZ() * q1 - uRef.getX() * q3,
                    uRef.getX() * q2 - uRef.getY() * q1);
  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

  }
","public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw new IllegalArgumentException(""Zero norm for rotation defining vector"");
    }

    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    
    if (v2v2 - v1v2 * coeffV <= 0) {
        throw new IllegalArgumentException(""Invalid configuration for rotation"");
    }

    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);

    // preliminary computation
    Vector3D uRef = u1;
    Vector3D vRef = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);

    if (FastMath.abs(c) < Precision.EPSILON) {
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);

        if (FastMath.abs(c) < Precision.EPSILON) {
            k = v2Su2.crossProduct(v3Su3);
            c = k.dotProduct(u2.crossProduct(u3));

            if (FastMath.abs(c) < Precision.EPSILON) {
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }

            uRef = u2;
            vRef = v2;
        }
    }

    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();

    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                     uRef.getZ() * q1 - uRef.getX() * q3,
                     uRef.getX() * q2 - uRef.getY() * q1);

    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

}",0,0
187,Math_52,"  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

  // norms computation
  double u1u1 = u1.getNormSq();
  double u2u2 = u2.getNormSq();
  double v1v1 = v1.getNormSq();
  double v2v2 = v2.getNormSq();
  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
  }

  // normalize v1 in order to have (v1'|v1') = (u1|u1)
  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
  double u1u2   = u1.dotProduct(u2);
  double v1v2   = v1.dotProduct(v2);
  double coeffU = u1u2 / u1u1;
  double coeffV = v1v2 / u1u1;
  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
  double alpha  = coeffU - beta * coeffV;
  v2 = new Vector3D(alpha, v1, beta, v2);

  // preliminary computation
  Vector3D uRef  = u1;
  Vector3D vRef  = v1;
  Vector3D v1Su1 = v1.subtract(u1);
  Vector3D v2Su2 = v2.subtract(u2);
  Vector3D k     = v1Su1.crossProduct(v2Su2);
  Vector3D u3    = u1.crossProduct(u2);
  double c       = k.dotProduct(u3);
  if (c == 0) {
    // the (q1, q2, q3) vector is close to the (u1, u2) plane
    // we try other vectors
    Vector3D v3 = Vector3D.crossProduct(v1, v2);
    Vector3D v3Su3 = v3.subtract(u3);
    k = v1Su1.crossProduct(v3Su3);
    Vector3D u2Prime = u1.crossProduct(u3);
    c = k.dotProduct(u2Prime);

    if (c == 0) {
      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
      k = v2Su2.crossProduct(v3Su3);;
      c = k.dotProduct(u2.crossProduct(u3));;

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

  }

  // compute the vectorial part
  c = FastMath.sqrt(c);
  double inv = 1.0 / (c + c);
  q1 = inv * k.getX();
  q2 = inv * k.getY();
  q3 = inv * k.getZ();

  // compute the scalar part
   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                    uRef.getZ() * q1 - uRef.getX() * q3,
                    uRef.getX() * q2 - uRef.getY() * q1);
  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

  }
","public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }

    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;

    double v2v2Corrected;
    if (v2v2 - v1v2 * coeffV <= 0) {
        v2v2Corrected = FastMath.abs(v2v2 - v1v2 * coeffV) >= 1e-10 ? v2v2 : 1; // correction based on significant threshold
    } else {
        v2v2Corrected = v2v2;
    }

    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2Corrected - v1v2 * coeffV));
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);

    // preliminary computation
    Vector3D uRef = u1;
    Vector3D vRef = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);
    if (c == 0) {
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);

        if (c == 0) {
            k = v2Su2.crossProduct(v3Su3);
            c = k.dotProduct(u2.crossProduct(u3));

            if (c == 0) {
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }

            uRef = u2;
            vRef = v2;
        }
    }

    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();

    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                     uRef.getZ() * q1 - uRef.getX() * q3,
                     uRef.getX() * q2 - uRef.getY() * q1);

    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}",1,0
187,Math_52,"  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

  // norms computation
  double u1u1 = u1.getNormSq();
  double u2u2 = u2.getNormSq();
  double v1v1 = v1.getNormSq();
  double v2v2 = v2.getNormSq();
  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
  }

  // normalize v1 in order to have (v1'|v1') = (u1|u1)
  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
  double u1u2   = u1.dotProduct(u2);
  double v1v2   = v1.dotProduct(v2);
  double coeffU = u1u2 / u1u1;
  double coeffV = v1v2 / u1u1;
  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
  double alpha  = coeffU - beta * coeffV;
  v2 = new Vector3D(alpha, v1, beta, v2);

  // preliminary computation
  Vector3D uRef  = u1;
  Vector3D vRef  = v1;
  Vector3D v1Su1 = v1.subtract(u1);
  Vector3D v2Su2 = v2.subtract(u2);
  Vector3D k     = v1Su1.crossProduct(v2Su2);
  Vector3D u3    = u1.crossProduct(u2);
  double c       = k.dotProduct(u3);
  if (c == 0) {
    // the (q1, q2, q3) vector is close to the (u1, u2) plane
    // we try other vectors
    Vector3D v3 = Vector3D.crossProduct(v1, v2);
    Vector3D v3Su3 = v3.subtract(u3);
    k = v1Su1.crossProduct(v3Su3);
    Vector3D u2Prime = u1.crossProduct(u3);
    c = k.dotProduct(u2Prime);

    if (c == 0) {
      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
      k = v2Su2.crossProduct(v3Su3);;
      c = k.dotProduct(u2.crossProduct(u3));;

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

  }

  // compute the vectorial part
  c = FastMath.sqrt(c);
  double inv = 1.0 / (c + c);
  q1 = inv * k.getX();
  q2 = inv * k.getY();
  q3 = inv * k.getZ();

  // compute the scalar part
   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                    uRef.getZ() * q1 - uRef.getX() * q3,
                    uRef.getX() * q2 - uRef.getY() * q1);
  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

  }
","public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }

    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2   = u1.dotProduct(u2);
    double v1v2   = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    if ((v2v2 - v1v2 * coeffV) <= Precision.EPSILON) {
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
    }
    double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
    double alpha  = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);

    // preliminary computation
    Vector3D uRef  = u1;
    Vector3D vRef  = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k     = v1Su1.crossProduct(v2Su2);
    Vector3D u3    = u1.crossProduct(u2);
    double c       = k.dotProduct(u3);
    if (FastMath.abs(c) < Precision.EPSILON) {
        // align condition, compute directly if close to aligned
        if (FastMath.abs(u1.dotProduct(v1Su1)) < Precision.EPSILON) {
            q0 = 1.0;
            q1 = 0.0;
            q2 = 0.0;
            q3 = 0.0;
            return;
        }
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);

        if (FastMath.abs(c) < Precision.EPSILON) {
            k = v2Su2.crossProduct(v3Su3);
            c = k.dotProduct(u2.crossProduct(u3));

            if (FastMath.abs(c) < Precision.EPSILON) {
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }
            uRef = u2;
            vRef = v2;
        }
    }

    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();

    // compute the scalar part
     k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                      uRef.getZ() * q1 - uRef.getX() * q3,
                      uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

}",2,0
187,Math_52,"  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

  // norms computation
  double u1u1 = u1.getNormSq();
  double u2u2 = u2.getNormSq();
  double v1v1 = v1.getNormSq();
  double v2v2 = v2.getNormSq();
  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
  }

  // normalize v1 in order to have (v1'|v1') = (u1|u1)
  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
  double u1u2   = u1.dotProduct(u2);
  double v1v2   = v1.dotProduct(v2);
  double coeffU = u1u2 / u1u1;
  double coeffV = v1v2 / u1u1;
  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
  double alpha  = coeffU - beta * coeffV;
  v2 = new Vector3D(alpha, v1, beta, v2);

  // preliminary computation
  Vector3D uRef  = u1;
  Vector3D vRef  = v1;
  Vector3D v1Su1 = v1.subtract(u1);
  Vector3D v2Su2 = v2.subtract(u2);
  Vector3D k     = v1Su1.crossProduct(v2Su2);
  Vector3D u3    = u1.crossProduct(u2);
  double c       = k.dotProduct(u3);
  if (c == 0) {
    // the (q1, q2, q3) vector is close to the (u1, u2) plane
    // we try other vectors
    Vector3D v3 = Vector3D.crossProduct(v1, v2);
    Vector3D v3Su3 = v3.subtract(u3);
    k = v1Su1.crossProduct(v3Su3);
    Vector3D u2Prime = u1.crossProduct(u3);
    c = k.dotProduct(u2Prime);

    if (c == 0) {
      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
      k = v2Su2.crossProduct(v3Su3);;
      c = k.dotProduct(u2.crossProduct(u3));;

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

  }

  // compute the vectorial part
  c = FastMath.sqrt(c);
  double inv = 1.0 / (c + c);
  q1 = inv * k.getX();
  q2 = inv * k.getY();
  q3 = inv * k.getZ();

  // compute the scalar part
   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                    uRef.getZ() * q1 - uRef.getX() * q3,
                    uRef.getX() * q2 - uRef.getY() * q1);
  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

  }
","public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }

    // normalize v1 to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

    // adjust v2 to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2   = u1.dotProduct(u2);
    double v1v2   = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    double denom  = v2v2 - v1v2 * coeffV;

    if (denom <= 0) {
        // switch to identity rotation if denominator is zero or negative
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
    }

    double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / denom);
    double alpha  = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);

    // preliminary computation
    Vector3D uRef  = u1;
    Vector3D vRef  = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k     = v1Su1.crossProduct(v2Su2);
    Vector3D u3    = u1.crossProduct(u2);
    double c       = k.dotProduct(u3);

    if (FastMath.abs(c) < Precision.EPSILON) {
        // if c is close to zero, check potential alignments and return identity if necessary
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        c = k.dotProduct(u1.crossProduct(u3));

        if (FastMath.abs(c) < Precision.EPSILON) {
            c = k.dotProduct(u2.crossProduct(u3));

            if (FastMath.abs(c) < Precision.EPSILON) {
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }

            uRef = u2;
            vRef = v2;
        }
    }

    // compute vectorial part
    c = FastMath.sqrt(FastMath.abs(c)); // take absolute value to prevent NaN
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();

    // compute scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                     uRef.getZ() * q1 - uRef.getX() * q3,
                     uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}",3,0
187,Math_52,"  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {

  // norms computation
  double u1u1 = u1.getNormSq();
  double u2u2 = u2.getNormSq();
  double v1v1 = v1.getNormSq();
  double v2v2 = v2.getNormSq();
  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
  }

  // normalize v1 in order to have (v1'|v1') = (u1|u1)
  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
  double u1u2   = u1.dotProduct(u2);
  double v1v2   = v1.dotProduct(v2);
  double coeffU = u1u2 / u1u1;
  double coeffV = v1v2 / u1u1;
  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
  double alpha  = coeffU - beta * coeffV;
  v2 = new Vector3D(alpha, v1, beta, v2);

  // preliminary computation
  Vector3D uRef  = u1;
  Vector3D vRef  = v1;
  Vector3D v1Su1 = v1.subtract(u1);
  Vector3D v2Su2 = v2.subtract(u2);
  Vector3D k     = v1Su1.crossProduct(v2Su2);
  Vector3D u3    = u1.crossProduct(u2);
  double c       = k.dotProduct(u3);
  if (c == 0) {
    // the (q1, q2, q3) vector is close to the (u1, u2) plane
    // we try other vectors
    Vector3D v3 = Vector3D.crossProduct(v1, v2);
    Vector3D v3Su3 = v3.subtract(u3);
    k = v1Su1.crossProduct(v3Su3);
    Vector3D u2Prime = u1.crossProduct(u3);
    c = k.dotProduct(u2Prime);

    if (c == 0) {
      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
      k = v2Su2.crossProduct(v3Su3);;
      c = k.dotProduct(u2.crossProduct(u3));;

      if (c == 0) {
        // the (q1, q2, q3) vector is aligned with everything
        // this is really the identity rotation
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
      }

      // we will have to use u2 and v2 to compute the scalar part
      uRef = u2;
      vRef = v2;

    }

  }

  // compute the vectorial part
  c = FastMath.sqrt(c);
  double inv = 1.0 / (c + c);
  q1 = inv * k.getX();
  q2 = inv * k.getY();
  q3 = inv * k.getZ();

  // compute the scalar part
   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                    uRef.getZ() * q1 - uRef.getX() * q3,
                    uRef.getX() * q2 - uRef.getY() * q1);
  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());

  }
","public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }

    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);

    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    double denominator = v2v2 - v1v2 * coeffV;
    // Added check for numerical stability
    if (FastMath.abs(denominator) < Precision.EPSILON) {
        q0 = 1.0;
        q1 = 0.0;
        q2 = 0.0;
        q3 = 0.0;
        return;
    }

    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / denominator);
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);

    // preliminary computation
    Vector3D uRef = u1;
    Vector3D vRef = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);
    if (FastMath.abs(c) < Precision.EPSILON) {
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);

        if (FastMath.abs(c) < Precision.EPSILON) {
            k = v2Su2.crossProduct(v3Su3);
            c = k.dotProduct(u2.crossProduct(u3));

            if (FastMath.abs(c) < Precision.EPSILON) {
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }

            uRef = u2;
            vRef = v2;
        }
    }

    // compute the vectorial part
    c = FastMath.sqrt(FastMath.abs(c)); // Correct use of absolute value for stability
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();

    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                     uRef.getZ() * q1 - uRef.getX() * q3,
                     uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}",4,0
188,Math_53,"public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }","public Complex add(Complex rhs) throws NullArgumentException {
    MathUtils.checkNotNull(rhs);
    if (Double.isNaN(real) || Double.isNaN(imaginary) || Double.isNaN(rhs.getReal()) || Double.isNaN(rhs.getImaginary())) {
        return Complex.NaN;
    }
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}",0,0
189,Math_55,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


      // rescale both vectors without losing precision,
      // to ensure their norm are the same order of magnitude

      // we reduce cancellation errors by preconditioning,
      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
      // v3 without loss of precision. See Kahan lecture
      // ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
 
 
       // compute cross product from v3 and v2 instead of v1 and v2
       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }","public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
    // compute rho as an approximation of v1.v2 / v2.v2
    double dot_v1_v2 = v1.dotProduct(v2);
    double dot_v2_v2 = v2.dotProduct(v2);
    double rho = dot_v1_v2 / dot_v2_v2;

    // precondition v1
    Vector3D v3 = new Vector3D(1.0, v1, -rho, v2);
    
    // compute cross product from v3 and v2 instead of v1 and v2
    return new Vector3D(v3.getY() * v2.getZ() - v3.getZ() * v2.getY(),
                        v3.getZ() * v2.getX() - v3.getX() * v2.getZ(),
                        v3.getX() * v2.getY() - v3.getY() * v2.getX());
}",0,0
189,Math_55,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


      // rescale both vectors without losing precision,
      // to ensure their norm are the same order of magnitude

      // we reduce cancellation errors by preconditioning,
      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
      // v3 without loss of precision. See Kahan lecture
      // ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
 
 
       // compute cross product from v3 and v2 instead of v1 and v2
       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }","public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {

    double rho = Math.rint(8 * (v1.dotProduct(v2) / v2.dotProduct(v2))) / 8.0;

    Vector3D v3 = new Vector3D(1.0, v1, -rho, v2);
    
    return new Vector3D(v3.getY() * v2.getZ() - v3.getZ() * v2.getY(),
                        v3.getZ() * v2.getX() - v3.getX() * v2.getZ(),
                        v3.getX() * v2.getY() - v3.getY() * v2.getX());
}",1,0
189,Math_55,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


      // rescale both vectors without losing precision,
      // to ensure their norm are the same order of magnitude

      // we reduce cancellation errors by preconditioning,
      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
      // v3 without loss of precision. See Kahan lecture
      // ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
 
 
       // compute cross product from v3 and v2 instead of v1 and v2
       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }","public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
    // Compute rho precisely using unscaled dot products to minimize cancellation errors
    double dot_v1_v2 = v1.dotProduct(v2);
    double dot_v2_v2 = v2.dotProduct(v2);
    double rho = dot_v1_v2 / dot_v2_v2;

    // Adjust v1 to a safer preconditioned vector
    Vector3D v3 = new Vector3D(v1.getX() - rho * v2.getX(),
                               v1.getY() - rho * v2.getY(),
                               v1.getZ() - rho * v2.getZ());

    // Compute cross product between preconditioned vector v3 and v2
    return new Vector3D(v3.getY() * v2.getZ() - v3.getZ() * v2.getY(),
                        v3.getZ() * v2.getX() - v3.getX() * v2.getZ(),
                        v3.getX() * v2.getY() - v3.getY() * v2.getX());
}",2,0
189,Math_55,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


      // rescale both vectors without losing precision,
      // to ensure their norm are the same order of magnitude

      // we reduce cancellation errors by preconditioning,
      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
      // v3 without loss of precision. See Kahan lecture
      // ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
 
 
       // compute cross product from v3 and v2 instead of v1 and v2
       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }","public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
    // Calculate the scaled components to mitigate precision errors
    double scale = 1.0 / Math.max(Math.abs(v1.getX()), Math.max(Math.abs(v1.getY()), Math.abs(v1.getZ())));
    Vector3D scaledV1 = new Vector3D(v1.getX() * scale, v1.getY() * scale, v1.getZ() * scale);
    Vector3D scaledV2 = new Vector3D(v2.getX() * scale, v2.getY() * scale, v2.getZ() * scale);

    // Compute rho to precondition the vectors, reducing cancellation errors
    double rho = scaledV1.dotProduct(scaledV2) / scaledV2.dotProduct(scaledV2);
    Vector3D preconditionedV1 = new Vector3D(scaledV1.getX() - rho * scaledV2.getX(),
                                             scaledV1.getY() - rho * scaledV2.getY(),
                                             scaledV1.getZ() - rho * scaledV2.getZ());

    // Compute cross product using preconditioned vectors
    return new Vector3D(preconditionedV1.getY() * scaledV2.getZ() - preconditionedV1.getZ() * scaledV2.getY(),
                        preconditionedV1.getZ() * scaledV2.getX() - preconditionedV1.getX() * scaledV2.getZ(),
                        preconditionedV1.getX() * scaledV2.getY() - preconditionedV1.getY() * scaledV2.getX());
}",3,0
189,Math_55,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


      // rescale both vectors without losing precision,
      // to ensure their norm are the same order of magnitude

      // we reduce cancellation errors by preconditioning,
      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
      // v3 without loss of precision. See Kahan lecture
      // ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
 
 
       // compute cross product from v3 and v2 instead of v1 and v2
       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }","public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
    // Compute rho using accurate normalization to mitigate precision issues
    double scaleV1 = Math.sqrt(v1.getX() * v1.getX() + v1.getY() * v1.getY() + v1.getZ() * v1.getZ());
    double scaleV2 = Math.sqrt(v2.getX() * v2.getX() + v2.getY() * v2.getY() + v2.getZ() * v2.getZ());
    
    Vector3D normalizedV1 = new Vector3D(v1.getX() / scaleV1, v1.getY() / scaleV1, v1.getZ() / scaleV1);
    Vector3D normalizedV2 = new Vector3D(v2.getX() / scaleV2, v2.getY() / scaleV2, v2.getZ() / scaleV2);

    double rho = normalizedV1.dotProduct(normalizedV2);

    // Preconditioning v1 using rho to reduce cancellation errors
    Vector3D v3 = new Vector3D(normalizedV1.getX() - rho * normalizedV2.getX(),
                               normalizedV1.getY() - rho * normalizedV2.getY(),
                               normalizedV1.getZ() - rho * normalizedV2.getZ());

    // Compute cross product between preconditioned v3 and normalized v2
    return new Vector3D(v3.getY() * normalizedV2.getZ() - v3.getZ() * normalizedV2.getY(),
                        v3.getZ() * normalizedV2.getX() - v3.getX() * normalizedV2.getZ(),
                        v3.getX() * normalizedV2.getY() - v3.getY() * normalizedV2.getX());
}",4,0
190,Math_56,"public int[] getCounts(int index) {
        if (index < 0 ||
            index >= totalSize) {
            throw new OutOfRangeException(index, 0, totalSize);
        }

        final int[] indices = new int[dimension];

        int count = 0;
        for (int i = 0; i < last; i++) {
            int idx = 0;
            final int offset = uniCounterOffset[i];
            while (count <= index) {
                count += offset;
                ++idx;
            }
            --idx;
            count -= offset;
             indices[i] = idx;
         }
 
         int idx = 1;
         while (count < index) {
             count += idx;
             ++idx;
         }
         --idx;
         indices[last] = idx;
 
         return indices;
     }","public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize);
    }

    final int[] indices = new int[dimension];
    int count = 0;

    for (int i = 0; i < last; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while ((count + offset) <= index) {
            count += offset;
            ++idx;
        }
        indices[i] = idx;
    }

    int idx = 0;
    while (count < index) {
        ++count;
        ++idx;
    }
    indices[last] = idx;

    return indices;
}",0,0
191,Math_57,"private static <T extends Clusterable<T>> List<Cluster<T>>
        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {

        final List<T> pointSet = new ArrayList<T>(points);
        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();

        // Choose one center uniformly at random from among the data points.
        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
        resultSet.add(new Cluster<T>(firstPoint));

        final double[] dx2 = new double[pointSet.size()];
        while (resultSet.size() < k) {
            // For each data point x, compute D(x), the distance between x and
            // the nearest center that has already been chosen.
            int sum = 0;
            for (int i = 0; i < pointSet.size(); i++) {
                final T p = pointSet.get(i);
                final Cluster<T> nearest = getNearestCluster(resultSet, p);
                final double d = p.distanceFrom(nearest.getCenter());
                sum += d * d;
                dx2[i] = sum;
            }

            // Add one new data point as a center. Each point x is chosen with
            // probability proportional to D(x)2
            final double r = random.nextDouble() * sum;
            for (int i = 0 ; i < dx2.length; i++) {
                if (dx2[i] >= r) {
                    final T p = pointSet.remove(i);
                    resultSet.add(new Cluster<T>(p));
                    break;
                }
            }
        }

        return resultSet;

    }
","private static <T extends Clusterable<T>> List<Cluster<T>> 
chooseInitialCenters(final Collection<T> points, final int k, final Random random) {
    final List<T> pointSet = new ArrayList<T>(points);
    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();

    // Choose one center uniformly at random from among the data points.
    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
    resultSet.add(new Cluster<T>(firstPoint));

    final double[] dx2 = new double[pointSet.size()];
    while (resultSet.size() < k) {
        // For each data point x, compute D(x), the distance between x and
        // the nearest center that has already been chosen.
        double sum = 0; // should be double for accumulating squared distances
        for (int i = 0; i < pointSet.size(); i++) {
            final T p = pointSet.get(i);
            final Cluster<T> nearest = getNearestCluster(resultSet, p);
            final double d = p.distanceFrom(nearest.getCenter());
            dx2[i] = d * d; // Store squared distance in dx2 directly
            sum += dx2[i];  // Accumulate sum of squared distances
        }

        // Add one new data point as a center. Each point x is chosen with
        // probability proportional to D(x)^2
        final double r = random.nextDouble() * sum;
        for (int i = 0; i < dx2.length; i++) {
            if (r <= dx2[i]) { // Correct condition to find the point based on distance proportion
                final T p = pointSet.remove(i);
                resultSet.add(new Cluster<T>(p));
                dx2[i] = 0; // Optional cleanup for clarity
                break;
            }
        }
    }

    return resultSet;
}",0,0
191,Math_57,"private static <T extends Clusterable<T>> List<Cluster<T>>
        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {

        final List<T> pointSet = new ArrayList<T>(points);
        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();

        // Choose one center uniformly at random from among the data points.
        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
        resultSet.add(new Cluster<T>(firstPoint));

        final double[] dx2 = new double[pointSet.size()];
        while (resultSet.size() < k) {
            // For each data point x, compute D(x), the distance between x and
            // the nearest center that has already been chosen.
            int sum = 0;
            for (int i = 0; i < pointSet.size(); i++) {
                final T p = pointSet.get(i);
                final Cluster<T> nearest = getNearestCluster(resultSet, p);
                final double d = p.distanceFrom(nearest.getCenter());
                sum += d * d;
                dx2[i] = sum;
            }

            // Add one new data point as a center. Each point x is chosen with
            // probability proportional to D(x)2
            final double r = random.nextDouble() * sum;
            for (int i = 0 ; i < dx2.length; i++) {
                if (dx2[i] >= r) {
                    final T p = pointSet.remove(i);
                    resultSet.add(new Cluster<T>(p));
                    break;
                }
            }
        }

        return resultSet;

    }
","private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) {
    final List<T> pointSet = new ArrayList<T>(points);
    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();

    // Choose one center uniformly at random from among the data points.
    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
    resultSet.add(new Cluster<T>(firstPoint));

    final double[] dx2 = new double[pointSet.size()];
    while (resultSet.size() < k) {
        // For each data point x, compute D(x), the distance between x and
        // the nearest center that has already been chosen.
        double sumSquaredDistances = 0;
        for (int i = 0; i < pointSet.size(); i++) {
            final T p = pointSet.get(i);
            final Cluster<T> nearest = getNearestCluster(resultSet, p);
            final double squaredDistance = Math.pow(p.distanceFrom(nearest.getCenter()), 2);
            dx2[i] = squaredDistance;
            sumSquaredDistances += squaredDistance;
        }

        // Normalize probabilities based on squared distances and choose a new center
        final double target = random.nextDouble() * sumSquaredDistances;
        double cumulativeProbability = 0;
        T chosenPoint = null;
        for (int i = 0; i < dx2.length; i++) {
            cumulativeProbability += dx2[i];
            if (cumulativeProbability >= target) {
                chosenPoint = pointSet.remove(i);
                dx2[i] = 0; // Avoid probabilities carrying over after removal
                break;
            }
        }

        if (chosenPoint != null) {
            resultSet.add(new Cluster<T>(chosenPoint));
        }
    }

    return resultSet;
}",1,0
192,Math_58,"public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
         return fit(new Gaussian.Parametric(), guess);
     }","public double[] fit() {
    // Retrieve observations
    final WeightedObservedPoint[] observations = getObservations();
    if (observations == null || observations.length == 0) {
        throw new IllegalArgumentException(""Observations cannot be null or empty."");
    }

    // Generate initial guess, ensuring valid values
    final double[] guess = (new ParameterGuesser(observations)).guess();
    for (double value : guess) {
        if (value <= 0) {
            throw new org.apache.commons.math.exception.NotStrictlyPositiveException(value);
        }
    }

    // Fit using the Gaussian.Parametric model
    return fit(new Gaussian.Parametric(), guess);
}",0,0
192,Math_58,"public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
         return fit(new Gaussian.Parametric(), guess);
     }","public double[] fit() {
    // Retrieve observations
    final WeightedObservedPoint[] observations = getObservations();
    if (observations == null || observations.length == 0) {
        throw new IllegalArgumentException(""Observations cannot be null or empty."");
    }

    // Generate initial guess while correcting invalid values
    final double[] guess = (new ParameterGuesser(observations)).guess();
    for (int i = 0; i < guess.length; i++) {
        if (guess[i] <= 0) {
            guess[i] = Math.abs(guess[i]) + 1.0; // Ensure strictly positive values
        }
    }

    // Fit using the Gaussian.Parametric model
    return fit(new Gaussian.Parametric(), guess);
}",1,0
192,Math_58,"public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
         return fit(new Gaussian.Parametric(), guess);
     }","public double[] fit() {
    final WeightedObservedPoint[] observations = getObservations();
    if (observations == null || observations.length == 0) {
        throw new IllegalArgumentException(""Observations cannot be null or empty."");
    }

    // Generate initial guess
    final double[] guess = (new ParameterGuesser(observations)).guess();

    // Adjust any invalid parameters to default values
    if (guess == null || guess.length < 3) {
        throw new IllegalStateException(""Generated guess is invalid."");
    }
    guess[0] = Math.max(guess[0], 1.0); // Ensure strictly positive amplitude
    guess[1] = Math.max(guess[1], 0.0); // Ensure non-negative mean
    guess[2] = Math.max(guess[2], 0.1); // Ensure strictly positive sigma

    // Fit using the Gaussian.Parametric model
    return fit(new Gaussian.Parametric(), guess);
}",2,0
192,Math_58,"public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
         return fit(new Gaussian.Parametric(), guess);
     }","public double[] fit() {
    // Retrieve observations
    final WeightedObservedPoint[] observations = getObservations();
    if (observations == null || observations.length == 0) {
        throw new IllegalArgumentException(""Observations cannot be null or empty."");
    }

    // Generate initial guess and sanitize invalid values during computation
    final double[] guess = (new ParameterGuesser(observations)).guess();
    if (guess == null || guess.length < 3) {
        throw new IllegalStateException(""Generated guess is invalid."");
    }

    // Adjust parameters dynamically to avoid invalid values
    for (int i = 0; i < guess.length; i++) {
        if (i == 0 || i == 2) { // Adjust amplitude and sigma for strict positivity
            if (guess[i] <= 0) {
                guess[i] = 1.0; // Default strictly positive value
            }
        } else if (i == 1) { // Adjust mean to a reasonable range
            if (guess[i] < 0 || Double.isNaN(guess[i])) {
                guess[i] = 0.0; // Default non-negative value
            }
        }
    }

    // Fit using the Gaussian.Parametric model
    return fit(new Gaussian.Parametric(), guess);
}",3,0
192,Math_58,"public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
         return fit(new Gaussian.Parametric(), guess);
     }","public double[] fit() {
    // Retrieve observations
    final WeightedObservedPoint[] observations = getObservations();
    if (observations == null || observations.length == 0) {
        throw new IllegalArgumentException(""Observations cannot be null or empty."");
    }

    // Generate initial guess and validate each parameter during initialization
    final double[] guess = (new ParameterGuesser(observations)).guess();
    if (guess == null || guess.length < 3) {
        throw new IllegalStateException(""Generated guess is invalid."");
    }

    // Validate amplitude
    if (guess[0] <= 0) {
        throw new org.apache.commons.math.exception.NotStrictlyPositiveException(guess[0]);
    }

    // Validate sigma
    if (guess[2] <= 0) {
        throw new org.apache.commons.math.exception.NotStrictlyPositiveException(guess[2]);
    }

    // Fit using the Gaussian.Parametric model
    return fit(new Gaussian.Parametric(), guess);
}",4,0
193,Math_59,"    public static float max(final float a, final float b) {
        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
    }
","public static float max(final float a, final float b) {
    if (Float.isNaN(a) || Float.isNaN(b)) {
        return Float.NaN;
    }
    return (a >= b) ? a : b;
}",0,0
194,Math_60,"public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
         try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
         } catch (MaxIterationsExceededException ex) {
             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                 return 0;
             } else if (x > (mean + 20 * standardDeviation)) {
                 return 1;
             } else {
                 throw ex;
             }
         }
     }","public double cumulativeProbability(double x) throws MathException {
    try {
        final double dev = x - mean;
        return 0.5 * (1.0 + Erf.erf(dev / (standardDeviation * FastMath.sqrt(2.0))));
    } catch (MaxIterationsExceededException ex) {
        if (Double.isInfinite(x)) {
            return x < mean ? 0 : 1;
        } else if (x < (mean - 20 * standardDeviation)) {
            return 0;
        } else if (x > (mean + 20 * standardDeviation)) {
            return 1;
        } else {
            throw ex;
        }
    }
}",0,0
194,Math_60,"public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
         try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
         } catch (MaxIterationsExceededException ex) {
             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                 return 0;
             } else if (x > (mean + 20 * standardDeviation)) {
                 return 1;
             } else {
                 throw ex;
             }
         }
     }","public double cumulativeProbability(double x) throws MathException {
    final double dev = x - mean;
    if (Double.isInfinite(x)) {
        return x < mean ? 0 : 1;
    }
    try {
        return Erf.erf(dev / (standardDeviation * FastMath.sqrt(2.0)));
    } catch (MaxIterationsExceededException ex) {
        if (x < mean - 10 * standardDeviation) {
            return 0;
        } else if (x > mean + 10 * standardDeviation) {
            return 1;
        } else {
            throw ex;
        }
    }
}",1,0
194,Math_60,"public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
         try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
         } catch (MaxIterationsExceededException ex) {
             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                 return 0;
             } else if (x > (mean + 20 * standardDeviation)) {
                 return 1;
             } else {
                 throw ex;
             }
         }
     }","public double cumulativeProbability(double x) throws MathException {
    final double dev = x - mean;
    try {
        double erfResult = Erf.erf(dev / (standardDeviation * FastMath.sqrt(2.0)));
        if (Double.isNaN(erfResult)) {
            throw new MathException(""Computation resulted in NaN"");
        }
        return 0.5 * (1.0 + erfResult);
    } catch (MaxIterationsExceededException ex) {
        if (x < (mean - 20 * standardDeviation)) {
            return 0;
        } else if (x > (mean + 20 * standardDeviation)) {
            return 1;
        } else {
            throw ex;
        }
    }
}",2,0
194,Math_60,"public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
         try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
         } catch (MaxIterationsExceededException ex) {
             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                 return 0;
             } else if (x > (mean + 20 * standardDeviation)) {
                 return 1;
             } else {
                 throw ex;
             }
         }
     }","public double cumulativeProbability(double x) throws MathException {
    final double dev = x - mean;
    double scaledDev = dev / (standardDeviation * FastMath.sqrt(2.0));
    try {
        if (Double.isNaN(scaledDev) || Double.isInfinite(scaledDev)) {
            return x < mean ? 0 : 1;
        }
        return 0.5 * (1.0 + Erf.erf(scaledDev));
    } catch (MaxIterationsExceededException ex) {
        // Use a tighter threshold for extreme values
        if (x < (mean - 10 * standardDeviation)) {
            return 0;
        } else if (x > (mean + 10 * standardDeviation)) {
            return 1;
        } else {
            throw ex;
        }
    }
}",3,0
194,Math_60,"public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
         try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
         } catch (MaxIterationsExceededException ex) {
             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
                 return 0;
             } else if (x > (mean + 20 * standardDeviation)) {
                 return 1;
             } else {
                 throw ex;
             }
         }
     }","public double cumulativeProbability(double x) throws MathException {
    double dev = x - mean;
    double scaledDev = dev / (standardDeviation * FastMath.sqrt(2.0));
    if (Double.isNaN(scaledDev) || Double.isInfinite(scaledDev)) {
        if (x < mean) {
            return 0;
        } else {
            return 1;
        }
    }
    try {
        double erfResult = Erf.erf(scaledDev);
        return 0.5 * (1.0 + erfResult);
    } catch (MaxIterationsExceededException ex) {
        // Mid-range approximation
        if (scaledDev < -10) {
            return 0;
        } else if (scaledDev > 10) {
            return 1;
        } else {
            return 0.5 * (1.0 + (scaledDev < 0 ? -1 : 1) * Math.exp(-Math.abs(scaledDev)));
        }
    }
}",4,0
195,Math_63,"    public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
","public static boolean equals(double x, double y) {
    if (Double.isNaN(x) && Double.isNaN(y)) {
        return true;
    }
    if (Double.doubleToLongBits(x) == Double.doubleToLongBits(y)) {
        return true;
    }
    return false;
}",0,0
195,Math_63,"    public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
","public static boolean equals(double x, double y) {
    if (Double.isNaN(x) || Double.isNaN(y)) {
        return Double.isNaN(x) && Double.isNaN(y);
    }
    long bitsX = Double.doubleToLongBits(x);
    long bitsY = Double.doubleToLongBits(y);
    return bitsX == bitsY;
}",1,0
195,Math_63,"    public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
","public static boolean equals(double x, double y) {
    if (Double.isNaN(x) || Double.isNaN(y)) {
        return Double.isNaN(x) && Double.isNaN(y);
    }
    if (Double.compare(x, y) == 0) {
        return true;
    }
    return false;
}",2,0
195,Math_63,"    public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
","public static boolean equals(double x, double y) {
    if (Double.isNaN(x) || Double.isNaN(y)) {
        return Double.isNaN(x) && Double.isNaN(y);
    }
    if (Double.compare(x, y) == 0 || (x == 0.0 && y == 0.0)) {
        return true;
    }
    return false;
}",3,0
195,Math_63,"    public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
","public static boolean equals(double x, double y) {
    if (Double.isNaN(x) || Double.isNaN(y)) {
        return Double.isNaN(x) && Double.isNaN(y);
    }
    if (Double.compare(x, y) == 0 || (x == 0.0 && y == 0.0)) {
        return true;
    }
    if (Double.isInfinite(x) && Double.isInfinite(y)) {
        return Double.compare(x, y) == 0;
    }
    return false;
}",4,0
196,Math_64,"@Override
    protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        // arrays shared with the other private methods
        solvedCols  = Math.min(rows, cols);
        diagR       = new double[cols];
        jacNorm     = new double[cols];
        beta        = new double[cols];
        permutation = new int[cols];
        lmDir       = new double[cols];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[cols];
        double[] oldX    = new double[cols];
        double[] oldRes  = new double[rows];
        double[] work1   = new double[cols];
        double[] work2   = new double[cols];
        double[] work3   = new double[cols];

        // evaluate the function at the starting point and calculate its norm
        updateResidualsAndCost();

        // outer loop
        lmPar = 0;
        boolean firstIteration = true;
        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
        while (true) {
            incrementIterationsCounter();

            // compute the Q.R. decomposition of the jacobian matrix
            VectorialPointValuePair previous = current;
            updateJacobian();
             qrDecomposition();
 
             // compute Qt.res
             qTy(residuals);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                jacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {

                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * point[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = Math.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (cost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // convergence has been reached
                return current;
            }

            // rescale if necessary
            for (int j = 0; j < cols; ++j) {
                diag[j] = Math.max(diag[j], jacNorm[j]);
            }

            // inner loop
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }
                double previousCost = cost;
                double[] tmpVec = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(oldRes, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = Math.sqrt(lmNorm);
                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = Math.min(delta, lmNorm);
                }

                // evaluate the function at x + p and calculate its norm
                updateResidualsAndCost();
                current = new VectorialPointValuePair(point, objective);

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * cost < previousCost) {
                    double r = cost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += jacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * Math.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < cols; ++k) {
                        double xK = diag[k] * point[k];
                        xNorm    += xK * xK;
                    }
                    xNorm = Math.sqrt(xNorm);

                    // tests for convergence.
                    // we use the vectorial convergence checker
                } else {
                    // failed iteration, reset the previous values
                    cost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }
                    tmpVec    = residuals;
                    residuals = oldRes;
                    oldRes    = tmpVec;
                }
                if (checker==null) {
                	if (((Math.abs(actRed) <= costRelativeTolerance) &&
                        (preRed <= costRelativeTolerance) &&
                        (ratio <= 2.0)) ||
                       (delta <= parRelativeTolerance * xNorm)) {
                       return current;
                   }
                } else {
                    if (checker.converged(getIterations(), previous, current)) {
                        return current;
                    }
                }
                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                            costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                            parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                            orthoTolerance);
                }

            }

        }

    }","@Override
protected VectorialPointValuePair doOptimize()
    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];

    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];

    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();

    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
    while (true) {
        incrementIterationsCounter();

        // compute the Q.R. decomposition of the jacobian matrix
        VectorialPointValuePair previous = current;
        updateJacobian();
        qrDecomposition();

        // compute Qt.res
        qTy(residuals);
        // now we don't need Q anymore,
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }

        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);

            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }

        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return current;
        }

        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }

        // inner loop
        double ratio = 0;
        while (true) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;

            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);

            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }

            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);

            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }

            // compute the scaled predicted reduction
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);

            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);

            // update the step bound
            if (ratio <= 0.25) {
                double tmp =
                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }

            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);

                // tests for convergence.
                // we use the vectorial convergence checker
                break;
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }

            if (checker == null) {
                if (((Math.abs(actRed) <= costRelativeTolerance) &&
                     (preRed <= costRelativeTolerance) &&
                     (ratio <= 2.0)) ||
                    (delta <= parRelativeTolerance * xNorm)) {
                    return current;
                }
            } else {
                if (checker.converged(getIterations(), previous, current)) {
                    return current;
                }
            }

            // tests for termination and stringent tolerances
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                        costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                        parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                        orthoTolerance);
            }
        }
    }
}",0,0
196,Math_64,"@Override
    protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        // arrays shared with the other private methods
        solvedCols  = Math.min(rows, cols);
        diagR       = new double[cols];
        jacNorm     = new double[cols];
        beta        = new double[cols];
        permutation = new int[cols];
        lmDir       = new double[cols];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[cols];
        double[] oldX    = new double[cols];
        double[] oldRes  = new double[rows];
        double[] work1   = new double[cols];
        double[] work2   = new double[cols];
        double[] work3   = new double[cols];

        // evaluate the function at the starting point and calculate its norm
        updateResidualsAndCost();

        // outer loop
        lmPar = 0;
        boolean firstIteration = true;
        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
        while (true) {
            incrementIterationsCounter();

            // compute the Q.R. decomposition of the jacobian matrix
            VectorialPointValuePair previous = current;
            updateJacobian();
             qrDecomposition();
 
             // compute Qt.res
             qTy(residuals);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                jacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {

                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * point[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = Math.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (cost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // convergence has been reached
                return current;
            }

            // rescale if necessary
            for (int j = 0; j < cols; ++j) {
                diag[j] = Math.max(diag[j], jacNorm[j]);
            }

            // inner loop
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }
                double previousCost = cost;
                double[] tmpVec = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(oldRes, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = Math.sqrt(lmNorm);
                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = Math.min(delta, lmNorm);
                }

                // evaluate the function at x + p and calculate its norm
                updateResidualsAndCost();
                current = new VectorialPointValuePair(point, objective);

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * cost < previousCost) {
                    double r = cost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += jacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * Math.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < cols; ++k) {
                        double xK = diag[k] * point[k];
                        xNorm    += xK * xK;
                    }
                    xNorm = Math.sqrt(xNorm);

                    // tests for convergence.
                    // we use the vectorial convergence checker
                } else {
                    // failed iteration, reset the previous values
                    cost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }
                    tmpVec    = residuals;
                    residuals = oldRes;
                    oldRes    = tmpVec;
                }
                if (checker==null) {
                	if (((Math.abs(actRed) <= costRelativeTolerance) &&
                        (preRed <= costRelativeTolerance) &&
                        (ratio <= 2.0)) ||
                       (delta <= parRelativeTolerance * xNorm)) {
                       return current;
                   }
                } else {
                    if (checker.converged(getIterations(), previous, current)) {
                        return current;
                    }
                }
                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                            costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                            parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                            orthoTolerance);
                }

            }

        }

    }","@Override
protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];

    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];

    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();

    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
    while (true) {
        incrementIterationsCounter();

        // compute the Q.R. decomposition of the jacobian matrix
        VectorialPointValuePair previous = current;
        updateJacobian();
        qrDecomposition();

        // compute Qt.res
        qTy(residuals);
        // now we don't need Q anymore,
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }

        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);

            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }

        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return current;
        }

        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }

        // inner loop
        double ratio;
        do {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tempVec = residuals;
            residuals = oldRes;
            oldRes = tempVec;

            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);

            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }

            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);

            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }

            // compute the scaled predicted reduction
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);

            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);

            // update the step bound
            if (ratio <= 0.25) {
                double temp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (temp < 0.1)) {
                    temp = 0.1;
                }
                delta = temp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= temp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }

            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);

                // tests for convergence.
                // we use the vectorial convergence checker
                break;
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tempVec = residuals;
                residuals = oldRes;
                oldRes = tempVec;
            }

            if (checker == null) {
                if (((Math.abs(actRed) <= costRelativeTolerance) &&
                     (preRed <= costRelativeTolerance) &&
                     (ratio <= 2.0)) ||
                    (delta <= parRelativeTolerance * xNorm)) {
                    return current;
                }
            } else {
                if (checker.converged(getIterations(), previous, current)) {
                    return current;
                }
            }

            // tests for termination and stringent tolerances
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                        costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                        parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                        orthoTolerance);
            }
        } while (true);
    }
}",1,0
196,Math_64,"@Override
    protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        // arrays shared with the other private methods
        solvedCols  = Math.min(rows, cols);
        diagR       = new double[cols];
        jacNorm     = new double[cols];
        beta        = new double[cols];
        permutation = new int[cols];
        lmDir       = new double[cols];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[cols];
        double[] oldX    = new double[cols];
        double[] oldRes  = new double[rows];
        double[] work1   = new double[cols];
        double[] work2   = new double[cols];
        double[] work3   = new double[cols];

        // evaluate the function at the starting point and calculate its norm
        updateResidualsAndCost();

        // outer loop
        lmPar = 0;
        boolean firstIteration = true;
        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
        while (true) {
            incrementIterationsCounter();

            // compute the Q.R. decomposition of the jacobian matrix
            VectorialPointValuePair previous = current;
            updateJacobian();
             qrDecomposition();
 
             // compute Qt.res
             qTy(residuals);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                jacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {

                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * point[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = Math.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (cost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // convergence has been reached
                return current;
            }

            // rescale if necessary
            for (int j = 0; j < cols; ++j) {
                diag[j] = Math.max(diag[j], jacNorm[j]);
            }

            // inner loop
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }
                double previousCost = cost;
                double[] tmpVec = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(oldRes, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = Math.sqrt(lmNorm);
                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = Math.min(delta, lmNorm);
                }

                // evaluate the function at x + p and calculate its norm
                updateResidualsAndCost();
                current = new VectorialPointValuePair(point, objective);

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * cost < previousCost) {
                    double r = cost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += jacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * Math.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < cols; ++k) {
                        double xK = diag[k] * point[k];
                        xNorm    += xK * xK;
                    }
                    xNorm = Math.sqrt(xNorm);

                    // tests for convergence.
                    // we use the vectorial convergence checker
                } else {
                    // failed iteration, reset the previous values
                    cost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }
                    tmpVec    = residuals;
                    residuals = oldRes;
                    oldRes    = tmpVec;
                }
                if (checker==null) {
                	if (((Math.abs(actRed) <= costRelativeTolerance) &&
                        (preRed <= costRelativeTolerance) &&
                        (ratio <= 2.0)) ||
                       (delta <= parRelativeTolerance * xNorm)) {
                       return current;
                   }
                } else {
                    if (checker.converged(getIterations(), previous, current)) {
                        return current;
                    }
                }
                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                            costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                            parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                            orthoTolerance);
                }

            }

        }

    }","@Override
protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];

    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];

    updateResidualsAndCost();

    lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);

    while (true) {
        incrementIterationsCounter();
        VectorialPointValuePair previous = current;

        updateJacobian();
        qrDecomposition();
        qTy(residuals);

        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }

        if (firstIteration) {
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }

        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            return current;
        }

        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }

        boolean successfulIteration = false;
        while (!successfulIteration) {
            for (int j = 0; j < solvedCols; ++j) {
                oldX[permutation[j]] = point[permutation[j]];
            }

            double previousCost = cost;
            double[] tempVec = residuals;
            residuals = oldRes;
            oldRes = tempVec;

            determineLMParameter(oldRes, delta, diag, work1, work2, work3);

            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                lmDir[permutation[j]] = -lmDir[permutation[j]];
                point[permutation[j]] = oldX[permutation[j]] + lmDir[permutation[j]];
                lmNorm += diag[permutation[j]] * lmDir[permutation[j]] * diag[permutation[j]] * lmDir[permutation[j]];
            }
            lmNorm = Math.sqrt(lmNorm);

            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }

            updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);

            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }

            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                for (int i = 0; i <= j; ++i) {
                    coeff1 += jacobian[i][permutation[j]] * lmDir[permutation[j]] *
                              jacobian[i][permutation[j]] * lmDir[permutation[j]];
                }
            }
            double coeff2 = lmPar * lmNorm * lmNorm;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            double ratio = (preRed == 0) ? 0 : (actRed / preRed);

            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                tmp = Math.max(0.1, Math.min(tmp, 0.5));
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2.0 * lmNorm;
                lmPar *= 0.5;
            }

            successfulIteration = ratio >= 1.0e-4;

            if (successfulIteration) {
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    xNorm += diag[k] * point[k] * diag[k] * point[k];
                }
                xNorm = Math.sqrt(xNorm);
            } else {
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    point[permutation[j]] = oldX[permutation[j]];
                }
                
                tempVec = residuals;
                residuals = oldRes;
                oldRes = tempVec;
            }
        }

        if (checker != null && checker.converged(getIterations(), previous, current)) {
            return current;
        }
    }
}",2,0
197,Math_69,"public RealMatrix getCorrelationPValues() throws MathException {
        TDistribution tDistribution = new TDistributionImpl(nObs - 2);
        int nVars = correlationMatrix.getColumnDimension();
        double[][] out = new double[nVars][nVars];
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < nVars; j++) {
                if (i == j) {
                    out[i][j] = 0d;
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
        return new BlockRealMatrix(out);
    }","public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                // Ensure that |r| < 1 to avoid invalid computations due to rounding errors
                if (Math.abs(r) >= 1.0) {
                    out[i][j] = Double.NaN; // Indeterminate p-value for invalid r
                } else {
                    double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                }
            }
        }
    }
    return new BlockRealMatrix(out);
}",0,0
197,Math_69,"public RealMatrix getCorrelationPValues() throws MathException {
        TDistribution tDistribution = new TDistributionImpl(nObs - 2);
        int nVars = correlationMatrix.getColumnDimension();
        double[][] out = new double[nVars][nVars];
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < nVars; j++) {
                if (i == j) {
                    out[i][j] = 0d;
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
        return new BlockRealMatrix(out);
    }","public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                if (Math.abs(r) >= 1.0) {
                    out[i][j] = Double.NaN; // Handle edge case where correlation coefficient is invalid
                } else {
                    // Add a small epsilon to handle numerical stability near limits
                    double adjustedR = Math.min(Math.max(r, -0.9999999), 0.9999999);
                    double t = Math.abs(adjustedR * Math.sqrt((nObs - 2) / (1 - adjustedR * adjustedR)));
                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                }
            }
        }
    }
    return new BlockRealMatrix(out);
}",1,0
197,Math_69,"public RealMatrix getCorrelationPValues() throws MathException {
        TDistribution tDistribution = new TDistributionImpl(nObs - 2);
        int nVars = correlationMatrix.getColumnDimension();
        double[][] out = new double[nVars][nVars];
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < nVars; j++) {
                if (i == j) {
                    out[i][j] = 0d;
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
        return new BlockRealMatrix(out);
    }","public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                if (Math.abs(r) >= 1.0) {
                    out[i][j] = 0.0; // Set p-value to 0 for perfect correlations
                } else if (Math.abs(r) < 1e-10) {
                    out[i][j] = 1.0; // Set p-value to 1 for near-zero correlations
                } else {
                    double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                }
            }
        }
    }
    return new BlockRealMatrix(out);
}",2,0
197,Math_69,"public RealMatrix getCorrelationPValues() throws MathException {
        TDistribution tDistribution = new TDistributionImpl(nObs - 2);
        int nVars = correlationMatrix.getColumnDimension();
        double[][] out = new double[nVars][nVars];
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < nVars; j++) {
                if (i == j) {
                    out[i][j] = 0d;
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
        return new BlockRealMatrix(out);
    }","public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                if (r == 1.0 || r == -1.0) {
                    out[i][j] = 0.0; // Perfect correlation
                } else {
                    try {
                        double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
                        out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                    } catch (Exception e) {
                        out[i][j] = Double.NaN; // Handle exceptions for invalid t
                    }
                }
            }
        }
    }
    return new BlockRealMatrix(out);
}",3,0
197,Math_69,"public RealMatrix getCorrelationPValues() throws MathException {
        TDistribution tDistribution = new TDistributionImpl(nObs - 2);
        int nVars = correlationMatrix.getColumnDimension();
        double[][] out = new double[nVars][nVars];
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < nVars; j++) {
                if (i == j) {
                    out[i][j] = 0d;
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
        return new BlockRealMatrix(out);
    }","public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                // Use threshold to ignore correlations close to 1
                if (Math.abs(r) >= 0.99999) {
                    out[i][j] = Double.NaN; // Undefined p-value for near-perfect correlations
                } else {
                    double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                }
            }
        }
    }
    return new BlockRealMatrix(out);
}",4,0
198,Math_7,"protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();

            // initialize the events states if needed
            if (! statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // get state at event time
                interpolator.setInterpolatedTime(eventT);
                 final double[] eventY = interpolator.getInterpolatedState().clone();
 
                 // advance all event states to current time
                 currentEvent.stepAccepted(eventT, eventY);
                 isLastStep = currentEvent.stop();
 
                 // handle the first part of the step, up to the event
                 for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, isLastStep);
                }

                if (isLastStep) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                boolean needReset = currentEvent.reset(eventT, eventY);
                if (needReset) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    computeDerivatives(eventT, y, yDot);
                    resetOccurred = true;
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            // last part of the step, after the last event
            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }
            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);

            // handle the remaining part of the step, after all events if any
            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;

    }","protected double acceptStep(final AbstractStepInterpolator interpolator,
                                final double[] y, final double[] yDot, final double tEnd)
        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {

            double previousT = interpolator.getGlobalPreviousTime();
            final double currentT = interpolator.getGlobalCurrentTime();

            // initialize the events states if needed
            if (!statesInitialized) {
                for (EventState state : eventsStates) {
                    state.reinitializeBegin(interpolator);
                }
                statesInitialized = true;
            }

            // search for next events that may occur during the step
            final int orderingSign = interpolator.isForward() ? +1 : -1;
            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

                /** {@inheritDoc} */
                public int compare(EventState es0, EventState es1) {
                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
                }

            });

            for (final EventState state : eventsStates) {
                if (state.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(state);
                }
            }

            while (!occuringEvents.isEmpty()) {

                // handle the chronologically first event
                final Iterator<EventState> iterator = occuringEvents.iterator();
                final EventState currentEvent = iterator.next();
                iterator.remove();

                // restrict the interpolator to the first part of the step, up to the event
                final double eventT = currentEvent.getEventTime();
                interpolator.setSoftPreviousTime(previousT);
                interpolator.setSoftCurrentTime(eventT);

                // get state at event time
                interpolator.setInterpolatedTime(eventT);
                final double[] eventY = interpolator.getInterpolatedState().clone();

                // advance all event states to current time
                currentEvent.stepAccepted(eventT, eventY);

                // handle the first part of the step, up to the event
                for (final StepHandler handler : stepHandlers) {
                    handler.handleStep(interpolator, currentEvent.stop() || isLastStep);
                }

                if (currentEvent.stop()) {
                    // the event asked to stop integration
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                boolean needReset = currentEvent.reset(eventT, eventY);
                if (needReset) {
                    // some event handler has triggered changes that
                    // invalidate the derivatives, we need to recompute them
                    System.arraycopy(eventY, 0, y, 0, y.length);
                    computeDerivatives(eventT, y, yDot);
                    resetOccurred = true;
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                    return eventT;
                }

                // prepare handling of the remaining part of the step
                previousT = eventT;
                interpolator.setSoftPreviousTime(eventT);
                interpolator.setSoftCurrentTime(currentT);

                // check if the same event occurs again in the remaining part of the step
                if (currentEvent.evaluateStep(interpolator)) {
                    // the event occurs during the current step
                    occuringEvents.add(currentEvent);
                }

            }

            // last part of the step, after the last event
            interpolator.setInterpolatedTime(currentT);
            final double[] currentY = interpolator.getInterpolatedState();
            for (final EventState state : eventsStates) {
                state.stepAccepted(currentT, currentY);
                isLastStep = isLastStep || state.stop();
            }

            for (StepHandler handler : stepHandlers) {
                handler.handleStep(interpolator, isLastStep);
            }

            return currentT;
}",0,0
199,Math_70,"public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return solve(min, max);
     }","public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         if (f == null) {
             throw new NullPointerException(""The function 'f' must not be null."");
         }
         verifyInterval(min, max);
         clearResult();
         return solve(min, max);
     }",0,0
199,Math_70,"public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return solve(min, max);
     }","public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
         if (f == null) {
             throw new IllegalArgumentException(""The function must not be null."");
         }
         
         // Ensure the interval is valid and contains a root
         verifyInterval(min, max);
         double functionMin = f.value(min);
         double functionMax = f.value(max);

         if (functionMin * functionMax > 0) {
             throw new IllegalArgumentException(""Function values at the endpoints do not have opposite signs."");
         }
         
         // Initialize state and solve the equation
         clearResult();
         double midpoint = UnivariateRealSolverUtils.midpoint(min, max);
         while (Math.abs(max - min) > getAbsoluteAccuracy()) {
             double value = f.value(midpoint);
             if (value == 0.0) {
                 return midpoint;
             } else if (value * functionMin < 0) {
                 max = midpoint;
                 functionMax = value;
             } else {
                 min = midpoint;
                 functionMin = value;
             }
             midpoint = UnivariateRealSolverUtils.midpoint(min, max);
         }
         
         return midpoint;
     }",1,0
200,Math_72,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
             setResult(yMin, 0);
             return result;
         }
 
        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(f, initial, yInitial, max, yMax, initial, yInitial);
        }

        if (yMin * yMax > 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                    final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

    clearResult();
    verifySequence(min, initial, max);

    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }

    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(min, 0);
        return result;  // Fixed return value to min
    }

    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, initial, min, yMin, initial, yInitial);
        // Corrected argument ordering
    }

    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(max, 0);
        return result;  // Fixed return value to max
    }

    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, max, initial, yInitial, max, yMax);
        // Corrected argument ordering
    }

    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(
              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }

    // full Brent algorithm starting with provided initial guess
    return solve(f, min, max, initial, yInitial, min, yMin, max, yMax);
    // Fixed argument ordering for initial guess and endpoints
}",0,0
200,Math_72,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
             setResult(yMin, 0);
             return result;
         }
 
        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(f, initial, yInitial, max, yMax, initial, yInitial);
        }

        if (yMin * yMax > 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                    final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);

    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return initial; // Return the initial guess properly
    }

    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(min, 0);
        return min; // Correctly return the minimum point
    }

    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, initial, min); // Simplify argument usage
    }

    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(max, 0);
        return max; // Properly return the maximum point
    }

    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, max, initial); // Simplify argument usage
    }

    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(
              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }

    // full Brent algorithm starting with provided initial guess
    return solve(f, min, max, initial); // Simplify argument handling for clarity
}",1,0
200,Math_72,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
             setResult(yMin, 0);
             return result;
         }
 
        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
            return solve(f, initial, yInitial, max, yMax, initial, yInitial);
        }

        if (yMin * yMax > 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
        }

        // full Brent algorithm starting with provided initial guess
        return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                    final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

    clearResult();
    verifySequence(min, initial, max);

    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return initial; // Use initial directly
    }

    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(min, 0);
        return min; // Use min directly
    }

    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, initial); // Simplified parameter list
    }

    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(max, 0);
        return max; // Use max directly
    }

    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, max); // Simplified parameter list
    }

    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(
            NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }

    // full Brent algorithm starting with provided initial guess
    return solve(f, min, max); // Simplified final call
}",2,0
201,Math_73,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

        clearResult();
        verifySequence(min, initial, max);

        // return the initial guess if it is good enough
        double yInitial = f.value(initial);
        if (Math.abs(yInitial) <= functionValueAccuracy) {
            setResult(initial, 0);
            return result;
        }

        // return the first endpoint if it is good enough
        double yMin = f.value(min);
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
            return result;
        }

        // reduce interval if min and initial bracket the root
        if (yInitial * yMin < 0) {
            return solve(f, min, yMin, initial, yInitial, min, yMin);
        }

        // return the second endpoint if it is good enough
        double yMax = f.value(max);
        if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
            return result;
        }

        // reduce interval if initial and max bracket the root
        if (yInitial * yMax < 0) {
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);

    }","public double solve(final UnivariateRealFunction f,
                    final double min, final double max, final double initial)
        throws MaxIterationsExceededException, FunctionEvaluationException {

    clearResult();
    verifySequence(min, initial, max);

    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }

    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(min, 0); // Fix: setResult was called with yMin instead of min
        return result;
    }

    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }

    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(max, 0); // Fix: setResult was called with yMax instead of max
        return result;
    }

    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }

    // check for non-bracketing of root
    if (yMin * yMax > 0) {
        throw new IllegalArgumentException(""Function values at endpoints do not bracket the root."");
    }

    // full Brent algorithm starting with provided initial guess
    return solve(f, min, yMin, max, yMax, initial, yInitial);
}",0,0
202,Math_74,"@Override
  public double integrate(final FirstOrderDifferentialEquations equations,
                          final double t0, final double[] y0,
                          final double t, final double[] y)
  throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart         = t0;
    double  hNew      = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      double error = 0;
      for (boolean loop = true; loop;) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
         }
 
         if (firstTime) {
           final double[] scale;
           if (vecAbsoluteTolerance == null) {
               scale = new double[y0.length];
               java.util.Arrays.fill(scale, scalAbsoluteTolerance);
             } else {
               scale = vecAbsoluteTolerance;
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
        }

        stepSize = hNew;

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error <= 1.0) {

          // discrete events handling
          interpolator.storeTime(stepStart + stepSize);
          if (manager.evaluateStep(interpolator)) {
              final double dt = manager.getEventTime() - stepStart;
              if (Math.abs(dt) <= Math.ulp(stepStart)) {
                  // rejecting the step would lead to a too small next step, we accept it
                  loop = false;
              } else {
                  // reject the step to match exactly the next switch time
                  hNew = dt;
              }
          } else {
            // accept the step
            loop = false;
          }

        } else {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              Math.min(maxGrowth,
                       Math.max(minReduction, safety * Math.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
          handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (fsal) {
        // save the last evaluation for the next step
        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
      }

      if (manager.reset(stepStart, y) && ! lastStep) {
        // some event handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      if (! lastStep) {
        // in some rare cases we may get here with stepSize = 0, for example
        // when an event occurs at integration start, reducing the first step
        // to zero; we have to reset the step to some safe non zero value
          stepSize = filterStep(stepSize, forward, true);

        // stepsize control for next step
        final double factor = Math.min(maxGrowth,
                                       Math.max(minReduction,
                                                safety * Math.pow(error, exp)));
        final double  scaledH    = stepSize * factor;
        final double  nextT      = stepStart + scaledH;
        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
        hNew = filterStep(scaledH, forward, nextIsLast);
      }

    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;

  }","@Override
public double integrate(final FirstOrderDifferentialEquations equations,
                        final double t0, final double[] y0,
                        final double t, final double[] y)
    throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();

    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {
        interpolator.shift();

        double error = 0;
        while (true) { // loop for step rejection and error control

            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }

            if (firstTime) {
                final double[] scale;
                if (vecAbsoluteTolerance == null) {
                    scale = new double[y0.length];
                    java.util.Arrays.fill(scale, scalAbsoluteTolerance);
                } else {
                    scale = vecAbsoluteTolerance;
                }
                hNew = initializeStep(equations, forward, getOrder(), scale,
                                      stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }

            stepSize = hNew;

            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }

            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }

            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                // discrete events handling
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        // rejecting the step would lead to a too small next step, we accept it
                        break;
                    } else {
                        // reject the step to match exactly the next switch time
                        hNew = dt;
                    }
                } else {
                    // accept the step
                    break;
                }
            } else {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = Math.min(maxGrowth,
                                               Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }

        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();

        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;

        if (fsal) {
            // save the last evaluation for the next step
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }

        if (manager.reset(stepStart, y) && !lastStep) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (!lastStep) {
            // in some rare cases we may get here with stepSize = 0, for example
            // when an event occurs at integration start, reducing the first step
            // to zero; we have to reset the step to some safe non-zero value
            stepSize = filterStep(stepSize, forward, true);

            // stepsize control for next step
            final double factor = Math.min(maxGrowth,
                                           Math.max(minReduction,
                                                    safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}",0,0
202,Math_74,"@Override
  public double integrate(final FirstOrderDifferentialEquations equations,
                          final double t0, final double[] y0,
                          final double t, final double[] y)
  throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart         = t0;
    double  hNew      = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      double error = 0;
      for (boolean loop = true; loop;) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
         }
 
         if (firstTime) {
           final double[] scale;
           if (vecAbsoluteTolerance == null) {
               scale = new double[y0.length];
               java.util.Arrays.fill(scale, scalAbsoluteTolerance);
             } else {
               scale = vecAbsoluteTolerance;
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
        }

        stepSize = hNew;

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error <= 1.0) {

          // discrete events handling
          interpolator.storeTime(stepStart + stepSize);
          if (manager.evaluateStep(interpolator)) {
              final double dt = manager.getEventTime() - stepStart;
              if (Math.abs(dt) <= Math.ulp(stepStart)) {
                  // rejecting the step would lead to a too small next step, we accept it
                  loop = false;
              } else {
                  // reject the step to match exactly the next switch time
                  hNew = dt;
              }
          } else {
            // accept the step
            loop = false;
          }

        } else {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              Math.min(maxGrowth,
                       Math.max(minReduction, safety * Math.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
          handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (fsal) {
        // save the last evaluation for the next step
        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
      }

      if (manager.reset(stepStart, y) && ! lastStep) {
        // some event handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      if (! lastStep) {
        // in some rare cases we may get here with stepSize = 0, for example
        // when an event occurs at integration start, reducing the first step
        // to zero; we have to reset the step to some safe non zero value
          stepSize = filterStep(stepSize, forward, true);

        // stepsize control for next step
        final double factor = Math.min(maxGrowth,
                                       Math.max(minReduction,
                                                safety * Math.pow(error, exp)));
        final double  scaledH    = stepSize * factor;
        final double  nextT      = stepStart + scaledH;
        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
        hNew = filterStep(scaledH, forward, nextIsLast);
      }

    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;

  }","@Override
public double integrate(final FirstOrderDifferentialEquations equations,
                        final double t0, final double[] y0,
                        final double t, final double[] y)
    throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);

    stepStart = t0;
    double hNew = 0;

    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean firstTime = true;
    boolean lastStep = false;

    while (!lastStep) {
        interpolator.shift();

        if (firstTime || !fsal) {
            computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
            final double[] scale = vecAbsoluteTolerance == null
                ? new double[y0.length]
                : vecAbsoluteTolerance;
            if (vecAbsoluteTolerance == null) {
                java.util.Arrays.fill(scale, scalAbsoluteTolerance);
            }
            hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
            firstTime = false;
        }

        stepSize = hNew;
        for (int k = 1; k < stages; ++k) {
            for (int j = 0; j < y0.length; ++j) {
                double sum = a[k - 1][0] * yDotK[0][j];
                for (int l = 1; l < k; ++l) {
                    sum += a[k - 1][l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
        }

        for (int j = 0; j < y0.length; ++j) {
            double sum = b[0] * yDotK[0][j];
            for (int l = 1; l < stages; ++l) {
                sum += b[l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
        }

        double error = estimateError(yDotK, y, yTmp, stepSize);
        if (error > 1.0) {
            hNew = filterStep(stepSize * Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))), forward, false);
            continue; // Reject the step and reattempt with new step size
        }

        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);

        interpolator.storeTime(nextStep);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();

        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }

        if (fsal) {
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }

        stepStart = nextStep;
        if (!lastStep && manager.reset(stepStart, y)) {
            computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (!lastStep) {
            stepSize = filterStep(stepSize, forward, true);
            hNew = filterStep(stepSize * Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))), forward, forward ? nextStep >= t : nextStep <= t);
        }
    }

    resetInternalState();
    return stepStart;
}",1,0
203,Math_75,"    public double getPct(Object v) {
        return getCumPct((Comparable<?>) v);
    }
","public double getPct(Object v) {
    long sumFreq = getSumFreq();
    if (sumFreq == 0) {
        return Double.NaN;
    }
    long count = getCount(v);
    return (double) count / (double) sumFreq;
}",0,0
204,Math_78,"public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

    try {
        forward = interpolator.isForward();
        final double t1 = interpolator.getCurrentTime();
        final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
        final double h = (t1 - t0) / n;

        double ta = t0;
        double ga = g0;
        double tb = ta + (forward ? convergence : -convergence);

        for (int i = 0; i < n; ++i) {
            tb += h;
            interpolator.setInterpolatedTime(tb);
            final double gb = handler.g(tb, interpolator.getInterpolatedState());

            if (g0Positive ^ (gb >= 0)) {
                increasing = gb >= ga;

                // Ensure ta and ga are updated correctly before solving for the root
                if (Math.signum(ga) == Math.signum(gb)) {
                    ta = tb;
                    ga = gb;
                }

                final UnivariateRealFunction f = new UnivariateRealFunction() {
                    public double value(final double t) throws FunctionEvaluationException {
                        try {
                            interpolator.setInterpolatedTime(t);
                            return handler.g(t, interpolator.getInterpolatedState());
                        } catch (DerivativeException e) {
                            throw new FunctionEvaluationException(e, t);
                        } catch (EventException e) {
                            throw new FunctionEvaluationException(e, t);
                        }
                    }
                };

                final BrentSolver solver = new BrentSolver();
                solver.setAbsoluteAccuracy(convergence);
                solver.setMaximalIterationCount(maxIterationCount);
                double root = Double.NaN;

                try {
                    root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                } catch (IllegalArgumentException ex) {
                    // Handle edge cases where endpoints do not bracket a root
                    ta = tb;
                    ga = gb;
                    continue;
                }

                if ((Math.abs(root - ta) <= convergence) &&
                        (Math.abs(root - previousEventTime) <= convergence)) {
                    ta = tb;
                    ga = gb;
                } else if (Double.isNaN(previousEventTime) ||
                        (Math.abs(previousEventTime - root) > convergence)) {
                    pendingEventTime = root;
                    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                        return false;
                    }
                    pendingEvent = true;
                    return true;
                }
            } else {
                ta = tb;
                ga = gb;
            }
        }

        pendingEvent = false;
        pendingEventTime = Double.NaN;
        return false;

    } catch (FunctionEvaluationException e) {
        final Throwable cause = e.getCause();
        if (cause instanceof DerivativeException) {
            throw (DerivativeException) cause;
        } else if (cause instanceof EventException) {
            throw (EventException) cause;
        }
        throw new EventException(e);
    }
}",0,0
204,Math_78,"public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

    try {
        forward = interpolator.isForward();
        final double t1 = interpolator.getCurrentTime();
        final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
        final double h = (t1 - t0) / n;

        double ta = t0;
        double ga = g0;
        double tb = ta + (forward ? convergence : -convergence);

        for (int i = 0; i < n; ++i) {
            tb += h;
            interpolator.setInterpolatedTime(tb);
            final double gb;

            try {
                gb = handler.g(tb, interpolator.getInterpolatedState());
            } catch (EventException e) {
                ta = tb;
                ga = g0Positive ? Math.abs(ga) : -Math.abs(ga);
                continue;
            }

            if (g0Positive ^ (gb >= 0)) {
                increasing = gb >= ga;

                final UnivariateRealFunction f = new UnivariateRealFunction() {
                    public double value(final double t) throws FunctionEvaluationException {
                        try {
                            interpolator.setInterpolatedTime(t);
                            return handler.g(t, interpolator.getInterpolatedState());
                        } catch (DerivativeException e) {
                            throw new FunctionEvaluationException(e, t);
                        } catch (EventException e) {
                            throw new FunctionEvaluationException(e, t);
                        }
                    }
                };

                final BrentSolver solver = new BrentSolver();
                solver.setAbsoluteAccuracy(Math.max(convergence, 1e-6));

                double root;
                try {
                    root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                } catch (IllegalArgumentException | FunctionEvaluationException ex) {
                    ta = tb;
                    ga = ga + (gb - ga) * 0.1; // Adjust ga slightly to avoid bracketing issues
                    continue;
                }

                if ((Math.abs(root - ta) <= convergence) &&
                        (Math.abs(root - previousEventTime) <= convergence)) {
                    ta = tb;
                    ga = gb;
                } else if (Double.isNaN(previousEventTime) ||
                        (Math.abs(previousEventTime - root) > convergence)) {
                    pendingEventTime = root;
                    pendingEvent = true;
                    return true;
                }
            } else {
                ta = tb;
                ga = gb;
            }
        }

        pendingEvent = false;
        pendingEventTime = Double.NaN;
        return false;

    } catch (FunctionEvaluationException e) {
        final Throwable cause = e.getCause();
        if (cause instanceof DerivativeException) {
            throw (DerivativeException) cause;
        } else if (cause instanceof EventException) {
            throw (EventException) cause;
        }
        throw new EventException(e);
    }
}",1,0
204,Math_78,"public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

        try {

            forward = interpolator.isForward();
            final double t1 = interpolator.getCurrentTime();
            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
            final double h  = (t1 - t0) / n;

            double ta = t0;
            double ga = g0;
            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
            for (int i = 0; i < n; ++i) {

                // evaluate handler value at the end of the substep
                tb += h;
                interpolator.setInterpolatedTime(tb);
                final double gb = handler.g(tb, interpolator.getInterpolatedState());

                // check events occurrence
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
                            // this should never happen
                         
                    // variation direction, with respect to the integration direction
                    increasing = gb >= ga;

                    final UnivariateRealFunction f = new UnivariateRealFunction() {
                        public double value(final double t) throws FunctionEvaluationException {
                            try {
                                interpolator.setInterpolatedTime(t);
                                return handler.g(t, interpolator.getInterpolatedState());
                            } catch (DerivativeException e) {
                                throw new FunctionEvaluationException(e, t);
                            } catch (EventException e) {
                                throw new FunctionEvaluationException(e, t);
                            }
                        }
                    };
                    final BrentSolver solver = new BrentSolver();
                    solver.setAbsoluteAccuracy(convergence);
                    solver.setMaximalIterationCount(maxIterationCount);
                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                    if ((Math.abs(root - ta) <= convergence) &&
                         (Math.abs(root - previousEventTime) <= convergence)) {
                        // we have either found nothing or found (again ?) a past event, we simply ignore it
                        ta = tb;
                        ga = gb;
                    } else if (Double.isNaN(previousEventTime) ||
                               (Math.abs(previousEventTime - root) > convergence)) {
                        pendingEventTime = root;
                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                            // we were already waiting for this event which was
                            // found during a previous call for a step that was
                            // rejected, this step must now be accepted since it
                            // properly ends exactly at the event occurrence
                            return false;
                        }
                        // either we were not waiting for the event or it has
                        // moved in such a way the step cannot be accepted
                        pendingEvent = true;
                        return true;
                    }

                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }

            }

            // no event during the whole step
            pendingEvent     = false;
            pendingEventTime = Double.NaN;
            return false;

        } catch (FunctionEvaluationException e) {
            final Throwable cause = e.getCause();
            if ((cause != null) && (cause instanceof DerivativeException)) {
                throw (DerivativeException) cause;
            } else if ((cause != null) && (cause instanceof EventException)) {
                throw (EventException) cause;
            }
            throw new EventException(e);
        }

    }","public boolean evaluateStep(final StepInterpolator interpolator)
        throws DerivativeException, EventException, ConvergenceException {

    try {
        boolean forward = interpolator.isForward();
        final double t1 = interpolator.getCurrentTime();
        final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
        final double h = (t1 - t0) / n;

        double ta = t0;
        double ga = g0;
        double tb;

        for (int i = 0; i < n; ++i) {
            // Move tb incrementally and ensure it is within bounds for this substep
            tb = ta + h;
            interpolator.setInterpolatedTime(tb);
            double[] interpolatedState = interpolator.getInterpolatedState();
            final double gb;

            try {
                gb = handler.g(tb, interpolatedState);
            } catch (EventException e) {
                // If g function fails, fallback by assuming ga persists
                ta = tb;
                continue;
            }

            // Check if there is a sign change indicating an event occurrence
            if ((g0Positive && gb < 0) || (!g0Positive && gb >= 0)) {
                increasing = gb >= ga;

                // Adjust ta and ga to ensure proper bracketing
                if ((ga * gb) > 0) {
                    ta -= convergence;
                    ga = g0Positive ? ga - Math.abs(ga) * 0.1 : ga + Math.abs(ga) * 0.1;
                }

                final UnivariateRealFunction f = new UnivariateRealFunction() {
                    public double value(final double t) throws FunctionEvaluationException {
                        try {
                            interpolator.setInterpolatedTime(t);
                            return handler.g(t, interpolator.getInterpolatedState());
                        } catch (Exception e) {
                            throw new FunctionEvaluationException(e, t);
                        }
                    }
                };

                BrentSolver solver = new BrentSolver();
                solver.setAbsoluteAccuracy(convergence);
                solver.setMaximalIterationCount(maxIterationCount);
                double root = Double.NaN;

                try {
                    // Solve for the root where an event occurs
                    root = solver.solve(f, ta, tb);
                } catch (Exception ex) {
                    // Skip to the next substep if solving fails
                    ta = tb;
                    continue;
                }

                if ((Math.abs(root - ta) <= convergence) && Double.isNaN(previousEventTime)) {
                    ta = tb;
                    ga = gb;
                } else {
                    pendingEventTime = root;
                    pendingEvent = true;
                    return true;
                }
            } else {
                // No event, move to next substep
                ta = tb;
                ga = gb;
            }
        }

        // No event occurred during the current step
        pendingEvent = false;
        pendingEventTime = Double.NaN;
        return false;

    } catch (Exception e) {
        throw new EventException(e);
    }
}",2,0
205,Math_79,"    public static double distance(int[] p1, int[] p2) {
      int sum = 0;
      for (int i = 0; i < p1.length; i++) {
          final int dp = p1[i] - p2[i];
          sum += dp * dp;
      }
      return Math.sqrt(sum);
    }
","public static double distance(int[] p1, int[] p2) {
    if (p1 == null || p2 == null) {
        throw new IllegalArgumentException(""Input point arrays cannot be null."");
    }
    if (p1.length != p2.length) {
        throw new IllegalArgumentException(""Input point arrays must have the same length."");
    }
    long sum = 0; // Use long to prevent integer overflow
    for (int i = 0; i < p1.length; i++) {
        final int dp = p1[i] - p2[i];
        sum += (long) dp * dp;
    }
    return Math.sqrt(sum);
}",0,0
206,Math_8,"    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
        if (sampleSize <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                    sampleSize);
        }

        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);

        for (int i = 0; i < sampleSize; i++) {
            out[i] = sample();
        }

        return out;

    }
","public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
    if (sampleSize <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);
    }

    @SuppressWarnings(""unchecked"")
    final T[] out = (T[]) java.lang.reflect.Array.newInstance(sample().getClass(), sampleSize);

    for (int i = 0; i < sampleSize; i++) {
        out[i] = sample();
    }

    return out;
}",0,0
207,Math_80,"private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
             int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }
            return true;
        }
        return false;
    }","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        int j = 4 * n - 1;
        for (int i = 0; i < j; i += 4) {
            for (int k = 0; k < 4; k++) { // Corrected condition to iterate over all 4 values (step irrelevant here)
                final double tmp = work[i + k];
                work[i + k] = work[j - k];
                work[j - k] = tmp;
            }
            j -= 4;
        }
        return true;
    }
    return false;
}",0,0
207,Math_80,"private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
             int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }
            return true;
        }
        return false;
    }","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        int j = 4 * n - 1;
        for (int i = 0; i < j; i += 4) {
            for (int k = 0; k < Math.min(4, step); k++) { // Restrict k within bounds of 0 to 4, avoiding step inconsistency
                final double tmp = work[i + k];
                work[i + k] = work[j - k];
                work[j - k] = tmp;
            }
            j -= 4;
        }
        return true;
    }
    return false;
}",1,0
207,Math_80,"private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
             int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }
            return true;
        }
        return false;
    }","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        int j = 4 * n - 1;
        for (int i = 0; i < j; i += 4) {
            for (int k = 0; k < 4; k++) { // Independent of step, iterate fully over 4 elements
                int leftIndex = i + k;
                int rightIndex = j - k;

                if (leftIndex < work.length && rightIndex >= 0) { // Add bounds check 
                    final double tmp = work[leftIndex];
                    work[leftIndex] = work[rightIndex];
                    work[rightIndex] = tmp;
                }
            }
            j -= 4;
        }
        return true;
    }
    return false;
}",2,0
207,Math_80,"private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
             int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }
            return true;
        }
        return false;
    }","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        int j = 4 * n - 1;
        for (int i = 0; i < j; i += step) {
            for (int k = 0; k < step && k < 4; k++) {
                final double tmp = work[i + k];
                work[i + k] = work[j - k];
                work[j - k] = tmp;
            }
            j -= step;
        }
        return true;
    }
    return false;
}",3,0
207,Math_80,"private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
             int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                    work[i + k] = work[j - k];
                    work[j - k] = tmp;
                }
                j -= 4;
            }
            return true;
        }
        return false;
    }","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        int j = 4 * n - 1;
        for (int i = 0; i < j; i += 4) {
            for (int k = 0; k < 4; k++) {
                final double tmp = work[i + k];
                work[i + k] = work[j - k];
                work[j - k] = tmp;
            }
            j -= 4;
        }
        return true;
    }
    return false;
}",4,0
208,Math_82,"private Integer getPivotRow(final int col, final SimplexTableau tableau) {
        double minRatio = Double.MAX_VALUE;
        Integer minRatioPos = null;
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
             final double entry = tableau.getEntry(i, col);
             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
                 final double ratio = rhs / entry;
                 if (ratio < minRatio) {
                     minRatio = ratio;
                    minRatioPos = i; 
                }
            }
        }
        return minRatioPos;
    }","private Integer getPivotRow(final int col, final SimplexTableau tableau) {
    double minRatio = Double.MAX_VALUE;
    Integer minRatioPos = null;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);

        if (MathUtils.compareTo(entry, 0, epsilon) > 0) { // Ensure entry is strictly > 0
            final double ratio = rhs / entry;
            if (ratio >= 0 && ratio < minRatio) { // Ensure ratio is valid and minimize it
                minRatio = ratio;
                minRatioPos = i;
            }
        }
    }
    return minRatioPos;
}",0,0
209,Math_84,"@Override
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();

            // save the original vertex
            final RealPointValuePair[] original = simplex;
            final RealPointValuePair best = original[0];

            // perform a reflection step
            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
            if (comparator.compare(reflected, best) < 0) {

                // compute the expanded simplex
                final RealPointValuePair[] reflectedSimplex = simplex;
                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
                if (comparator.compare(reflected, expanded) <= 0) {
                    // accept the reflected simplex
                    simplex = reflectedSimplex;
                }

                return;

            }

            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex

            // check convergence
                return;
            }

        }

    }","@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    while (true) {
        incrementIterationsCounter();

        // preserve the original simplex
        final RealPointValuePair[] original = simplex.clone();
        final RealPointValuePair best = original[0];

        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
            // compute the expanded simplex
            final RealPointValuePair[] reflectedSimplex = simplex.clone();
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(expanded, reflected) < 0) {
                // accept the expanded simplex
                simplex = reflectedSimplex.clone();
            } else {
                // accept the reflected simplex
                simplex = reflectedSimplex.clone();
            }
            return;
        }

        // compute the contracted simplex
        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
            // accept the contracted simplex
            simplex = original.clone();
            return;
        }

        // reduce the simplex if no improvement
        reduceSimplex(comparator);
    }
}",0,0
209,Math_84,"@Override
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();

            // save the original vertex
            final RealPointValuePair[] original = simplex;
            final RealPointValuePair best = original[0];

            // perform a reflection step
            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
            if (comparator.compare(reflected, best) < 0) {

                // compute the expanded simplex
                final RealPointValuePair[] reflectedSimplex = simplex;
                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
                if (comparator.compare(reflected, expanded) <= 0) {
                    // accept the reflected simplex
                    simplex = reflectedSimplex;
                }

                return;

            }

            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex

            // check convergence
                return;
            }

        }

    }","@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    while (true) {
        incrementIterationsCounter();

        // save the original vertex
        final RealPointValuePair[] original = simplex.clone();
        final RealPointValuePair best = original[0];

        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(reflected, expanded) < 0) {
                // accept expanded simplex
                simplex = original.clone();
                original[0] = expanded;
            } else {
                // accept reflected simplex
                simplex = original.clone();
                original[0] = reflected;
            }
            return;
        }

        // perform a contraction step
        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
            // accept contracted simplex
            simplex = original.clone();
            original[0] = contracted;
            return;
        }

        // reduce simplex
        for (int i = 1; i < simplex.length; i++) {
            simplex[i] = new RealPointValuePair(
                simplex[0].getPoint(),
                simplex[i].getValue() * gamma);
        }
    }
}",1,0
209,Math_84,"@Override
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();

            // save the original vertex
            final RealPointValuePair[] original = simplex;
            final RealPointValuePair best = original[0];

            // perform a reflection step
            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
            if (comparator.compare(reflected, best) < 0) {

                // compute the expanded simplex
                final RealPointValuePair[] reflectedSimplex = simplex;
                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
                if (comparator.compare(reflected, expanded) <= 0) {
                    // accept the reflected simplex
                    simplex = reflectedSimplex;
                }

                return;

            }

            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex

            // check convergence
                return;
            }

        }

    }","@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    
    while (true) {
        incrementIterationsCounter();

        // Save the original simplex
        final RealPointValuePair[] original = simplex.clone();
        final RealPointValuePair best = original[0];

        // Perform reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
            // Attempt to expand if reflection is successful
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(expanded, reflected) < 0) {
                // Accept the expanded simplex
                simplex[0] = expanded;
            } else {
                // Accept the reflected simplex
                simplex[0] = reflected;
            }
            return;
        }

        // Perform contraction step
        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
            // Accept the contracted simplex
            simplex[0] = contracted;
            return;
        }

        // Reduce simplex when no improvement is made
        for (int i = 1; i < simplex.length; i++) {
            for (int j = 0; j < simplex[i].getPoint().length; j++) {
                double reducedValue = simplex[0].getPoint()[j] + (simplex[i].getPoint()[j] - simplex[0].getPoint()[j]) * gamma;
                simplex[i].getPoint()[j] = reducedValue;
            }
        }
    }
}",2,0
209,Math_84,"@Override
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();

            // save the original vertex
            final RealPointValuePair[] original = simplex;
            final RealPointValuePair best = original[0];

            // perform a reflection step
            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
            if (comparator.compare(reflected, best) < 0) {

                // compute the expanded simplex
                final RealPointValuePair[] reflectedSimplex = simplex;
                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
                if (comparator.compare(reflected, expanded) <= 0) {
                    // accept the reflected simplex
                    simplex = reflectedSimplex;
                }

                return;

            }

            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex

            // check convergence
                return;
            }

        }

    }","@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    boolean loopCondition = true;
    while (loopCondition) {
        incrementIterationsCounter();

        // save the original simplex
        final RealPointValuePair[] original = simplex.clone();
        final RealPointValuePair best = original[0];

        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {

            // compute the expanded simplex
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(expanded, reflected) < 0) {
                // accept the expanded simplex
                simplex[0] = expanded;
            } else {
                // accept the reflected simplex
                simplex[0] = reflected;
            }
            loopCondition = false;
        } else {
            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex
                simplex[0] = contracted;
                loopCondition = false;
            } else {
                // reduce the simplex if no improvement
                reduceSimplex(comparator);
            }
        }
    }
}",3,0
209,Math_84,"@Override
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();

            // save the original vertex
            final RealPointValuePair[] original = simplex;
            final RealPointValuePair best = original[0];

            // perform a reflection step
            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
            if (comparator.compare(reflected, best) < 0) {

                // compute the expanded simplex
                final RealPointValuePair[] reflectedSimplex = simplex;
                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
                if (comparator.compare(reflected, expanded) <= 0) {
                    // accept the reflected simplex
                    simplex = reflectedSimplex;
                }

                return;

            }

            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex

            // check convergence
                return;
            }

        }

    }","@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

    boolean improved = false;
    do {
        incrementIterationsCounter();

        // save the original simplex
        final RealPointValuePair[] original = simplex.clone();
        final RealPointValuePair best = original[0];

        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
            // compute the expanded simplex
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(expanded, reflected) < 0) {
                // accept the expanded simplex
                simplex[0] = expanded;
            } else {
                // accept the reflected simplex
                simplex[0] = reflected;
            }
            improved = true;
        } else {
            // compute the contracted simplex
            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
            if (comparator.compare(contracted, best) < 0) {
                // accept the contracted simplex
                simplex[0] = contracted;
                improved = true;
            } else {
                // reduce the simplex if no improvement
                reduceSimplex(comparator);
                improved = false;
            }
        }
    } while (!improved);
}",4,0
210,Math_85,"public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
        
        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0 ;
    
        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            
            fb = function.value(b);
            numIterations++ ;
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
         if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }
        
        return new double[]{a, b};
    }","public static double[] bracket(UnivariateRealFunction function, 
            double initial, double lowerBound, double upperBound,
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {

        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }

        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0;

        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            fb = function.value(b);
            numIterations++;
        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 (a > lowerBound || b < upperBound));

        if (fa * fb >= 0.0 || numIterations >= maximumIterations) {
            throw new ConvergenceException(
                      ""number of iterations={0}, maximum iterations={1}, "" +
                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }

        return new double[]{a, b};
    }",0,0
210,Math_85,"public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
        
        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0 ;
    
        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            
            fb = function.value(b);
            numIterations++ ;
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
         if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }
        
        return new double[]{a, b};
    }","public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound,
            int maximumIterations) throws ConvergenceException,
            FunctionEvaluationException {

    if (function == null) {
        throw MathRuntimeException.createIllegalArgumentException(""function is null"");
    }
    if (maximumIterations <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(
              ""bad value for maximum iterations number: {0}"", maximumIterations);
    }
    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
        throw MathRuntimeException.createIllegalArgumentException(
              ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
              lowerBound, initial, upperBound);
    }

    double a = initial;
    double b = initial;
    double fa = function.value(a);
    double fb = fa;
    int numIterations = 0 ;

    boolean changeA = true;
    boolean changeB = true;
    
    do {
        if (changeA) {
            a = Math.max(a - 1.0, lowerBound);
            fa = function.value(a);
        }
        if (changeB) {
            b = Math.min(b + 1.0, upperBound);
            fb = function.value(b);
        }
        numIterations++;

        changeA = (fa * fb > 0.0) && (a > lowerBound);
        changeB = (fa * fb > 0.0) && (b < upperBound);

    } while ((fa * fb > 0.0) && numIterations < maximumIterations && (changeA || changeB));

    if (fa * fb >= 0.0) {
        throw new ConvergenceException(
              ""number of iterations={0}, maximum iterations={1}, "" +
              ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
              ""final b value={6}, f(a)={7}, f(b)={8}"",
              numIterations, maximumIterations, initial,
              lowerBound, upperBound, a, b, fa, fb);
    }

    return new double[]{a, b};
}",1,0
210,Math_85,"public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
        
        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0 ;
    
        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            
            fb = function.value(b);
            numIterations++ ;
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
         if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }
        
        return new double[]{a, b};
    }","public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound,
            int maximumIterations) throws ConvergenceException,
            FunctionEvaluationException {

    if (function == null) {
        throw MathRuntimeException.createIllegalArgumentException(""function is null"");
    }
    if (maximumIterations <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(
              ""bad value for maximum iterations number: {0}"", maximumIterations);
    }
    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
        throw MathRuntimeException.createIllegalArgumentException(
              ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
              lowerBound, initial, upperBound);
    }

    double a = initial;
    double b = initial;
    double fa = function.value(a);
    double fb = fa;
    int numIterations = 0 ;

    if (fa == 0.0) {
        return new double[]{a, a};
    }

    boolean changeA = true;
    boolean changeB = true;

    while (fa * fb > 0.0 && numIterations < maximumIterations && (a > lowerBound || b < upperBound)) {
        if (changeA) {
            a = Math.max(a - 1.0, lowerBound);
            fa = function.value(a);
        }
        if (changeB) {
            b = Math.min(b + 1.0, upperBound);
            fb = function.value(b);
        }
        numIterations++;

        changeA = (fa * fb > 0.0) && (a > lowerBound);
        changeB = (fa * fb > 0.0) && (b < upperBound);
    }

    if (fa * fb >= 0.0) {
        throw new ConvergenceException(
              ""number of iterations={0}, maximum iterations={1}, "" +
              ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
              ""final b value={6}, f(a)={7}, f(b)={8}"",
              numIterations, maximumIterations, initial,
              lowerBound, upperBound, a, b, fa, fb);
    }

    return new double[]{a, b};
}",2,0
210,Math_85,"public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound, 
            int maximumIterations) throws ConvergenceException, 
            FunctionEvaluationException {
        
        if (function == null) {
            throw MathRuntimeException.createIllegalArgumentException(""function is null"");
        }
        if (maximumIterations <= 0)  {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""bad value for maximum iterations number: {0}"", maximumIterations);
        }
        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"",
                  lowerBound, initial, upperBound);
        }
        double a = initial;
        double b = initial;
        double fa;
        double fb;
        int numIterations = 0 ;
    
        do {
            a = Math.max(a - 1.0, lowerBound);
            b = Math.min(b + 1.0, upperBound);
            fa = function.value(a);
            
            fb = function.value(b);
            numIterations++ ;
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
         if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                      ""final b value={6}, f(a)={7}, f(b)={8}"",
                      numIterations, maximumIterations, initial,
                      lowerBound, upperBound, a, b, fa, fb);
        }
        
        return new double[]{a, b};
    }","public static double[] bracket(UnivariateRealFunction function,
            double initial, double lowerBound, double upperBound,
            int maximumIterations) throws ConvergenceException,
            FunctionEvaluationException {

    if (function == null) {
        throw MathRuntimeException.createIllegalArgumentException(""function is null"");
    }
    if (maximumIterations <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(
              ""bad value for maximum iterations number: {0}"", maximumIterations);
    }
    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
        throw MathRuntimeException.createIllegalArgumentException(
              ""invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}"",
              lowerBound, initial, upperBound);
    }

    double a = initial;
    double b = initial;
    double fa;
    double fb;
    int numIterations = 0;

    // Track if bracket was successful to avoid unnecessary iterations
    boolean bracketFound = false;

    do {
        a = Math.max(a - 1.0, lowerBound);
        fa = function.value(a);

        b = Math.min(b + 1.0, upperBound);
        fb = function.value(b);
        numIterations++;

        // Stop iterating if valid bracket is found
        if (fa * fb <= 0.0) {
            bracketFound = true;
            break;
        }
    } while ((numIterations < maximumIterations) && (a > lowerBound || b < upperBound));

    if (!bracketFound) {
        throw new ConvergenceException(
                  ""number of iterations={0}, maximum iterations={1}, "" +
                  ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
                  ""final b value={6}, f(a)={7}, f(b)={8}"",
                  numIterations, maximumIterations, initial,
                  lowerBound, upperBound, a, b, fa, fb);
    }

    return new double[]{a, b};
}",3,0
211,Math_86,"    public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }

    }","public CholeskyDecompositionImpl(final RealMatrix matrix,
                                 final double relativeSymmetryThreshold,
                                 final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(),
                                           matrix.getColumnDimension());
    }

    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;

    // check the matrix before transformation
    for (int i = 0; i < order; ++i) {

        final double[] lI = lTData[i];

        if (lTData[i][i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }
        // check off-diagonal elements (and reset them to 0)
        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta =
                relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
            lJ[i] = 0;
        }
    }

    // transform the matrix
    for (int i = 0; i < order; ++i) {

        final double[] ltI = lTData[i];

        // check diagonal element
        if (ltI[i] <= 0) {
            throw new NotPositiveDefiniteMatrixException();
        }

        ltI[i] = Math.sqrt(ltI[i]);
        final double inverse = 1.0 / ltI[i];

        for (int q = i + 1; q < order; ++q) {
            final double[] ltQ = lTData[q];
            ltQ[i] *= inverse;
        }
        for (int q = i + 1; q < order; ++q) {
            final double[] ltQ = lTData[q];
            for (int p = q; p < order; ++p) {
                ltQ[p] -= ltQ[i] * ltI[p];
            }
        }
    }
}",0,0
211,Math_86,"    public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }

    }","public CholeskyDecompositionImpl(final RealMatrix matrix, 
                                 final double relativeSymmetryThreshold, 
                                 final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
    }

    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;

    // Check the matrix before transformation
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];

        // Ensure diagonal elements are above the positivity threshold
        if (lI[i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }

        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));

            // Check for symmetry within the threshold
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }

            // Reset off-diagonal elements to zero for decomposition
            lJ[i] = 0;
            lI[j] = 0; // Ensure symmetry of clearing values
        }
    }

    // Perform the decomposition
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];

        // Validate diagonal values during decomposition
        if (ltI[i] <= 0) {
            throw new NotPositiveDefiniteMatrixException();
        }

        ltI[i] = Math.sqrt(ltI[i]);
        final double inverseDiagonal = 1.0 / ltI[i];

        for (int j = i + 1; j < order; ++j) {
            final double[] ltJ = lTData[j];
            ltJ[i] *= inverseDiagonal;

            for (int k = j; k < order; ++k) {
                // Ensure updates happen for the remaining triangular matrix
                ltJ[k] -= ltJ[i] * ltI[k];
            }
        }
    }
}",1,0
211,Math_86,"    public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }

    }","public CholeskyDecompositionImpl(final RealMatrix matrix,
                                 final double relativeSymmetryThreshold,
                                 final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    
    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(),
                                           matrix.getColumnDimension());
    }

    final int order = matrix.getRowDimension();
    lTData   = matrix.getData();
    cachedL  = null;
    cachedLT = null;

    // Check the matrix before transformation
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];

        // Ensure diagonal elements are above the positivity threshold
        if (lI[i] <= absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }

        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));

            // Check for symmetry within the threshold
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }

            // Reset off-diagonal elements to zero for decomposition
            lJ[i] = 0;
        }
    }

    // Transform the matrix
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];

        // Validate diagonal values during decomposition
        if (ltI[i] <= absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }

        ltI[i] = Math.sqrt(ltI[i]);
        final double inverseDiagonal = 1.0 / ltI[i];

        for (int q = i + 1; q < order; ++q) {
            final double[] ltQ = lTData[q];
            ltQ[i] *= inverseDiagonal;

            for (int p = i; p < order; ++p) {
                ltQ[p] -= ltQ[i] * ltI[p];
            }
        }
    }
}",2,0
211,Math_86,"    public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }

    }","public CholeskyDecompositionImpl(final RealMatrix matrix,
                                 final double relativeSymmetryThreshold,
                                 final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(),
                                           matrix.getColumnDimension());
    }

    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;

    // check the matrix before transformation
    for (int i = 0; i < order; ++i) {

        final double[] lI = lTData[i];

        if (lTData[i][i] <= absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }
        // check off-diagonal elements (and reset them to 0)
        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta =
                relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
            lJ[i] = 0;
            lI[j] = 0; // Ensure symmetry by setting both lIJ and lJI to zero
        }
    }

    // transform the matrix
    for (int i = 0; i < order; ++i) {

        final double[] ltI = lTData[i];

        // check diagonal element
        if (ltI[i] <= 0) {
            throw new NotPositiveDefiniteMatrixException();
        }

        ltI[i] = Math.sqrt(ltI[i]);
        final double inverseDiagonal = 1.0 / ltI[i];

        for (int q = i + 1; q < order; ++q) {
            final double[] ltQ = lTData[q];
            ltQ[i] *= inverseDiagonal;
            for (int p = i; p < order; ++p) {
                ltQ[p] -= ltQ[i] * ltI[p];
            }
        }
    }
}",3,0
211,Math_86,"    public CholeskyDecompositionImpl(final RealMatrix matrix,
                                     final double relativeSymmetryThreshold,
                                     final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

        if (!matrix.isSquare()) {
            throw new NonSquareMatrixException(matrix.getRowDimension(),
                                               matrix.getColumnDimension());
        }

        final int order = matrix.getRowDimension();
        lTData   = matrix.getData();
        cachedL  = null;
        cachedLT = null;

        // check the matrix before transformation
        for (int i = 0; i < order; ++i) {

            final double[] lI = lTData[i];

            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
            // check off-diagonal elements (and reset them to 0)
            for (int j = i + 1; j < order; ++j) {
                final double[] lJ = lTData[j];
                final double lIJ = lI[j];
                final double lJI = lJ[i];
                final double maxDelta =
                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                if (Math.abs(lIJ - lJI) > maxDelta) {
                    throw new NotSymmetricMatrixException();
                }
                lJ[i] = 0;
           }
        }

        // transform the matrix
        for (int i = 0; i < order; ++i) {

            final double[] ltI = lTData[i];

            // check diagonal element

            ltI[i] = Math.sqrt(ltI[i]);
            final double inverse = 1.0 / ltI[i];

            for (int q = order - 1; q > i; --q) {
                ltI[q] *= inverse;
                final double[] ltQ = lTData[q];
                for (int p = q; p < order; ++p) {
                    ltQ[p] -= ltI[q] * ltI[p];
                }
            }

        }

    }","public CholeskyDecompositionImpl(final RealMatrix matrix,
                                 final double relativeSymmetryThreshold,
                                 final double absolutePositivityThreshold)
        throws NonSquareMatrixException,
               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {

    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(),
                                           matrix.getColumnDimension());
    }

    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;

    // Check the matrix before transformation
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];

        // Ensure diagonal elements are above the positivity threshold
        if (lTData[i][i] <= absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }

        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));

            // Check for symmetry within the threshold
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }

            // Reset off-diagonal elements to zero for decomposition
            lJ[i] = 0;
        }
    }

    // Transform the matrix
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];

        if (ltI[i] <= 0) {
            throw new NotPositiveDefiniteMatrixException();
        }

        ltI[i] = Math.sqrt(ltI[i]);
        final double inverseDiagonal = 1.0 / ltI[i];

        for (int q = i + 1; q < order; ++q) {
            final double[] ltQ = lTData[q];
            ltQ[i] *= inverseDiagonal;
        }
        for (int q = i + 1; q < order; ++q) {
            final double[] ltQ = lTData[q];
            for (int p = q; p < order; ++p) {
                ltQ[p] -= ltQ[i] * ltI[p];
            }
        }
    }
}",4,0
212,Math_87,"private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 if (row == null) {
                 row = i;
                 } else {
                 return null;
                 }
             }
         }
         return row;
    }","private Integer getBasicRow(final int col) {
    Integer row = null;
    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
        if (!MathUtils.equals(getEntry(i, col), 0.0)) { // Removed epsilon comparison here
            if (row == null) {
                row = i;
            } else {
                return null;
            }
        }
    }
    return row;
}",0,0
212,Math_87,"private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 if (row == null) {
                 row = i;
                 } else {
                 return null;
                 }
             }
         }
         return row;
    }","private Integer getBasicRow(final int col) {
    Integer row = null;
    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
        double entry = getEntry(i, col);
        if (!MathUtils.equals(entry, 0.0, epsilon) && !MathUtils.equals(entry, 1.0, epsilon)) {
            if (row == null) {
                row = i;
            } else {
                return null;
            }
        }
    }
    return row;
}",1,0
212,Math_87,"private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 if (row == null) {
                 row = i;
                 } else {
                 return null;
                 }
             }
         }
         return row;
    }","private Integer getBasicRow(final int col) {
    Integer row = null;
    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
        double entry = getEntry(i, col);
        if (!MathUtils.equals(entry, 0.0, epsilon)) {
            if (MathUtils.equals(entry, 1.0, epsilon) || MathUtils.equals(entry, -1.0, epsilon)) {
                if (row == null) {
                    row = i;
                } else {
                    return null;
                }
            }
        }
    }
    return row;
}",2,0
212,Math_87,"private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 if (row == null) {
                 row = i;
                 } else {
                 return null;
                 }
             }
         }
         return row;
    }","private Integer getBasicRow(final int col) {
    Integer row = null;
    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
        double entry = getEntry(i, col);
        // Skip rows where the entry is zero
        if (!MathUtils.equals(entry, 0.0, epsilon)) {
            // Check if the entry absolute value is 1, indicating a valid basic variable
            if (MathUtils.equals(entry, 1.0, epsilon) || MathUtils.equals(entry, -1.0, epsilon)) {
                if (row == null) {
                    row = i;
                } else {
                    return null;
                }
            }
        }
    }
    return row;
}",3,0
212,Math_87,"private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 if (row == null) {
                 row = i;
                 } else {
                 return null;
                 }
             }
         }
         return row;
    }","private Integer getBasicRow(final int col) {
    Integer row = null;
    boolean foundNonZero = false;
    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
        double entry = getEntry(i, col);
        if (MathUtils.equals(entry, 1.0, epsilon)) { // Looking for unit entry
            if (row == null) {
                row = i;
                foundNonZero = true;
            } else {
                return null;
            }
        } else if (!MathUtils.equals(entry, 0.0, epsilon)) {
            return null;
        }
    }
    return foundNonZero ? row : null; // Return null if no valid basic variable found
}",4,0
213,Math_88,"protected RealPointValuePair getSolution() {
        double[] coefficients = new double[getOriginalNumDecisionVariables()];
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             if (basicRow != null) {
                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                     if (tableau.getEntry(basicRow, j) == 1) {
                          coefficients[i] = 0;
                     }
                 }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
    for (int i = 0; i < coefficients.length; i++) {
        basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
        if (basicRow != null) {
            for (int j = getNumObjectiveFunctions(); j < getOriginalNumDecisionVariables(); j++) {
                if (tableau.getEntry(basicRow, j) == 1) {
                    coefficients[i] = 0;
                    break;
                }
            }
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0,0
213,Math_88,"protected RealPointValuePair getSolution() {
        double[] coefficients = new double[getOriginalNumDecisionVariables()];
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             if (basicRow != null) {
                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                     if (tableau.getEntry(basicRow, j) == 1) {
                          coefficients[i] = 0;
                     }
                 }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
    for (int i = 0; i < coefficients.length; i++) {
        basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        if (basicRow == null) {
            coefficients[i] = 0;
        } else {
            coefficients[i] = getEntry(basicRow, getRhsOffset()) - (restrictToNonNegative ? 0 : mostNegative);
            for (int j = getNumObjectiveFunctions(); j < getHeight(); j++) {
                if (getEntry(basicRow, j) == 1 && j != (getNumObjectiveFunctions() + i)) {
                    coefficients[i] = 0;
                    break;
                }
            }
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",1,0
213,Math_88,"protected RealPointValuePair getSolution() {
        double[] coefficients = new double[getOriginalNumDecisionVariables()];
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             if (basicRow != null) {
                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                     if (tableau.getEntry(basicRow, j) == 1) {
                          coefficients[i] = 0;
                     }
                 }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
    for (int i = 0; i < coefficients.length; i++) {
        basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        if (basicRow != null) {
            coefficients[i] = getEntry(basicRow, getRhsOffset()) - (restrictToNonNegative ? 0 : mostNegative);
            boolean hasOtherBasicOne = false;
            for (int j = getNumObjectiveFunctions(); j < getWidth() - 1; j++) {
                if (j != (getNumObjectiveFunctions() + i) && tableau.getEntry(basicRow, j) == 1) {
                    hasOtherBasicOne = true;
                    break;
                }
            }
            if (hasOtherBasicOne) {
                coefficients[i] = 0;
            }
        } else {
            coefficients[i] = 0;
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",2,0
213,Math_88,"protected RealPointValuePair getSolution() {
        double[] coefficients = new double[getOriginalNumDecisionVariables()];
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             if (basicRow != null) {
                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                     if (tableau.getEntry(basicRow, j) == 1) {
                          coefficients[i] = 0;
                     }
                 }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
    for (int i = 0; i < coefficients.length; i++) {
        basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        double coefficient = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
        if (basicRow != null) {
            boolean isZero = false;
            for (int j = 0; j < getOriginalNumDecisionVariables(); j++) {
                if (j != i && tableau.getEntry(basicRow, getNumObjectiveFunctions() + j) == 1) {
                    isZero = true;
                    break;
                }
            }
            coefficients[i] = isZero ? 0 : coefficient;
        } else {
            coefficients[i] = coefficient;
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",3,0
213,Math_88,"protected RealPointValuePair getSolution() {
        double[] coefficients = new double[getOriginalNumDecisionVariables()];
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             if (basicRow != null) {
                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                     if (tableau.getEntry(basicRow, j) == 1) {
                          coefficients[i] = 0;
                     }
                 }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
    for (int i = 0; i < coefficients.length; i++) {
        basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        if (basicRow != null) {
            coefficients[i] = getEntry(basicRow, getRhsOffset()) - (restrictToNonNegative ? 0 : mostNegative);
            boolean isBasicColumnValid = true;
            for (int j = getNumObjectiveFunctions(); j < getOriginalNumDecisionVariables(); j++) {
                if (j != i && tableau.getEntry(basicRow, getNumObjectiveFunctions() + j) != 0) {
                    isBasicColumnValid = false;
                    break;
                }
            }
            if (!isBasicColumnValid) {
                coefficients[i] = 0;
            }
        } else {
            coefficients[i] = 0;
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",4,0
214,Math_89,"    public void addValue(Object v) {
            addValue((Comparable<?>) v);            
    }
","public void addValue(Object v) {
    if (v instanceof Comparable<?>) {
        addValue((Comparable<?>) v);
    } else {
        throw new IllegalArgumentException(""Object must be Comparable"");
    }
}",0,0
215,Math_9,"    public Line revert() {
        final Line reverted = new Line(zero, zero.subtract(direction));
        return reverted;
    }
",Match failed,0,0
215,Math_9,"    public Line revert() {
        final Line reverted = new Line(zero, zero.subtract(direction));
        return reverted;
    }
",Match failed,1,0
215,Math_9,"    public Line revert() {
        final Line reverted = new Line(zero, zero.subtract(direction));
        return reverted;
    }
","public Line revert() {
    // Reverse the direction by using subtract().
    final Line reverted = new Line(zero, zero.add(direction.negate()));
    return reverted;
}",2,0
215,Math_9,"    public Line revert() {
        final Line reverted = new Line(zero, zero.subtract(direction));
        return reverted;
    }
","public Line revert() {
    // Reverse the direction while ensuring numerical precision using scaled addition
    Vector3D invertedDirection = direction.normalize().negate();
    return new Line(zero, invertedDirection);
}",3,0
215,Math_9,"    public Line revert() {
        final Line reverted = new Line(zero, zero.subtract(direction));
        return reverted;
    }
",Match failed,4,0
216,Math_91,"    public int compareTo(Fraction object) {
        double nOd = doubleValue();
        double dOn = object.doubleValue();
        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
    }
","public int compareTo(Fraction object) {
    long nOd = this.numerator * (long)object.denominator;
    long dOn = object.numerator * (long)this.denominator;
    return Long.compare(nOd, dOn);
}",0,0
217,Math_94,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }
","public static int gcd(int u, int v) {
    if (u == 0 || v == 0) {
        return Math.abs(u + v);
    }

    // Keep u and v negative to avoid overflow during negation
    if (u > 0) {
        u = -u;
    }
    if (v > 0) {
        v = -v;
    }

    // Find power of 2 to factor out common twos
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        u /= 2;
        v /= 2;
        k++;
    }

    if (k == 31) {
        throw new ArithmeticException(""Overflow: gcd is 2^31"");
    }

    // Ensure u is odd
    while ((u & 1) == 0) {
        u /= 2;
    }

    int t;
    do {
        while ((v & 1) == 0) {
            v /= 2;
        }

        // Swap u and v if necessary so u is the larger one
        if (u > v) {
            int temp = u;
            u = v;
            v = temp;
        }

        v = (v - u);
    } while (v != 0);

    return -u * (1 << k);
}",0,0
218,Math_95,"    protected double getInitialDomain(double p) {
        double ret;
        double d = getDenominatorDegreesOfFreedom();
            // use mean
            ret = d / (d - 2.0);
        return ret;
    }
",Match failed,0,0
218,Math_95,"    protected double getInitialDomain(double p) {
        double ret;
        double d = getDenominatorDegreesOfFreedom();
            // use mean
            ret = d / (d - 2.0);
        return ret;
    }
","protected double getInitialDomain(double p) {
    double ret;
    double d = getDenominatorDegreesOfFreedom();
    if (d > 2.0) {
        // use mean
        ret = d / (d - 2.0);
    } else {
        // handle cases where d <= 2.0 explicitly
        if (d == 2.0) {
            ret = Double.MAX_VALUE; // asymptote
        } else {
            ret = 1.0; // Arbitrary positive value for d < 2.0
        }
    }
    return ret;
}",1,0
219,Math_96,"public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else  {
            try {
                Complex rhs = (Complex)other;
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
                ret = false;
            }
        }
      
        return ret;
    }","public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (!(other instanceof Complex)) {
        return false;
    }
    Complex rhs = (Complex) other;
    if (this.isNaN() && rhs.isNaN()) {
        return true;
    }
    return Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())
        && Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary());
}",0,0
219,Math_96,"public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else  {
            try {
                Complex rhs = (Complex)other;
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
                ret = false;
            }
        }
      
        return ret;
    }","public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (!(other instanceof Complex)) {
        return false;
    }
    Complex rhs = (Complex) other;
    if (this.isNaN() || rhs.isNaN()) {
        return this.isNaN() && rhs.isNaN();
    }
    if (Double.compare(this.real, rhs.getReal()) != 0) {
        return false;
    }
    if (Double.compare(this.imaginary, rhs.getImaginary()) != 0) {
        return false;
    }
    return true;
}",1,0
219,Math_96,"public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else  {
            try {
                Complex rhs = (Complex)other;
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
                ret = false;
            }
        }
      
        return ret;
    }","public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (!(other instanceof Complex)) {
        return false;
    }
    Complex rhs = (Complex) other;

    if (this.isNaN() || rhs.isNaN()) {
        return this.isNaN() && rhs.isNaN();
    }

    boolean realEqual = Double.compare(real, -0.0) == 0 && Double.compare(rhs.getReal(), -0.0) == 0 
                        || Double.compare(real, rhs.getReal()) == 0;
    boolean imaginaryEqual = Double.compare(imaginary, rhs.getImaginary()) == 0;

    return realEqual && imaginaryEqual;
}",2,0
219,Math_96,"public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else  {
            try {
                Complex rhs = (Complex)other;
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
                ret = false;
            }
        }
      
        return ret;
    }","public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (!(other instanceof Complex)) {
        return false;
    }
    Complex rhs = (Complex) other;

    if (this.isNaN() || rhs.isNaN()) {
        return this.isNaN() && rhs.isNaN();
    }

    if (Double.doubleToLongBits(real) != Double.doubleToLongBits(rhs.getReal())) {
        if (!(Double.compare(real, -0.0) == 0 && Double.compare(rhs.getReal(), -0.0) == 0)) {
            return false;
        }
    }

    if (Double.doubleToLongBits(imaginary) != Double.doubleToLongBits(rhs.getImaginary())) {
        return false;
    }

    return true;
}",3,0
219,Math_96,"public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else  {
            try {
                Complex rhs = (Complex)other;
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
                ret = false;
            }
        }
      
        return ret;
    }","public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (!(other instanceof Complex)) {
        return false;
    }
    Complex rhs = (Complex) other;

    if (this.isNaN() || rhs.isNaN()) {
        return this.isNaN() && rhs.isNaN();
    }

    // Handle special case for -0.0 comparison for real and imaginary parts
    boolean realEqual = (Double.compare(real, -0.0) == 0 && Double.compare(rhs.getReal(), -0.0) == 0)
            || Double.compare(real, rhs.getReal()) == 0;
    boolean imaginaryEqual = (Double.compare(imaginary, -0.0) == 0 && Double.compare(rhs.getImaginary(), -0.0) == 0)
            || Double.compare(imaginary, rhs.getImaginary()) == 0;

    return realEqual && imaginaryEqual;
}",4,0
220,Math_97,"public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
        clearResult();
        verifyInterval(min, max);
        
        double ret = Double.NaN;
        
        double yMin = f.value(min);
        double yMax = f.value(max);
         
         // Verify bracketing
         double sign = yMin * yMax;
         if (sign >= 0) {
             // check if either value is close to a zero
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
         } else {
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
             // either min or max is a root
         }
 
         return ret;
    }","public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
        clearResult();
        verifyInterval(min, max);
        
        double ret = Double.NaN;
        
        double yMin = f.value(min);
        double yMax = f.value(max);
         
        // Verify bracketing
        double sign = yMin * yMax;
        if (sign > 0) {
            // Neither endpoint value is close enough to zero and the interval does not bracket a root.
            throw new IllegalArgumentException(
                ""Function values at endpoints do not have different signs. "" +
                ""Endpoints: ["" + min + "", "" + max + ""] "" +
                ""Values: ["" + yMin + "", "" + yMax + ""]"");
        } else if (Math.abs(yMin) < functionValueAccuracy) {
            // min is a root
            setResult(min, 0);
            return min;
        } else if (Math.abs(yMax) < functionValueAccuracy) {
            // max is a root
            setResult(max, 0);
            return max;
        } else {
            // Solve using initial guesses
            ret = solve(min, yMin, max, yMax, min, yMin);
        }

        return ret;
    }",0,0
220,Math_97,"public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
        clearResult();
        verifyInterval(min, max);
        
        double ret = Double.NaN;
        
        double yMin = f.value(min);
        double yMax = f.value(max);
         
         // Verify bracketing
         double sign = yMin * yMax;
         if (sign >= 0) {
             // check if either value is close to a zero
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
         } else {
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
             // either min or max is a root
         }
 
         return ret;
    }",Match failed,1,0
220,Math_97,"public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
        clearResult();
        verifyInterval(min, max);
        
        double ret = Double.NaN;
        
        double yMin = f.value(min);
        double yMax = f.value(max);
         
         // Verify bracketing
         double sign = yMin * yMax;
         if (sign >= 0) {
             // check if either value is close to a zero
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
         } else {
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
             // either min or max is a root
         }
 
         return ret;
    }","public double solve(double min, double max) throws MaxIterationsExceededException, 
        FunctionEvaluationException {
        
        clearResult();
        verifyInterval(min, max);
        
        double ret = Double.NaN;
        
        double yMin = f.value(min);
        double yMax = f.value(max);
         
        // Verify bracketing
        double sign = yMin * yMax;
        if (sign > 0 && Math.abs(yMin) >= functionValueAccuracy && Math.abs(yMax) >= functionValueAccuracy) {
            // Neither endpoint value is close enough to zero and the interval does not bracket a root.
            throw new IllegalArgumentException(
                ""Function values at endpoints do not have different signs. "" +
                ""Endpoints: ["" + min + "", "" + max + ""] "" +
                ""Values: ["" + yMin + "", "" + yMax + ""]"");
        } else if (Math.abs(yMin) < functionValueAccuracy) {
            // min is a root
            setResult(min, 0);
            return min;
        } else if (Math.abs(yMax) < functionValueAccuracy) {
            // max is a root
            setResult(max, 0);
            return max;
        } else {
            // Solve using initial guesses
            ret = solve(min, yMin, max, yMax, min, yMin);
        }

        return ret;
    }",2,0
221,Mockito_1,"    public void captureArgumentsFrom(Invocation invocation) {
        if (invocation.getMethod().isVarArgs()) {
            int indexOfVararg = invocation.getRawArguments().length - 1;
            throw new UnsupportedOperationException();

        } else {
            for (int position = 0; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
        }

//        for (int position = 0; position < matchers.size(); position++) {
//            Matcher m = matchers.get(position);
//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {
//                //TODO SF - this whole lot can be moved captureFrom implementation
//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {
//                    Object array = invocation.getRawArguments()[position];
//                    for (int i = 0; i < Array.getLength(array); i++) {
//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));
//                    }
//                    //since we've captured all varargs already, it does not make sense to process other matchers.
//                    return;
//                } else {
//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);
//                }
//            }
//        }
    }
","public void captureArgumentsFrom(Invocation invocation) {
    if (invocation.getMethod().isVarArgs()) {
        int indexOfVararg = invocation.getRawArguments().length - 1;
        
        for (int position = 0; position < matchers.size(); position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {
                if (position == indexOfVararg) {
                    Object array = invocation.getRawArguments()[position];
                    for (int i = 0; i < Array.getLength(array); i++) {
                        ((CapturesArguments) m).captureFrom(Array.get(array, i));
                    }
                    return; // Exit after capturing all varargs
                } else {
                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);
                }
            }
        }
    } else {
        for (int position = 0; position < matchers.size(); position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments) {
                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
            }
        }
    }
}",0,0
222,Mockito_12,"public Class getGenericType(Field field) {        
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
                 return (Class) actual;
                 //in case of nested generics we don't go deep
         }
         
         return Object.class;
    }","public Class<?> getGenericType(Field field) {
    Type generic = field.getGenericType();
    if (generic instanceof ParameterizedType) {
        Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
        if (actual instanceof Class<?>) {
            return (Class<?>) actual;
        }
    }
    return Object.class;
}",0,0
222,Mockito_12,"public Class getGenericType(Field field) {        
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
                 return (Class) actual;
                 //in case of nested generics we don't go deep
         }
         
         return Object.class;
    }","public Class<?> getGenericType(Field field) {
    Type generic = field.getGenericType();
    if (generic instanceof ParameterizedType) {
        Type actualType = ((ParameterizedType) generic).getActualTypeArguments()[0];
        while (actualType instanceof ParameterizedType) {
            actualType = ((ParameterizedType) actualType).getActualTypeArguments()[0];
        }
        if (actualType instanceof Class) {
            return (Class<?>) actualType;
        }
    }
    return Object.class;
}",1,0
222,Mockito_12,"public Class getGenericType(Field field) {        
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
                 return (Class) actual;
                 //in case of nested generics we don't go deep
         }
         
         return Object.class;
    }","public Class<?> getGenericType(Field field) {
    Type generic = field.getGenericType();
    if (generic instanceof ParameterizedType) {
        Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];

        if (actual instanceof ParameterizedType) {
            actual = ((ParameterizedType) actual).getRawType();
        }
        
        if (actual instanceof Class<?>) {
            return (Class<?>) actual;
        }
    }
    return Object.class;
}",2,0
223,Mockito_13,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             }
         }
         
        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }","public Object handle(Invocation invocation) throws Throwable {
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        // stubbing voids with stubVoid() or doAnswer() style
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                        .getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();

    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                    invocation);

    mockingProgress.validateState();

    // if verificationMode is not null then someone is doing verify()
    if (verificationMode != null) {
        // We need to check if verification was started on the correct mock
        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
            verificationMode.verify(data);
            return null;
        } else {
            // this means there is an invocation on a different mock. Re-adding verification mode
            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
            mockingProgress.resetVerificationMode();
        }
    }

    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);

    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);

        // redo setting invocation for potential stubbing in case of partial
        // mocks / spies.
        // Without it, the real method inside 'when' might have delegated
        // to other self method and overwrite the intended stubbed method
        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}",0,0
223,Mockito_13,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             }
         }
         
        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }","public Object handle(Invocation invocation) throws Throwable {
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);

    if (invocationContainerImpl.hasAnswersForStubbing()) {
        // stubbing voids with stubVoid() or doAnswer() style
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }

    VerificationMode verificationMode = mockingProgress.pullVerificationMode();
    mockingProgress.validateState();

    if (verificationMode != null && verificationMode instanceof MockAwareVerificationMode) {
        if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
            verificationMode.verify(data);
            return null;
        }
        // Reset verification mode if invocation is on a different mock
        mockingProgress.resetVerificationMode();
    }

    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocationMatcher);
    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);
        // Reset invocation container to ensure proper stubbing setup
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}",1,0
223,Mockito_13,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             }
         }
         
        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }","public Object handle(Invocation invocation) throws Throwable {
    // Check if we're in the stubbing phase
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }
    
    // Get the verification mode and validate state
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();
    mockingProgress.validateState();

    // Set up matcher for the invocation
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
    
    // Verification phase
    if (verificationMode != null && verificationMode instanceof MockAwareVerificationMode) {
        if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
            verificationMode.verify(data);
            return null;
        }
    }

    // Proceed to stubbing setup
    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);

    // Handle invocation response
    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);
        // Reset to ensure correct state for potential stubbing
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}",2,0
223,Mockito_13,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             }
         }
         
        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }","public Object handle(Invocation invocation) throws Throwable {
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();

    // Bind the matchers before checking for stubbing setup
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);

    mockingProgress.validateState();

    if (verificationMode != null && verificationMode instanceof MockAwareVerificationMode) {
        if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
            verificationMode.verify(data);
            return null;
        }
    }

    // Stubbing phase: set method for stubbing if answers exist
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }

    // Set invocation for potential stubbing
    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);

    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);
        // Reset invocation container to maintain correct state after answering
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}",3,0
223,Mockito_13,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             }
         }
         
        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }","public Object handle(Invocation invocation) throws Throwable {
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();

    // Bind the matchers before checking for stubbing setup
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);

    mockingProgress.validateState();

    // Verification phase
    if (verificationMode != null) {
        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
            verificationMode.verify(data);
            return null;
        }
        mockingProgress.resetVerificationMode();
    }

    // Stubbing phase: set method for stubbing if answers exist
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }

    // Set invocation for potential stubbing
    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);

    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);
        // Reset invocation container to maintain correct state after answering
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}",4,0
224,Mockito_18,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
","public Object answer(InvocationOnMock invocation) {
    if (methodsGuru.isToString(invocation.getMethod())) {
        Object mock = invocation.getMock();
        MockName name = mockUtil.getMockName(mock);
        if (name.isDefault()) {
            return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
        } else {
            return name.toString();
        }
    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
        // see issue 184.
        // mocks by default should return 0 if references are the same, otherwise some other value because they are not the same.
        // Hence we return 1 (anything but 0 is good).
        // Only for compareTo() method by the Comparable interface
        return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
    }

    Class<?> returnType = invocation.getMethod().getReturnType();
    if(returnType == void.class) {
        return null;
    }
    return returnValueFor(returnType);
}",0,0
224,Mockito_18,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
",Match failed,1,0
224,Mockito_18,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
",Match failed,2,0
224,Mockito_18,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
",Match failed,3,0
224,Mockito_18,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
",Match failed,4,0
225,Mockito_20,"    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }
","public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
        throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
    }
    
    Class<? extends T> mockedProxyType;
    try {
        mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
    } catch (Exception e) {
        throw new MockitoException(
            join(""Failed to generate mock bytecode for:"",
                 ""  Type to mock: "" + describeClass(settings.getTypeToMock()),
                 ""  Extra interfaces: "" + settings.getExtraInterfaces()
            ), e);
    }

    T mockInstance = null;
    try {
        mockInstance = classInstantiator.instantiate(mockedProxyType);
        
        if (!(mockInstance instanceof MockMethodInterceptor.MockAccess)) {
            throw new MockitoException(
                join(""Mock instance is not compatible with MockAccess interface."",
                     ""  Mock class: "" + mockedProxyType.getName(),
                     ""  Instance provided: "" + mockInstance
                )
            );
        }
        
        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

        return ensureMockIsAssignableToMockedType(settings, mockInstance);
    } catch (ClassCastException cce) {
        throw new MockitoException(join(
                ""ClassCastException occurred while creating the mockito mock:"",
                ""  Mock class: "" + describeClass(mockedProxyType),
                ""  Type to mock: "" + describeClass(settings.getTypeToMock()),
                ""  Proxy instance class: "" + (mockInstance != null ? describeClass(mockInstance) : ""null""),
                ""  Instance creation by: "" + classInstantiator.getClass().getSimpleName(),
                """",
                ""You might experience classloading issues. Please ask the Mockito mailing list.""
        ), cce);
    } catch (InstantiationException e) {
        throw new MockitoException(""Unable to create mock instance of type '""
            + settings.getTypeToMock().getSimpleName() + ""'"", e);
    } catch (Exception e) {
        throw new MockitoException(""Unexpected error during mock creation"", e);
    }
}",0,0
225,Mockito_20,"    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }
","public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
        throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
    }

    Class<? extends T> mockedProxyType;
    try {
        mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
    } catch (Exception e) {
        throw new MockitoException(
            join(""Failed to generate mock bytecode for:"",
                 ""  Type to mock: "" + describeClass(settings.getTypeToMock()),
                 ""  Extra interfaces: "" + settings.getExtraInterfaces()
            ), e);
    }

    T mockInstance = null;
    try {
        if (settings.useConstructor()) {
            mockInstance = createMockViaConstructor(mockedProxyType, settings);
        } else {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
        }

        if (!(mockInstance instanceof MockMethodInterceptor.MockAccess)) {
            throw new MockitoException(
                join(""Mock instance is not compatible with MockAccess interface."",
                     ""  Mock class: "" + mockedProxyType.getName(),
                     ""  Instance provided: "" + mockInstance
                )
            );
        }

        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

        return ensureMockIsAssignableToMockedType(settings, mockInstance);
    } catch (ClassCastException cce) {
        throw new MockitoException(join(
                ""ClassCastException occurred while creating the mockito mock:"",
                ""  Mock class: "" + describeClass(mockedProxyType),
                ""  Type to mock: "" + describeClass(settings.getTypeToMock()),
                ""  Proxy instance class: "" + (mockInstance != null ? describeClass(mockInstance) : ""null""),
                ""  Instance creation by: "" + classInstantiator.getClass().getSimpleName(),
                """",
                ""You might experience classloading issues. Please ask the Mockito mailing list.""
        ), cce);
    } catch (InstantiationException e) {
        throw new MockitoException(""Unable to create mock instance of type '""
            + settings.getTypeToMock().getSimpleName() + ""'"", e);
    } catch (Exception e) {
        throw new MockitoException(""Unexpected error during mock creation"", e);
    }
}

private <T> T createMockViaConstructor(Class<? extends T> mockedProxyType, MockCreationSettings<T> settings) throws InstantiationException {
    try {
        // Using the constructor with specific arguments, if provided in settings.
        return mockedProxyType.getDeclaredConstructor().newInstance();
    } catch (ReflectiveOperationException e) {
        throw new InstantiationException(""Failed to instantiate class with default constructor: "" + mockedProxyType.getName(), e);
    }
}",1,0
225,Mockito_20,"    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }
","public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
        throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
    }

    Class<? extends T> mockedProxyType;
    try {
        mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
    } catch (Exception e) {
        throw new MockitoException(
            join(""Failed to generate mock bytecode for:"",
                 ""  Type to mock: "" + describeClass(settings.getTypeToMock()),
                 ""  Extra interfaces: "" + settings.getExtraInterfaces()
            ), e);
    }

    T mockInstance;
    try {
        if (settings.getSpiedInstance() != null) {
            mockInstance = mockedProxyType.cast(settings.getSpiedInstance());
        } else if (settings.useConstructor() && settings.getOuterClassInstance() != null) {
            mockInstance = createInnerClassMock(mockedProxyType, settings.getOuterClassInstance());
        } else if (settings.useConstructor()) {
            mockInstance = createMockUsingConstructor(mockedProxyType, settings);
        } else {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
        }

        if (!(mockInstance instanceof MockMethodInterceptor.MockAccess)) {
            throw new MockitoException(
                join(""Mock instance is not compatible with MockAccess interface."",
                     ""  Mock class: "" + mockedProxyType.getName(),
                     ""  Instance provided: "" + mockInstance
                )
            );
        }

        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

        return ensureMockIsAssignableToMockedType(settings, mockInstance);
    } catch (Exception e) {
        throw new MockitoException(""Failed to create mock instance. Verify constructor usage and type compatibility."", e);
    }
}

private <T> T createMockUsingConstructor(Class<? extends T> mockedProxyType, MockCreationSettings<T> settings) throws Exception {
    try {
        return mockedProxyType.getDeclaredConstructor().newInstance();
    } catch (ReflectiveOperationException e) {
        throw new InstantiationException(""Failed to instantiate class with provided constructor: "" + mockedProxyType.getName(), e);
    }
}

private <T> T createInnerClassMock(Class<? extends T> mockedProxyType, Object outerInstance) throws Exception {
    try {
        return mockedProxyType.getDeclaredConstructor(outerInstance.getClass()).newInstance(outerInstance);
    } catch (ReflectiveOperationException e) {
        throw new InstantiationException(""Failed to instantiate inner class with the provided outer instance: "" + mockedProxyType.getName(), e);
    }
}",2,0
225,Mockito_20,"    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }
","public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
        throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
    }
    Class<? extends T> mockedProxyType;
    try {
        mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
    } catch (Exception e) {
        throw new MockitoException(
            join(""Failed to generate mock bytecode for:"",
                 ""  Type to mock: "" + describeClass(settings.getTypeToMock()),
                 ""  Extra interfaces: "" + settings.getExtraInterfaces()
            ), e);
    }

    T mockInstance;
    try {
        if (settings.getSpiedInstance() != null) {
            mockInstance = settings.getSpiedInstance();
        } else if (settings.useConstructor()) {
            mockInstance = createMockWithConstructor(mockedProxyType, settings);
        } else {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
        }

        if (!(mockInstance instanceof MockMethodInterceptor.MockAccess)) {
            throw new MockitoException(
                join(""Mock instance is not compatible with MockAccess interface."",
                     ""  Mock class: "" + mockedProxyType.getName(),
                     ""  Instance provided: "" + mockInstance
                )
            );
        }

        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

        return ensureMockIsAssignableToMockedType(settings, mockInstance);
    } catch (Exception e) {
        throw new MockitoException(""Failed to create mock instance."", e);
    }
}

private <T> T createMockWithConstructor(Class<? extends T> mockedProxyType, MockCreationSettings<T> settings) throws Exception {
    try {
        if (settings.getOuterClassInstance() != null) {
            return mockedProxyType.getDeclaredConstructor(settings.getOuterClassInstance().getClass())
                                  .newInstance(settings.getOuterClassInstance());
        }
        return mockedProxyType.getConstructor().newInstance();
    } catch (ReflectiveOperationException e) {
        throw new InstantiationException(""Failed to instantiate class: "" + mockedProxyType.getName(), e);
    }
}",3,0
225,Mockito_20,"    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }
","public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
        throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
    }
    Class<? extends T> mockedProxyType;
    try {
        mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
    } catch (Exception e) {
        throw new MockitoException(
            join(""Failed to generate mock bytecode for:"",
                 ""  Type to mock: "" + describeClass(settings.getTypeToMock()),
                 ""  Extra interfaces: "" + settings.getExtraInterfaces()
            ), e);
    }

    T mockInstance;
    try {
        if (settings.getUseConstructor()) {
            mockInstance = instantiateWithConstructor(mockedProxyType, settings);
        } else {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
        }

        if (!(mockInstance instanceof MockMethodInterceptor.MockAccess)) {
            throw new MockitoException(
                join(""Mock instance is not compatible with MockAccess interface."",
                     ""  Mock class: "" + mockedProxyType.getName(),
                     ""  Instance provided: "" + mockInstance
                )
            );
        }

        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

        return ensureMockIsAssignableToMockedType(settings, mockInstance);
    } catch (Exception e) {
        throw new MockitoException(""Failed to create mock instance."", e);
    }
}

private <T> T instantiateWithConstructor(Class<? extends T> mockedProxyType, MockCreationSettings<T> settings) throws InstantiationException {
    try {
        // Instantiate using constructor if specified in settings
        return mockedProxyType.getConstructor().newInstance();
    } catch (ReflectiveOperationException e) {
        throw new InstantiationException(""Failed to instantiate class with constructor: "" + mockedProxyType.getName(), e);
    }
}",4,0
226,Mockito_22,"    public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }
","public static boolean areEqual(Object o1, Object o2) {
    if (o1 == null || o2 == null) {
        return o1 == null && o2 == null;
    } else if (isArray(o1)) {
        return isArray(o2) && areArraysEqual(o1, o2);
    } else {
        return o1.equals(o2);
    }
}

private static boolean isArray(Object obj) {
    return obj != null && obj.getClass().isArray();
}

private static boolean areArraysEqual(Object o1, Object o2) {
    return areArrayLengthsEqual(o1, o2) && areArrayElementsEqual(o1, o2);
}

private static boolean areArrayLengthsEqual(Object o1, Object o2) {
    int length1 = java.lang.reflect.Array.getLength(o1);
    int length2 = java.lang.reflect.Array.getLength(o2);
    return length1 == length2;
}

private static boolean areArrayElementsEqual(Object o1, Object o2) {
    int length = java.lang.reflect.Array.getLength(o1);
    for (int i = 0; i < length; i++) {
        Object elem1 = java.lang.reflect.Array.get(o1, i);
        Object elem2 = java.lang.reflect.Array.get(o2, i);
        if (!areEqual(elem1, elem2)) {
            return false;
        }
    }
    return true;
}",0,0
226,Mockito_22,"    public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }
","public static boolean areEqual(Object o1, Object o2) {
    if (o1 == null || o2 == null) {
        return o1 == o2;
    } else if (o1.getClass() != o2.getClass()) {
        return false;
    } else if (isArray(o1)) {
        return areArraysEqual(o1, o2);
    } else {
        return o1.equals(o2);
    }
}

private static boolean isArray(Object obj) {
    return obj != null && obj.getClass().isArray();
}

private static boolean areArraysEqual(Object o1, Object o2) {
    if (!areArrayLengthsEqual(o1, o2)) {
        return false;
    }

    int length = java.lang.reflect.Array.getLength(o1);
    for (int i = 0; i < length; i++) {
        Object elem1 = java.lang.reflect.Array.get(o1, i);
        Object elem2 = java.lang.reflect.Array.get(o2, i);
        if (!areEqual(elem1, elem2)) {
            return false;
        }
    }
    return true;
}

private static boolean areArrayLengthsEqual(Object o1, Object o2) {
    return java.lang.reflect.Array.getLength(o1) == java.lang.reflect.Array.getLength(o2);
}",1,0
226,Mockito_22,"    public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }
","public static boolean areEqual(Object o1, Object o2) {
    if (o1 == null || o2 == null) {
        return o1 == null && o2 == null;
    }

    if (o1.getClass().isArray() && o2.getClass().isArray()) {
        return areArraysEqual(o1, o2);
    }

    if (!o1.getClass().equals(o2.getClass())) {
        return false;
    }

    return o1.equals(o2);
}

private static boolean areArraysEqual(Object o1, Object o2) {
    int length1 = java.lang.reflect.Array.getLength(o1);
    int length2 = java.lang.reflect.Array.getLength(o2);

    if (length1 != length2) {
        return false;
    }

    for (int i = 0; i < length1; i++) {
        Object elem1 = java.lang.reflect.Array.get(o1, i);
        Object elem2 = java.lang.reflect.Array.get(o2, i);
        if (!areEqual(elem1, elem2)) {
            return false;
        }
    }
    return true;
}",2,0
226,Mockito_22,"    public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }
","public static boolean areEqual(Object o1, Object o2) {
    if (o1 == null || o2 == null) {
        return o1 == null && o2 == null;
    } else if (isArray(o1) && isArray(o2)) {
        return areArraysEqual(o1, o2);
    } else {
        return o1.equals(o2);
    }
}

private static boolean isArray(Object obj) {
    return obj != null && obj.getClass().isArray();
}

private static boolean areArraysEqual(Object o1, Object o2) {
    int length1 = java.lang.reflect.Array.getLength(o1);
    int length2 = java.lang.reflect.Array.getLength(o2);

    if (length1 != length2) {
        return false;
    }

    for (int i = 0; i < length1; i++) {
        Object elem1 = java.lang.reflect.Array.get(o1, i);
        Object elem2 = java.lang.reflect.Array.get(o2, i);
        if (!areEqual(elem1, elem2)) {
            return false;
        }
    }
    return true;
}",3,0
226,Mockito_22,"    public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }
","public static boolean areEqual(Object o1, Object o2) {
    if (o1 == o2) {
        return true; // handles both being null and same reference
    }
    if (o1 == null || o2 == null) {
        return false; // one is null, the other is not
    }
    if (isArray(o1) && isArray(o2)) {
        return areArraysEqual(o1, o2); // both are arrays
    }
    // if o1 and o2 are of different types, they are not equal
    if (!o1.getClass().equals(o2.getClass())) {
        return false;
    }
    return o1.equals(o2); // use the standard equals method
}

private static boolean isArray(Object obj) {
    return obj != null && obj.getClass().isArray();
}

private static boolean areArraysEqual(Object o1, Object o2) {
    int length = java.lang.reflect.Array.getLength(o1);
    if (length != java.lang.reflect.Array.getLength(o2)) {
        return false; // different lengths
    }
    for (int i = 0; i < length; i++) {
        // compare each element recursively
        Object elem1 = java.lang.reflect.Array.get(o1, i);
        Object elem2 = java.lang.reflect.Array.get(o2, i);
        if (!areEqual(elem1, elem2)) {
            return false;
        }
    }
    return true;
}",4,0
227,Mockito_24,"    public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }
","public Object answer(InvocationOnMock invocation) {
    if (methodsGuru.isToString(invocation.getMethod())) {
        Object mock = invocation.getMock();
        MockName name = mockUtil.getMockName(mock);
        if (name.isDefault()) {
            return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
        } else {
            return name.toString();
        }
    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
        Object[] args = invocation.getArguments();
        Object mock = invocation.getMock();
        if (args.length > 0 && args[0] == mock) {
            return 0;
        } else {
            return 1;
        }
    }
    
    Class<?> returnType = invocation.getMethod().getReturnType();
    return returnValueFor(returnType);
}",0,0
228,Mockito_26,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.util;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings(""unchecked"")
public class Primitives {
    
    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {
        if(clazz.isPrimitive()) {
            return clazz;
        }
        return (Class<T>) primitiveTypes.get(clazz);
    }

    public static boolean isPrimitiveWrapper(Class<?> type) {
        return wrapperReturnValues.containsKey(type);
    }

    public static <T> T primitiveWrapperOf(Class<T> type) {
        return (T) wrapperReturnValues.get(type);
    }

    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {
        return (T) primitiveValues.get(primitiveType);
    }
    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();
    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();

    static {
        primitiveTypes.put(Boolean.class, Boolean.TYPE);
        primitiveTypes.put(Character.class, Character.TYPE);
        primitiveTypes.put(Byte.class, Byte.TYPE);
        primitiveTypes.put(Short.class, Short.TYPE);
        primitiveTypes.put(Integer.class, Integer.TYPE);
        primitiveTypes.put(Long.class, Long.TYPE);
        primitiveTypes.put(Float.class, Float.TYPE);
        primitiveTypes.put(Double.class, Double.TYPE);
    }

    static {
        wrapperReturnValues.put(Boolean.class, false);
        wrapperReturnValues.put(Character.class, '\u0000');
        wrapperReturnValues.put(Byte.class, (byte) 0);
        wrapperReturnValues.put(Short.class, (short) 0);
        wrapperReturnValues.put(Integer.class, 0);
        wrapperReturnValues.put(Long.class, 0L);
        wrapperReturnValues.put(Float.class, 0F);
        wrapperReturnValues.put(Double.class, 0D);
    }

    static {
        primitiveValues.put(boolean.class, false);
        primitiveValues.put(char.class, '\u0000');
        primitiveValues.put(byte.class, (byte) 0);
        primitiveValues.put(short.class, (short) 0);
        primitiveValues.put(int.class, 0);
        primitiveValues.put(long.class, 0L);
        primitiveValues.put(float.class, 0F);
        primitiveValues.put(double.class, 0);
    }
}",Match failed,0,0
228,Mockito_26,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.util;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings(""unchecked"")
public class Primitives {
    
    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {
        if(clazz.isPrimitive()) {
            return clazz;
        }
        return (Class<T>) primitiveTypes.get(clazz);
    }

    public static boolean isPrimitiveWrapper(Class<?> type) {
        return wrapperReturnValues.containsKey(type);
    }

    public static <T> T primitiveWrapperOf(Class<T> type) {
        return (T) wrapperReturnValues.get(type);
    }

    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {
        return (T) primitiveValues.get(primitiveType);
    }
    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();
    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();

    static {
        primitiveTypes.put(Boolean.class, Boolean.TYPE);
        primitiveTypes.put(Character.class, Character.TYPE);
        primitiveTypes.put(Byte.class, Byte.TYPE);
        primitiveTypes.put(Short.class, Short.TYPE);
        primitiveTypes.put(Integer.class, Integer.TYPE);
        primitiveTypes.put(Long.class, Long.TYPE);
        primitiveTypes.put(Float.class, Float.TYPE);
        primitiveTypes.put(Double.class, Double.TYPE);
    }

    static {
        wrapperReturnValues.put(Boolean.class, false);
        wrapperReturnValues.put(Character.class, '\u0000');
        wrapperReturnValues.put(Byte.class, (byte) 0);
        wrapperReturnValues.put(Short.class, (short) 0);
        wrapperReturnValues.put(Integer.class, 0);
        wrapperReturnValues.put(Long.class, 0L);
        wrapperReturnValues.put(Float.class, 0F);
        wrapperReturnValues.put(Double.class, 0D);
    }

    static {
        primitiveValues.put(boolean.class, false);
        primitiveValues.put(char.class, '\u0000');
        primitiveValues.put(byte.class, (byte) 0);
        primitiveValues.put(short.class, (short) 0);
        primitiveValues.put(int.class, 0);
        primitiveValues.put(long.class, 0L);
        primitiveValues.put(float.class, 0F);
        primitiveValues.put(double.class, 0);
    }
}",Match failed,1,0
228,Mockito_26,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.util;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings(""unchecked"")
public class Primitives {
    
    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {
        if(clazz.isPrimitive()) {
            return clazz;
        }
        return (Class<T>) primitiveTypes.get(clazz);
    }

    public static boolean isPrimitiveWrapper(Class<?> type) {
        return wrapperReturnValues.containsKey(type);
    }

    public static <T> T primitiveWrapperOf(Class<T> type) {
        return (T) wrapperReturnValues.get(type);
    }

    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {
        return (T) primitiveValues.get(primitiveType);
    }
    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();
    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();

    static {
        primitiveTypes.put(Boolean.class, Boolean.TYPE);
        primitiveTypes.put(Character.class, Character.TYPE);
        primitiveTypes.put(Byte.class, Byte.TYPE);
        primitiveTypes.put(Short.class, Short.TYPE);
        primitiveTypes.put(Integer.class, Integer.TYPE);
        primitiveTypes.put(Long.class, Long.TYPE);
        primitiveTypes.put(Float.class, Float.TYPE);
        primitiveTypes.put(Double.class, Double.TYPE);
    }

    static {
        wrapperReturnValues.put(Boolean.class, false);
        wrapperReturnValues.put(Character.class, '\u0000');
        wrapperReturnValues.put(Byte.class, (byte) 0);
        wrapperReturnValues.put(Short.class, (short) 0);
        wrapperReturnValues.put(Integer.class, 0);
        wrapperReturnValues.put(Long.class, 0L);
        wrapperReturnValues.put(Float.class, 0F);
        wrapperReturnValues.put(Double.class, 0D);
    }

    static {
        primitiveValues.put(boolean.class, false);
        primitiveValues.put(char.class, '\u0000');
        primitiveValues.put(byte.class, (byte) 0);
        primitiveValues.put(short.class, (short) 0);
        primitiveValues.put(int.class, 0);
        primitiveValues.put(long.class, 0L);
        primitiveValues.put(float.class, 0F);
        primitiveValues.put(double.class, 0);
    }
}",Match failed,2,0
228,Mockito_26,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.util;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings(""unchecked"")
public class Primitives {
    
    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {
        if(clazz.isPrimitive()) {
            return clazz;
        }
        return (Class<T>) primitiveTypes.get(clazz);
    }

    public static boolean isPrimitiveWrapper(Class<?> type) {
        return wrapperReturnValues.containsKey(type);
    }

    public static <T> T primitiveWrapperOf(Class<T> type) {
        return (T) wrapperReturnValues.get(type);
    }

    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {
        return (T) primitiveValues.get(primitiveType);
    }
    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();
    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();

    static {
        primitiveTypes.put(Boolean.class, Boolean.TYPE);
        primitiveTypes.put(Character.class, Character.TYPE);
        primitiveTypes.put(Byte.class, Byte.TYPE);
        primitiveTypes.put(Short.class, Short.TYPE);
        primitiveTypes.put(Integer.class, Integer.TYPE);
        primitiveTypes.put(Long.class, Long.TYPE);
        primitiveTypes.put(Float.class, Float.TYPE);
        primitiveTypes.put(Double.class, Double.TYPE);
    }

    static {
        wrapperReturnValues.put(Boolean.class, false);
        wrapperReturnValues.put(Character.class, '\u0000');
        wrapperReturnValues.put(Byte.class, (byte) 0);
        wrapperReturnValues.put(Short.class, (short) 0);
        wrapperReturnValues.put(Integer.class, 0);
        wrapperReturnValues.put(Long.class, 0L);
        wrapperReturnValues.put(Float.class, 0F);
        wrapperReturnValues.put(Double.class, 0D);
    }

    static {
        primitiveValues.put(boolean.class, false);
        primitiveValues.put(char.class, '\u0000');
        primitiveValues.put(byte.class, (byte) 0);
        primitiveValues.put(short.class, (short) 0);
        primitiveValues.put(int.class, 0);
        primitiveValues.put(long.class, 0L);
        primitiveValues.put(float.class, 0F);
        primitiveValues.put(double.class, 0);
    }
}",Match failed,3,0
228,Mockito_26,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.util;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings(""unchecked"")
public class Primitives {
    
    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {
        if(clazz.isPrimitive()) {
            return clazz;
        }
        return (Class<T>) primitiveTypes.get(clazz);
    }

    public static boolean isPrimitiveWrapper(Class<?> type) {
        return wrapperReturnValues.containsKey(type);
    }

    public static <T> T primitiveWrapperOf(Class<T> type) {
        return (T) wrapperReturnValues.get(type);
    }

    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {
        return (T) primitiveValues.get(primitiveType);
    }
    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();
    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();
    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();

    static {
        primitiveTypes.put(Boolean.class, Boolean.TYPE);
        primitiveTypes.put(Character.class, Character.TYPE);
        primitiveTypes.put(Byte.class, Byte.TYPE);
        primitiveTypes.put(Short.class, Short.TYPE);
        primitiveTypes.put(Integer.class, Integer.TYPE);
        primitiveTypes.put(Long.class, Long.TYPE);
        primitiveTypes.put(Float.class, Float.TYPE);
        primitiveTypes.put(Double.class, Double.TYPE);
    }

    static {
        wrapperReturnValues.put(Boolean.class, false);
        wrapperReturnValues.put(Character.class, '\u0000');
        wrapperReturnValues.put(Byte.class, (byte) 0);
        wrapperReturnValues.put(Short.class, (short) 0);
        wrapperReturnValues.put(Integer.class, 0);
        wrapperReturnValues.put(Long.class, 0L);
        wrapperReturnValues.put(Float.class, 0F);
        wrapperReturnValues.put(Double.class, 0D);
    }

    static {
        primitiveValues.put(boolean.class, false);
        primitiveValues.put(char.class, '\u0000');
        primitiveValues.put(byte.class, (byte) 0);
        primitiveValues.put(short.class, (short) 0);
        primitiveValues.put(int.class, 0);
        primitiveValues.put(long.class, 0L);
        primitiveValues.put(float.class, 0F);
        primitiveValues.put(double.class, 0);
    }
}",Match failed,4,0
229,Mockito_27,"public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
         MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
         ((Factory) mock).setCallback(0, newFilter);
     }","public <T> void resetMock(T mock) {
    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);

    if (!(mock instanceof Factory)) {
        throw new IllegalArgumentException(""Mock must be an instance of Factory"");
    }

    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
    
    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler,
            (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
    
    ((Factory) mock).setCallback(0, newFilter);
}",0,0
229,Mockito_27,"public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
         MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
         ((Factory) mock).setCallback(0, newFilter);
     }","public <T> void resetMock(T mock) {
    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);

    if (!isMockValid(mock)) {
        throw new IllegalArgumentException(""Mock must be a valid instance"");
    }

    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler,
            (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));

    try {
        ((Factory) mock).setCallback(0, newFilter);
    } catch (Exception e) {
        throw new RuntimeException(""Failed to set callback on mock"", e);
    }
}

private boolean isMockValid(Object mock) {
    return mock != null && mock instanceof Factory && isMockitoMock(mock);
}",1,0
229,Mockito_27,"public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
         MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
         ((Factory) mock).setCallback(0, newFilter);
     }","public <T> void resetMock(T mock) {
    // Check if the mock is a CGlib proxy before proceeding
    if (!(mock instanceof Factory)) {
        throw new IllegalArgumentException(""The provided object is not a CGlib proxy and cannot have callbacks set."");
    }

    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);

    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler,
            (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));

    // Attempt to set the callback
    try {
        ((Factory) mock).setCallback(0, newFilter);
    } catch (ClassCastException e) {
        throw new IllegalStateException(""Failed to cast the proxy to Factory. Ensure the mock is created with CGlib."", e);
    }
}",2,0
229,Mockito_27,"public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
         MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
         ((Factory) mock).setCallback(0, newFilter);
     }","public <T> void resetMock(T mock) {
    // Check if the mock is null or invalid
    if (mock == null || !(mock instanceof Factory)) {
        throw new IllegalArgumentException(""Provided mock is null or not a valid CGlib proxy Factory instance."");
    }

    // Explicitly check if the mock handler is valid, assume this method returns a boolean
    if (!isMockitoMock(mock)) {
        throw new IllegalStateException(""The provided object is not a valid Mockito mock."");
    }

    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);

    // Preset settings with expected default return behavior
    MockSettings mockSettings = org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_SMART_NULLS);

    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) mockSettings);

    // Set the callback using try-catch to handle failed cast exceptions
    try {
        ((Factory) mock).setCallback(0, newFilter);
    } catch (ClassCastException e) {
        throw new RuntimeException(""Failed to set callback. Verify that the mock is created using correct interfaces."", e);
    }
}",3,0
229,Mockito_27,"public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
         MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
         ((Factory) mock).setCallback(0, newFilter);
     }","public <T> void resetMock(T mock) {
    // Converting the handler reference to the new instance of the mock
    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);

    // Create a filter with new mockHandler and the existing settings.
    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler,
            (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));

    // Get the actual interceptor from the mock and apply new callback safely
    if (mock instanceof Factory) {
        ((Factory) mock).setCallback(0, newFilter);
    } else {
        throw new IllegalArgumentException(""Mock must be an instance of Factory"");
    }
}",4,0
230,Mockito_28,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }","private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
        OngoingInjecter injecter = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);
        if (injecter != null) {
            injecter.thenInject();
        }
    }
}",0,0
230,Mockito_28,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }","private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
        OngoingInjecter injecter = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);
        if (injecter != null && canInject(injecter, fieldInstance)) {
            injecter.thenInject();
        }
    }
}

private boolean canInject(OngoingInjecter injecter, Object fieldInstance) {
    // Implement logic to determine if injection is possible
    // This might involve checking the state of fieldInstance, verifying dependencies, etc.
    return true; // Placeholder for actual logic
}",1,0
230,Mockito_28,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }","private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
        OngoingInjecter injecter = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);
        if (injecter != null && mocks.contains(fieldInstance)) {
            injecter.thenInject();
        }
    }
}",2,0
230,Mockito_28,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }","private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
        OngoingInjecter injecter = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);
        if (injecter != null && fieldInstance.equals(field.getType())) {
            injecter.thenInject();
        }
    }
}",3,0
230,Mockito_28,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }","private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
        OngoingInjecter injecter = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);
        if (injecter != null) {
            injecter.thenInject();
            mocks.remove(injecter); // Assuming injecter represents the injected mock, remove it to ensure it's not injected multiple times
        }
    }
}",4,0
231,Mockito_29,"public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
         description.appendText(wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }",Match failed,0,0
231,Mockito_29,"public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
         description.appendText(wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }","public void describeTo(Description description) {
    description.appendText(""same("");
    appendQuoting(description);
    description.appendText(wanted != null ? wanted.toString() : ""null"");
    appendQuoting(description);
    description.appendText("")"");
}",1,0
232,Mockito_33,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
         	/* Avoid unnecessary cloning */
         return m1.equals(m2);
     }","public boolean hasSameMethod(Invocation candidate) {
    // not using method.equals() for 1 good reason:
    // sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
    Method m1 = invocation.getMethod();
    Method m2 = candidate.getMethod();

    // Compare declaring class and method name
    if (!m1.getDeclaringClass().equals(m2.getDeclaringClass()) || !m1.getName().equals(m2.getName())) {
        return false;
    }

    // Compare return types and parameter types
    if (!m1.getReturnType().equals(m2.getReturnType()) || !Arrays.equals(m1.getParameterTypes(), m2.getParameterTypes())) {
        return false;
    }

    // Compare exceptions
    if (!Arrays.equals(m1.getExceptionTypes(), m2.getExceptionTypes())) {
        return false;
    }

    return true;
}",0,0
232,Mockito_33,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
         	/* Avoid unnecessary cloning */
         return m1.equals(m2);
     }","public boolean hasSameMethod(Invocation candidate) {
    // not using method.equals() for 1 good reason:
    // sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
    Method m1 = invocation.getMethod();
    Method m2 = candidate.getMethod();

    // Compare declaring class
    if (!m1.getDeclaringClass().isAssignableFrom(m2.getDeclaringClass()) &&
        !m2.getDeclaringClass().isAssignableFrom(m1.getDeclaringClass())) {
        return false;
    }

    // Compare method names
    if (!m1.getName().equals(m2.getName())) {
        return false;
    }

    // Compare return types
    if (!m1.getReturnType().isAssignableFrom(m2.getReturnType()) &&
        !m2.getReturnType().isAssignableFrom(m1.getReturnType())) {
        return false;
    }

    // Compare parameters
    Class<?>[] p1 = m1.getParameterTypes();
    Class<?>[] p2 = m2.getParameterTypes();
    if (p1.length != p2.length) {
        return false;
    }
    for (int i = 0; i < p1.length; i++) {
        if (!p1[i].isAssignableFrom(p2[i]) && !p2[i].isAssignableFrom(p1[i])) {
            return false;
        }
    }

    // Check exception types
    Class<?>[] e1 = m1.getExceptionTypes();
    Class<?>[] e2 = m2.getExceptionTypes();
    for (Class<?> eType : e1) {
        boolean found = false;
        for (Class<?> eType2 : e2) {
            if (eType.isAssignableFrom(eType2) || eType2.isAssignableFrom(eType)) {
                found = true;
                break;
            }
        }
        if (!found) {
            return false;
        }
    }
    return true;
}",1,0
232,Mockito_33,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
         	/* Avoid unnecessary cloning */
         return m1.equals(m2);
     }","public boolean hasSameMethod(Invocation candidate) {
    Method m1 = invocation.getMethod();
    Method m2 = candidate.getMethod();

    // Return false if either method contains generics, as direct comparison may fail
    if (hasGenerics(m1) || hasGenerics(m2)) {
        return false;
    }
    return m1.equals(m2);
}

// Helper method to check if a method has generics
private boolean hasGenerics(Method method) {
    if (method.getTypeParameters().length > 0) {
        return true;
    }
    for (Class<?> param : method.getParameterTypes()) {
        if (param.getTypeParameters().length > 0) {
            return true;
        }
    }
    return false;
}",2,0
232,Mockito_33,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
         	/* Avoid unnecessary cloning */
         return m1.equals(m2);
     }","public boolean hasSameMethod(Invocation candidate) {
    Method m1 = invocation.getMethod();
    Method m2 = candidate.getMethod();

    // Compare method names first as they are more likely to differ
    if (!m1.getName().equals(m2.getName())) {
        return false;
    }

    // Compare parameter count and types
    Class<?>[] params1 = m1.getParameterTypes();
    Class<?>[] params2 = m2.getParameterTypes();
    if (params1.length != params2.length) {
        return false;
    }
    for (int i = 0; i < params1.length; i++) {
        if (!params1[i].equals(params2[i])) {
            return false;
        }
    }

    // Compare return types
    if (!m1.getReturnType().equals(m2.getReturnType())) {
        return false;
    }

    // Compare exception types (less crucial, but keeps signature consistent)
    Class<?>[] exceptions1 = m1.getExceptionTypes();
    Class<?>[] exceptions2 = m2.getExceptionTypes();
    if (!Arrays.equals(exceptions1, exceptions2)) {
        return false;
    }

    return true;
}",3,0
232,Mockito_33,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
         	/* Avoid unnecessary cloning */
         return m1.equals(m2);
     }","public boolean hasSameMethod(Invocation candidate) {
    Method m1 = invocation.getMethod();
    Method m2 = candidate.getMethod();

    // Compare method names first
    if (!m1.getName().equals(m2.getName())) {
        return false;
    }

    // Compare declaring classes with isAssignableFrom to consider hierarchy
    if (!m1.getDeclaringClass().isAssignableFrom(m2.getDeclaringClass()) &&
        !m2.getDeclaringClass().isAssignableFrom(m1.getDeclaringClass())) {
        return false;
    }

    // Compare parameter types with isAssignableFrom to handle inheritance and interfaces
    Class<?>[] params1 = m1.getParameterTypes();
    Class<?>[] params2 = m2.getParameterTypes();
    if (params1.length != params2.length) {
        return false;
    }
    for (int i = 0; i < params1.length; i++) {
        if (!params1[i].isAssignableFrom(params2[i]) && !params2[i].isAssignableFrom(params1[i])) {
            return false;
        }
    }

    // Compare return types to consider covariant return types
    if (!m1.getReturnType().isAssignableFrom(m2.getReturnType()) &&
        !m2.getReturnType().isAssignableFrom(m1.getReturnType())) {
        return false;
    }

    // Compare exception types using covariance logic for inheritance
    Class<?>[] exceptions1 = m1.getExceptionTypes();
    Class<?>[] exceptions2 = m2.getExceptionTypes();
    if (exceptions1.length != exceptions2.length) {
        return false;
    }
    for (int i = 0; i < exceptions1.length; i++) {
        boolean found = false;
        for (int j = 0; j < exceptions2.length; j++) {
            if (exceptions1[i].isAssignableFrom(exceptions2[j]) || exceptions2[j].isAssignableFrom(exceptions1[i])) {
                found = true;
                break;
            }
        }
        if (!found) {
            return false;
        }
    }

    return true;
}",4,0
233,Mockito_34,"public void captureArgumentsFrom(Invocation i) {
         int k = 0;
         for (Matcher m : matchers) {
             if (m instanceof CapturesArguments) {
                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
             }
             k++;
        }
    }","public void captureArgumentsFrom(Invocation i) {
    int k = 0;
    Object[] arguments = i.getArguments();
    for (Matcher m : matchers) {
        if (m instanceof CapturesArguments && k < arguments.length) {
            ((CapturesArguments) m).captureFrom(arguments[k]);
        }
        k++;
    }
}",0,0
234,Mockito_38,"    private boolean safelyMatches(Matcher m, Object arg) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }
","private boolean safelyMatches(Matcher m, Object arg) {
    try {
        return arg != null && m.matches(arg);
    } catch (Throwable t) {
        return false;
    }
}",0,0
234,Mockito_38,"    private boolean safelyMatches(Matcher m, Object arg) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }
","private boolean safelyMatches(Matcher m, Object arg) {
    if (arg == null) {
        return false; // Explicitly handle null argument
    }
    try {
        return m.matches(arg);
    } catch (Throwable t) {
        return false;
    }
}",1,0
234,Mockito_38,"    private boolean safelyMatches(Matcher m, Object arg) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }
","private boolean safelyMatches(Matcher m, Object arg) {
    if (arg == null) {
        try {
            // Provide a default object to prevent null issues
            return m.matches(new Object());
        } catch (Throwable t) {
            return false;
        }
    }
    try {
        return m.matches(arg);
    } catch (Throwable t) {
        return false;
    }
}",2,0
234,Mockito_38,"    private boolean safelyMatches(Matcher m, Object arg) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }
","private boolean safelyMatches(Matcher m, Object arg) {
    if (m == null) {
        return false; // Explicitly handle a null Matcher
    }
    try {
        return arg != null ? m.matches(arg) : m.matches(null); // Gracefully handle null arg
    } catch (Throwable t) {
        return false;
    }
}",3,0
234,Mockito_38,"    private boolean safelyMatches(Matcher m, Object arg) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }
","private boolean safelyMatches(Matcher m, Object arg) {
    if (m != null && (arg instanceof String || arg instanceof Number)) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }
    return false;
}",4,0
235,Mockito_5,"    public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }
",Match failed,0,0
235,Mockito_5,"    public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }
","public void verify(VerificationData data) {
        AssertionError lastError = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);
                // Exit immediately on successful verification
                return;
            } catch (MockitoAssertionError | org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                lastError = handleVerifyException(e);
            }
        }

        // Throw the last captured error if verification failed within the timer
        if (lastError != null) {
            throw lastError;
        }

        // Fail explicitly if the timer completed without a definitive verification result
        throw new AssertionError(""Verification timed out without success."");
    }",1,0
235,Mockito_5,"    public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }
","public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);
                // Exit immediately on successful verification
                if (returnOnSuccess) {
                    return;
                }
            } catch (MockitoAssertionError e) {
                // If both assertions fail capture one exception to throw after timer ends
                error = handleVerifyException(e);
                timer.reset(); // Reset the timer before retry
            } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }
        //If neither succeed forcibly except as fallback
        throw new AssertionError(""last-""Error caught/....
       //...,  
}",2,0
235,Mockito_5,"    public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }
","public void verify(VerificationData data) {
        AssertionError error = null;
        timer.start();

        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                }
                
            } catch (MockitoAssertionError | org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);

                // Adjust logic: Stop timer immediately if a known non-retryable exception occurs
                if (isNonRetryableException(e)) {
                    break;
                }
            }
        }

        if (error != null) {
            throw error;
        }

        // Fail explicitly if no errors were thrown but verification never succeeded
        throw new AssertionError(""Verification failed: Timer elapsed without success."");
    }

private boolean isNonRetryableException(Exception e) {
    return e instanceof org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
}",3,0
235,Mockito_5,"    public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }
","public void verify(VerificationData data) {
    AssertionError error = null;
    timer.start();

    while (timer.isCounting()) {
        try {
            delegate.verify(data);

            if (returnOnSuccess) {
                return;
            } else {
                // Clear any previous errors after a successful verification
                error = null;
            }
        } catch (MockitoAssertionError e) {
            error = handleVerifyException(e);
            // Adjust to reset the timer to allow retries
            timer.reset();
        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
            error = handleVerifyException(e);
            // Stop the validation loop early for non-retryable exceptions
            break;
        }
    }

    // Throw error if it exists after all retries
    if (error != null) {
        throw error;
    }

    // Explicit failure if no verification success but timer expired
    throw new AssertionError(""Verification timed out without success."");
}",4,0
236,Mockito_7,"        private void readTypeVariables() {
            for (Type type : typeVariable.getBounds()) {
                registerTypeVariablesOn(type);
            }
            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
        }
","private void readTypeVariables() {
    if (typeVariable == null) {
        throw new MockitoException(""Raw extraction not supported for : 'null'"");
    }
    for (Type type : typeVariable.getBounds()) {
        registerTypeVariablesOn(type);
    }
    Type actualTypeArgument = getActualTypeArgumentFor(typeVariable);
    if (actualTypeArgument != null) {
        registerTypeVariablesOn(actualTypeArgument);
    }
}",0,0
236,Mockito_7,"        private void readTypeVariables() {
            for (Type type : typeVariable.getBounds()) {
                registerTypeVariablesOn(type);
            }
            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
        }
","private void readTypeVariables() {
    if (typeVariable == null) {
        return; // Exit early if there is no type variable
    }
    for (Type type : typeVariable.getBounds()) {
        registerTypeVariablesOn(type);
    }
    Type actualTypeArgument = getActualTypeArgumentFor(typeVariable);
    if (actualTypeArgument != null) {
        registerTypeVariablesOn(actualTypeArgument);
    }
}",1,0
237,Mockito_8,"    protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
        }
    }
","protected void registerTypeVariablesOn(Type classType) {
        // Detect loop due to self-referencing generic types
        Set<Type> processedTypes = new HashSet<>();

        while (classType instanceof ParameterizedType && processedTypes.add(classType)) {
            ParameterizedType parameterizedType = (ParameterizedType) classType;
            TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            
            for (int i = 0; i < actualTypeArguments.length; i++) {
                TypeVariable typeParameter = typeParameters[i];
                Type actualTypeArgument = actualTypeArguments[i];

                if (actualTypeArgument instanceof WildcardType) {
                    contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
                } else {
                    contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
                }
            }

            classType = ((Class<?>) parameterizedType.getRawType()).getGenericSuperclass();
        }
    }",0,0
237,Mockito_8,"    protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
        }
    }
",Match failed,1,0
237,Mockito_8,"    protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
        }
    }
","protected void registerTypeVariablesOn(Type classType) {
    // Detect loop due to self-referencing generic types
    Set<Type> visitedTypes = new HashSet<>();
    while (classType instanceof ParameterizedType) {
        if (!visitedTypes.add(classType)) {
            // Stop processing if we've already seen this type (avoid infinite recursion)
            break;
        }
        
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable<?>[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable<?> typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];
            
            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
        }
        
        classType = ((Class<?>) parameterizedType.getRawType()).getGenericSuperclass();
    }
}",2,0
237,Mockito_8,"    protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
        }
    }
","protected void registerTypeVariablesOn(Type classType) {
    Set<Type> visitingTypes = new HashSet<>();
    registerTypeVariablesRecursive(classType, visitingTypes);
}

private void registerTypeVariablesRecursive(Type classType, Set<Type> visitingTypes) {
    if (!(classType instanceof ParameterizedType) || visitingTypes.contains(classType)) {
        return;
    }
    
    visitingTypes.add(classType);
    ParameterizedType parameterizedType = (ParameterizedType) classType;
    TypeVariable<?>[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
    
    for (int i = 0; i < actualTypeArguments.length; i++) {
        TypeVariable<?> typeParameter = typeParameters[i];
        Type actualTypeArgument = actualTypeArguments[i];
        
        if (actualTypeArgument instanceof WildcardType) {
            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
        } else {
            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
        }
    }
    
    registerTypeVariablesRecursive(((Class<?>) parameterizedType.getRawType()).getGenericSuperclass(), visitingTypes);
}",3,0
237,Mockito_8,"    protected void registerTypeVariablesOn(Type classType) {
        if (!(classType instanceof ParameterizedType)) {
            return;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < actualTypeArguments.length; i++) {
            TypeVariable typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
            // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
        }
    }
","protected void registerTypeVariablesOn(Type classType) {
    Set<Type> processedTypes = new HashSet<>();
    while (classType instanceof ParameterizedType) {
        if (!processedTypes.add(classType)) {
            // Avoid infinite recursion by breaking on self-referencing types
            break;
        }
        ParameterizedType parameterizedType = (ParameterizedType) classType;
        TypeVariable<?>[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();

        for (int i = 0; i < typeParameters.length && i < actualTypeArguments.length; i++) {
            TypeVariable<?> typeParameter = typeParameters[i];
            Type actualTypeArgument = actualTypeArguments[i];

            if (actualTypeArgument instanceof WildcardType) {
                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
            }
        }

        classType = ((Class<?>) parameterizedType.getRawType()).getGenericSuperclass();
    }
}",4,0
238,Time_11,"    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
    static {
        cVerbose.set(Boolean.FALSE);
    }
",static ThreadLocal<Boolean> cVerbose = ThreadLocal.withInitial(() -> Boolean.FALSE);,0,0
238,Time_11,"    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
    static {
        cVerbose.set(Boolean.FALSE);
    }
","static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {
    @Override
    protected Boolean initialValue() {
        return Boolean.FALSE;
    }
};",1,0
239,Time_14,"public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
        // overridden as superclass algorithm can't handle
        // 2004-02-29 + 48 months -> 2008-02-29 type dates
         if (valueToAdd == 0) {
             return values;
         }
             // month is largest field and being added to, such as month-day
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
            }
            instant = add(instant, valueToAdd);
            return iChronology.get(partial, instant);
        } else {
            return super.add(partial, fieldIndex, values, valueToAdd);
        }
    }","public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
    // overridden as superclass algorithm can't handle
    // 2004-02-29 + 48 months -> 2008-02-29 type dates
    if (valueToAdd == 0) {
        return values;
    }
    // month is largest field and being added to, such as month-day
    if (DateTimeUtils.isContiguous(partial)) {
        long instant = 0L;
        for (int i = 0, isize = partial.size(); i < isize; i++) {
            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
        }
        instant = instantWithFieldAdjustment(partial, fieldIndex, instant, values[fieldIndex]);
        instant = add(instant, valueToAdd);
        return iChronology.get(partial, instant);
    } else {
        return super.add(partial, fieldIndex, values, valueToAdd);
    }
}

private long instantWithFieldAdjustment(ReadablePartial partial, int fieldIndex, long instant, int fieldValue) {
    // Handle special cases involving leap years or end-of-month adjustments here
    DateTimeField field = partial.getFieldType(fieldIndex).getField(iChronology);
    return field.set(instant, fieldValue);
}",0,0
239,Time_14,"public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
        // overridden as superclass algorithm can't handle
        // 2004-02-29 + 48 months -> 2008-02-29 type dates
         if (valueToAdd == 0) {
             return values;
         }
             // month is largest field and being added to, such as month-day
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
            }
            instant = add(instant, valueToAdd);
            return iChronology.get(partial, instant);
        } else {
            return super.add(partial, fieldIndex, values, valueToAdd);
        }
    }","public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
    // Check if valueToAdd is zero or the partial is empty
    if (valueToAdd == 0 || partial.size() == 0) {
        return values;
    }

    // Start from the current value in the field index
    long instant = partial.getFieldType(fieldIndex).getField(iChronology).set(0L, values[fieldIndex]);
    
    // Add valueToAdd to the instant using the field at fieldIndex
    instant = partial.getFieldType(fieldIndex).getField(iChronology).add(instant, valueToAdd);

    // Adjust the remaining fields back into the array
    for (int i = 0; i < partial.size(); i++) {
        if (i != fieldIndex) {
            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
        } else {
            values[i] = partial.getFieldType(i).getField(iChronology).get(instant);
        }
    }
    
    // Handle leap year and end-of-month adjustments
    if (!DateTimeUtils.isContiguous(partial)) {
        int[] adjustedValues = super.add(partial, fieldIndex, values, valueToAdd);
        if (adjustedValues != null) {
            return adjustedValues;
        }
    }
    
    return values;
}",1,0
239,Time_14,"public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
        // overridden as superclass algorithm can't handle
        // 2004-02-29 + 48 months -> 2008-02-29 type dates
         if (valueToAdd == 0) {
             return values;
         }
             // month is largest field and being added to, such as month-day
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
            }
            instant = add(instant, valueToAdd);
            return iChronology.get(partial, instant);
        } else {
            return super.add(partial, fieldIndex, values, valueToAdd);
        }
    }","public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
    // Return the original values if there is no value to add
    if (valueToAdd == 0) {
        return values;
    }

    // Handle contiguous date-time fields
    if (DateTimeUtils.isContiguous(partial)) {
        long instant = 0L;

        // Set the instant for the initial state based on the fields and values
        for (int i = 0; i < partial.size(); i++) {
            if (i == fieldIndex) {
                continue;
            }
            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
        }
        
        // Adjust the field at the specified fieldIndex
        int currentFieldValue = values[fieldIndex];
        instant = partial.getFieldType(fieldIndex).getField(iChronology).set(instant, currentFieldValue);
        instant = partial.getFieldType(fieldIndex).getField(iChronology).add(instant, valueToAdd);

        // Extract the updated field values, ensuring leap year and end-of-month are handled correctly
        int[] updatedValues = new int[partial.size()];
        for (int i = 0; i < partial.size(); i++) {
            DateTimeField field = partial.getFieldType(i).getField(iChronology);
            updatedValues[i] = field.get(instant);
        }

        return updatedValues;
    } 

    // Delegate to superclass logic for non-contiguous cases
    return super.add(partial, fieldIndex, values, valueToAdd);
}",2,0
239,Time_14,"public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
        // overridden as superclass algorithm can't handle
        // 2004-02-29 + 48 months -> 2008-02-29 type dates
         if (valueToAdd == 0) {
             return values;
         }
             // month is largest field and being added to, such as month-day
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
            }
            instant = add(instant, valueToAdd);
            return iChronology.get(partial, instant);
        } else {
            return super.add(partial, fieldIndex, values, valueToAdd);
        }
    }","public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
    // Early exit if valueToAdd is 0
    if (valueToAdd == 0) {
        return values;
    }

    // Initialize an instant from the partial and values
    long instant = 0L;
    for (int i = 0; i < partial.size(); i++) {
        instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
    }

    // Add valueToAdd to the specific field if contiguous; adjust remaining values to ensure consistency
    if (DateTimeUtils.isContiguous(partial)) {
        DateTimeField field = partial.getFieldType(fieldIndex).getField(iChronology);
        instant = field.add(instant, valueToAdd);

        // Handle edge cases involving leap years or end-of-month
        int[] updatedValues = new int[partial.size()];
        for (int i = 0; i < partial.size(); i++) {
            DateTimeField currentField = partial.getFieldType(i).getField(iChronology);
            updatedValues[i] = currentField.get(instant);
        }
        return updatedValues;
    } 

    // Fallback to the superclass logic for non-contiguous partials
    return super.add(partial, fieldIndex, values, valueToAdd);
}",3,0
239,Time_14,"public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
        // overridden as superclass algorithm can't handle
        // 2004-02-29 + 48 months -> 2008-02-29 type dates
         if (valueToAdd == 0) {
             return values;
         }
             // month is largest field and being added to, such as month-day
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
            }
            instant = add(instant, valueToAdd);
            return iChronology.get(partial, instant);
        } else {
            return super.add(partial, fieldIndex, values, valueToAdd);
        }
    }","public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
    // Early exit if valueToAdd is 0
    if (valueToAdd == 0) {
        return values;
    }

    // Handle contiguous date-time fields
    if (DateTimeUtils.isContiguous(partial)) {
        long instant = 0L;

        // Set all fields from the values array
        for (int i = 0; i < partial.size(); i++) {
            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
        }

        // Add value to the specified field index
        DateTimeField field = partial.getFieldType(fieldIndex).getField(iChronology);
        instant = field.add(instant, valueToAdd);

        // Extract updated values back into the array
        int[] updatedValues = new int[partial.size()];
        for (int i = 0; i < partial.size(); i++) {
            DateTimeField currentField = partial.getFieldType(i).getField(iChronology);
            updatedValues[i] = currentField.get(instant);
        }

        // Handle special cases for leap years/end of month
        if (fieldIndex > 0 && partial.getFieldType(0).getName().equals(""monthOfYear"")) {
            updatedValues = adjustForLeapYear(partial, updatedValues, fieldIndex, valueToAdd);
        }

        return updatedValues;
    }

    // Fallback to the superclass logic for non-contiguous cases
    return super.add(partial, fieldIndex, values, valueToAdd);
}

// Helper Method: Adjusts values for leap year or end-of-month cases
private int[] adjustForLeapYear(ReadablePartial partial, int[] values, int fieldIndex, int valueToAdd) {
    DateTimeField field = partial.getFieldType(fieldIndex).getField(iChronology);
    int monthsAdded = field.getDifference(values[fieldIndex], valueToAdd);

    if (monthsAdded % 12 == 0) {
        int daysInMonth = field.getMaximumValue();
        if (values[fieldIndex] > daysInMonth) {
            values[fieldIndex] = daysInMonth;
        }
    }

    return values;
}",4,0
240,Time_15,"public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
                 return -val1;
             case 0:
                 return 0L;
            case 1:
                return val1;
        }
        long total = val1 * val2;
        if (total / val2 != val1) {
          throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
        }
        return total;
    }","public static long safeMultiply(long val1, int val2) {
    switch (val2) {
        case -1:
            if (val1 == Long.MIN_VALUE) {
                throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
            }
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
    }
    long total = val1 * val2;
    if ((val2 != 0) && (total / val2 != val1)) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}",0,0
241,Time_16,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);

    if (newPos < 0) {
        return newPos; // Return early if parsing failed
    }

    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}",0,0
241,Time_16,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);

    // Only set instant state if parsing succeeded (newPos >= 0)
    if (newPos >= 0) {
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
    }
    return newPos;
}",1,0
241,Time_16,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);

    if (newPos < 0) {
        return newPos; // Early return on failure
    }

    long parsedMillis = bucket.computeMillis(false, text);
    if (parsedMillis == instantMillis) {
        return position; // Early return if no changes occurred
    }

    instant.setMillis(parsedMillis);

    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);

    if (iZone != null) {
        instant.setZone(iZone);
    }

    return newPos;
}",2,0
241,Time_16,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);

    if (newPos < 0) {
        return newPos; // Early return on failure
    }

    long parsedMillis = bucket.computeMillis(false, text);
    if (parsedMillis == instantLocal) {
        parsedMillis = bucket.computeMillis(true, text); // Consider pivot year
    }

    instant.setMillis(parsedMillis);
    chrono = selectChronology(bucket, chrono);

    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);

    if (iZone != null) {
        instant.setZone(iZone);
    }

    return newPos;
}",3,0
241,Time_16,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);

    if (newPos < 0) {
        return newPos; // Stop processing if parsing fails
    }

    long parsedMillis = bucket.computeMillis(false, text);

    // Validate parsed instant against bounds
    if (parsedMillis < Long.MIN_VALUE || parsedMillis > Long.MAX_VALUE) {
        throw new IllegalArgumentException(""Parsed milliseconds out of bounds"");
    }

    instant.setMillis(parsedMillis);
    chrono = selectChronology(bucket, chrono);

    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);

    if (iZone != null) {
        instant.setZone(iZone);
    }

    return newPos;
}",4,0
242,Time_17,"public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
         if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
         long local = convertUTCToLocal(instant);
         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }","public long adjustOffset(long instant, boolean earlierOrLater) {
    // evaluate 3 hours before and after to work out if anything is happening
    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
    
    if (instantBefore == instantAfter) {
        return instant; // not an overlap (less than is a gap, equal is normal case)
    }

    // work out range of instants that have duplicate local times
    long local = convertUTCToLocal(instant);
    
    // calculate result based on earlierOrLater flag
    try {
        long adjusted = convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
        return adjusted;
    } catch (IllegalArgumentException ex) {
        // fallback in case of invalid local time
        return earlierOrLater ? instantAfter : instantBefore;
    }
}",0,0
242,Time_17,"public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
         if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
         long local = convertUTCToLocal(instant);
         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }","public long adjustOffset(long instant, boolean earlierOrLater) {
    // Evaluate two instants before and after to determine overlap or gap
    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
    
    if (instantBefore == instantAfter) {
        return instant; // not an overlap
    }

    // Determine range of duplicates due to overlap
    long local = convertUTCToLocal(instant);
    long adjusted = earlierOrLater ? instantAfter : instantBefore;

    // Check if the adjusted value is valid
    int offsetOriginal = getOffset(instant);
    int offsetAdjusted = getOffset(adjusted);

    if (offsetOriginal != offsetAdjusted) {
        // Handle zone changes causing invalid local times
        return earlierOrLater ? instantAfter : instantBefore;
    }

    // Return a valid adjusted value
    return convertLocalToUTC(local, false, adjusted);
}",1,0
242,Time_17,"public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
         if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
         long local = convertUTCToLocal(instant);
         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }","public long adjustOffset(long instant, boolean earlierOrLater) {
    // calculate the original local time
    long local = convertUTCToLocal(instant);

    // handle potential overlaps or gaps by evaluating before and after
    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);

    if (instantBefore == instantAfter) {
        // no overlap detected, use the original instant
        return instant;
    }

    // get the offsets before and after
    int offsetBefore = getOffset(instantBefore);
    int offsetAfter = getOffset(instantAfter);

    // adjust based on the earlierOrLater flag
    if (earlierOrLater) {
        if (offsetAfter > offsetBefore) {
            // prefer the later offset
            return instant + (offsetAfter - offsetBefore);
        } else {
            return instant;
        }
    } else {
        if (offsetBefore > offsetAfter) {
            // prefer the earlier offset
            return instant - (offsetBefore - offsetAfter);
        } else {
            return instant;
        }
    }
}",2,0
242,Time_17,"public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
         if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
         long local = convertUTCToLocal(instant);
         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }","public long adjustOffset(long instant, boolean earlierOrLater) {
    // Evaluate the local time for three hours before and after
    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);

    // If there is no overlap, return the original instant
    if (instantBefore == instantAfter) {
        return instant;
    }

    // Determine the range of duplicate local times
    long local = convertUTCToLocal(instant);

    // Check both possible offsets and determine the correct one based on validity
    int offsetBefore = getOffset(instantBefore);
    int offsetAfter = getOffset(instantAfter);

    if (earlierOrLater) {
        return local - offsetAfter > instant ? instant : convertLocalToUTC(local, false, instantAfter);
    } else {
        return local - offsetBefore < instant ? instant : convertLocalToUTC(local, false, instantBefore);
    }
}",3,0
242,Time_17,"public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
         if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
         long local = convertUTCToLocal(instant);
         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }","public long adjustOffset(long instant, boolean earlierOrLater) {
    // Calculate 3 hours before and after the given instant
    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);

    // If instantBefore and instantAfter are the same, there's no overlap
    if (instantBefore == instantAfter) {
        return instant;
    }

    // Determine the local time of the given instant
    long local = convertUTCToLocal(instant);

    // Handle overlap by checking which offset applies to the local time
    int offsetBefore = getOffset(instant - DateTimeConstants.MILLIS_PER_HOUR);
    int offsetAfter = getOffset(instant + DateTimeConstants.MILLIS_PER_HOUR);

    if (earlierOrLater) {
        // Favor the later offset if specified
        return offsetAfter > offsetBefore ? convertLocalToUTC(local, false, instant + (offsetAfter - offsetBefore)) : instant;
    } else {
        // Favor the earlier offset if specified
        return offsetBefore > offsetAfter ? convertLocalToUTC(local, false, instant - (offsetBefore - offsetAfter)) : instant;
    }
}",4,0
243,Time_18,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
         // Assume date is Gregorian.
         long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (instant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist"");
            }
        }
        return instant;
    }","public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
        // Validate the input values to ensure they represent a valid date
        if (monthOfYear < 1 || monthOfYear > 12) {
            throw new IllegalArgumentException(""Month of year must be in the range [1,12]"");
        }
        if (dayOfMonth < 1 || dayOfMonth > 31) {
            throw new IllegalArgumentException(""Day of month must be in the range [1,31]"");
        }
        if (hourOfDay < 0 || hourOfDay > 23) {
            throw new IllegalArgumentException(""Hour of day must be in the range [0,23]"");
        }
        if (minuteOfHour < 0 || minuteOfHour > 59) {
            throw new IllegalArgumentException(""Minute of hour must be in the range [0,59]"");
        }
        if (secondOfMinute < 0 || secondOfMinute > 59) {
            throw new IllegalArgumentException(""Second of minute must be in the range [0,59]"");
        }
        if (millisOfSecond < 0 || millisOfSecond > 999) {
            throw new IllegalArgumentException(""Millis of second must be in the range [0,999]"");
        }
 
        // Assume date is Gregorian.
        long instant;
        try {
            instant = iGregorianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(""Invalid date in Gregorian chronology: "" + e.getMessage());
        }
        
        if (instant < iCutoverMillis) {
            // Maybe it's Julian.
            try {
                instant = iJulianChronology.getDateTimeMillis
                    (year, monthOfYear, dayOfMonth,
                     hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            } catch (IllegalArgumentException e) {
                throw new IllegalArgumentException(""Invalid date in Julian chronology: "" + e.getMessage());
            }
            
            if (instant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist in the cutover period"");
            }
        }
        return instant;
    }",0,0
243,Time_18,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
         // Assume date is Gregorian.
         long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (instant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist"");
            }
        }
        return instant;
    }","public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException {
    Chronology base;
    if ((base = getBase()) != null) {
        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
    }

    // Validate the input values to ensure they represent a valid date
    if (monthOfYear < 1 || monthOfYear > 12) {
        throw new IllegalArgumentException(""Invalid month: "" + monthOfYear);
    }

    // Adjust the day for February in leap years to avoid issues
    if (monthOfYear == 2) {
        int maxDay = (iGregorianChronology.isLeapYear(year)) ? 29 : 28;
        if (dayOfMonth < 1 || dayOfMonth > maxDay) {
            throw new IllegalArgumentException(""Invalid day for February: "" + dayOfMonth);
        }
    } else if (dayOfMonth < 1 || dayOfMonth > 31) {
        throw new IllegalArgumentException(""Invalid day: "" + dayOfMonth);
    }

    // Assume date is Gregorian.
    long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);

    if (instant < iCutoverMillis) {
        // Maybe it's Julian.
        instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        if (instant >= iCutoverMillis) {
            // Check for dates in the illegal cutover gap
            throw new IllegalArgumentException(""Specified date does not exist in the cutover period"");
        }
    }
    return instant;
}",1,0
243,Time_18,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
         // Assume date is Gregorian.
         long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (instant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist"");
            }
        }
        return instant;
    }","public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException {
    Chronology base;
    if ((base = getBase()) != null) {
        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
    }

    // Validate the input values to ensure they represent a valid date
    if (monthOfYear < 1 || monthOfYear > 12) {
        throw new IllegalArgumentException(""Invalid month: "" + monthOfYear);
    }
    
    if (dayOfMonth < 1 || dayOfMonth > 31 || (monthOfYear == 2 && dayOfMonth > 28 && !iGregorianChronology.isLeapYear(year))) {
        throw new IllegalArgumentException(""Invalid day: "" + dayOfMonth + "" for month: "" + monthOfYear + "", year: "" + year);
    }
    
    if (hourOfDay < 0 || hourOfDay > 23) {
        throw new IllegalArgumentException(""Invalid hourOfDay: "" + hourOfDay);
    }
    if (minuteOfHour < 0 || minuteOfHour > 59) {
        throw new IllegalArgumentException(""Invalid minuteOfHour: "" + minuteOfHour);
    }
    if (secondOfMinute < 0 || secondOfMinute > 59) {
        throw new IllegalArgumentException(""Invalid secondOfMinute: "" + secondOfMinute);
    }
    if (millisOfSecond < 0 || millisOfSecond > 999) {
        throw new IllegalArgumentException(""Invalid millisOfSecond: "" + millisOfSecond);
    }

    // Assume date is Gregorian.
    long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);

    if (instant < iCutoverMillis) {
        // Maybe it's Julian.
        instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        if (instant >= iCutoverMillis) {
            // Gap between Julian and Gregorian calendars
            throw new IllegalArgumentException(""Date in cutover gap between Julian and Gregorian calendars"");
        }
    }
    return instant;
}",2,0
243,Time_18,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
         // Assume date is Gregorian.
         long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (instant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist"");
            }
        }
        return instant;
    }","public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                              int hourOfDay, int minuteOfHour,
                              int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException {
    Chronology base;
    if ((base = getBase()) != null) {
        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
    }

    // Validate the input values to ensure they represent a valid date
    if (monthOfYear < 1 || monthOfYear > 12) {
        throw new IllegalArgumentException(""Invalid month: "" + monthOfYear);
    }

    int maxDayInMonth = 31; // Default max days in a month
    if (monthOfYear == 2) {
        maxDayInMonth = iGregorianChronology.isLeapYear(year) ? 29 : 28;
    } else if (monthOfYear == 4 || monthOfYear == 6 || monthOfYear == 9 || monthOfYear == 11) {
        maxDayInMonth = 30;
    }

    if (dayOfMonth < 1 || dayOfMonth > maxDayInMonth) {
        throw new IllegalArgumentException(""Invalid day: "" + dayOfMonth + "" for month: "" + monthOfYear + "", year: "" + year);
    }

    if (hourOfDay < 0 || hourOfDay > 23) {
        throw new IllegalArgumentException(""Invalid hourOfDay: "" + hourOfDay);
    }
    if (minuteOfHour < 0 || minuteOfHour > 59) {
        throw new IllegalArgumentException(""Invalid minuteOfHour: "" + minuteOfHour);
    }
    if (secondOfMinute < 0 || secondOfMinute > 59) {
        throw new IllegalArgumentException(""Invalid secondOfMinute: "" + secondOfMinute);
    }
    if (millisOfSecond < 0 || millisOfSecond > 999) {
        throw new IllegalArgumentException(""Invalid millisOfSecond: "" + millisOfSecond);
    }

    // Assume date is Gregorian.
    long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);

    if (instant < iCutoverMillis) {
        // Check Julian chronology before cutover
        instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        if (instant >= iCutoverMillis) {
            // The date falls in the cutover gap
            throw new IllegalArgumentException(""Date in cutover gap between Julian and Gregorian calendars"");
        }
    }
    return instant;
}",3,0
243,Time_18,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
        if ((base = getBase()) != null) {
            return base.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
 
         // Assume date is Gregorian.
         long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
                (year, monthOfYear, dayOfMonth,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (instant >= iCutoverMillis) {
                // Okay, it's in the illegal cutover gap.
                throw new IllegalArgumentException(""Specified date does not exist"");
            }
        }
        return instant;
    }","public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                              int hourOfDay, int minuteOfHour,
                              int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException {
    Chronology base;
    if ((base = getBase()) != null) {
        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
    }

    // Validate the input values to ensure they represent a valid date
    if (monthOfYear < 1 || monthOfYear > 12) {
        throw new IllegalArgumentException(""Invalid month value: "" + monthOfYear);
    }

    int maxDayInMonth = 31; // Default max days in a month
    if (monthOfYear == 2) {
        maxDayInMonth = iGregorianChronology.isLeapYear(year) ? 29 : 28;
    } else if (monthOfYear == 4 || monthOfYear == 6 || monthOfYear == 9 || monthOfYear == 11) {
        maxDayInMonth = 30;
    }

    if (dayOfMonth < 1 || dayOfMonth > maxDayInMonth) {
        throw new IllegalArgumentException(""Invalid day value: "" + dayOfMonth + "" for month: "" + monthOfYear + "" in year: "" + year);
    }

    if (hourOfDay < 0 || hourOfDay > 23) {
        throw new IllegalArgumentException(""Invalid hourOfDay value: "" + hourOfDay);
    }
    if (minuteOfHour < 0 || minuteOfHour > 59) {
        throw new IllegalArgumentException(""Invalid minuteOfHour value: "" + minuteOfHour);
    }
    if (secondOfMinute < 0 || secondOfMinute > 59) {
        throw new IllegalArgumentException(""Invalid secondOfMinute value: "" + secondOfMinute);
    }
    if (millisOfSecond < 0 || millisOfSecond > 999) {
        throw new IllegalArgumentException(""Invalid millisOfSecond value: "" + millisOfSecond);
    }

    try {
        // Assume date is Gregorian.
        long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);

        if (instant < iCutoverMillis) {
            // Check Julian chronology before cutover
            instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
                    hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);

            if (instant >= iCutoverMillis) {
                // Fall within the cutover gap, invalid date
                throw new IllegalArgumentException(""Date falls within the illegal cutover period between Julian and Gregorian calendars"");
            }
        }
        return instant;
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(""Invalid date: "" + e.getMessage());
    }
}",4,0
244,Time_19,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
        }
        return offsetAdjusted;
    }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);
    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // we need to ensure that time is always after the DST gap
        // this happens naturally for positive offsets, but not for negative
        if (offsetLocal < offsetAdjusted) {
            // if we just return offsetAdjusted then the time is pushed
            // back before the transition, whereas it should be
            // on or after the transition
            long nextLocal = nextTransition(instantAdjusted);
            if (nextLocal == instantLocal - offsetAdjusted) {
                return offsetAdjusted;
            } else {
                return offsetLocal;
            }
        }
    } else if (offsetLocal > 0) {
        long prev = previousTransition(instantAdjusted);
        if (prev < instantAdjusted) {
            int offsetPrev = getOffset(prev);
            int diff = offsetPrev - offsetLocal;
            if (instantAdjusted - prev <= diff) {
                return offsetPrev;
            }
        }
    }
    return offsetAdjusted;
}",0,0
244,Time_19,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
        }
        return offsetAdjusted;
    }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // ensure time is after any DST gap for negative adjustments
        if (offsetLocal < offsetAdjusted) {
            long nextTransitionInstant = nextTransition(instantAdjusted);
            if (nextTransitionInstant <= instantAdjusted) {
                return offsetAdjusted;
            } else {
                return offsetLocal;
            }
        }

        // ensure time is before any DST overlap for positive adjustments
        if (offsetLocal > offsetAdjusted) {
            long previousTransitionInstant = previousTransition(instantAdjusted);
            if (previousTransitionInstant >= instantAdjusted) {
                return offsetAdjusted;
            }
        }
    }
    return offsetAdjusted;
}",1,0
244,Time_19,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
        }
        return offsetAdjusted;
    }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);
    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // identify if there is a gap or overlap
        if (instantAdjusted > instantLocal && offsetLocal < offsetAdjusted) {
            // time is in a gap; consider offsetAdjusted unless within previous transition
            long prevTransition = previousTransition(instantAdjusted);
            if (prevTransition >= instantLocal - offsetLocal) {
                return offsetLocal;
            }
        } else if (instantAdjusted < instantLocal && offsetLocal > offsetAdjusted) {
            // time is in an overlap; ensure we match the later offset after transition
            long nextTransition = nextTransition(instantAdjusted);
            if (nextTransition <= instantLocal - offsetAdjusted) {
                return offsetAdjusted;
            }
        }
    }
    return offsetAdjusted;
}",2,0
244,Time_19,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
        }
        return offsetAdjusted;
    }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (initially estimated)
    final int offsetLocal = getOffset(instantLocal);

    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we are close to a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // HANDLE POSITIVE OFFSET VARIATIONS
        if (offsetLocal < offsetAdjusted) {
            // Ensure that the time is on or after the transition
            long nextTransitionInstant = nextTransition(instantAdjusted);
            if (nextTransitionInstant > instantLocal - offsetAdjusted) {
                return offsetAdjusted;
            } else {
                return offsetLocal;
            }
        }

        // HANDLE NEGATIVE OFFSET VARIATIONS
        if (offsetLocal > offsetAdjusted) {
            // Ensure aligned with the later offset for any overlaps
            long prevTransitionInstant = previousTransition(instantAdjusted);
            if (prevTransitionInstant < instantLocal - offsetLocal) {
                return offsetAdjusted;
            }
        }
    }

    // if offsets matched or no boundary adjustment is needed, return the adjusted offset
    return offsetAdjusted;
}",3,0
244,Time_19,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
        }
        return offsetAdjusted;
    }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // For positive offset changes, ensure time is after the DST gap
        if (offsetLocal < offsetAdjusted) {
            long nextTransitionTime = nextTransition(instantAdjusted);
            if (nextTransitionTime > instantLocal - offsetAdjusted) {
                return offsetAdjusted;
            } else {
                return offsetLocal;
            }
        }

        // For negative offset changes, ensure time is in the overlap region
        if (offsetLocal > offsetAdjusted) {
            long prevTransitionTime = previousTransition(instantAdjusted);
            if (prevTransitionTime <= instantLocal - offsetLocal) {
                return offsetAdjusted;
            } else {
                return offsetLocal;
            }
        }
    }

    // If no adjustments are needed, or offsets match, return the adjusted offset
    return offsetAdjusted;
}",4,0
245,Time_20,"public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                     bucket.setZone(DateTimeZone.forID(id));
                     return position + id.length();
                 }
             }
             return ~position;
         }","public int parseInto(DateTimeParserBucket bucket, String text, int position) {
    if (position < 0 || position >= text.length()) {
        return ~position;
    }
    String str = text.substring(position);
    for (String id : ALL_IDS) {
        if (str.startsWith(id)) {
            if (id.length() + position <= text.length() && text.substring(position, position + id.length()).equals(id)) {
                bucket.setZone(DateTimeZone.forID(id));
                return position + id.length();
            }
        }
    }
    return ~position;
}",0,0
245,Time_20,"public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                     bucket.setZone(DateTimeZone.forID(id));
                     return position + id.length();
                 }
             }
             return ~position;
         }","public int parseInto(DateTimeParserBucket bucket, String text, int position) {
    if (position < 0 || position >= text.length()) {
        return ~position;
    }
    for (String id : ALL_IDS) {
        int idLength = id.length();
        int endIndex = position + idLength;
        if (endIndex <= text.length() && text.substring(position, endIndex).equals(id)) {
            bucket.setZone(DateTimeZone.forID(id));
            return endIndex;
        }
    }
    return ~position;
}",1,0
245,Time_20,"public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                     bucket.setZone(DateTimeZone.forID(id));
                     return position + id.length();
                 }
             }
             return ~position;
         }","public int parseInto(DateTimeParserBucket bucket, String text, int position) {
    if (position < 0 || position >= text.length()) {
        return ~position;
    }
    // Modify the loop to ensure exact match with ids in text
    for (String id : ALL_IDS) {
        String subText = position + id.length() <= text.length() ? text.substring(position, position + id.length()) : """";
        if (subText.equals(id)) {
            bucket.setZone(DateTimeZone.forID(id));
            return position + id.length();
        }
    }
    return ~position;
}",2,0
245,Time_20,"public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                     bucket.setZone(DateTimeZone.forID(id));
                     return position + id.length();
                 }
             }
             return ~position;
         }","public int parseInto(DateTimeParserBucket bucket, String text, int position) {
    if (position < 0 || position >= text.length()) {
        return ~position;
    }
    // Attempt to match the longest possible id first
    String subText = text.substring(position);
    String bestMatch = null;
    for (String id : ALL_IDS) {
        if (subText.startsWith(id)) {
            if (bestMatch == null || id.length() > bestMatch.length()) {
                bestMatch = id;
            }
        }
    }
    if (bestMatch != null) {
        bucket.setZone(DateTimeZone.forID(bestMatch));
        return position + bestMatch.length();
    }
    return ~position;
}",3,0
246,Time_22,"    protected BasePeriod(long duration) {
        this(duration, null, null);
        // bug [3264409]
    }
","protected BasePeriod(long duration) {
    this(duration, PeriodType.standard(), null);
    // fixed bug [3264409]
}",0,0
246,Time_22,"    protected BasePeriod(long duration) {
        this(duration, null, null);
        // bug [3264409]
    }
","protected BasePeriod(long duration) {
    this(duration, PeriodType.time(), null);
}",1,0
246,Time_22,"    protected BasePeriod(long duration) {
        this(duration, null, null);
        // bug [3264409]
    }
","protected BasePeriod(long duration) {
    this(duration, PeriodType.millis(), null);
}",2,0
246,Time_22,"    protected BasePeriod(long duration) {
        this(duration, null, null);
        // bug [3264409]
    }
","protected BasePeriod(long duration) {
        this(duration, PeriodType.forFields(new DurationFieldType[]{DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds()}), null);
    }",3,0
246,Time_22,"    protected BasePeriod(long duration) {
        this(duration, null, null);
        // bug [3264409]
    }
","protected BasePeriod(long duration) {
    this(duration, PeriodType.dayTime(), null);
}",4,0
247,Time_23,"private static synchronized String getConvertedId(String id) {
        Map<String, String> map = cZoneIdConversion;
        if (map == null) {
            // Backwards compatibility with TimeZone.
            map = new HashMap<String, String>();
            map.put(""GMT"", ""UTC"");
            map.put(""MIT"", ""Pacific/Apia"");
            map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
            map.put(""AST"", ""America/Anchorage"");
            map.put(""PST"", ""America/Los_Angeles"");
            map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
             map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
             map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""WET"", ""Europe/London"");
             map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
             map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
             map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
            map.put(""AET"", ""Australia/Sydney"");
            map.put(""SST"", ""Pacific/Guadalcanal"");
            map.put(""NST"", ""Pacific/Auckland"");
            cZoneIdConversion = map;
        }
        return map.get(id);
    }","private static synchronized String getConvertedId(String id) {
        if (cZoneIdConversion == null) {
            // Backwards compatibility with TimeZone.
            Map<String, String> map = new HashMap<String, String>();
            map.put(""GMT"", ""UTC"");
            map.put(""MIT"", ""Pacific/Apia"");
            map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
            map.put(""AST"", ""America/Anchorage"");
            map.put(""PST"", ""America/Los_Angeles"");
            map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
            map.put(""PNT"", ""America/Phoenix"");
            map.put(""CST"", ""America/Chicago"");
            map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
            map.put(""IET"", ""America/Indianapolis"");
            map.put(""PRT"", ""America/Puerto_Rico"");
            map.put(""CNT"", ""America/St_Johns"");
            map.put(""AGT"", ""America/Buenos_Aires"");
            map.put(""BET"", ""America/Sao_Paulo"");
            map.put(""WET"", ""Europe/London"");
            map.put(""ECT"", ""Europe/Paris"");
            map.put(""ART"", ""Africa/Cairo"");
            map.put(""CAT"", ""Africa/Harare"");
            map.put(""EET"", ""Europe/Bucharest"");
            map.put(""EAT"", ""Africa/Addis_Ababa"");
            map.put(""MET"", ""Asia/Tehran"");
            map.put(""NET"", ""Asia/Yerevan"");
            map.put(""PLT"", ""Asia/Karachi"");
            map.put(""IST"", ""Asia/Calcutta"");
            map.put(""BST"", ""Asia/Dhaka"");
            map.put(""VST"", ""Asia/Saigon"");
            map.put(""CTT"", ""Asia/Shanghai"");
            map.put(""JST"", ""Asia/Tokyo"");
            map.put(""ACT"", ""Australia/Darwin"");
            map.put(""AET"", ""Australia/Sydney"");
            map.put(""SST"", ""Pacific/Guadalcanal"");
            map.put(""NST"", ""Pacific/Auckland"");
            cZoneIdConversion = map;
        }
        return cZoneIdConversion.get(id);
    }",0,0
247,Time_23,"private static synchronized String getConvertedId(String id) {
        Map<String, String> map = cZoneIdConversion;
        if (map == null) {
            // Backwards compatibility with TimeZone.
            map = new HashMap<String, String>();
            map.put(""GMT"", ""UTC"");
            map.put(""MIT"", ""Pacific/Apia"");
            map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
            map.put(""AST"", ""America/Anchorage"");
            map.put(""PST"", ""America/Los_Angeles"");
            map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
             map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
             map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""WET"", ""Europe/London"");
             map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
             map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
             map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
            map.put(""AET"", ""Australia/Sydney"");
            map.put(""SST"", ""Pacific/Guadalcanal"");
            map.put(""NST"", ""Pacific/Auckland"");
            cZoneIdConversion = map;
        }
        return map.get(id);
    }","private static synchronized String getConvertedId(String id) {
    if (cZoneIdConversion == null) {
        synchronized (getConvertedId.class) {
            if (cZoneIdConversion == null) {
                Map<String, String> map = new HashMap<>();
                map.put(""GMT"", ""UTC"");
                map.put(""MIT"", ""Pacific/Apia"");
                map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
                map.put(""AST"", ""America/Anchorage"");
                map.put(""PST"", ""America/Los_Angeles"");
                map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
                map.put(""PNT"", ""America/Phoenix"");
                map.put(""CST"", ""America/Chicago"");
                map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
                map.put(""IET"", ""America/Indianapolis"");
                map.put(""PRT"", ""America/Puerto_Rico"");
                map.put(""CNT"", ""America/St_Johns"");
                map.put(""AGT"", ""America/Buenos_Aires"");
                map.put(""BET"", ""America/Sao_Paulo"");
                map.put(""WET"", ""Europe/London"");
                map.put(""ECT"", ""Europe/Paris"");
                map.put(""ART"", ""Africa/Cairo"");
                map.put(""CAT"", ""Africa/Harare"");
                map.put(""EET"", ""Europe/Bucharest"");
                map.put(""EAT"", ""Africa/Addis_Ababa"");
                map.put(""MET"", ""Asia/Tehran"");
                map.put(""NET"", ""Asia/Yerevan"");
                map.put(""PLT"", ""Asia/Karachi"");
                map.put(""IST"", ""Asia/Calcutta"");
                map.put(""BST"", ""Asia/Dhaka"");
                map.put(""VST"", ""Asia/Saigon"");
                map.put(""CTT"", ""Asia/Shanghai"");
                map.put(""JST"", ""Asia/Tokyo"");
                map.put(""ACT"", ""Australia/Darwin"");
                map.put(""AET"", ""Australia/Sydney"");
                map.put(""SST"", ""Pacific/Guadalcanal"");
                map.put(""NST"", ""Pacific/Auckland"");
                cZoneIdConversion = map;
            }
        }
    }
    return cZoneIdConversion.get(id);
}",1,0
247,Time_23,"private static synchronized String getConvertedId(String id) {
        Map<String, String> map = cZoneIdConversion;
        if (map == null) {
            // Backwards compatibility with TimeZone.
            map = new HashMap<String, String>();
            map.put(""GMT"", ""UTC"");
            map.put(""MIT"", ""Pacific/Apia"");
            map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
            map.put(""AST"", ""America/Anchorage"");
            map.put(""PST"", ""America/Los_Angeles"");
            map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
             map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
             map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""WET"", ""Europe/London"");
             map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
             map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
             map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
            map.put(""AET"", ""Australia/Sydney"");
            map.put(""SST"", ""Pacific/Guadalcanal"");
            map.put(""NST"", ""Pacific/Auckland"");
            cZoneIdConversion = map;
        }
        return map.get(id);
    }","private static synchronized String getConvertedId(String id) {
    if (cZoneIdConversion == null) {
        Map<String, String> newMap = new HashMap<String, String>();
        newMap.put(""GMT"", ""UTC"");
        newMap.put(""MIT"", ""Pacific/Apia"");
        newMap.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
        newMap.put(""AST"", ""America/Anchorage"");
        newMap.put(""PST"", ""America/Los_Angeles"");
        newMap.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
        newMap.put(""PNT"", ""America/Phoenix"");
        newMap.put(""CST"", ""America/Chicago"");
        newMap.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
        newMap.put(""IET"", ""America/Indianapolis"");
        newMap.put(""PRT"", ""America/Puerto_Rico"");
        newMap.put(""CNT"", ""America/St_Johns"");
        newMap.put(""AGT"", ""America/Buenos_Aires"");
        newMap.put(""BET"", ""America/Sao_Paulo"");
        newMap.put(""WET"", ""Europe/London"");
        newMap.put(""ECT"", ""Europe/Paris"");
        newMap.put(""ART"", ""Africa/Cairo"");
        newMap.put(""CAT"", ""Africa/Harare"");
        newMap.put(""EET"", ""Europe/Bucharest"");
        newMap.put(""EAT"", ""Africa/Addis_Ababa"");
        newMap.put(""MET"", ""Asia/Tehran"");
        newMap.put(""NET"", ""Asia/Yerevan"");
        newMap.put(""PLT"", ""Asia/Karachi"");
        newMap.put(""IST"", ""Asia/Calcutta"");
        newMap.put(""BST"", ""Asia/Dhaka"");
        newMap.put(""VST"", ""Asia/Saigon"");
        newMap.put(""CTT"", ""Asia/Shanghai"");
        newMap.put(""JST"", ""Asia/Tokyo"");
        newMap.put(""ACT"", ""Australia/Darwin"");
        newMap.put(""AET"", ""Australia/Sydney"");
        newMap.put(""SST"", ""Pacific/Guadalcanal"");
        newMap.put(""NST"", ""Pacific/Auckland"");
        cZoneIdConversion = newMap;
    }
    return cZoneIdConversion.get(id);
}",2,0
247,Time_23,"private static synchronized String getConvertedId(String id) {
        Map<String, String> map = cZoneIdConversion;
        if (map == null) {
            // Backwards compatibility with TimeZone.
            map = new HashMap<String, String>();
            map.put(""GMT"", ""UTC"");
            map.put(""MIT"", ""Pacific/Apia"");
            map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
            map.put(""AST"", ""America/Anchorage"");
            map.put(""PST"", ""America/Los_Angeles"");
            map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
             map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
             map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""WET"", ""Europe/London"");
             map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
             map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
             map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
            map.put(""AET"", ""Australia/Sydney"");
            map.put(""SST"", ""Pacific/Guadalcanal"");
            map.put(""NST"", ""Pacific/Auckland"");
            cZoneIdConversion = map;
        }
        return map.get(id);
    }","private static synchronized String getConvertedId(String id) {
    Map<String, String> localCopy = cZoneIdConversion;
    if (localCopy == null) {
        synchronized (getConvertedId.class) {
            if (cZoneIdConversion == null) {
                Map<String, String> map = new HashMap<String, String>();
                map.put(""GMT"", ""UTC"");
                map.put(""MIT"", ""Pacific/Apia"");
                map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
                map.put(""AST"", ""America/Anchorage"");
                map.put(""PST"", ""America/Los_Angeles"");
                map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
                map.put(""PNT"", ""America/Phoenix"");
                map.put(""CST"", ""America/Chicago"");
                map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
                map.put(""IET"", ""America/Indianapolis"");
                map.put(""PRT"", ""America/Puerto_Rico"");
                map.put(""CNT"", ""America/St_Johns"");
                map.put(""AGT"", ""America/Buenos_Aires"");
                map.put(""BET"", ""America/Sao_Paulo"");
                map.put(""WET"", ""Europe/London"");
                map.put(""ECT"", ""Europe/Paris"");
                map.put(""ART"", ""Africa/Cairo"");
                map.put(""CAT"", ""Africa/Harare"");
                map.put(""EET"", ""Europe/Bucharest"");
                map.put(""EAT"", ""Africa/Addis_Ababa"");
                map.put(""MET"", ""Asia/Tehran"");
                map.put(""NET"", ""Asia/Yerevan"");
                map.put(""PLT"", ""Asia/Karachi"");
                map.put(""IST"", ""Asia/Calcutta"");
                map.put(""BST"", ""Asia/Dhaka"");
                map.put(""VST"", ""Asia/Saigon"");
                map.put(""CTT"", ""Asia/Shanghai"");
                map.put(""JST"", ""Asia/Tokyo"");
                map.put(""ACT"", ""Australia/Darwin"");
                map.put(""AET"", ""Australia/Sydney"");
                map.put(""SST"", ""Pacific/Guadalcanal"");
                map.put(""NST"", ""Pacific/Auckland"");
                cZoneIdConversion = map;
            }
            localCopy = cZoneIdConversion;
        }
    }
    return localCopy.get(id);
}",3,0
247,Time_23,"private static synchronized String getConvertedId(String id) {
        Map<String, String> map = cZoneIdConversion;
        if (map == null) {
            // Backwards compatibility with TimeZone.
            map = new HashMap<String, String>();
            map.put(""GMT"", ""UTC"");
            map.put(""MIT"", ""Pacific/Apia"");
            map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
            map.put(""AST"", ""America/Anchorage"");
            map.put(""PST"", ""America/Los_Angeles"");
            map.put(""MST"", ""America/Denver"");  // JDK 1.1 compatible
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
             map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
             map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""WET"", ""Europe/London"");
             map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
             map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
             map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
            map.put(""AET"", ""Australia/Sydney"");
            map.put(""SST"", ""Pacific/Guadalcanal"");
            map.put(""NST"", ""Pacific/Auckland"");
            cZoneIdConversion = map;
        }
        return map.get(id);
    }",Match failed,4,0
248,Time_24,"public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);
        if (count > 0) {
            // alter base year for parsing if first field is month or day
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }

        long millis = iMillis;
        try {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }
        
        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message =
                    ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }
        
        return millis;
    }","public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);

        long millis = iMillis;
        try {
            for (int i = 0; i < count; i++) {
                millis = savedFields[i].set(millis, resetFields);
            }
        } catch (IllegalFieldValueException e) {
            if (text != null) {
                e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }

        if (count > 0) {
            // alter base year for parsing if first field is month or day
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }

        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }

        return millis;
    }",0,0
248,Time_24,"public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);
        if (count > 0) {
            // alter base year for parsing if first field is month or day
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }

        long millis = iMillis;
        try {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }
        
        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message =
                    ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }
        
        return millis;
    }","public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);
        
        long millis = iMillis;
        try {
            for (int i = 0; i < count; i++) {
                millis = savedFields[i].set(millis, resetFields);
            }
        } catch (IllegalFieldValueException e) {
            if (text != null) {
                e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }
        
        if (count > 0) {
            // Alter base year for parsing if first field is month or day, and adjust position
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0 
                && savedFields[0].iField.getType() != DateTimeFieldType.year()) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                millis = savedFields[0].set(millis, resetFields); // Reset the millis after saving year field
            }
        }

        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }

        return millis;
    }",1,0
248,Time_24,"public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);
        if (count > 0) {
            // alter base year for parsing if first field is month or day
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }

        long millis = iMillis;
        try {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }
        
        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message =
                    ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }
        
        return millis;
    }","public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);

        boolean needsYearAdjustment = false;
        long millis = iMillis;
        try {
            for (int i = 0; i < count; i++) {
                if (i == 0) {
                    // alter base year for parsing if first field is month or day
                    DurationField months = DurationFieldType.months().getField(iChrono);
                    DurationField days = DurationFieldType.days().getField(iChrono);
                    DurationField first = savedFields[i].iField.getDurationField();
                    if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                        saveField(DateTimeFieldType.year(), iDefaultYear);
                        needsYearAdjustment = true;
                    }
                }
                millis = savedFields[i].set(millis, resetFields);
            }
        } catch (IllegalFieldValueException e) {
            if (text != null) {
                e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }

        if (needsYearAdjustment) {
            millis = computeMillis(resetFields, text);
        }

        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }

        return millis;
    }",2,0
248,Time_24,"public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);
        if (count > 0) {
            // alter base year for parsing if first field is month or day
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }

        long millis = iMillis;
        try {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }
        
        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message =
                    ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }
        
        return millis;
    }","public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);

    // Check first field for month or day and compare with year directly
    if (count > 0) {
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        
        if ((months.equals(first) || days.equals(first)) && savedFields[0].iField.getType() != DateTimeFieldType.year()) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }

    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    
    return millis;
}",3,0
248,Time_24,"public long computeMillis(boolean resetFields, String text) {
        SavedField[] savedFields = iSavedFields;
        int count = iSavedFieldsCount;
        if (iSavedFieldsShared) {
            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
            iSavedFieldsShared = false;
        }
        sort(savedFields, count);
        if (count > 0) {
            // alter base year for parsing if first field is month or day
            DurationField months = DurationFieldType.months().getField(iChrono);
            DurationField days = DurationFieldType.days().getField(iChrono);
            DurationField first = savedFields[0].iField.getDurationField();
            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
                saveField(DateTimeFieldType.year(), iDefaultYear);
                return computeMillis(resetFields, text);
            }
        }

        long millis = iMillis;
        try {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
            }
            throw e;
        }
        
        if (iZone == null) {
            millis -= iOffset;
        } else {
            int offset = iZone.getOffsetFromLocal(millis);
            millis -= offset;
            if (offset != iZone.getOffset(millis)) {
                String message =
                    ""Illegal instant due to time zone offset transition ("" + iZone + ')';
                if (text != null) {
                    message = ""Cannot parse \"""" + text + ""\"": "" + message;
                }
                throw new IllegalArgumentException(message);
            }
        }
        
        return millis;
    }","public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);

    long millis = iMillis;

    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + ""\"""");
        }
        throw e;
    }

    if (count > 0) {
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }

    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }

    return millis;
}",4,0
249,Time_25,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);

    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // we need to ensure that time is always after the DST gap
        // this happens naturally for positive offsets, but not for negative
        if ((offsetLocal - offsetAdjusted) < 0) {
            // if we just return offsetAdjusted then the time is pushed
            // back before the transition, whereas it should be
            // on or after the transition
            long nextLocal = nextTransition(instantAdjusted);
            long nextAdjusted = nextLocal - offsetAdjusted;
            if (nextLocal != nextAdjusted) {
                return offsetLocal;
            }
        }
    }
    return offsetAdjusted;
}",0,0
249,Time_25,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalc the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);
    // if the offsets differ, we're near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        long nextLocal = nextTransition(instantAdjusted);
        long nextAdjusted = nextTransition(instantAdjusted - offsetAdjusted);
        if (nextLocal == nextAdjusted) {
            // force recalculation for backward transitions
            int manualOffset = getOffset(nextLocal + offsetAdjusted - offsetLocal);
            if (manualOffset == offsetAdjusted) {
                return offsetLocal;
            }
        }
    }
    return offsetAdjusted;
}",1,0
249,Time_25,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);

    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // logic to handle positive and negative transitions
        if ((offsetLocal - offsetAdjusted) < 0) {
            long nextTransition = nextTransition(instantAdjusted);
            return (instantAdjusted < nextTransition) ? offsetAdjusted : offsetLocal;
        } else {
            long previousTransition = nextTransition(instantAdjusted - 1);
            if (instantAdjusted < previousTransition) {
                return offsetLocal;
            }
        }
    }

    return offsetAdjusted;
}",2,0
249,Time_25,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }","public int getOffsetFromLocal(long instantLocal) {
    // Retrieve the initial offset for the given local time
    final int offsetLocal = getOffset(instantLocal);

    // Compute the adjusted time based on the initial offset and retrieve the adjusted offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // If the offsets differ, handle possible DST transitions
    if (offsetLocal != offsetAdjusted) {
        long nextTransitionAdjusted = nextTransition(instantAdjusted);
        long nextTransitionLocal = nextTransition(instantLocal);

        // Check whether the transition times align
        if (nextTransitionAdjusted == nextTransitionLocal) {
            // Ensure time stays on the correct side of the DST boundary
            if (instantAdjusted < nextTransitionAdjusted && (offsetLocal - offsetAdjusted) < 0) {
                return offsetAdjusted;
            } else if (instantAdjusted >= nextTransitionAdjusted && (offsetLocal - offsetAdjusted) > 0) {
                return offsetLocal;
            }
        } else {
            // If transitions do not align, return the local offset
            return offsetLocal;
        }
    }

    // Default to the adjusted offset
    return offsetAdjusted;
}",3,0
249,Time_25,"public int getOffsetFromLocal(long instantLocal) {
        // get the offset at instantLocal (first estimate)
        final int offsetLocal = getOffset(instantLocal);
        // adjust instantLocal using the estimate and recalc the offset
        final long instantAdjusted = instantLocal - offsetLocal;
        final int offsetAdjusted = getOffset(instantAdjusted);
        // if the offsets differ, we must be near a DST boundary
        if (offsetLocal != offsetAdjusted) {
            // we need to ensure that time is always after the DST gap
            // this happens naturally for positive offsets, but not for negative
            if ((offsetLocal - offsetAdjusted) < 0) {
                // if we just return offsetAdjusted then the time is pushed
                // back before the transition, whereas it should be
                // on or after the transition
                long nextLocal = nextTransition(instantAdjusted);
                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }","public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);

    // adjust instantLocal using the estimate and recalculate the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);

    // if the offsets differ, we must handle potential transitions
    if (offsetLocal != offsetAdjusted) {
        // Verify if the transition occurs in the adjusted time
        long nextTransitionAdjusted = nextTransition(instantAdjusted);
        if (instantAdjusted < nextTransitionAdjusted) {
            // Steer towards the correct boundary based on the adjustments
            return offsetLocal < offsetAdjusted ? offsetAdjusted : offsetLocal;
        } else {
            // If adjusted time has skipped transition, reconcile to ensure correctness
            return offsetLocal > offsetAdjusted ? offsetAdjusted : offsetLocal;
        }
    }

    // Default to the adjusted offset
    return offsetAdjusted;
}",4,0
250,Time_27,"private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
        if (notPrinter && notParser) {
            throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
        }
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
            return new PeriodFormatter(null, (PeriodParser) comp[1]);
        } else if (notParser) {
            return new PeriodFormatter((PeriodPrinter) comp[0], null);
        } else {
            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
        }
    }","private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
    if (notPrinter && notParser) {
        throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
    }
    int size = elementPairs.size();
    if (size >= 2 && elementPairs.get(0) instanceof Separator) {
        Separator sep = (Separator) elementPairs.get(0);
        PeriodFormatter f = toFormatter(elementPairs.subList(1, size), notPrinter, notParser);
        sep = sep.finish(f.getPrinter(), f.getParser());
        return new PeriodFormatter(sep, sep);
    }
    Object[] comp = createComposite(elementPairs);
    if (comp.length < 2 || !(comp[0] instanceof PeriodPrinter) || !(comp[1] instanceof PeriodParser)) {
        throw new IllegalStateException(""Invalid component structure for PeriodFormatter"");
    }
    if (notPrinter) {
        return new PeriodFormatter(null, (PeriodParser) comp[1]);
    } else if (notParser) {
        return new PeriodFormatter((PeriodPrinter) comp[0], null);
    } else {
        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
    }
}",0,0
250,Time_27,"private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
        if (notPrinter && notParser) {
            throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
        }
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
            return new PeriodFormatter(null, (PeriodParser) comp[1]);
        } else if (notParser) {
            return new PeriodFormatter((PeriodPrinter) comp[0], null);
        } else {
            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
        }
    }","private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
    if (notPrinter && notParser) {
        throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
    }
    int size = elementPairs.size();
    if (size >= 2 && elementPairs.get(0) instanceof Separator) {
        Separator sep = (Separator) elementPairs.get(0);
        PeriodFormatter f = toFormatter(elementPairs.subList(1, size), notPrinter, notParser);
        if (f.getPrinter() == null && f.getParser() == null) {
            throw new IllegalStateException(""Invalid subFormatter with neither a printer nor parser"");
        }
        sep = sep.finish(f.getPrinter(), f.getParser());
        return new PeriodFormatter(sep, sep);
    }
    Object[] comp = createComposite(elementPairs);
    if (!(comp[0] instanceof PeriodPrinter)) {
        comp[0] = Literal.EMPTY;
    }
    if (!(comp[1] instanceof PeriodParser)) {
        comp[1] = Literal.EMPTY;
    }
    return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
}",1,0
250,Time_27,"private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
        if (notPrinter && notParser) {
            throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
        }
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
            return new PeriodFormatter(null, (PeriodParser) comp[1]);
        } else if (notParser) {
            return new PeriodFormatter((PeriodPrinter) comp[0], null);
        } else {
            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
        }
    }","private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
    if (notPrinter && notParser) {
        throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
    }
    int size = elementPairs.size();
    if (size >= 2 && elementPairs.get(0) instanceof Separator) {
        Separator sep = (Separator) elementPairs.get(0);
        PeriodFormatter f;
        try {
            f = toFormatter(elementPairs.subList(1, size), notPrinter, notParser);
        } catch (IllegalStateException e) {
            return new PeriodFormatter(null, null); // Handle invalid states with null printer/parser.
        }
        sep = sep.finish(f.getPrinter(), f.getParser());
        return new PeriodFormatter(sep, sep);
    }
    Object[] comp = createComposite(elementPairs);
    if (comp.length < 2 || (!(comp[0] instanceof PeriodPrinter) && !(comp[1] instanceof PeriodParser))) {
        return new PeriodFormatter(null, null); // Default to a null PeriodFormatter for unexpected cases.
    }
    return new PeriodFormatter(
        comp[0] instanceof PeriodPrinter ? (PeriodPrinter) comp[0] : null,
        comp[1] instanceof PeriodParser ? (PeriodParser) comp[1] : null
    );
}",2,0
250,Time_27,"private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
        if (notPrinter && notParser) {
            throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
        }
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
            return new PeriodFormatter(null, (PeriodParser) comp[1]);
        } else if (notParser) {
            return new PeriodFormatter((PeriodPrinter) comp[0], null);
        } else {
            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
        }
    }","private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
    if (notPrinter && notParser) {
        throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
    }
    int size = elementPairs.size();
    if (size >= 2 && elementPairs.get(0) instanceof Separator) {
        Separator sep = (Separator) elementPairs.get(0);
        // Check if sublist can be processed
        if (size > 2) {
            PeriodFormatter f = toFormatter(elementPairs.subList(1, size), notPrinter, notParser);
            sep = sep.finish(f.getPrinter(), f.getParser());
            return new PeriodFormatter(sep, sep);
        } else {
            sep = sep.finish(null, null); // Handle cases where sublist doesn't contain format information
            return new PeriodFormatter(sep, sep);
        }
    }
    Object[] comp = createComposite(elementPairs);
    // Ensure components are properly initialized
    PeriodPrinter printer = (comp[0] instanceof PeriodPrinter) ? (PeriodPrinter) comp[0] : Literal.EMPTY;
    PeriodParser parser = (comp[1] instanceof PeriodParser) ? (PeriodParser) comp[1] : Literal.EMPTY;

    if (notPrinter) {
        printer = null; // Override printer if it's not needed
    }
    if (notParser) {
        parser = null; // Override parser if it's not needed
    }
    return new PeriodFormatter(printer, parser);
}",3,0
250,Time_27,"private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
        if (notPrinter && notParser) {
            throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
        }
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
            return new PeriodFormatter(null, (PeriodParser) comp[1]);
        } else if (notParser) {
            return new PeriodFormatter((PeriodPrinter) comp[0], null);
        } else {
            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
        }
    }","private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
    if (notPrinter && notParser) {
        throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
    }
    int size = elementPairs.size();
    if (size >= 2 && elementPairs.get(0) instanceof Separator) {
        Separator sep = (Separator) elementPairs.get(0);
        List<Object> subList = elementPairs.subList(1, size);
        if (subList.isEmpty()) {
            sep = sep.finish(null, null); // Handle case where the sublist lacks format information
            return new PeriodFormatter(sep, sep);
        }
        PeriodFormatter f = toFormatter(subList, notPrinter, notParser);
        sep = sep.finish(f.getPrinter(), f.getParser());
        return new PeriodFormatter(sep, sep);
    }
    Object[] comp = createComposite(elementPairs);
    PeriodPrinter printer = (comp[0] instanceof PeriodPrinter) ? (PeriodPrinter) comp[0] : Literal.EMPTY;
    PeriodParser parser = (comp[1] instanceof PeriodParser) ? (PeriodParser) comp[1] : Literal.EMPTY;

    if (comp.length >= 2) {
        // Adjust printer and parser if not required
        printer = notPrinter ? null : printer;
        parser = notParser ? null : parser;
    } else {
        printer = null;
        parser = null;
    }

    return new PeriodFormatter(printer, parser);
}",4,0
251,Time_4,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                        if (compare > 0) {
                            break;
                        } else if (compare == 0) {
                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                            if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
             Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];

        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField != null && unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField != null && loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField != null && loopRangeField != null && rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}",0,0
251,Time_4,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                        if (compare > 0) {
                            break;
                        } else if (compare == 0) {
                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                            if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
             Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];

        // find correct insertion point to keep largest-smallest order
        int i = 0;
        for (; i < iTypes.length; i++) {
            DateTimeFieldType loopType = iTypes[i];
            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
            
            if (!loopUnitField.isSupported()) {
                break;
            }

            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            int compare = unitField.compareTo(loopUnitField);
            if (compare > 0) {
                break;
            } else if (compare == 0) {
                DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                if (rangeField.compareTo(loopRangeField) > 0) {
                    break;
                }
            }
        }
        
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, iTypes.length - i);
        System.arraycopy(iValues, i, newValues, i + 1, iValues.length - i);
        
        // use public constructor to ensure full validation
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}",1,0
251,Time_4,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                        if (compare > 0) {
                            break;
                        } else if (compare == 0) {
                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                            if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
             Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];

        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        for (; i < iTypes.length; i++) {
            DateTimeFieldType loopType = iTypes[i];
            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
            
            int compare = unitField.compareTo(loopUnitField);
            if (compare > 0) {
                break;
            } else if (compare == 0) {
                DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                if (rangeField != null && loopRangeField != null && rangeField.compareTo(loopRangeField) > 0) {
                    break;
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, iTypes.length - i);
        System.arraycopy(iValues, i, newValues, i + 1, iValues.length - i);
        // use public constructor to ensure full validation
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}",2,0
251,Time_4,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                        if (compare > 0) {
                            break;
                        } else if (compare == 0) {
                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                            if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
             Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];

        // Add the new field in correct order based only on insertion and validation rather than comparison
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        for (; i < iTypes.length; i++) {
            DateTimeFieldType loopType = iTypes[i];
            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
            
            if (!loopUnitField.isSupported() || unitField.compareTo(loopUnitField) <= 0) {
                break;
            }
        }
        
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, iTypes.length - i);
        System.arraycopy(iValues, i, newValues, i + 1, iValues.length - i);
        
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}",3,0
251,Time_4,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                        if (compare > 0) {
                            break;
                        } else if (compare == 0) {
                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                            if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
             Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }","public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        
        // Always add the new field at the end without comparing to existing fields
        System.arraycopy(iTypes, 0, newTypes, 0, iTypes.length);
        System.arraycopy(iValues, 0, newValues, 0, iValues.length);
        newTypes[iTypes.length] = fieldType;
        newValues[iValues.length] = value;
        
        // Validate the new partial
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}",4,0
252,Time_5,"public Period normalizedStandard(PeriodType type) {
        type = DateTimeUtils.getPeriodType(type);
        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
             years = FieldUtils.safeAdd(years, months / 12);
             months = months % 12;
             if (years != 0) {
                 result = result.withYears(years);
             }
             if (months != 0) {
                 result = result.withMonths(months);
             }
         }
         return result;
    }","public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));

    // Adjust calculations according to whether the fields are supported by the period type
    boolean yearSupported = type.isSupported(DurationFieldType.years());
    boolean monthSupported = type.isSupported(DurationFieldType.months());

    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());

    int years = yearSupported ? getYears() : 0;
    int months = monthSupported ? getMonths() : 0;

    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;
        if (yearSupported && years != 0) {
            result = result.withYears(years);
        }
        if (monthSupported && months != 0) {
            result = result.withMonths(months);
        }
    }
    return result;
}",0,0
252,Time_5,"public Period normalizedStandard(PeriodType type) {
        type = DateTimeUtils.getPeriodType(type);
        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
             years = FieldUtils.safeAdd(years, months / 12);
             months = months % 12;
             if (years != 0) {
                 result = result.withYears(years);
             }
             if (months != 0) {
                 result = result.withMonths(months);
             }
         }
         return result;
    }","public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    int millis = 0;
    millis = FieldUtils.safeAdd(millis, getMillis());
    millis = FieldUtils.safeAdd(millis, getSeconds() * DateTimeConstants.MILLIS_PER_SECOND);
    millis = FieldUtils.safeAdd(millis, getMinutes() * DateTimeConstants.MILLIS_PER_MINUTE);
    millis = FieldUtils.safeAdd(millis, getHours() * DateTimeConstants.MILLIS_PER_HOUR);
    millis = FieldUtils.safeAdd(millis, getDays() * DateTimeConstants.MILLIS_PER_DAY);
    millis = FieldUtils.safeAdd(millis, getWeeks() * DateTimeConstants.MILLIS_PER_WEEK);

    int[] values = new int[8];
    values[6] = millis;

    int years = getYears();
    int months = getMonths();

    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;

        if (type.isSupported(DurationFieldType.years())) {
            values[type.indexOf(DurationFieldType.years())] = years;
        }
        if (type.isSupported(DurationFieldType.months())) {
            values[type.indexOf(DurationFieldType.months())] = months;
        }
    }

    return new Period(values, type);
}",1,0
252,Time_5,"public Period normalizedStandard(PeriodType type) {
        type = DateTimeUtils.getPeriodType(type);
        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
             years = FieldUtils.safeAdd(years, months / 12);
             months = months % 12;
             if (years != 0) {
                 result = result.withYears(years);
             }
             if (months != 0) {
                 result = result.withMonths(months);
             }
         }
         return result;
    }","public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));

    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());

    int years = getYears();
    int months = getMonths();

    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;
        
        if (type.isSupported(DurationFieldType.years()) && years != 0) {
            result = result.withYears(years);
        } else {
            throw new UnsupportedOperationException(""Years field is not supported"");
        }

        if (type.isSupported(DurationFieldType.months()) && months != 0) {
            result = result.withMonths(months);
        } else {
            throw new UnsupportedOperationException(""Months field is not supported"");
        }
    }
    return result;
}",2,0
252,Time_5,"public Period normalizedStandard(PeriodType type) {
        type = DateTimeUtils.getPeriodType(type);
        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
             years = FieldUtils.safeAdd(years, months / 12);
             months = months % 12;
             if (years != 0) {
                 result = result.withYears(years);
             }
             if (months != 0) {
                 result = result.withMonths(months);
             }
         }
         return result;
    }","public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);

    int milliSecondsFactor = DateTimeConstants.MILLIS_PER_SECOND;
    int milliMinutesFactor = DateTimeConstants.MILLIS_PER_MINUTE;
    int milliHoursFactor = DateTimeConstants.MILLIS_PER_HOUR;
    int milliDaysFactor = DateTimeConstants.MILLIS_PER_DAY;
    int milliWeeksFactor = DateTimeConstants.MILLIS_PER_WEEK;

    long millis = 0;
    millis += getMillis();
    millis += ((long)getSeconds() * milliSecondsFactor);
    millis += ((long)getMinutes() * milliMinutesFactor);
    millis += ((long)getHours() * milliHoursFactor);
    millis += ((long)getDays() * milliDaysFactor);
    millis += ((long)getWeeks() * milliWeeksFactor);

    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
    int years = getYears();
    int months = getMonths();

    if (type.isSupported(DurationFieldType.years()) || type.isSupported(DurationFieldType.months())) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;
        
        if (type.isSupported(DurationFieldType.years()) && years != 0) {
            result = result.withYears(years);
        }
        if (type.isSupported(DurationFieldType.months()) && months != 0) {
            result = result.withMonths(months);
        }
    }

    return result;
}",3,0
252,Time_5,"public Period normalizedStandard(PeriodType type) {
        type = DateTimeUtils.getPeriodType(type);
        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
             years = FieldUtils.safeAdd(years, months / 12);
             months = months % 12;
             if (years != 0) {
                 result = result.withYears(years);
             }
             if (months != 0) {
                 result = result.withMonths(months);
             }
         }
         return result;
    }","public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
    if (type.isSupported(DurationFieldType.seconds())) {
        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    }
    if (type.isSupported(DurationFieldType.minutes())) {
        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    }
    if (type.isSupported(DurationFieldType.hours())) {
        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    }
    if (type.isSupported(DurationFieldType.days())) {
        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    }
    if (type.isSupported(DurationFieldType.weeks())) {
        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
    }

    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());

    int years = getYears();
    int months = getMonths();
    
    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;

        int[] values = result.getValues();
        if (type.isSupported(DurationFieldType.years())) {
            values[type.indexOf(DurationFieldType.years())] = years;
        }
        if (type.isSupported(DurationFieldType.months())) {
            values[type.indexOf(DurationFieldType.months())] = months;
        }
        result = new Period(values, type);
    }

    return result;
}",4,0
253,Time_7,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        if (text == null) {
            throw new IllegalArgumentException(""Text must not be null"");
        }
        if (position < 0 || position > text.length()) {
            throw new IllegalArgumentException(""Position is out of bounds"");
        }
        
        long instantMillis = instant.getMillis();
        Chronology chrono = instant.getChronology();
        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
        chrono = selectChronology(chrono);
        int defaultYear = chrono.year().get(instantLocal);
        
        DateTimeParserBucket bucket = new DateTimeParserBucket(
            instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        if (newPos < 0) {
            return newPos;
        }
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }",0,0
253,Time_7,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
        if (text == null) {
            throw new IllegalArgumentException(""Text must not be null"");
        }
        if (position < 0 || position > text.length()) {
            throw new IllegalArgumentException(""Position is out of bounds"");
        }
        
        // Safely adjust the chronology to handle edge cases like leap seconds or mismatched time zones
        Chronology chrono = instant.getChronology();
        chrono = selectChronology(chrono.withUTC()); // Work with UTC to eliminate timezone ambiguities

        long instantLocal = instant.getMillis();
        int defaultYear = chrono.year().get(instantLocal);
        
        DateTimeParserBucket bucket = new DateTimeParserBucket(
            instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        if (newPos < 0) {
            return newPos;
        }

        // Ensure bucket.computeMillis does not fail for ambiguous edge cases
        long computedMillis = bucket.computeMillis(true, text);
        if (computedMillis == Long.MIN_VALUE) {
            throw new IllegalArgumentException(""Failed to compute milliseconds for given text"");
        }
        instant.setMillis(computedMillis);

        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }

        instant.setChronology(chrono);
        if (iZone != null && !iZone.equals(instant.getChronology().getZone())) {
            instant.setZone(iZone);
        }
        return newPos;
    }",1,0
253,Time_7,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    if (text == null) {
        throw new IllegalArgumentException(""Text must not be null"");
    }
    if (position < 0 || position > text.length()) {
        throw new IllegalArgumentException(""Position is out of bounds"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    chrono = selectChronology(chrono);
    
    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantMillis, chrono, iLocale, iPivotYear, chrono.year().get(instantMillis));
    
    int newPos = parser.parseInto(bucket, text, position);
    if (newPos < 0) {
        return newPos;
    }

    long parsedMillis = bucket.computeMillis(true, text);
    if (bucket.getOffsetInteger() != null) {
        parsedMillis -= bucket.getOffsetInteger();
    }
    
    instant.setMillis(parsedMillis);
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null && !iZone.equals(instant.getChronology().getZone())) {
        instant.setZone(iZone);
    }
    return newPos;
}",2,0
253,Time_7,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    if (text == null) {
        throw new IllegalArgumentException(""Text must not be null"");
    }
    if (position < 0 || position > text.length()) {
        throw new IllegalArgumentException(""Position is out of bounds"");
    }

    long instantMillis = instant.getMillis();
    Chronology initialChrono = instant.getChronology();
    Chronology chrono = selectChronology(initialChrono.withUTC());

    DateTimeParserBucket bucket = new DateTimeParserBucket(
            instantMillis, chrono, iLocale, iPivotYear, chrono.year().get(instantMillis));

    int newPos = parser.parseInto(bucket, text, position);
    if (newPos < 0) {
        return newPos;
    }

    long computedMillis = bucket.computeMillis(true, text);
    if (bucket.getOffsetInteger() != null) {
        computedMillis -= bucket.getOffsetInteger();
    }

    instant.setMillis(computedMillis);

    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        initialChrono = initialChrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        initialChrono = initialChrono.withZone(bucket.getZone());
    }

    instant.setChronology(initialChrono);
    if (iZone != null && !iZone.equals(initialChrono.getZone())) {
        instant.setZone(iZone);
    }
    return newPos;
}",3,0
253,Time_7,"public int parseInto(ReadWritableInstant instant, String text, int position) {
        DateTimeParser parser = requireParser();
        if (instant == null) {
            throw new IllegalArgumentException(""Instant must not be null"");
        }
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
        int newPos = parser.parseInto(bucket, text, position);
        instant.setMillis(bucket.computeMillis(false, text));
        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
            int parsedOffset = bucket.getOffsetInteger();
            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
            chrono = chrono.withZone(parsedZone);
        } else if (bucket.getZone() != null) {
            chrono = chrono.withZone(bucket.getZone());
        }
        instant.setChronology(chrono);
        if (iZone != null) {
            instant.setZone(iZone);
        }
        return newPos;
    }","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    if (text == null) {
        throw new IllegalArgumentException(""Text must not be null"");
    }
    if (position < 0 || position > text.length()) {
        throw new IllegalArgumentException(""Position is out of bounds"");
    }

    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    chrono = selectChronology(chrono);

    DateTimeParserBucket bucket = new DateTimeParserBucket(
        instantMillis, chrono, iLocale, iPivotYear, chrono.year().get(instantMillis));

    int newPos = parser.parseInto(bucket, text, position);
    if (newPos < 0) {
        return newPos;
    }

    long parsedMillis = bucket.computeMillis(false, text);
    if (parsedMillis == Long.MIN_VALUE) {
        throw new IllegalStateException(""Failed to compute milliseconds"");
    }

    instant.setMillis(parsedMillis);

    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null && !iZone.equals(instant.getChronology().getZone())) {
        instant.setZone(iZone);
    }
    return newPos;
}",4,0
254,Time_8,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
        if (hoursOffset == 0 && minutesOffset == 0) {
            return DateTimeZone.UTC;
        }
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                 minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }","public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
    if (hoursOffset == 0 && minutesOffset == 0) {
        return DateTimeZone.UTC;
    }
    if (hoursOffset < -23 || hoursOffset > 23) {
        throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
    }
    if (minutesOffset < 0 || minutesOffset > 59) {
        throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
    }
    int offset;
    try {
        int hoursInMinutes = hoursOffset * 60;
        if (hoursInMinutes < 0) {
            offset = FieldUtils.safeMultiply(hoursInMinutes - minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } else {
            offset = FieldUtils.safeMultiply(hoursInMinutes + minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        }
    } catch (ArithmeticException ex) {
        throw new IllegalArgumentException(""Offset is too large"");
    }
    return forOffsetMillis(offset);
}",0,0
254,Time_8,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
        if (hoursOffset == 0 && minutesOffset == 0) {
            return DateTimeZone.UTC;
        }
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                 minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }","public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
    if (hoursOffset == 0 && minutesOffset == 0) {
        return DateTimeZone.UTC;
    }
    if (hoursOffset < -23 || hoursOffset > 23) {
        throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
    }
    if (minutesOffset < 0 || minutesOffset > 59) {
        throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
    }

    // Adjust minutesOffset to account for direction of hoursOffset
    int totalMinutes = (hoursOffset < 0) ? (hoursOffset * 60 - minutesOffset) : (hoursOffset * 60 + minutesOffset);

    try {
        int offset = FieldUtils.safeMultiply(totalMinutes, DateTimeConstants.MILLIS_PER_MINUTE);
        return forOffsetMillis(offset);
    } catch (ArithmeticException ex) {
        throw new IllegalArgumentException(""Offset is too large"");
    }
}",1,0
254,Time_8,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
        if (hoursOffset == 0 && minutesOffset == 0) {
            return DateTimeZone.UTC;
        }
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                 minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }","public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
    if (hoursOffset == 0 && minutesOffset == 0) {
        return DateTimeZone.UTC;
    }
    if (hoursOffset < -23 || hoursOffset > 23) {
        throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
    }
    if (minutesOffset < -59 || minutesOffset > 59) {
        throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
    }

    try {
        int totalMinutes = hoursOffset * 60 + minutesOffset;
        if (totalMinutes < -1439 || totalMinutes > 1439) {
            throw new IllegalArgumentException(""Offset exceeds valid range"");
        }
        int offset = FieldUtils.safeMultiply(totalMinutes, DateTimeConstants.MILLIS_PER_MINUTE);
        return forOffsetMillis(offset);
    } catch (ArithmeticException ex) {
        throw new IllegalArgumentException(""Offset is too large"");
    }
}",2,0
254,Time_8,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
        if (hoursOffset == 0 && minutesOffset == 0) {
            return DateTimeZone.UTC;
        }
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                 minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }","public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
    if (hoursOffset == 0 && minutesOffset == 0) {
        return DateTimeZone.UTC;
    }
    if (hoursOffset < -23 || hoursOffset > 23) {
        throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
    }

    // Normalize minutesOffset to always be positive
    boolean isNegative = minutesOffset < 0;
    minutesOffset = Math.abs(minutesOffset);
    if (minutesOffset > 59) {
        throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
    }

    try {
        int totalMinutes = (isNegative ? (-hoursOffset * 60 - minutesOffset) : (hoursOffset * 60 + minutesOffset));
        if (totalMinutes < -1439 || totalMinutes > 1439) {
            throw new IllegalArgumentException(""Offset exceeds valid range"");
        }
        int offset = FieldUtils.safeMultiply(totalMinutes, DateTimeConstants.MILLIS_PER_MINUTE);
        return forOffsetMillis(offset);
    } catch (ArithmeticException ex) {
        throw new IllegalArgumentException(""Offset is too large"");
    }
}",3,0
254,Time_8,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
        if (hoursOffset == 0 && minutesOffset == 0) {
            return DateTimeZone.UTC;
        }
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                 minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }","public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
    if (hoursOffset == 0 && minutesOffset == 0) {
        return DateTimeZone.UTC;
    }
    if (hoursOffset < -23 || hoursOffset > 23) {
        throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
    }
    if (minutesOffset < -59 || minutesOffset > 59) {
        throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
    }

    // Convert negative minutes into proper negative total offset
    int effectiveMinutes = hoursOffset * 60 + minutesOffset;

    // Check for valid range of total time zone offset
    if (effectiveMinutes < -1439 || effectiveMinutes > 1439) {
        throw new IllegalArgumentException(""Offset exceeds valid range"");
    }

    try {
        int offset = FieldUtils.safeMultiply(effectiveMinutes, DateTimeConstants.MILLIS_PER_MINUTE);
        return forOffsetMillis(offset);
    } catch (ArithmeticException ex) {
        throw new IllegalArgumentException(""Offset is too large"");
    }
}",4,0
