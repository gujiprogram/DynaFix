[
  {
    "method": "com.google.common.base.Predicate.apply",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "com.google.common.base.Predicates.alwaysFalse",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "com.google.javascript.jscomp.NodeUtil.callHasLocalResult",
    "doc": "/**\n   * @return Whether the call has a local result.\n   */",
    "code": "static boolean callHasLocalResult(Node n) {\n    Preconditions.checkState(n.getType() == Token.CALL);\n    return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0;\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.NodeUtil.isAssignmentOp",
    "doc": "/**\n   * Returns true if the operator is commutative.\n   * e.g. (a * b) * c = c * (b * a)\n   * Note 1: \"+\" is not commutative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   * Note 2: only operations on literals and pure functions are commutative.\n   */",
    "code": "static boolean isAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return true;\n    }\n    return false;\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.NodeUtil.isImmutableValue",
    "doc": "/**\n   * Returns true if this is an immutable value.\n   */",
    "code": "static boolean isImmutableValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.NOT:\n        return isImmutableValue(n.getFirstChild());\n      case Token.VOID:\n      case Token.NEG:\n        return isImmutableValue(n.getFirstChild());\n      case Token.NAME:\n        String name = n.getString();\n        return \"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name);\n    }\n\n    return false;\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.NodeUtil.isSimpleOperator",
    "doc": "/**\n   * Returns whether this a BLOCK node with no children.\n   *\n   * @param block The node.\n   */",
    "code": "static boolean isSimpleOperator(Node n) {\n    return isSimpleOperatorType(n.getType());\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.NodeUtil.isToStringMethodCall",
    "doc": "/**\n   * Given the new or call, this returns the nth\n   * argument of the call or null if no such argument exists.\n   */",
    "code": "private static boolean isToStringMethodCall(Node call) {\n    Node getNode = call.getFirstChild();\n    if (isGet(getNode)) {\n      Node propNode = getNode.getLastChild();\n      return isString(propNode) && \"toString\".equals(propNode.getString());\n    }\n    return false;\n  }"
  },
  {
    "method": "com.google.javascript.rhino.Node.getParent",
    "doc": "/**\n   * @see Node#siblings()\n   */",
    "code": "public Node getParent() {\n    return parent;\n  }"
  },
  {
    "method": "com.google.javascript.rhino.Node.getType",
    "doc": "/**\n     * This should only be called for STRING nodes created in object lits.\n     */",
    "code": "public int getType() {\n    return type;\n  }"
  }
]