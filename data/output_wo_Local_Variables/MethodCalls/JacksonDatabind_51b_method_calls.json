[
  {
    "method": "com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer",
    "doc": "/**\n     * Method for finding a value deserializer, and creating a contextual\n     * version if necessary, for value reached via specified property.\n     */",
    "code": "public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type,\n            BeanProperty prop) throws JsonMappingException"
  },
  {
    "method": "com.fasterxml.jackson.databind.DeserializationContext.getTypeFactory",
    "doc": "/**********************************************************\n     */",
    "code": "public final TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }"
  },
  {
    "method": "com.fasterxml.jackson.databind.JavaType.getRawClass",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "com.fasterxml.jackson.databind.jsontype.TypeIdResolver.typeFromId",
    "doc": "/**\n     * Method called to resolve type from given type identifier.\n     *\n     * @since 2.5 (throws clause added in 2.8)\n     */",
    "code": "public JavaType typeFromId(DatabindContext context, String id) throws IOException;"
  },
  {
    "method": "com.fasterxml.jackson.databind.type.TypeFactory.constructSpecializedType",
    "doc": "/**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */",
    "code": "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n\n\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null,\n                        new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType,\n                        NO_TYPES);\n            }\n            if (newType == null) {\n                TypeBindings tb = null;\n\n                if (baseType.containedTypeCount() == typeParamCount) {\n                    if (typeParamCount == 1) {\n                        tb = TypeBindings.create(subclass, baseType.containedType(0));\n                    } else if (typeParamCount == 2) {\n                        tb = TypeBindings.create(subclass, baseType.containedType(0),\n                                baseType.containedType(1));\n                    }\n                }\n                newType = _fromClass(null, subclass,\n                        (tb == null) ? TypeBindings.emptyBindings() : tb);\n            }\n        } while (false);\n\n        return newType;\n\n\n        if (baseType instanceof SimpleType) {\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        if (baseType instanceof ArrayType) {\n            if (subclass.isArray()) {\n                ArrayType at = (ArrayType) baseType;\n                Class<?> rawComp = subclass.getComponentType();\n                if (at.getContentType().getRawClass() == rawComp) {\n                    return baseType;\n                }\n                JavaType componentType = _fromAny(null, rawComp, null);\n                return ((ArrayType) baseType).withComponentType(componentType);\n            }\n        }\n\n        return baseType.narrowBy(subclass);\n    }"
  }
]