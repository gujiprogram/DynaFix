[
  {
    "method": "org.jsoup.helper.DescendableLinkedList.add",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "org.jsoup.helper.StringUtil.in",
    "doc": "/**\n     * Tests if a code point is \"whitespace\" as defined in the HTML spec.\n     * @param c code point to test\n     * @return true if code point is whitespace, false otherwise\n     */",
    "code": "public static boolean in(String needle, String... haystack) {\n        for (String hay : haystack) {\n            if (hay.equals(needle))\n            return true;\n        }\n        return false;\n    }"
  },
  {
    "method": "org.jsoup.nodes.Element.appendChild",
    "doc": "/**\n     * Add a node child node to this element.\n     *\n     * @param child node to add.\n     * @return this element, so that you can add more child nodes or elements.\n     */",
    "code": "public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        addChildren(child);\n        return this;\n    }"
  },
  {
    "method": "org.jsoup.nodes.Element.tagName",
    "doc": "/**\n     * Get the name of the tag for this element. E.g. {@code div}\n     *\n     * @return the tag name\n     */",
    "code": "public String tagName() {\n        return tag.getName();\n    }"
  },
  {
    "method": "org.jsoup.parser.HtmlTreeBuilder.currentElement",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "org.jsoup.parser.HtmlTreeBuilder.insertEmpty",
    "doc": "/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */",
    "code": "Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name());\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); // if not acked, promulagates error\n            } else {\n                tag.setSelfClosing();\n                tokeniser.acknowledgeSelfClosingFlag(); // not an distinct error\n            }\n        }\n        return el;\n    }"
  },
  {
    "method": "org.jsoup.parser.HtmlTreeBuilder.insertNode",
    "doc": "/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */",
    "code": "private void insertNode(Node node) {\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }"
  },
  {
    "method": "org.jsoup.parser.Tag.valueOf",
    "doc": "/**\n     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n     * <p/>\n     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n     *\n     * @param tagName Name of tag, e.g. \"p\". Case insensitive.\n     * @return The tag, either defined or new generic.\n     */",
    "code": "public static Tag valueOf(String tagName) {\n        Validate.notNull(tagName);\n        Tag tag = tags.get(tagName);\n\n        if (tag == null) {\n            tagName = tagName.trim().toLowerCase();\n            Validate.notEmpty(tagName);\n            tag = tags.get(tagName);\n\n            if (tag == null) {\n                tag = new Tag(tagName);\n                tag.isBlock = false;\n                tag.canContainBlock = true;\n            }\n        }\n        return tag;\n    }"
  },
  {
    "method": "org.jsoup.parser.Token$Character.getData",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "org.jsoup.parser.Token$StartTag.isSelfClosing",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "org.jsoup.parser.Token$StartTag.name",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "org.jsoup.parser.Tokeniser.emit",
    "doc": "/**\n * Readers the input stream into tokens.\n */",
    "code": "void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag;\n            if (startTag.selfClosing)\n                selfClosingFlagAcknowledged = false;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes != null)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }"
  }
]