[
  {
    "method": "org.apache.commons.codec.binary.Base64.encode",
    "doc": "/**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */",
    "code": "void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            byte b = lineSeparator[lineSeparator.length - 1];\n            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }"
  },
  {
    "method": "org.apache.commons.codec.binary.Base64.hasData",
    "doc": "/**\n     * Returns true if this Base64 object has buffered data for reading.\n     *\n     * @return true if there is Base64 object still available for reading.\n     */",
    "code": "boolean hasData() {\n        return this.buffer != null;\n    }"
  },
  {
    "method": "org.apache.commons.codec.binary.Base64.readResults",
    "doc": "/**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     *\n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */",
    "code": "int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            System.arraycopy(buffer, readPos, b, bPos, len);\n            readPos += len;\n            if (readPos >= pos) {\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }"
  },
  {
    "method": "org.apache.commons.codec.binary.Base64.setInitialBuffer",
    "doc": "/**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     *\n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */",
    "code": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }"
  }
]