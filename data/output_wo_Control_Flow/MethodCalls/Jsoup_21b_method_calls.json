[
  {
    "method": "org.jsoup.parser.TokenQueue.chompTo",
    "doc": "/**\n     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n     * <p>\n     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n     * isEmpty() == true).\n     * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>\n     * @return Data matched from queue.\n     */",
    "code": "public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }"
  },
  {
    "method": "org.jsoup.parser.TokenQueue.consumeWhitespace",
    "doc": "/**\n     * Pulls the next run of whitespace characters of the queue.\n     */",
    "code": "public boolean consumeWhitespace() {\n        boolean seen = false;\n        while (matchesWhitespace()) {\n            pos++;\n            seen = true;\n        }\n        return seen;\n    }"
  },
  {
    "method": "org.jsoup.parser.TokenQueue.isEmpty",
    "doc": "/**\n     * Is the queue empty?\n     * @return true if no data left in queue.\n     */",
    "code": "public boolean isEmpty() {\n        return remainingLength() == 0;\n    }"
  },
  {
    "method": "org.jsoup.parser.TokenQueue.matchChomp",
    "doc": "/**\n     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n     * queue.\n     * @param seq String to search for, and if found, remove from queue.\n     * @return true if found and removed, false if not found.\n     */",
    "code": "public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }"
  },
  {
    "method": "org.jsoup.parser.TokenQueue.matchesAny",
    "doc": "/**\n     Tests if the next characters match any of the sequences. Case insensitive.\n     @param seq list of strings to case insensitively check for\n     @return true of any matched, false if none did\n     */",
    "code": "public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }"
  },
  {
    "method": "org.jsoup.select.CombiningEvaluator$Or.add",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "org.jsoup.select.QueryParser.consumeSubQuery",
    "doc": "/**\n     * Parse the query\n     * @return Evaluator\n     */",
    "code": "private String consumeSubQuery() {\n        StringBuilder sq = new StringBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(combinators))\n                break;\n            else\n                sq.append(tq.consume());\n        }\n        return sq.toString();\n    }"
  },
  {
    "method": "org.jsoup.select.QueryParser.findElements",
    "doc": "/**\n     * Parse the query\n     * @return Evaluator\n     */",
    "code": "private void findElements() {\n        if (tq.matchChomp(\"#\"))\n            byId();\n        else if (tq.matchChomp(\".\"))\n            byClass();\n        else if (tq.matchesWord())\n            byTag();\n        else if (tq.matches(\"[\"))\n            byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            allElements();\n        else if (tq.matchChomp(\":lt(\"))\n            indexLessThan();\n        else if (tq.matchChomp(\":gt(\"))\n            indexGreaterThan();\n        else if (tq.matchChomp(\":eq(\"))\n            indexEquals();\n        else if (tq.matches(\":has(\"))\n            has();\n        else if (tq.matches(\":contains(\"))\n            contains(false);\n        else if (tq.matches(\":containsOwn(\"))\n            contains(true);\n        else if (tq.matches(\":matches(\"))\n            matches(false);\n        else if (tq.matches(\":matchesOwn(\"))\n            matches(true);\n        else if (tq.matches(\":not(\"))\n            not();\n        else // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n    }"
  },
  {
    "method": "org.jsoup.select.QueryParser.parse",
    "doc": "/**\n     * Parse a CSS query into an Evaluator.\n     * @param query CSS query\n     * @return Evaluator\n     */",
    "code": "public static Evaluator parse(String query) {\n        QueryParser p = new QueryParser(query);\n        return p.parse();\n    }"
  }
]