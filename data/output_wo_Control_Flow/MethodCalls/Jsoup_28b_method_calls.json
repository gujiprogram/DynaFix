[
  {
    "method": "org.jsoup.nodes.Entities.getCharacterByName",
    "doc": "/**\n     * Get the Character value of the named entity\n     * @param name named entity (e.g. \"lt\" or \"amp\")\n     * @return the Character value of the named entity (e.g. '<' or '&')\n     */",
    "code": "public static Character getCharacterByName(String name) {\n        return full.get(name);\n    }"
  },
  {
    "method": "org.jsoup.nodes.Entities.isNamedEntity",
    "doc": "/**\n     * Check if the input is a known named entity\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity\n     */",
    "code": "public static boolean isNamedEntity(String name) {\n        return full.containsKey(name);\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.consumeLetterThenDigitSequence",
    "doc": "/**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */",
    "code": "String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.current",
    "doc": "/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */",
    "code": "char current() {\n        return isEmpty() ? EOF : input[pos];\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.isEmpty",
    "doc": "/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */",
    "code": "boolean isEmpty() {\n        return pos >= length;\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.mark",
    "doc": "/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */",
    "code": "void mark() {\n        mark = pos;\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.matchConsume",
    "doc": "/**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */",
    "code": "boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.matches",
    "doc": "/**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */",
    "code": "boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.matchesAny",
    "doc": "/**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */",
    "code": "boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.matchesDigit",
    "doc": "/**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */",
    "code": "boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.matchesLetter",
    "doc": "/**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */",
    "code": "boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }"
  },
  {
    "method": "org.jsoup.parser.CharacterReader.rewindToMark",
    "doc": "/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */",
    "code": "void rewindToMark() {\n        pos = mark;\n    }"
  },
  {
    "method": "org.jsoup.parser.Tokeniser.characterReferenceError",
    "doc": "/**\n * Readers the input stream into tokens.\n */",
    "code": "private void characterReferenceError(String message) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n    }"
  }
]