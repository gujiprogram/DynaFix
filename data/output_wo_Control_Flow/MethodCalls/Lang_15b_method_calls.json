[
  {
    "method": "org.apache.commons.lang3.ClassUtils.isAssignable",
    "doc": "/**\n     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n     *\n     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n     * Class pair in the input arrays. It can be used to check if a set of arguments\n     * (the first parameter) are suitably compatible with a set of method parameter types\n     * (the second parameter).</p>\n     *\n     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n     * method takes into account widenings of primitive classes and\n     * {@code null}s.</p>\n     *\n     * <p>Primitive widenings allow an int to be assigned to a {@code long},\n     * {@code float} or {@code double}. This method returns the correct\n     * result for these cases.</p>\n     *\n     * <p>{@code Null} may be assigned to any reference type. This method will\n     * return {@code true} if {@code null} is passed in and the toClass is\n     * non-primitive.</p>\n     *\n     * <p>Specifically, this method tests whether the type represented by the\n     * specified {@code Class} parameter can be converted to the type\n     * represented by this {@code Class} object via an identity conversion\n     * widening primitive or widening reference conversion. See\n     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n     *\n     * <p><strong>Since Lang 3.0,</strong> this method will default behavior for\n     * calculating assignability between primitive and wrapper types <em>corresponding\n     * to the running Java version</em>; i.e. autoboxing will be the default\n     * behavior in VMs running Java versions >= 1.5.</p>\n     *\n     * @param classArray  the array of Classes to check, may be {@code null}\n     * @param toClassArray  the array of Classes to try to assign into, may be {@code null}\n     * @return {@code true} if assignment possible\n     */",
    "code": "public static boolean isAssignable(Class<?>[] classArray, Class<?>... toClassArray) {\n        return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));\n    }"
  },
  {
    "method": "org.apache.commons.lang3.reflect.TypeUtils.getRawType",
    "doc": "/**\n     * <p> Get the raw type of a Java type, given its context. Primarily for use\n     * with {@link TypeVariable}s and {@link GenericArrayType}s, or when you do\n     * not know the runtime type of <code>type</code>: if you know you have a\n     * {@link Class} instance, it is already raw; if you know you have a\n     * {@link ParameterizedType}, its raw type is only a method call away. </p>\n     *\n     * @param type to resolve\n     * @param assigningType type to be resolved against\n     * @return the resolved <code>Class</code> object or <code>null</code> if\n     * the type could not be resolved\n     */",
    "code": "return getRawType((ParameterizedType) type);\n        }\n\n        if (type instanceof TypeVariable<?>) {"
  },
  {
    "method": "org.apache.commons.lang3.reflect.TypeUtils.getTypeArguments",
    "doc": "/**\n     * <p> Gets the type arguments of a class/interface based on a subtype. For\n     * instance, this method will determine that both of the parameters for the\n     * interface {@link Map} are {@link Object} for the subtype\n     * {@link java.util.Properties Properties} even though the subtype does not\n     * directly implement the <code>Map</code> interface. <p> </p> This method\n     * returns <code>null</code> if <code>type</code> is not assignable to\n     * <code>toClass</code>. It returns an empty map if none of the classes or\n     * interfaces in its inheritance hierarchy specify any type arguments. </p>\n     * <p> A side-effect of this method is that it also retrieves the type\n     * arguments for the classes and interfaces that are part of the hierarchy\n     * between <code>type</code> and <code>toClass</code>. So with the above\n     * example, this method will also determine that the type arguments for\n     * {@link java.util.Hashtable Hashtable} are also both <code>Object</code>.\n     * In cases where the interface specified by <code>toClass</code> is\n     * (indirectly) implemented more than once (e.g. where <code>toClass</code>\n     * specifies the interface {@link java.lang.Iterable Iterable} and\n     * <code>type</code> specifies a parameterized type that implements both\n     * {@link java.util.Set Set} and {@link java.util.Collection Collection}),\n     * this method will look at the inheritance hierarchy of only one of the\n     * implementations/subclasses; the first interface encountered that isn't a\n     * subinterface to one of the others in the <code>type</code> to\n     * <code>toClass</code> hierarchy. </p>\n     *\n     * @param type the type from which to determine the type parameters of\n     * <code>toClass</code>\n     * @param toClass the class whose type parameters are to be determined based\n     * on the subtype <code>type</code>\n     * @return a map of the type assignments for the type variables in each type\n     * in the inheritance hierarchy from <code>type</code> to\n     * <code>toClass</code> inclusive.\n     */",
    "code": "return getTypeArguments(type, getRawType(type), null);\n    }\n\n    public static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass) {"
  },
  {
    "method": "org.apache.commons.lang3.reflect.TypeUtils.isAssignable",
    "doc": "/**\n     * <p> Checks if the subject type may be implicitly cast to the target type\n     * following the Java generics rules. If both types are {@link Class}\n     * objects, the method returns the result of\n     * {@link ClassUtils#isAssignable(Class, Class)}. </p>\n     *\n     * @param type the subject type to be assigned to the target type\n     * @param toType the target type\n     * @return <code>true</code> if <code>type</code> is assignable to <code>toType</code>.\n     */",
    "code": "public static boolean isAssignable(Type type, Type toType) {\n        return isAssignable(type, toType, null);\n    }"
  }
]