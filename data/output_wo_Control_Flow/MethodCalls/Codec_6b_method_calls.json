[
  {
    "method": "org.apache.commons.codec.binary.Base64.decode",
    "doc": "/**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */",
    "code": "void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n\n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }"
  },
  {
    "method": "org.apache.commons.codec.binary.Base64.hasData",
    "doc": "/**\n     * Returns true if this Base64 object has buffered data for reading.\n     *\n     * @return true if there is Base64 object still available for reading.\n     */",
    "code": "boolean hasData() {\n        return this.buffer != null;\n    }"
  },
  {
    "method": "org.apache.commons.codec.binary.Base64.readResults",
    "doc": "/**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     *\n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */",
    "code": "int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }"
  },
  {
    "method": "org.apache.commons.codec.binary.Base64.setInitialBuffer",
    "doc": "/**\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     *\n     * @param out\n     *            byte[] array to buffer directly to.\n     * @param outPos\n     *            Position to start buffering into.\n     * @param outAvail\n     *            Amount of bytes available for direct buffering.\n     */",
    "code": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }"
  }
]