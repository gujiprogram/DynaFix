[
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocInfoParser.next",
    "doc": "/**\n   * Gets the next token of the token stream or the buffered token if a matching\n   * was previously made.\n   */",
    "code": "private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocInfoParser.toString",
    "doc": "/**\n   * Converts a JSDoc token to its string representation.\n   */",
    "code": "private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocToken.ordinal",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharno",
    "doc": "/**\n   * Gets the remaining JSDoc line without the {@link JsDocToken#EOL},\n   * {@link JsDocToken#EOF} or {@link JsDocToken#EOC}.\n   */",
    "code": "final int getCharno() {\n    return lineno == initLineno? initCharno + charno : charno;\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getLineno",
    "doc": "/**\n   * Gets the remaining JSDoc line without the {@link JsDocToken#EOL},\n   * {@link JsDocToken#EOF} or {@link JsDocToken#EOC}.\n   */",
    "code": "final int getLineno() { return lineno; }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getRemainingJSDocLine",
    "doc": "/**\n   * Gets the remaining JSDoc line without the {@link JsDocToken#EOL},\n   * {@link JsDocToken#EOF} or {@link JsDocToken#EOC}.\n   */",
    "code": "String getRemainingJSDocLine() {\n    int c;\n    for (;;) {\n      c = getChar();\n      switch (c) {\n        case '*':\n          if (peekChar() != '/') {\n            addToString(c);\n            break;\n          }\n        case EOF_CHAR:\n        case '\\n':\n          ungetChar(c);\n          this.string = getStringFromBuffer();\n          stringBufferTop = 0;\n          return this.string;\n\n        default:\n          addToString(c);\n          break;\n      }\n    }\n  }"
  },
  {
    "method": "com.google.javascript.rhino.JSDocInfoBuilder.markText",
    "doc": "/**\n   * Adds a textual block to the current marker.\n   */",
    "code": "public void markText(String text, int startLineno, int startCharno,\n      int endLineno, int endCharno) {\n    if (currentMarker != null) {\n      JSDocInfo.StringPosition position = new JSDocInfo.StringPosition();\n      position.setItem(text);\n      position.setPositionInformation(startLineno, startCharno,\n          endLineno, endCharno);\n      currentMarker.setDescription(position);\n    }\n  }"
  }
]