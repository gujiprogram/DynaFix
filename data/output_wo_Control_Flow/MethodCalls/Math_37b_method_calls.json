[
  {
    "method": "org.apache.commons.math.complex.Complex.createComplex",
    "doc": "/**\n     * Returns a {@code Complex} whose value is\n     * {@code (this + addend)}.\n     * Uses the definitional formula\n     * <pre>\n     *  <code>\n     *   (a + bi) + (c + di) = (a+c) + (b+d)i\n     *  </code>\n     * </pre>\n     * <br/>\n     * If either {@code this} or {@code addend} has a {@code NaN} value in\n     * either part, {@link #NaN} is returned; otherwise {@code Infinite}\n     * and {@code NaN} values are returned in the parts of the result\n     * according to the rules for {@link java.lang.Double} arithmetic.\n     *\n     * @param  addend Value to be added to this {@code Complex}.\n     * @return {@code this + addend}.\n     * @throws NullArgumentException if {@code addend} is {@code null}.\n     */",
    "code": "return createComplex(real + addend.getReal(),\n                             imaginary + addend.getImaginary());"
  },
  {
    "method": "org.apache.commons.math.util.FastMath.cos",
    "doc": "/**\n     *  Cosine function\n     *  @param x a number\n     *  @return cos(x)\n     */",
    "code": "public static double cos(double x) {\n        int quadrant = 0;\n\n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        double xb = 0;\n        if (xa > 3294198.0) {\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n\n            int k = (int)(xa * 0.6366197723675814);\n\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0) {\n                    break;\n                }\n\n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }"
  },
  {
    "method": "org.apache.commons.math.util.FastMath.cosh",
    "doc": "/** Compute the hyperbolic cosine of a number.\n     * @param x number on which evaluation is done\n     * @return hyperbolic cosine of x\n     */",
    "code": "public static double cosh(double x) {\n      if (x != x) {\n          return x;\n      }\n\n\n\n      if (x > 20.0) {\n          return exp(x)/2.0;\n      }\n\n      if (x < -20) {\n          return exp(-x)/2.0;\n      }\n\n      double hiPrec[] = new double[2];\n      if (x < 0.0) {\n          x = -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya = hiPrec[0] + hiPrec[1];\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp = ya * HEX_40000000;\n      double yaa = ya + temp - temp;\n      double yab = ya - yaa;\n\n      double recip = 1.0/ya;\n      temp = recip * HEX_40000000;\n      double recipa = recip + temp - temp;\n      double recipb = recip - recipa;\n\n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      recipb += -yb * recip * recip;\n\n      temp = ya + recipa;\n      yb += -(temp - ya - recipa);\n      ya = temp;\n      temp = ya + recipb;\n      yb += -(temp - ya - recipb);\n      ya = temp;\n\n      double result = ya + yb;\n      result *= 0.5;\n      return result;\n    }"
  },
  {
    "method": "org.apache.commons.math.util.FastMath.sin",
    "doc": "/**\n     *  Sine function.\n     *  @param x a number\n     *  @return sin(x)\n     */",
    "code": "public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        if (xa > 3294198.0) {\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n\n            int k = (int)(xa * 0.6366197723675814);\n\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0) {\n                    break;\n                }\n\n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }"
  },
  {
    "method": "org.apache.commons.math.util.FastMath.sinh",
    "doc": "/** Compute the hyperbolic sine of a number.\n     * @param x number on which evaluation is done\n     * @return hyperbolic sine of x\n     */",
    "code": "public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n\n\n      if (x > 20.0) {\n          return exp(x)/2.0;\n      }\n\n      if (x < -20) {\n          return -exp(-x)/2.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }"
  }
]